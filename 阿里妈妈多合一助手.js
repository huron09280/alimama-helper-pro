// ==UserScript==
// @name         é˜¿é‡Œå¦ˆå¦ˆå¤šåˆä¸€åŠ©æ‰‹ (Proç‰ˆ)
// @namespace    http://tampermonkey.net/
// @version      5.30
// @description  äº¤äº’ä¼˜åŒ–ç‰ˆï¼šå¢åŠ åŠ è´­æˆæœ¬è®¡ç®—ã€èŠ±è´¹å æ¯”ã€é¢„ç®—åˆ†ç±»å æ¯”ã€æ€§èƒ½ä¼˜åŒ–ã€‚åŒ…å«çŠ¶æ€è®°å¿†ã€èƒ¶å›ŠæŒ‰é’®UIã€æ—¥å¿—æŠ˜å ã€æŠ¥è¡¨ç›´è¿ä¸‹è½½æ‹¦æˆªã€‚é›†æˆç®—æ³•æŠ¤èˆªåŠŸèƒ½ã€‚
// @author       Gemini & Liangchao
// @match        *://alimama.com/*
// @match        *://*.alimama.com/*
// @match        https://one.alimama.com/*
// @grant        GM_setClipboard
// @grant        GM_setValue
// @grant        GM_getValue
// @connect      alimama.com
// @connect      ai.alimama.com
// @connect      *.alimama.com
// @connect      one.alimama.com
// ==/UserScript==
/**
 * æ›´æ–°æ—¥å¿—
 * 
 * v5.30 (2026-02-15)
 * - âœ… æ–°å¢ä»£ç æ£€æŸ¥å›¢é˜Ÿæœºåˆ¶ï¼šè¡¥å……å›¢é˜ŸèŒè´£æ–‡æ¡£ä¸ PR æ£€æŸ¥æ¸…å•
 * - âœ… æ–°å¢ä¸€é”®å®¡æŸ¥è„šæœ¬ï¼š`scripts/review-team.sh` ç»Ÿä¸€æ¶æ„/å®‰å…¨/æµ‹è¯•/ç‰ˆæœ¬æ ¡éªŒ
 * - ğŸ”§ CI/Release æµç¨‹ç»Ÿä¸€ï¼šå‘å¸ƒå‰æ£€æŸ¥æ”¹ä¸ºå¤ç”¨åŒä¸€å¥—å›¢é˜Ÿæ£€æŸ¥å…¥å£
 * - ğŸ”§ å®¡æŸ¥è´£ä»»è‡ªåŠ¨åˆ†é…ï¼šæ–°å¢ `.github/CODEOWNERS`
 * 
 * v5.29 (2026-02-15)
 * - âœ¨ ä¸»é¢æ¿å·¥å…·åŒºé‡æ„ï¼šæ–°å¢ã€Œè¾…åŠ©æ˜¾ç¤ºã€å…¥å£ï¼Œä¸ã€Œç®—æ³•æŠ¤èˆªã€ã€Œä¸‡èƒ½æŸ¥æ•°ã€å½¢æˆä¸‰å…¥å£å¸ƒå±€
 * - âœ¨ è¾…åŠ©æ˜¾ç¤ºä½“éªŒä¼˜åŒ–ï¼šå¼€å…³åŒºæ”¹ä¸ºä¸»é¢æ¿å†…è”å±•å¼€/æ”¶èµ·ï¼ŒåŠ å…¥è¿‡æ¸¡åŠ¨ç”»å¹¶é»˜è®¤æ”¶èµ·
 * - ğŸ”§ é…ç½®ç‰ˆæœ¬åŒ–è¿ç§»ï¼šæ–°å¢ `configRevision`ï¼Œå‡çº§æ—¶è‡ªåŠ¨ä¿®æ­£é»˜è®¤é…ç½®å¹¶æŒä¹…åŒ–
 * - ğŸ”§ é»˜è®¤è¡Œä¸ºä¿®è®¢ï¼šæ—¥å¿—åŒºé»˜è®¤æŠ˜å ï¼Œé¦–æ¬¡æ‰“å¼€æ›´èšç„¦æ ¸å¿ƒæ“ä½œåŒº
 * - âœ… å†’çƒŸä¸å›å½’å¢å¼ºï¼šè¡¥å……è¾…åŠ©æ˜¾ç¤ºä¸é…ç½®è¿ç§»ç›¸å…³æ£€æŸ¥ï¼Œæ–°å¢æœ¬åœ°çƒŸæµ‹é¡µ `dev/smoke-harness.html`
 * 
 * v5.28 (2026-02-15)
 * - âœ¨ ä¸‡èƒ½æŸ¥æ•°å¼¹çª—å¤´éƒ¨å…¨é‡é‡æ„ï¼šæ›¿æ¢ä¸ºæ–°ç‰ˆå“ç‰Œå¤´å›¾ä¸æ–‡æ¡ˆï¼Œç»Ÿä¸€å¸ƒå±€ä¸è§†è§‰å±‚çº§
 * - âœ¨ å¼¹çª—é¦–å±ä½“éªŒä¼˜åŒ–ï¼šiframe å…ˆéšè—åæ¸…ç†å†å±•ç¤ºï¼Œå‡å°‘å‰ 1 ç§’æ•´é¡µé—ªç°
 * - ğŸ”§ æ ·å¼è§„åˆ™æ”¹ä¸ºåŠ¨æ€é€‰æ‹©å™¨ï¼šå…¼å®¹åŠ¨æ€ `mx_*` èŠ‚ç‚¹ï¼Œè¡¥é½ `mb16` éšè—ä¸ `top` å®šä½
 * - ğŸ”§ å¿«æ·æŸ¥æ•°æ–‡æ¡ˆå‡çº§ï¼šç”±â€œè·å–è®¡åˆ’IDâ€æ”¹ä¸ºâ€œè®¡åˆ’åï¼š{å¯¹åº”è®¡åˆ’å}â€
 * - ğŸ› è®¡åˆ’åè¯†åˆ«ä¿®å¤ï¼šä¼˜å…ˆåŒ¹é…è®¡åˆ’åŒºå— `a[title]`ï¼Œè§„é¿è¯¯å–å•†å“æ ‡é¢˜/å¹³å°æ¨èç­‰å™ªéŸ³
 * - âœ¨ æ–°å¢å¼€å‘åŠ è½½å™¨è„šæœ¬ï¼š`dev/dev-loader.user.js` æ”¯æŒæœ¬åœ°è„šæœ¬è‡ªåŠ¨åŠ è½½ä¸æ‰§è¡Œï¼Œä¾¿äºå¿«é€Ÿè”è°ƒ
 * - ğŸ”§ ç‰ˆæœ¬å·åŒæ­¥æœºåˆ¶å¢å¼ºï¼šç»Ÿä¸€åŠ¨æ€è¯»å– `GM_info/GM.info`ï¼ŒåŒ IIFE ç‰ˆæœ¬å±•ç¤ºä¿æŒä¸€è‡´
 * - ğŸ› æ—¥å¿—ç³»ç»Ÿç¨³å®šæ€§ä¿®å¤ï¼š`Logger.flush` æ—©é€€åˆ†æ”¯é‡ç½® timerï¼Œé¿å…æ—¥å¿—åˆ·æ–°é”æ­»
 * - ğŸ”§ è‡ªåŠ¨åŒ–è´¨é‡åŠ å›ºï¼šè¡¥å…… Logger API å›å½’æµ‹è¯•ï¼ŒCI/Release å·¥ä½œæµé€‚é… userscript ä»“åº“
 * - ğŸ”§ ä¸»é¢æ¿ä¸‰å…¥å£æ’ç‰ˆä¿®å¤ï¼šæŒ‰é’®æ–‡æ¡ˆå¼ºåˆ¶å•è¡Œæ˜¾ç¤ºï¼Œé¿å…â€œä¸‡èƒ½æŸ¥æ•°/è¾…åŠ©æ˜¾ç¤ºâ€åœ¨çª„å®½åº¦ä¸‹æ¢è¡Œ
 * 
 * v5.27 (2026-02-14)
 * - âœ¨ ç‰ˆæœ¬å·æ”¹ä¸ºåŠ¨æ€è§£æï¼šç»Ÿä¸€ä» GM_info / GM.info è¯»å–ï¼Œç§»é™¤ç¡¬ç¼–ç ç‰ˆæœ¬ fallback
 * - âœ¨ åŒ IIFE å…±ç”¨åŒä¸€ç‰ˆæœ¬è§£æå™¨ï¼Œä¸»é¢æ¿ã€æŠ¤èˆªé¢æ¿ä¸å¯åŠ¨æ—¥å¿—ç‰ˆæœ¬ä¿æŒä¸€è‡´
 * - ğŸ“ æ–‡æ¡£åŒæ­¥ï¼šREADME å¾½ç« æ”¹ä¸º GitHub Release åŠ¨æ€ç‰ˆæœ¬æ˜¾ç¤º
 * 
 * v5.26 (2026-02-13)
 * - âœ¨ æ–°å¢ã€Œè®¡åˆ’IDè¯†åˆ«ã€æ¨¡å—ï¼šè‡ªåŠ¨æ‰«æå¹¶ä¸ºé¡µé¢ ID æ³¨å…¥ã€Œä¸‡èƒ½æŸ¥æ•°ã€å¿«æ·å…¥å£
 * - âœ¨ UI è§†è§‰æ ‡å‡†å‡çº§ï¼šç»Ÿä¸€ iPhone çº§åœ†è§’è§„èŒƒï¼ˆ18px/12px/10pxï¼‰ï¼Œè§†è§‰æ›´æ„Ÿæ€§
 * - âœ¨ æ·±åº¦ç²¾è£…ä¿®ï¼šå…¨é¢å¼•å…¥ Glassmorphism ç£¨ç ‚ç»ç’ƒè´¨æ„Ÿï¼Œä¼˜åŒ–è¡¨æ ¼é…è‰²ä¸å±‚çº§æ„Ÿ
 * - âœ¨ å›¾æ ‡ä½“ç³»æ ‡å‡†åŒ–ï¼šå…¨é‡ä½¿ç”¨é«˜è´¨é‡ SVG æ›¿æ¢ Unicodeï¼Œè§†è§‰æ¯”é‡ã€å¤§å°åŠé¢œè‰²è¡¨ç°å¯¹é½
 * - âœ¨ ç®—æ³•æŠ¤èˆªä½“éªŒå¢å¼ºï¼šæ”¯æŒé¢æ¿å±…ä¸­ã€æœ€å¤§åŒ–å±•ç¤ºï¼Œä¼˜åŒ–é•¿æ—¥å¿—è‡ªåŠ¨é«˜åº¦è®¡ç®—
 * - ğŸ”§ ç•Œé¢å¾®è°ƒï¼šç²¾ç®€ç®—æ³•æŠ¤èˆªæ ‡é¢˜æ ç»“æ„ï¼Œä¼˜åŒ–æ•°æ®è¡¨æ ¼èƒŒæ™¯é…è‰²ä¸å„çº§å›¾æ ‡æ˜¾ç¤ºæ¯”ä¾‹
 * - ğŸ”§ ç»†èŠ‚ä¿®å¤ï¼šè°ƒä¼˜åˆ·æ–°å›¾æ ‡å±•ç¤ºæ•ˆæœï¼Œä¿®å¤æ—¥å¿—è¾“å‡ºç©ºæ ¼æ ¼å¼ï¼Œæå‡æè‡´ç¨³å®šæ€§
 * - ğŸ”§ æ€§èƒ½ä¼˜åŒ–ï¼šä¼˜åŒ– MutationObserver ç›‘å¬é¢‘ç‡ï¼Œå‡å°‘æ‰«æå¼€é”€
 * 
 * v5.25 (2026-02-13)
 * - âœ¨ ä¿®å¤æ ·å¼æ³¨å…¥ç¼“å­˜æœºåˆ¶ï¼Œé€šè¿‡åŠ¨æ€ ID å¼ºåˆ¶åˆ·æ–°æ ·å¼
 * - âœ¨ ä¼˜åŒ–è§¦å‘å™¨ UI æ ·å¼ï¼Œæå‡åŸç”Ÿè§†è§‰èåˆåº¦
 * - ğŸ”§ ä¿®å¤æ—¥å¿—ç³»ç»Ÿåœ¨ç‰¹å®šåœºæ™¯ä¸‹çš„å¼•ç”¨é”™è¯¯
 * - ğŸ”§ å¢å¼ºæ•°æ®æŠ“å–ç¨³å®šæ€§ï¼Œä¼˜åŒ– API æ³¨å…¥é€»è¾‘
 * - âœ¨ å…³é”®è¯æ¨å¹¿é¡µé¢æ–°å¢ã€Œå…¨èƒ½æ•°æ®æŸ¥ã€å¿«æ·å…¥å£
 * 
 * v5.24 (2026-02-12)
 * - âœ¨ æ–°å¢å¤šè¡¨æ ¼ä¸Šä¸‹æ–‡è¯†åˆ«ä¸èƒ½åŠ›è¯„åˆ†ï¼Œä¼˜å…ˆå¤„ç†å½“å‰å¯è§ä¸”åˆ—ç»“æ„åŒ¹é…çš„æ•°æ®è¡¨
 * - âœ¨ å…¼å®¹ Sticky Table åŒè¡¨å¤´å®šä½ï¼Œæå‡è¡¨å¤´æ˜ å°„ç¨³å®šæ€§
 * - ğŸ”§ èŠ±è´¹æ’åºæ”¹ä¸ºä½œç”¨åŸŸå®šä½ï¼Œå‡å°‘è·¨æ¨¡å—è¯¯è§¦å‘æ’åºçš„é—®é¢˜
 * - ğŸ”§ è·¯ç”±å˜åŒ–é‡ç½®å¢åŠ èŠ‚æµä¿æŠ¤ï¼Œé¿å…çŸ­æ—¶é—´é‡å¤é‡ç½®
 * - ğŸ”§ é¦–æ¬¡æ‰§è¡Œå¢åŠ å»é‡ä¿æŠ¤ï¼Œé™ä½ MutationObserver é«˜é¢‘æ›´æ–°ä¸‹çš„é‡å¤è®¡ç®—
 * 
 * v5.23 (2026-02-08)
 * - ğŸ› ä¿®å¤ä½œç”¨åŸŸå¼•ç”¨é”™è¯¯å¯¼è‡´çš„ç®—æ³•æŠ¤èˆªæ¨¡å—åŠ è½½å¤±è´¥é—®é¢˜
 * - âœ¨ å®ç°å…¨ UI ç‰ˆæœ¬å·è‡ªåŠ¨åŒ–åŒæ­¥ï¼Œæ‰€æœ‰ç•Œé¢å‡æ˜¾ç¤ºæœ€æ–°ç‰ˆæœ¬
 * - ğŸ”§ æ•´ç†å¹¶ä¼˜åŒ–ä»Šæ—¥æ‰€æœ‰æ›´æ–°æ—¥å¿—ï¼Œä¿æŒç•Œé¢æ•´æ´
 * - ğŸ”§ ä¿®å¤æ—¥å¿—æ—¥æœŸåˆå¹¶é€»è¾‘ï¼Œå‡†ç¡®è¯†åˆ«å¹¶æŒ‰å¤©åˆ†ç»„
 * - âœ¨ ç‚¹å‡»ã€Œç®—æ³•æŠ¤èˆªã€åä¸»é¢æ¿è‡ªåŠ¨æœ€å°åŒ–ï¼Œæå‡ç©ºé—´åˆ©ç”¨ç‡
 * - ğŸ”§ ä¼˜åŒ–é¢æ¿å±‚çº§ (z-index)ï¼Œè§£å†³å±‚çº§é®æŒ¡é—®é¢˜
 * - ğŸ”§ ç§»é™¤æŠ¤èˆªã€Œæœ€å°åŒ–ã€å›¾æ ‡ï¼Œé›†æˆæŠ¤èˆªæ¨¡å—å¹¶æ”¯æŒä¸€é”®è°ƒå‡º
 * - âœ¨ æ–°å¢é¢„ç®—åˆ†ç±»å æ¯”æ˜¾ç¤º (åŸºç¡€ + å¤šç›®æ ‡é¢„ç®—)
 * 
 * v5.15 (2026-02-05)
 * - âœ¨ æ–°å¢ Tab åˆ‡æ¢ç›‘å¬ï¼ˆå…³é”®è¯ã€äººç¾¤ã€åˆ›æ„ç­‰ï¼‰
 * - âœ¨ åˆ‡æ¢ Tab æ—¶è‡ªåŠ¨é‡æ–°æŒ‰èŠ±è´¹é™åºæ’åº
 * 
 * v5.12 (2026-01-31)
 * - âœ¨ æ–°å¢ã€ŒèŠ±è´¹æ’åºã€å¼€å…³ï¼Œè‡ªåŠ¨æŒ‰èŠ±è´¹é™åºæ’åˆ—è¡¨æ ¼
 * - âœ¨ åˆ‡æ¢é¡µé¢/ç‚¹å‡»è®¡åˆ’æ—¶è‡ªåŠ¨é‡æ–°æ’åº
 * - âœ¨ ç›‘å¬ URL å˜åŒ– (hashchange/popstate)
 * - ğŸ› ä¿®å¤æ€»èŠ±è´¹æ—¥å¿—é‡å¤è¾“å‡ºé—®é¢˜
 * 
 * v4.11 (2026-01-31)
 * - âœ¨ UI æ ·å¼é‡æ–°è®¾è®¡ï¼Œç°è‰²ç³»ä¸»é¢˜
 * - âœ¨ æ‚¬æµ®çƒæ¢å¤ 40px SVG å›¾æ ‡
 * - âœ¨ é¢æ¿ä½ç½®å¯¹é½æ‚¬æµ®çƒ
 * - âœ¨ ç‚¹å‡»é¢æ¿å¤–éƒ¨è‡ªåŠ¨æœ€å°åŒ–
 * - âœ¨ å·¦ä¾§å¯æ‹–æ‹½è°ƒæ•´å®½åº¦
 * - âœ¨ ç¼©æ”¾åŠ¨ç”»æ•ˆæœ
 */

const resolveScriptVersion = () => {
    const fromGMInfo = typeof GM_info !== 'undefined'
        && GM_info
        && GM_info.script
        && GM_info.script.version;
    if (typeof fromGMInfo === 'string' && fromGMInfo.trim()) {
        return fromGMInfo.trim();
    }

    const fromGM = typeof GM !== 'undefined'
        && GM
        && GM.info
        && GM.info.script
        && GM.info.script.version;
    if (typeof fromGM === 'string' && fromGM.trim()) {
        return fromGM.trim();
    }

    return 'dev';
};

if (typeof globalThis !== 'undefined' && typeof globalThis.__AM_GET_SCRIPT_VERSION__ !== 'function') {
    globalThis.__AM_GET_SCRIPT_VERSION__ = resolveScriptVersion;
}

(function () {
    'use strict';

    // å…¨å±€ç‰ˆæœ¬ç®¡ç†
    const CURRENT_VERSION = typeof globalThis !== 'undefined' && typeof globalThis.__AM_GET_SCRIPT_VERSION__ === 'function'
        ? globalThis.__AM_GET_SCRIPT_VERSION__()
        : resolveScriptVersion();

    // ==========================================
    // 1. é…ç½®ä¸çŠ¶æ€ç®¡ç†
    // ==========================================
    const CONSTANTS = {
        STORAGE_KEY: 'AM_HELPER_CONFIG',
        CONFIG_REVISION: 2,
        LEGACY_STORAGE_KEYS: ['AM_HELPER_CONFIG_V5_15', 'AM_HELPER_CONFIG_V5_14', 'AM_HELPER_CONFIG_V5_13'],
        TAG_BASE_STYLE: 'align-items:center;border:0 none;border-radius:var(--mx-effects-tag-border-radius,8px);display:inline-flex;font-size:9px;font-weight:800;height:var(--mx-effects-tag-height,16px);justify-content:center;padding:0 var(--mx-effects-tag-h-gap,1px);position:relative;transition:background-color var(--duration),color var(--duration),border var(--duration),opacity var(--duration);-webkit-user-select:none;-moz-user-select:none;user-select:none;width:100%;margin-top:2px;',
        STYLES: {
            cost: 'background-color:rgba(255,0,106,0.1);color:#ff006a;',
            cart: 'background-color:rgba(114,46,209,0.1);color:#722ed1;',
            percent: 'background-color:rgba(24,144,255,0.1);color:#1890ff;',
            ratio: 'background-color:rgba(250,140,22,0.1);color:#fa8c16;',
            budget: 'color:#52c41a;transition:all 0.3s;'
        },
        KEYWORDS: ['æŸ¥è¯¢', 'æœç´¢', 'ç¡®å®š', 'ä»Šå¤©', 'æ˜¨å¤©', 'è¿‡å»', 'æœ¬æœˆ', 'ä¸Šæœˆ', 'è®¡åˆ’', 'å•å…ƒ', 'åˆ›æ„', 'æ¨å¹¿'],
        DL_KEYWORDS: ["oss-accelerate", "aliyuncs.com", "download"]
    };

    const DEFAULT_CONFIG = {
        panelOpen: false,
        showCost: true,
        showCartCost: true,
        showPercent: true,
        showCostRatio: true,
        showBudget: true,
        autoClose: true,
        autoSortCharge: true,  // èŠ±è´¹é™åºæ’åº
        logExpanded: false,
        magicReportOpen: false,
        configRevision: CONSTANTS.CONFIG_REVISION
    };

    const resolveHookTargetWindow = () => {
        try {
            if (typeof unsafeWindow !== 'undefined' && unsafeWindow && unsafeWindow.window === unsafeWindow) {
                return unsafeWindow;
            }
        } catch { }
        return window;
    };

    const createHookManager = () => {
        const hookWindow = resolveHookTargetWindow();
        if (hookWindow.__AM_HOOK_MANAGER__) return hookWindow.__AM_HOOK_MANAGER__;
        if (window.__AM_HOOK_MANAGER__) return window.__AM_HOOK_MANAGER__;

        const manager = {
            installed: false,
            fetchHandlers: [],
            xhrOpenHandlers: [],
            xhrSendHandlers: [],
            xhrLoadHandlers: [],
            requestHistory: [],
            requestHistoryLimit: 4000,

            recordRequest(entry = {}) {
                const rawUrl = entry?.url;
                if (!rawUrl) return;
                let normalizedUrl = '';
                try {
                    normalizedUrl = new URL(String(rawUrl), window.location.origin).toString();
                } catch {
                    normalizedUrl = String(rawUrl || '').trim();
                }
                if (!normalizedUrl) return;
                const method = String(entry?.method || 'GET').trim().toUpperCase() || 'GET';
                this.requestHistory.push({
                    ts: Date.now(),
                    method,
                    url: normalizedUrl,
                    body: entry?.body ?? null,
                    source: String(entry?.source || '').trim()
                });
                const maxSizeRaw = Number(this.requestHistoryLimit);
                const maxSize = Math.max(500, Number.isFinite(maxSizeRaw) ? maxSizeRaw : 4000);
                if (this.requestHistory.length > maxSize) {
                    this.requestHistory.splice(0, this.requestHistory.length - maxSize);
                }
            },

            getRequestHistory(options = {}) {
                const includePattern = options.includePattern instanceof RegExp ? options.includePattern : null;
                const sinceRaw = Number(options.since);
                const since = Math.max(0, Number.isFinite(sinceRaw) ? sinceRaw : 0);
                const limitRaw = Number(options.limit);
                const fallbackLimitRaw = Number(this.requestHistoryLimit);
                const fallbackLimit = Number.isFinite(fallbackLimitRaw) ? fallbackLimitRaw : 4000;
                const limit = Math.max(1, Math.min(20000, Number.isFinite(limitRaw) ? limitRaw : fallbackLimit));
                let list = Array.isArray(this.requestHistory) ? this.requestHistory.slice() : [];
                if (since > 0) {
                    list = list.filter(item => Number(item?.ts) >= since);
                }
                if (includePattern) {
                    list = list.filter(item => {
                        let path = '';
                        try {
                            path = new URL(String(item?.url || ''), window.location.origin).pathname || '';
                        } catch {
                            path = String(item?.url || '');
                        }
                        return !!path && includePattern.test(path);
                    });
                }
                if (list.length > limit) {
                    list = list.slice(list.length - limit);
                }
                return list.map(item => ({ ...item }));
            },

            clearRequestHistory() {
                this.requestHistory = [];
            },

            unregisterHandler(listName, handler) {
                const list = this[listName];
                if (!Array.isArray(list) || typeof handler !== 'function') return false;
                const index = list.indexOf(handler);
                if (index < 0) return false;
                list.splice(index, 1);
                return true;
            },

            registerFetch(handler) {
                if (typeof handler !== 'function') return () => false;
                this.fetchHandlers.push(handler);
                return () => this.unregisterHandler('fetchHandlers', handler);
            },

            registerXHROpen(handler) {
                if (typeof handler !== 'function') return () => false;
                this.xhrOpenHandlers.push(handler);
                return () => this.unregisterHandler('xhrOpenHandlers', handler);
            },

            registerXHRSend(handler) {
                if (typeof handler !== 'function') return () => false;
                this.xhrSendHandlers.push(handler);
                return () => this.unregisterHandler('xhrSendHandlers', handler);
            },

            registerXHRLoad(handler) {
                if (typeof handler !== 'function') return () => false;
                this.xhrLoadHandlers.push(handler);
                return () => this.unregisterHandler('xhrLoadHandlers', handler);
            },

            install() {
                if (this.installed || hookWindow.__AM_HOOKS_INSTALLED__) return;

                const originalFetch = hookWindow.fetch;
                if (typeof originalFetch === 'function') {
                    hookWindow.fetch = async function (...args) {
                        const first = args?.[0];
                        const second = args?.[1];
                        const method = second?.method || first?.method || 'GET';
                        const url = typeof first === 'string'
                            ? first
                            : first?.url || '';
                        const body = second?.body || first?.body || '';
                        manager.recordRequest({
                            method,
                            url,
                            body,
                            source: 'fetch'
                        });
                        const response = await originalFetch.apply(this, args);
                        manager.fetchHandlers.forEach(handler => {
                            try {
                                handler({ args, response });
                            } catch { }
                        });
                        return response;
                    };
                }

                const originalOpen = hookWindow.XMLHttpRequest.prototype.open;
                const originalSend = hookWindow.XMLHttpRequest.prototype.send;

                hookWindow.XMLHttpRequest.prototype.open = function (...args) {
                    const [method, url] = args;
                    this.__amHookMethod = method;
                    this.__amHookUrl = url;

                    manager.xhrOpenHandlers.forEach(handler => {
                        try {
                            handler({ xhr: this, method, url, args });
                        } catch { }
                    });

                    return originalOpen.apply(this, args);
                };

                hookWindow.XMLHttpRequest.prototype.send = function (...args) {
                    const [data] = args;
                    const xhr = this;
                    manager.recordRequest({
                        method: xhr.__amHookMethod || 'POST',
                        url: xhr.__amHookUrl || '',
                        body: data,
                        source: 'xhr'
                    });

                    manager.xhrSendHandlers.forEach(handler => {
                        try {
                            handler({
                                xhr,
                                data,
                                method: xhr.__amHookMethod,
                                url: xhr.__amHookUrl,
                                args
                            });
                        } catch { }
                    });

                    xhr.addEventListener('load', function () {
                        manager.xhrLoadHandlers.forEach(handler => {
                            try {
                                handler({
                                    xhr: this,
                                    method: this.__amHookMethod,
                                    url: this.__amHookUrl
                                });
                            } catch { }
                        });
                    });

                    return originalSend.apply(xhr, args);
                };

                this.installed = true;
                hookWindow.__AM_HOOKS_INSTALLED__ = true;
                window.__AM_HOOKS_INSTALLED__ = true;
            }
        };

        hookWindow.__AM_HOOK_MANAGER__ = manager;
        window.__AM_HOOK_MANAGER__ = manager;
        return manager;
    };

    const safeParseJSON = (raw) => {
        if (!raw) return null;
        try {
            return JSON.parse(raw);
        } catch {
            return null;
        }
    };

    const normalizeConfig = (rawConfig) => {
        const parsedRevision = Number(rawConfig?.configRevision);
        const hasValidRevision = Number.isFinite(parsedRevision);
        const needsRevisionUpgrade = !hasValidRevision || parsedRevision < CONSTANTS.CONFIG_REVISION;
        const nextConfig = { ...DEFAULT_CONFIG, ...rawConfig, panelOpen: false };

        if (needsRevisionUpgrade) {
            nextConfig.logExpanded = false;
            nextConfig.configRevision = CONSTANTS.CONFIG_REVISION;
        } else {
            nextConfig.configRevision = parsedRevision;
        }

        return { config: nextConfig, migrated: needsRevisionUpgrade };
    };

    const loadConfig = () => {
        const current = safeParseJSON(localStorage.getItem(CONSTANTS.STORAGE_KEY));
        if (current && typeof current === 'object') {
            const { config, migrated } = normalizeConfig(current);
            if (migrated) {
                localStorage.setItem(CONSTANTS.STORAGE_KEY, JSON.stringify(config));
            }
            return config;
        }

        for (const legacyKey of CONSTANTS.LEGACY_STORAGE_KEYS) {
            const legacy = safeParseJSON(localStorage.getItem(legacyKey));
            if (legacy && typeof legacy === 'object') {
                const { config } = normalizeConfig(legacy);
                localStorage.setItem(CONSTANTS.STORAGE_KEY, JSON.stringify(config));
                return config;
            }
        }

        return { ...DEFAULT_CONFIG };
    };

    const State = {
        config: loadConfig(),
        save() {
            localStorage.setItem(CONSTANTS.STORAGE_KEY, JSON.stringify(this.config));
        }
    };

    // ==========================================
    // 2. æ—¥å¿—ç³»ç»Ÿ (DOM ç¼“å­˜ä¼˜åŒ–)
    // ==========================================
    const Logger = {
        el: null,
        buffer: [],
        timer: null,

        info(msg, ...args) {
            this.log(msg, false, ...args);
        },

        warn(msg, ...args) {
            this.log(msg, true, ...args);
        },

        error(msg, ...args) {
            this.log(msg, true, ...args);
        },

        log(msg, isError = false, ...args) {
            const now = new Date();
            const time = `${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;

            const toText = (value) => {
                if (typeof value === 'string') return value;
                if (value === null || value === undefined) return String(value ?? '');
                try {
                    return JSON.stringify(value);
                } catch {
                    return String(value);
                }
            };
            const fullMsg = [msg, ...args].map(toText).filter(Boolean).join(' ');

            // Console output
            const logStyle = isError ? 'color: #ff4d4f' : 'color: #1890ff';
            console.log(`%c[AM] ${fullMsg}`, logStyle);

            // Buffer for UI update
            this.buffer.push({ time, msg: fullMsg, isError });
            this.scheduleFlush();
        },

        scheduleFlush() {
            if (this.timer) return;
            this.timer = requestAnimationFrame(() => this.flush());
        },

        flush() {
            if (!this.el || this.buffer.length === 0) {
                this.timer = null;
                return;
            }

            const fragment = document.createDocumentFragment();
            const today = new Date().toLocaleDateString('zh-CN');

            // å‡†ç¡®æ£€æŸ¥æ˜¯å¦éœ€è¦æ’å…¥æ—¥æœŸæ ‡é¢˜ (æŸ¥æ‰¾å®¹å™¨å†…æœ€åä¸€ä¸ªæ—¥æœŸæ ‡é¢˜)
            const dateHeaders = this.el.getElementsByClassName('am-log-date-header');
            const lastDateText = dateHeaders.length > 0 ? dateHeaders[dateHeaders.length - 1].dataset.date : '';

            this.buffer.forEach(({ time, msg, isError }) => {
                if (today !== this.lastFlushedDate && today !== lastDateText) {
                    const dateDiv = document.createElement('div');
                    dateDiv.className = 'am-log-date-header';
                    dateDiv.dataset.date = today;
                    dateDiv.style.cssText = 'color:#888;font-size:10px;text-align:center;margin:8px 0;border-bottom:1px solid #eee;position:relative;';
                    const dateText = document.createElement('span');
                    dateText.style.cssText = 'background:#fff;padding:0 8px;position:relative;top:8px;';
                    dateText.textContent = today;
                    dateDiv.appendChild(dateText);
                    fragment.appendChild(dateDiv);
                    this.lastFlushedDate = today;
                }

                const div = document.createElement('div');
                div.className = 'am-log-line';
                const timeNode = document.createElement('span');
                timeNode.className = 'am-log-time';
                timeNode.textContent = `[${time}]`;
                div.appendChild(timeNode);
                div.appendChild(document.createTextNode(msg));
                if (isError) div.style.color = '#ff4d4f';
                fragment.appendChild(div);
            });

            this.el.appendChild(fragment);

            // æ¸…ç†æ—§æ—¥å¿— (ä¿æŒçº¦100æ¡)
            while (this.el.childElementCount > 100) {
                this.el.firstChild.remove();
            }

            // æ»šåŠ¨åˆ°åº•éƒ¨
            if (State.config.logExpanded && (this.el.scrollHeight - this.el.scrollTop - this.el.clientHeight < 50)) {
                this.el.scrollTop = this.el.scrollHeight;
            }

            this.buffer = [];
            this.timer = null;
        },

        clear() {
            if (this.el) this.el.innerHTML = '';
        }
    };

    // ==========================================
    // 3. æ ¸å¿ƒè®¡ç®— (Logic)
    // ==========================================
    const Core = {
        // ä½¿ç”¨ XPath é«˜æ•ˆæŸ¥æ‰¾åŒ…å« "èŠ±è´¹(å…ƒ)" çš„å…ƒç´ ï¼Œé¿å…éå†æ‰€æœ‰ span
        getTotalCost() {
            try {
                // XPath å®šä½ï¼šæŸ¥æ‰¾åŒ…å«æ–‡æœ¬ "èŠ±è´¹(å…ƒ)" çš„ span
                // é™åˆ¶æŸ¥æ‰¾èŒƒå›´åœ¨å¸¸è§çš„é¡¶éƒ¨ç»Ÿè®¡åŒºåŸŸ (class åŒ…å« summary æˆ– overview çš„ div)ï¼Œå¦‚æœæ‰¾ä¸åˆ°åˆ™å…¨æ–‡æŸ¥æ‰¾
                const xpath = "//span[contains(text(), 'èŠ±è´¹(å…ƒ)')]";
                const result = document.evaluate(xpath, document, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null);
                let span = result.singleNodeValue;

                if (span) {
                    const container = span.closest('div');
                    if (container) {
                        const rawText = container.textContent.replace('èŠ±è´¹(å…ƒ)', '').replace(/,/g, '').trim();
                        // æå–ç¬¬ä¸€ä¸ªæµ®ç‚¹æ•°
                        const match = rawText.match(/(\d+(\.\d+)?)/);
                        if (match) {
                            return parseFloat(match[0]) || 0;
                        }
                    }
                }
                return 0;
            } catch (e) {
                return 0;
            }
        },

        // è§£æå•å…ƒæ ¼æ•°å€¼
        parseValue(cell) {
            if (!cell) return 0;
            // ä¼˜åŒ–ï¼šåªè·å–æ–‡æœ¬èŠ‚ç‚¹ï¼Œé¿å…è·å–åˆ°å·²æ’å…¥çš„ tag å¯¼è‡´é‡å¤è®¡ç®—åå·®
            let text = '';
            let child = cell.firstChild;
            while (child) {
                if (child.nodeType === 3) { // Text node
                    text += child.nodeValue;
                } else if (child.nodeType === 1 && !child.classList.contains('am-helper-tag')) { // Element node (non-tag)
                    text += child.textContent;
                }
                child = child.nextSibling;
            }
            const match = text.replace(/,/g, '').trim().match(/^(\d+(\.\d+)?)/);
            return match ? parseFloat(match[1]) : 0;
        },

        renderTag(cell, type, text, extraStyle) {
            const fullStyle = CONSTANTS.TAG_BASE_STYLE + extraStyle;
            const existing = cell.querySelector(`.am-helper-tag.${type}`);
            if (existing) {
                if (existing.textContent === text) return false;
                existing.textContent = text;
                existing.style.cssText = fullStyle;
                return true;
            }

            const span = document.createElement('span');
            span.className = `am-helper-tag ${type}`;
            span.style.cssText = fullStyle;
            span.textContent = text;
            cell.appendChild(span);
            return true;
        },

        // åˆ—ç´¢å¼•æ˜ å°„ç¼“å­˜
        colMapCache: { signature: '', map: null },

        getColumnIndexMap(headers) {
            // ç”Ÿæˆ Header ç­¾åä»¥å†³å®šæ˜¯å¦æ›´æ–° Map
            const signature = Array.from(headers).map(h => (h.textContent || '').replace(/\s+/g, '')).join('|');
            if (this.colMapCache.signature === signature && this.colMapCache.map) {
                return this.colMapCache.map;
            }

            const map = { cost: -1, wang: -1, carts: [], guide: -1, click: -1, budget: -1 };
            headers.forEach((th, i) => {
                const text = (th.textContent || '').replace(/\s+/g, ''); // ç§»é™¤æ‰€æœ‰ç©ºæ ¼
                const idx = (th.cellIndex !== undefined) ? th.cellIndex : i;

                if (text.includes('èŠ±è´¹') && !text.includes('å¹³å‡') && !text.includes('åƒæ¬¡')) map.cost = idx;
                else if (text.includes('æ—ºæ—ºå’¨è¯¢é‡')) map.wang = idx;
                else if ((text.includes('è´­ç‰©è½¦') || text.includes('åŠ è´­')) && !text.includes('ç‡') && !text.includes('æˆæœ¬')) map.carts.push(idx);
                else if ((text.includes('å¼•å¯¼è®¿é—®') && text.includes('æ½œå®¢')) || (text.includes('æ½œå®¢æ•°') && !text.includes('å æ¯”'))) map.guide = idx;
                else if (text.includes('ç‚¹å‡»é‡')) map.click = idx;
                else if (text.includes('é¢„ç®—') && !text.includes('å»ºè®®')) map.budget = idx;
            });

            this.colMapCache = { signature, map };
            return map;
        },

        isElementVisible(el) {
            if (!el) return false;
            const style = window.getComputedStyle(el);
            if (style.display === 'none' || style.visibility === 'hidden') return false;
            return el.getClientRects().length > 0;
        },

        resolveStickyHeaderWrapper(stickyBodyWrapper) {
            if (!stickyBodyWrapper) return null;
            const parent = stickyBodyWrapper.parentElement;
            if (!parent) return null;

            const directBodies = Array.from(parent.children).filter(el => el.matches('[mx-stickytable-wrapper="body"]'));
            const directHeads = Array.from(parent.children).filter(el => el.matches('[mx-stickytable-wrapper="head"]'));
            if (directBodies.length > 0 && directBodies.length === directHeads.length) {
                const idx = directBodies.indexOf(stickyBodyWrapper);
                if (idx > -1) return directHeads[idx];
            }

            const prev = stickyBodyWrapper.previousElementSibling;
            if (prev?.matches('[mx-stickytable-wrapper="head"]')) return prev;
            const next = stickyBodyWrapper.nextElementSibling;
            if (next?.matches('[mx-stickytable-wrapper="head"]')) return next;

            return parent.querySelector('[mx-stickytable-wrapper="head"]');
        },

        getTableHeaders(table) {
            if (!table) return null;

            const stickyBodyWrapper = table.closest('[mx-stickytable-wrapper="body"]');
            const stickyHeaderWrapper = this.resolveStickyHeaderWrapper(stickyBodyWrapper);
            if (stickyHeaderWrapper) {
                const stickyHeaders = stickyHeaderWrapper.querySelectorAll('th');
                if (stickyHeaders.length > 0) return stickyHeaders;
            }

            const headers = table.querySelectorAll('thead th');
            return headers.length > 0 ? headers : null;
        },

        getTableScore(colMap) {
            let score = 0;
            if (colMap.cost > -1) score += 8;
            if (colMap.wang > -1) score += 4;
            if (colMap.carts.length > 0) score += 2;
            if (colMap.guide > -1 && colMap.click > -1) score += 2;
            if (colMap.budget > -1) score += 1;
            return score;
        },

        getTableMaxCells(table, maxScanRows = 30) {
            if (!table) return 0;

            const rows = table.rows;
            let maxCells = 0;
            let scanned = 0;
            for (let i = 0; i < rows.length && scanned < maxScanRows; i++) {
                const row = rows[i];
                if (!row || row.parentElement?.tagName === 'THEAD') continue;
                scanned++;
                if (row.cells && row.cells.length > maxCells) {
                    maxCells = row.cells.length;
                }
            }
            return maxCells;
        },

        getTableCapabilityScore(colMap, headerCount, maxCells) {
            if (!colMap || headerCount <= 0 || maxCells <= 0) return 0;

            const offset = Math.max(0, headerCount - maxCells);
            const toBodyIdx = (idx) => (idx > -1 ? idx - offset : -1);
            const hasCell = (idx) => idx > -1 && idx < maxCells;

            const costIdx = toBodyIdx(colMap.cost);
            const wangIdx = toBodyIdx(colMap.wang);
            const guideIdx = toBodyIdx(colMap.guide);
            const clickIdx = toBodyIdx(colMap.click);
            const budgetIdx = toBodyIdx(colMap.budget);
            const cartIdxList = (colMap.carts || []).map(toBodyIdx);

            let score = 0;
            if (hasCell(costIdx)) score += 12;
            if (hasCell(wangIdx)) score += 6;
            if (cartIdxList.some(hasCell)) score += 4;
            if (hasCell(guideIdx) && hasCell(clickIdx)) score += 3;
            if (hasCell(budgetIdx)) score += 2;
            score += Math.min(5, Math.floor(maxCells / 5));

            return score;
        },

        resolveTableContext() {
            const tableList = document.querySelectorAll('div[mx-stickytable-wrapper="body"] table, table');
            if (!tableList || tableList.length === 0) return null;

            const contexts = [];
            const seen = new Set();

            tableList.forEach(table => {
                if (!table || seen.has(table)) return;
                seen.add(table);

                const headers = this.getTableHeaders(table);
                if (!headers || headers.length === 0) return;

                const colMap = this.getColumnIndexMap(headers);
                const stickyBodyWrapper = table.closest('[mx-stickytable-wrapper="body"]');
                const visible = this.isElementVisible(stickyBodyWrapper || table);
                const rowCount = table.tBodies?.[0]?.rows?.length || table.rows.length || 0;
                const maxCells = this.getTableMaxCells(table);
                const baseScore = this.getTableScore(colMap);
                const capabilityScore = this.getTableCapabilityScore(colMap, headers.length, maxCells);

                if (rowCount <= 0 || maxCells <= 0) return;
                if (capabilityScore <= 0 && baseScore <= 0) return;

                contexts.push({
                    table,
                    headers,
                    colMap,
                    score: baseScore,
                    capabilityScore,
                    visible,
                    rowCount,
                    maxCells
                });
            });

            if (contexts.length === 0) return null;

            contexts.sort((a, b) => {
                const visibleDelta = Number(b.visible) - Number(a.visible);
                if (visibleDelta !== 0) return visibleDelta;
                const capabilityDelta = b.capabilityScore - a.capabilityScore;
                if (capabilityDelta !== 0) return capabilityDelta;
                const scoreDelta = b.score - a.score;
                if (scoreDelta !== 0) return scoreDelta;
                const cellDelta = b.maxCells - a.maxCells;
                if (cellDelta !== 0) return cellDelta;
                return b.rowCount - a.rowCount;
            });

            return contexts[0];
        },

        resolveChargeHeader(table) {
            const stickyBodyWrapper = table?.closest?.('[mx-stickytable-wrapper="body"]');
            const stickyHeaderWrapper = this.resolveStickyHeaderWrapper(stickyBodyWrapper);
            const scopedHeader = stickyHeaderWrapper?.querySelector('[mx-stickytable-sort="charge"]');
            if (scopedHeader) return scopedHeader;
            const scope = stickyBodyWrapper?.parentElement || document;
            return scope.querySelector('[mx-stickytable-sort="charge"]') || document.querySelector('[mx-stickytable-sort="charge"]');
        },

        run() {
            const tableContext = this.resolveTableContext();
            if (!tableContext) return;
            const { table, headers, colMap } = tableContext;

            // è‡ªåŠ¨ç‚¹å‡»èŠ±è´¹åˆ—é™åºæ’åºï¼ˆéœ€è¦å¼€å¯é…ç½®ï¼Œä¸”æœªæ’åºæ—¶ï¼‰
            if (State.config.autoSortCharge && !this._sortedByCharge) {
                const chargeHeader = this.resolveChargeHeader(table);
                if (chargeHeader) {
                    // æ£€æŸ¥å½“å‰æ˜¯å¦å·²ç»æ˜¯é™åº
                    const currentOrder = chargeHeader.getAttribute('mx-stickytable-sort-order');
                    if (currentOrder !== 'desc') {
                        // ç‚¹å‡»é™åºæŒ‰é’®
                        const descBtn = chargeHeader.querySelector('[mx-stickytable-sort-trigger="desc"]');
                        if (descBtn) {
                            descBtn.click();
                            Logger.log('ğŸ“Š å·²è‡ªåŠ¨æŒ‰èŠ±è´¹é™åºæ’åº');
                            this._sortedByCharge = true;
                            return; // ç­‰å¾…æ’åºå®Œæˆåå†æ¸²æŸ“æ•°æ®
                        }
                    } else {
                        this._sortedByCharge = true; // å·²ç»æ˜¯é™åºï¼Œæ ‡è®°
                    }
                }
            }
            const { showCost, showCartCost, showPercent, showCostRatio, showBudget } = State.config;

            // æ£€æŸ¥æ˜¯å¦éœ€è¦æ‰§è¡Œ
            const needCost = showCost && colMap.cost > -1 && colMap.wang > -1;
            const needCart = showCartCost && colMap.cost > -1 && colMap.carts.length > 0;
            const needPercent = showPercent && colMap.guide > -1 && colMap.click > -1;
            const needRatio = showCostRatio && colMap.cost > -1;
            const needBudget = showBudget && colMap.cost > -1 && colMap.budget > -1;

            if (!needCost && !needCart && !needPercent && !needRatio && !needBudget) return;

            // è·å–æ€»èŠ±è´¹ (åªéœ€ä¸€æ¬¡ï¼Œä¸”å»é‡æ—¥å¿—)
            const totalCost = needRatio ? this.getTotalCost() : 0;
            if (needRatio && totalCost > 0 && this._lastTotalCost !== totalCost) {
                this._lastTotalCost = totalCost;
                Logger.log(`ğŸ’° æ€»èŠ±è´¹æ›´æ–°: ${totalCost}`);
            }

            const rows = table.rows; // ä½¿ç”¨åŸç”Ÿ .rows å±æ€§æ¯” querySelectorAll æ›´å¿«
            let updatedCount = 0;

            // ä½¿ç”¨ for å¾ªç¯éå†ï¼Œæ€§èƒ½ç•¥ä¼˜äº forEach
            for (let i = 0; i < rows.length; i++) {
                const row = rows[i];
                // è·³è¿‡è¡¨å¤´è¡Œ
                if (row.parentElement.tagName === 'THEAD') continue;

                const cells = row.cells;
                if (!cells || cells.length === 0) continue;

                // è‡ªåŠ¨åç§»ä¿®æ­£ (å¤„ç†åˆè®¡è¡Œæˆ–åˆ†ç»„æ ‡é¢˜è¡Œçš„ colspan)
                let curMap = colMap;
                const offset = headers.length - cells.length;

                if (offset > 0) {
                    curMap = { ...colMap }; // æµ…æ‹·è´
                    if (curMap.cost > -1) curMap.cost -= offset;
                    if (curMap.wang > -1) curMap.wang -= offset;
                    curMap.carts = curMap.carts.map(c => c - offset);
                    if (curMap.guide > -1) curMap.guide -= offset;
                    if (curMap.click > -1) curMap.click -= offset;
                    if (curMap.budget > -1) curMap.budget -= offset;
                }

                const getCell = (idx) => cells[idx];

                // 1. è¯¢å•æˆæœ¬
                if (needCost) {
                    const cCost = getCell(curMap.cost);
                    const cWang = getCell(curMap.wang);
                    if (cCost && cWang) {
                        const cost_val = this.parseValue(cCost);
                        const wang_val = this.parseValue(cWang);
                        if (wang_val > 0) {
                            if (this.renderTag(cWang, 'cost-tag', `è¯¢æˆ: ${(cost_val / wang_val).toFixed(1)}`, CONSTANTS.STYLES.cost)) updatedCount++;
                        }
                    }
                }

                // 2. åŠ è´­æˆæœ¬
                if (needCart && curMap.cost > -1) {
                    const cCost = getCell(curMap.cost);
                    if (cCost) {
                        const cost_val = this.parseValue(cCost);
                        curMap.carts.forEach(cIdx => {
                            const cCart = getCell(cIdx);
                            if (cCart) {
                                const cart_val = this.parseValue(cCart);
                                if (cart_val > 0) {
                                    if (this.renderTag(cCart, 'cart-tag', `åŠ æˆ: ${(cost_val / cart_val).toFixed(1)}`, CONSTANTS.STYLES.cart)) updatedCount++;
                                }
                            }
                        });
                    }
                }

                // 3. æ½œå®¢å æ¯”
                if (needPercent) {
                    const cGuide = getCell(curMap.guide);
                    const cClick = getCell(curMap.click);
                    if (cGuide && cClick) {
                        const guide_val = this.parseValue(cGuide);
                        const click_val = this.parseValue(cClick);
                        if (click_val > 0) {
                            if (this.renderTag(cGuide, 'percent-tag', `æ½œå®¢: ${((guide_val / click_val) * 100).toFixed(1)}%`, CONSTANTS.STYLES.percent)) updatedCount++;
                        }
                    }
                }

                // 4. èŠ±è´¹å æ¯”
                if (needRatio && totalCost > 0) {
                    const cCost = getCell(curMap.cost);
                    if (cCost) {
                        const cost_val = this.parseValue(cCost);
                        if (cost_val > 0) {
                            if (this.renderTag(cCost, 'ratio-tag', `å æ¯”: ${((cost_val / totalCost) * 100).toFixed(1)}%`, CONSTANTS.STYLES.ratio)) updatedCount++;
                        }
                    }
                }

                if (needBudget) {
                    const cCost = getCell(curMap.cost);
                    const cBudget = getCell(curMap.budget);
                    if (cCost && cBudget) {
                        // è§£æèŠ±è´¹å•å…ƒæ ¼ï¼šè·å–æ€»èŠ±è´¹å’ŒåŸºç¡€èŠ±è´¹
                        const costText = cCost.textContent || '';
                        const baseCostMatch = costText.match(/åŸºç¡€([\d,.]+)/);
                        const totalCostVal = this.parseValue(cCost);
                        const baseCost = baseCostMatch ? parseFloat(baseCostMatch[1].replace(/,/g, '')) : 0;
                        const multiCost = totalCostVal - baseCost;

                        // åœ¨é¢„ç®—å•å…ƒæ ¼ä¸­æŸ¥æ‰¾åŒ…å«"åŸºç¡€"å’Œ"å¤šç›®æ ‡"çš„div
                        const budgetDivs = cBudget.querySelectorAll('div');
                        let baseDiv = null;
                        let multiDiv = null;

                        budgetDivs.forEach(div => {
                            const text = div.textContent || '';
                            if (text.includes('åŸºç¡€') && !div.classList.contains('am-helper-tag')) {
                                baseDiv = div;
                            } else if (text.includes('å¤šç›®æ ‡') && !div.classList.contains('am-helper-tag')) {
                                multiDiv = div;
                            }
                        });

                        // è§£æé¢„ç®—å€¼
                        const budgetText = cBudget.textContent || '';
                        const baseBudgetMatch = budgetText.match(/åŸºç¡€[ï¼š:]\s*([\d,]+)/);
                        const multiBudgetMatch = budgetText.match(/å¤šç›®æ ‡[ï¼š:]\s*([\d,]+)/);
                        const baseBudget = baseBudgetMatch ? parseFloat(baseBudgetMatch[1].replace(/,/g, '')) : 0;
                        const multiBudget = multiBudgetMatch ? parseFloat(multiBudgetMatch[1].replace(/,/g, '')) : 0;

                        // åœ¨"åŸºç¡€"divåæ·»åŠ åŸºç¡€å æ¯”æ ‡ç­¾
                        if (baseDiv && baseBudget > 0) {
                            const basePercent = Math.min(100, (baseCost / baseBudget) * 100).toFixed(1);
                            const bgStyle = `background:linear-gradient(90deg,rgba(82,196,26,0.25) ${basePercent}%,rgba(82,196,26,0.05) ${basePercent}%);`;

                            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨æ ‡ç­¾
                            let existingTag = baseDiv.parentElement.querySelector('.am-helper-tag.budget-base-tag');
                            if (!existingTag) {
                                const span = document.createElement('span');
                                span.className = 'am-helper-tag budget-base-tag';
                                span.style.cssText = CONSTANTS.TAG_BASE_STYLE + CONSTANTS.STYLES.budget + bgStyle;
                                span.textContent = `${basePercent}%`;
                                baseDiv.after(span);
                                updatedCount++;
                            } else if (existingTag.textContent !== `${basePercent}%`) {
                                existingTag.textContent = `${basePercent}%`;
                                existingTag.style.cssText = CONSTANTS.TAG_BASE_STYLE + CONSTANTS.STYLES.budget + bgStyle;
                                updatedCount++;
                            }
                        }

                        // åœ¨"å¤šç›®æ ‡"divåæ·»åŠ å¤šç›®æ ‡å æ¯”æ ‡ç­¾
                        if (multiDiv && multiBudget > 0 && multiCost >= 0) {
                            const multiPercent = Math.min(100, (multiCost / multiBudget) * 100).toFixed(1);
                            const bgStyle = `background:linear-gradient(90deg,rgba(82,196,26,0.25) ${multiPercent}%,rgba(82,196,26,0.05) ${multiPercent}%);`;

                            // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨æ ‡ç­¾
                            let existingTag = multiDiv.parentElement.querySelector('.am-helper-tag.budget-multi-tag');
                            if (!existingTag) {
                                const span = document.createElement('span');
                                span.className = 'am-helper-tag budget-multi-tag';
                                span.style.cssText = CONSTANTS.TAG_BASE_STYLE + CONSTANTS.STYLES.budget + bgStyle;
                                span.textContent = `${multiPercent}%`;
                                multiDiv.after(span);
                                updatedCount++;
                            } else if (existingTag.textContent !== `${multiPercent}%`) {
                                existingTag.textContent = `${multiPercent}%`;
                                existingTag.style.cssText = CONSTANTS.TAG_BASE_STYLE + CONSTANTS.STYLES.budget + bgStyle;
                                updatedCount++;
                            }
                        }

                        // å¦‚æœæ²¡æœ‰æ‰¾åˆ°åˆ†ç±»divï¼Œä½¿ç”¨åŸæ¥çš„æ€»ä½“é¢„ç®—è¿›åº¦æ˜¾ç¤º
                        if (!baseDiv && !multiDiv) {
                            const totalBudget = this.parseValue(cBudget);
                            if (totalBudget > 0) {
                                const percent = Math.min(100, (totalCostVal / totalBudget) * 100).toFixed(1);
                                const bgStyle = `background:linear-gradient(90deg,rgba(82,196,26,0.25) ${percent}%,rgba(82,196,26,0.05) ${percent}%);`;
                                if (this.renderTag(cBudget, 'budget-tag', `${percent}%`, CONSTANTS.STYLES.budget + bgStyle)) updatedCount++;
                            }
                        }
                    }
                }
            }

            if (updatedCount > 0) Logger.log(`âœ… æ›´æ–° ${updatedCount} é¡¹æ•°æ®`);
        }
    };

    const resetSortState = (reason) => {
        Core._sortedByCharge = false;
        Core._lastTotalCost = null;
        Logger.log(`ğŸ“ ${reason}ï¼Œé‡ç½®æ’åº`);
    };

    // ==========================================
    // 4. UI ç•Œé¢ (View) - å‚è€ƒç®—æ³•æŠ¤èˆªè„šæœ¬æ ·å¼
    // ==========================================
    const UI = {
        runtime: {
            assistExpanded: false
        },

        init() {
            this.injectStyles();
            this.createElements();
            this.bindEvents();
            this.updateState();
        },

        injectStyles() {
            // å¼ºåˆ¶æ›´æ–°æ ·å¼ï¼šå¦‚æœå­˜åœ¨æ—§ ID çš„æ ·å¼æ ‡ç­¾ï¼Œå…ˆç§»é™¤
            const oldStyle = document.getElementById('am-helper-mac26-style');
            if (oldStyle) oldStyle.remove();

            if (document.getElementById('am-helper-pro-v26-style')) return;
            const css = `
                :root {
                    --am26-font: "SF Pro Display", "SF Pro Text", "PingFang SC", "Microsoft YaHei", sans-serif;
                    --am26-mono: "SF Mono", "JetBrains Mono", "Menlo", "Monaco", "Consolas", monospace;
                    --am26-text: #1b2438;
                    --am26-text-soft: #505a74;
                    --am26-border: rgba(255, 255, 255, 0.4); 
                    --am26-border-strong: rgba(255, 255, 255, 0.6);
                    --am26-surface: rgba(255, 255, 255, 0.25);
                    --am26-surface-strong: rgba(255, 255, 255, 0.45);
                    --am26-panel: linear-gradient(135deg, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0.1));
                    --am26-panel-strong: linear-gradient(135deg, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0.2));
                    --am26-primary: rgba(69, 84, 229, 1);
                    --am26-primary-strong: #1d3fcf;
                    --am26-primary-soft: rgba(42, 91, 255, 0.15);
                    --am26-success: #0ea86f;
                    --am26-warning: #e8a325;
                    --am26-danger: #ea4f4f;
                    --am26-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
                    --am26-glow: inset 0 0 0 1px rgba(255, 255, 255, 0.3);
                    --mx-number-report-brand-color: rgba(69,84,229,1);
                    --mx-number-report-brand-color50: rgba(69,84,229,0.5);
                    --mx-number-report-brand-color10: rgba(69,84,229,0.1);
                    --mx-number-report-brand-color1: rgba(69,84,229,0.01);
                }

                #am-helper-panel,
                #am-magic-report-popup,
                #alimama-escort-helper-ui,
                #am-report-capture-panel,
                #alimama-escort-helper-ui-result-overlay > div {
                    font-family: var(--am26-font) !important;
                    color: var(--am26-text) !important;
                    backdrop-filter: blur(20px);
                    -webkit-backdrop-filter: blur(20px);
                    box-shadow: var(--am26-shadow) !important;
                    border: 1px solid var(--am26-border) !important;
                }

                /* æ‚¬æµ®çƒï¼ˆæœ€å°åŒ–æŒ‰é’®ï¼‰ */
                #am-helper-icon {
                    position: fixed; top: 120px; right: 20px; z-index: 999999;
                    width: 40px; height: 40px; border-radius: 50%;
                    border: 1px solid var(--am26-border);
                    background: var(--am26-surface-strong);
                    backdrop-filter: blur(10px);
                    -webkit-backdrop-filter: blur(10px);
                    box-shadow: var(--am26-shadow), var(--am26-glow);
                    cursor: pointer;
                    display: flex; align-items: center; justify-content: center;
                    color: var(--am26-primary);
                    transition: all 0.3s ease;
                }
                #am-helper-icon:hover { 
                    transform: translateY(-1px) scale(1.08);
                    border-color: var(--am26-border-strong);
                    color: var(--am26-primary-strong);
                    background: rgba(255,255,255,0.6);
                }

                /* ä¸»é¢æ¿ */
                #am-helper-panel {
                    position: fixed; top: 120px; right: 20px; z-index: 999999;
                    background: var(--am26-panel);
                    border-radius: 18px;
                    width: 280px; min-width: 250px; max-width: 500px;
                    opacity: 1; transform: scale(1); transform-origin: top right;
                    transition: opacity 0.3s ease, transform 0.3s ease, width 0.5s ease;
                    overflow: hidden;
                }
                #am-helper-panel.hidden {
                    opacity: 0; transform: scale(0.8); pointer-events: none;
                }

                /* å¤´éƒ¨ */
                .am-header { 
                    padding: 14px 18px; 
                    border-bottom: 1px solid var(--am26-border); 
                    background: rgba(255, 255, 255, 0.1);
                    display: flex; justify-content: space-between; align-items: center; 
                }
                .am-title { 
                    font-weight: 600; font-size: 15px; color: var(--am26-text);
                    display: flex; align-items: center; gap: 8px;
                    text-shadow: 0 1px 0 rgba(255,255,255,0.4);
                }
                .am-version {
                    font-size: 10px; color: var(--am26-text-soft); font-weight: normal;
                    background: rgba(255,255,255,0.3); padding: 1px 4px; border-radius: 6px;
                }
                .am-icon-btn { 
                    cursor: pointer; color: var(--am26-text-soft); font-size: 16px; font-weight: bold;
                    width: 28px; height: 28px; display: flex; align-items: center; justify-content: center;
                    border-radius: 8px; transition: all 0.2s;
                }
                .am-icon-btn:hover { background: rgba(255, 255, 255, 0.3); color: var(--am26-text); }
                .am-icon-btn.danger:hover { background: rgba(234, 79, 79, 0.15); color: var(--am26-danger); }
                
                .am-close-btn { 
                    cursor: pointer; color: var(--am26-text-soft); font-size: 16px; font-weight: bold;
                    width: 28px; height: 28px; display: flex; align-items: center; justify-content: center;
                    border-radius: 8px; transition: all 0.2s;
                }
                .am-close-btn:hover { background: rgba(255, 255, 255, 0.3); color: var(--am26-danger); }

                /* å†…å®¹åŒº */
                .am-body { padding: 18px; }



                .am-tools-row {
                    display: grid;
                    grid-template-columns: repeat(2, minmax(0, 1fr));
                    gap: 8px;
                    margin-bottom: 0;
                }
                .am-tool-btn {
                    flex: 1; text-align: center; padding: 12px 0; border-radius: 10px;
                    background: var(--mx-number-report-brand-color1); 
                    border: 1px solid rgba(0, 0, 0, 0.1);
                    color: var(--am26-text-soft); font-size: 12px; font-weight: 500;
                    cursor: pointer; transition: all 0.3s;
                    display: flex; align-items: center; justify-content: center; gap: 4px;
                    white-space: nowrap;
                    word-break: keep-all;
                    flex-wrap: nowrap;
                    line-height: 1.2;
                }
                .am-tool-btn svg {
                    width: 14px;
                    height: 14px;
                    flex: 0 0 14px;
                }
                .am-tool-btn:hover {
                    background: var(--mx-number-report-brand-color10); 
                    border-color: var(--mx-number-report-brand-color);
                    color: var(--mx-number-report-brand-color);
                    box-shadow: 0 0 10px var(--mx-number-report-brand-color50); /* äº®ç¯æ•ˆæœ */
                    transform: translateY(-1px);
                }
                .am-tool-btn.active {
                    background: linear-gradient(135deg, var(--mx-number-report-brand-color10), rgba(69, 84, 229, 0.2));
                    border-color: var(--mx-number-report-brand-color);
                    color: var(--mx-number-report-brand-color);
                    box-shadow: inset 0 0 0 1px var(--mx-number-report-brand-color10), 0 0 10px var(--mx-number-report-brand-color50);
                }

                #am-assist-switches {
                    max-height: 0;
                    opacity: 0;
                    transform: translateY(-6px);
                    overflow: hidden;
                    pointer-events: none;
                    margin-top: 0;
                    padding: 0 10px;
                    border-radius: 12px;
                    border: 1px solid transparent;
                    background: linear-gradient(135deg, rgba(69, 84, 229, 0.14), rgba(69, 84, 229, 0.04) 55%, rgba(255, 255, 255, 0.24));
                    transition: max-height 0.32s ease, opacity 0.24s ease, transform 0.32s ease, margin-top 0.32s ease, padding 0.32s ease, border-color 0.32s ease;
                }
                #am-assist-switches.open {
                    max-height: 220px;
                    opacity: 1;
                    transform: translateY(0);
                    pointer-events: auto;
                    margin-top: 10px;
                    padding: 12px 10px;
                    border-color: rgba(69, 84, 229, 0.22);
                }

                .am-switches-grid {
                    display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px;
                }
                .am-switch-btn {
                    height: 36px; /* å›ºå®šé«˜åº¦ */
                    text-align: center; font-size: 12px; border-radius: 10px;
                    border: 1px solid #e0e0e0; /* é»˜è®¤æµ…ç°è‰²è¾¹æ¡† */
                    background: rgba(255, 255, 255, 0.4);
                    color: var(--am26-text-soft); cursor: pointer; transition: all 0.3s;
                    display: flex; align-items: center; justify-content: center;
                }
                .am-switch-btn:hover {
                    background: rgba(255, 255, 255, 0.8); 
                    border-color: var(--mx-number-report-brand-color);
                    box-shadow: 0 0 8px var(--mx-number-report-brand-color10); /* äº®ç¯æ•ˆæœ */
                }
                .am-switch-btn.active {
                    background: var(--mx-number-report-brand-color10); 
                    border-color: var(--mx-number-report-brand-color);
                    color: var(--mx-number-report-brand-color); font-weight: 600;
                    box-shadow: inset 0 0 4px var(--mx-number-report-brand-color10);
                }

                .am-campaign-id-token {
                    display: inline;
                }
                .am-campaign-search-btn {
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    margin-left: 2px;
                    -webkit-appearance: none;
                    appearance: none;
                    border: 0;
                    background: transparent;
                    color: #a3adb8;
                    line-height: 1;
                    cursor: pointer;
                    user-select: none;
                    vertical-align: middle;
                    padding: 0;
                }
                .am-campaign-search-btn svg {
                    width: 11px;
                    height: 11px;
                    display: block;
                    fill: currentColor;
                    pointer-events: none;
                }
                
                /* ç®—æ³•æŠ¤èˆªå¼¹çª—å±…ä¸­ */
                #alimama-escort-helper-ui {
                    top: 50% !important; left: 50% !important;
                    transform: translate(-50%, -50%) !important;
                    max-height: 90vh; overflow-y: auto;
                }

                /* æ—¥å¿—åŒº */
                .am-log-section { margin-top: 16px; }
                .am-log-header { 
                    display: flex; justify-content: space-between; align-items: center;
                    font-size: 12px; color: var(--am26-text-soft); margin-bottom: 8px; padding: 0 4px;
                }
                .am-action-btn { 
                    cursor: pointer; color: var(--am26-text-soft); margin-left: 10px; 
                    padding: 2px 8px; border-radius: 4px; transition: all 0.2s;
                    background: rgba(255,255,255,0.2);
                }
                .am-action-btn:hover { background: rgba(255, 255, 255, 0.5); color: var(--am26-primary-strong); }
                #am-log-content {
                    height: 100px; overflow-y: auto; 
                    background: rgba(0, 0, 0, 0.03);
                    border: 1px solid inset rgba(0,0,0,0.05);
                    border-radius: 10px;
                    padding: 10px;
                    font-size: 11px;
                    color: var(--am26-text);
                    font-family: var(--am26-mono);
                    box-shadow: inset 0 2px 4px rgba(0,0,0,0.03);
                    transition: all 0.3s ease;
                }
                #am-log-content.collapsed { height: 0; padding: 0; border: none; opacity: 0; }
                .am-log-line { 
                    padding: 3px 0; line-height: 1.5; 
                    border-bottom: 1px dashed rgba(0, 0, 0, 0.1);
                }
                .am-log-line:last-child { border-bottom: none; }
                .am-log-time { color: rgba(0,0,0,0.4); margin-right: 6px; }

                /* æ‹–æ‹½è°ƒæ•´å®½åº¦ */
                .am-resizer-left {
                    position: absolute; left: 0; top: 0; bottom: 0; width: 6px;
                    cursor: ew-resize; z-index: 10; transition: background 0.2s;
                }
                .am-resizer-left:hover { background: rgba(42, 91, 255, 0.22); }

                /* æŠ¥è¡¨æ•è·å¼¹çª— */
                #am-report-capture-panel {
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    width: 340px;
                    padding: 14px;
                    border-radius: 12px;
                    border: 1px solid var(--am26-border);
                    background: var(--am26-panel-strong);
                    color: var(--am26-text);
                    z-index: 2147483647;
                    display: none;
                }
                #am-report-capture-panel .am-download-header {
                    margin-bottom: 10px;
                    font-weight: 600;
                    color: var(--am26-primary-strong);
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                }
                #am-report-capture-panel .am-download-source {
                    color: var(--am26-text-soft);
                    font-size: 10px;
                }
                #am-report-capture-panel .am-download-url {
                    background: rgba(255, 255, 255, 0.60);
                    border: 1px solid var(--am26-border);
                    border-radius: 8px;
                    margin-bottom: 12px;
                    padding: 8px;
                    word-break: break-all;
                    font-size: 11px;
                    color: var(--am26-text-soft);
                    max-height: 56px;
                    overflow: hidden;
                }
                #am-report-capture-panel .am-download-actions {
                    display: flex;
                    gap: 10px;
                }
                #am-report-capture-panel .am-download-link,
                #am-report-capture-panel .am-download-btn {
                    border: 1px solid transparent;
                    border-radius: 8px;
                    padding: 8px 0;
                    text-align: center;
                    cursor: pointer;
                    font-weight: 500;
                    transition: all 0.2s;
                }
                #am-report-capture-panel .am-download-link {
                    flex: 2;
                    text-decoration: none;
                    background: linear-gradient(135deg, var(--am26-primary), var(--am26-primary-strong));
                    color: #fff;
                }
                #am-report-capture-panel .am-download-btn {
                    background: rgba(255, 255, 255, 0.72);
                    border-color: var(--am26-border);
                    color: var(--am26-text-soft);
                }
                #am-report-capture-panel .am-download-btn:hover,
                #am-report-capture-panel .am-download-link:hover {
                    transform: translateY(-1px);
                }
                #am-report-capture-panel .am-download-copy { flex: 1; }
                #am-report-capture-panel .am-download-close { flex: 0.5; }
                #am-report-capture-panel .am-download-hint {
                    margin-top: 8px;
                    font-size: 10px;
                    color: var(--am26-text-soft);
                }

                #am-magic-report-popup {
                    background: var(--am26-panel-strong) !important;
                }
                #am-magic-report-popup .am-magic-header {
                    background: rgba(255, 255, 255, 0.3) !important;
                }

                #alimama-escort-helper-ui [id$="-log-wrapper"] {
                    background: rgba(255, 255, 255, 0.4) !important;
                }
                #alimama-escort-helper-ui input {
                    background: rgba(255, 255, 255, 0.5) !important;
                }
                #alimama-escort-helper-ui .card-header {
                    background: rgba(255, 255, 255, 0.4) !important;
                }
                #alimama-escort-helper-ui .card-body {
                    background: rgba(255, 255, 255, 0.2) !important;
                }

                /* Mobile/Small screen adaptations */
                @media (max-width: 1080px) {
                    #am-magic-report-popup {
                        width: min(96vw, 900px) !important;
                        left: 50% !important;
                        transform: translateX(-50%) !important;
                    }
                    #am-helper-panel,
                    #alimama-escort-helper-ui {
                        max-width: calc(100vw - 24px) !important;
                    }
                }

                /* Native Style for Optimizer Trigger */
                #am-trigger-optimizer {
                    --line-height: 1.5;
                    --font-size: 12px;
                    --font-family: PingFangSC-Regular,PingFang SC,"Microsoft Yahei","SimHei",sans-serif;
                    --font-number: Tahoma;
                    --font-color: #333;
                    --font-color-hover: #333;
                    --font-color-active: var(--color-brand);
                    --font-color-secondary: #666;
                    --font-color-tip: #999;
                    --anchor-font-color: #333;
                    --app-nav-bg: #303a58;
                    --app-bg: #f9f9f9;
                    --app-min-width: 1418px;
                    --color-brand: #4554e5;
                    --color-brand-gradient: #4554e5;
                    --color-brand-hover: #3325d4;
                    --color-brand-hover-gradient: #3325d4;
                    --color-brand-vs: #f5714d;
                    --color-brand-light: rgba(69,84,229,.2);
                    --color-brand-opacity: rgba(69,84,229,.1);
                    --color-brand-text: #fff;
                    --color-brand-text-hover: #fff;
                    --color-brand-opacity5: rgba(69,84,229,.05);
                    --color-brand-opacity10: rgba(69,84,229,.1);
                    --color-brand-opacity20: rgba(69,84,229,.2);
                    --color-brand-opacity50: rgba(69,84,229,.5);
                    --color-bg: #f8f9fa;
                    --color-bg-hover: var(--color-brand-opacity);
                    --color-bg-active: var(--color-brand-opacity);
                    --input-v-gap: 8px;
                    --input-h-gap: 8px;
                    --input-min-width: 64px;
                    --input-height: 32px;
                    --input-font-size: var(--font-size);
                    --input-icon-size: 16px;
                    --input-icon-gap: 4px;
                    --border-radius: 8px;
                    --input-small-v-gap: 8px;
                    --input-small-h-gap: 8px;
                    --input-small-min-width: 48px;
                    --input-small-height: 24px;
                    --input-small-font-size: var(--font-size);
                    --input-small-icon-size: 12px;
                    --input-small-icon-gap: 4px;
                    --border-small-radius: 6px;
                    --input-large-v-gap: 8px;
                    --input-large-h-gap: 8px;
                    --input-large-min-width: 80px;
                    --input-large-height: 40px;
                    --input-large-font-size: calc(var(--font-size) + 2px);
                    --input-large-icon-size: 20px;
                    --input-large-icon-gap: 4px;
                    --border-large-radius: 10px;
                    --input-gap-border: #e4e7f0;
                    --bg-highlight: #f0f2f5;
                    --border-highlight: #f0f2f5;
                    --border-highlight-shadow: none;
                    --bg-highlight-hover: #e4e7f0;
                    --border-highlight-hover: #e4e7f0;
                    --border-highlight-shadow-hover: none;
                    --bg-highlight-active: #fff;
                    --border-highlight-active-opacity: 0.5;
                    --border-highlight-active: rgba(69,84,229,var(--border-highlight-active-opacity));
                    --border-highlight-shadow-active-h: 0px;
                    --border-highlight-shadow-active-v: 2px;
                    --border-highlight-shadow-active-blur: 4px;
                    --border-highlight-shadow-active-opacity: 0.2;
                    --border-highlight-shadow-active: var(--border-highlight-shadow-active-h) var(--border-highlight-shadow-active-v) var(--border-highlight-shadow-active-blur) 0 rgba(69,84,229,var(--border-highlight-shadow-active-opacity));
                    --output-bg: #fff;
                    --output-color: var(--font-color,#333);
                    --output-color-hover: var(--font-color-hover,#333);
                    --output-color-active: var(--font-color-active,var(--color-brand));
                    --output-small-v-gap: 8px;
                    --output-small-h-gap: 16px;
                    --output-small-border-radius: 8px;
                    --output-v-gap: 16px;
                    --output-h-gap: 24px;
                    --output-border-radius: 24px;
                    --output-large-v-gap: 24px;
                    --output-large-h-gap: 24px;
                    --output-large-border-radius: 16px;
                    --output-small-offset: 8px;
                    --output-small-item-max-height: 244px;
                    --output-small-item-height: var(--input-small-height);
                    --output-small-item-fontsize: 12px;
                    --output-offset: 8px;
                    --output-item-max-height: 312px;
                    --output-item-height: var(--input-height);
                    --output-item-fontsize: 12px;
                    --output-large-offset: 8px;
                    --output-large-item-max-height: 380px;
                    --output-large-item-height: var(--input-large-height);
                    --output-large-item-fontsize: 14px;
                    --btn-brand: var(--color-brand);
                    --btn-brand-gradient: var(--color-brand-gradient);
                    --btn-brand-shadow: none;
                    --btn-brand-text: var(--color-brand-text);
                    --btn-brand-hover: var(--color-brand-hover);
                    --btn-brand-gradient-hover: var(--color-brand-hover-gradient);
                    --btn-brand-shadow-hover-h: 0px;
                    --btn-brand-shadow-hover-v: 2px;
                    --btn-brand-shadow-hover-blur: 10px;
                    --btn-brand-shadow-hover-opacity: 0.4;
                    --btn-brand-shadow-hover: var(--btn-brand-shadow-hover-h,0px) var(--btn-brand-shadow-hover-v,2px) var(--btn-brand-shadow-hover-blur,10px) 0 rgba(69,84,229,var(--btn-brand-shadow-hover-opacity,0.4));
                    --btn-brand-text-hover: var(--color-brand-text-hover);
                    --btn-border: #e4e7f0;
                    --btn-bg: #fff;
                    --btn-text: #333;
                    --btn-border-hover: rgba(69,84,229,.5);
                    --btn-bg-hover: #fff;
                    --btn-text-hover: var(--color-brand);
                    --btn-h-gap: 12px;
                    --btn-min-width: var(--input-min-width);
                    --btn-font-size: var(--input-font-size);
                    --btn-border-radius: 500px;
                    --btn-small-h-gap: 12px;
                    --btn-small-min-width: var(--input-small-min-width);
                    --btn-small-font-size: var(--input-small-font-size);
                    --btn-small-border-radius: 500px;
                    --btn-large-h-gap: 12px;
                    --btn-large-min-width: var(--input-large-min-width);
                    --btn-large-font-size: var(--input-large-font-size);
                    --btn-large-border-radius: 500px;
                    --btn-font-weight: normal;
                    --btn-small-font-weight: normal;
                    --btn-large-font-weight: normal;
                    --color-border: #e4e7f0;
                    --color-warn: #ffa53d;
                    --color-red: #ff4d4d;
                    --color-green: #08bf81;
                    --color-blue: #6a76ea;
                    --duration: 0.2s;
                    --mx-text-placeholder: #999;
                    --mx-trigger-color: var(--font-color,#333);
                    --mx-trigger-color-hover: var(--font-color,#333);
                    --mx-trigger-color-active: var(--font-color,#333);
                    --mx-trigger-tag-bg: #fff;
                    --mx-trigger-tag-color: #333;
                    --mx-trigger-tag-arrow-color: #999;
                    --mx-trigger-tag-bg-hover: #fff;
                    --mx-trigger-tag-color-hover: #333;
                    --mx-trigger-tag-arrow-color-hover: #999;
                    --mx-trigger-tag-bg-active: var(--color-brand-opacity);
                    --mx-trigger-tag-color-active: #333;
                    --mx-trigger-tag-arrow-color-active: #999;
                    --mx-trigger-tag-height: calc(var(--input-height) - 8px);
                    --mx-trigger-arrow-size: 16px;
                    --mx-trigger-arrow-color: #999;
                    --mx-trigger-arrow-color-hover: #666;
                    --mx-trigger-arrow-color-active: #666;
                    --mx-trigger-prefix-icon: #666;
                    --mx-trigger-prefix-text: #666;
                    --mx-comp-disabled-opacity: 0.4;
                    --mx-comp-expand-amin-color: var(--color-brand);
                    --mx-comp-expand-amin-timer: 300ms;
                    --mx-comp-expand-amin-ease: ease-out;
                    --mx-grid-bg: #fff;
                    --mx-grid-body-v-top: var(--output-v-gap,16px);
                    --mx-grid-body-v-bottom: var(--output-v-gap,16px);
                    --mx-grid-border-radius: var(--output-border-radius,24px);
                    --mx-grid-h-gap: var(--output-h-gap,24px);
                    --mx-grid-title-bg: transparent;
                    --mx-grid-title-v-gap: 16px;
                    --mx-grid-title-font-size: 16px;
                    --mx-grid-title-font-weight: bold;
                    --mx-grid-title-color-border: var(--color-border);
                    --mx-grid-title-link-font-size: 12px;
                    --mx-grid-title-link-color: var(--color-brand);
                    --mx-grid-title-link-color-hover: var(--color-brand-hover);
                    --mx-grid-shadow: 0 4px 10px 0 hsla(16,7%,67%,.2);
                    --mx-grid-gap: 16px;
                    --mx-checkbox-size: 14px;
                    --mx-checkbox-border-radius: 4px;
                    --mx-checkbox-border: #dde1eb;
                    --mx-checkbox-bg: #fff;
                    --mx-checkbox-shadow: none;
                    --mx-checkbox-border-hover: #dde1eb;
                    --mx-checkbox-shadow-hover: 0 0 4px 0 rgba(0,0,0,.16);
                    --mx-checkbox-bg-hover: #fff;
                    --mx-table-font-size: var(--font-size);
                    --mx-table-ceil-h-gap: 8px;
                    --mx-table-ceil-v-gap: 12px;
                    --mx-table-ceil-small-h-gap: 4px;
                    --mx-table-ceil-small-v-gap: 4px;
                    --mx-table-ceil-large-h-gap: 24px;
                    --mx-table-ceil-large-v-gap: 24px;
                    --mx-table-ceil-text-align: left;
                    --mx-table-ceil-vertical-align: middle;
                    --mx-table-ceil-font-color: #333;
                    --mx-table-head-line-number: 2;
                    --mx-table-head-border: 1px solid var(--color-border);
                    --mx-table-head-height: 60px;
                    --mx-table-head-small-height: 40px;
                    --mx-table-head-large-height: 80px;
                    --mx-table-head-group-height: 80px;
                    --mx-table-head-bg: #fff;
                    --mx-table-head-font-size: 12px;
                    --mx-table-head-font-color: #333;
                    --mx-table-head-font-weight: bold;
                    --mx-table-hover-bg: #f8f9fa;
                    --mx-table-hover-oper-bg: #e4e7f0;
                    --mx-table-scrollbar-bg: #333;
                    --mx-effects-card-color-bg: #fff;
                    --mx-effects-card-title-font-size: 18px;
                    --mx-effects-card-sub-title-font-size: 14px;
                    --mx-effects-card-tip-font-size: 12px;
                    --mx-effects-card-color-border: var(--color-border);
                    --mx-effects-card-shadow: 0 1px 4px 0 hsla(0,0%,73%,.5);
                    --mx-effects-tag-mode: opacity;
                    --mx-effects-tag-height: 16px;
                    --mx-effects-tag-border-radius: calc(var(--mx-effects-tag-height, 16px)/2);
                    --mx-effects-tag-h-gap: 6px;
                    --mx-effects-tag-font-size: 20px;
                    --mx-effects-tag-font-scale: 0.5;
                    --mx-effects-large-tag-height: 18px;
                    --mx-effects-large-tag-border-radius: calc(var(--mx-effects-large-tag-height, 16px)/2);
                    --mx-effects-large-tag-h-gap: 8px;
                    --mx-effects-large-tag-font-size: 12px;
                    --mx-effects-large-tag-font-scale: 1;
                    --mx-effects-notice-border-radius: var(--border-radius);
                    --mx-effects-notice-v-gap: 8px;
                    --mx-effects-notice-h-gap: var(--output-h-gap,24px);
                    --mx-effects-notice-fontsize: 12px;
                    --mx-effects-notice-line-height: 20px;
                    --mx-effects-notice-round-height: 40px;
                    --mx-effects-progress-height: 6px;
                    --mx-effects-progress-num-height: 24px;
                    --mx-effects-progress-bg: #e4e7f0;
                    --mx-dialog-text-align: left;
                    --mx-dialog-color-bg: #e8ebf2;
                    --mx-dialog-shadow: 0 2px 10px 0 rgba(0,0,0,.16);
                    --mx-dialog-body-border-color: 0 none;
                    --mx-tabs-line-item-gap: 16px;
                    --mx-tabs-line-v-gap: var(--mx-grid-title-v-gap);
                    --mx-tabs-line-h-gap: 12px;
                    --mx-tabs-line-font-size: var(--mx-grid-title-font-size,16px);
                    --mx-tabs-line-font-weight: 500;
                    --mx-tabs-line-small-v-gap: calc(var(--mx-grid-title-v-gap)/2);
                    --mx-tabs-line-small-h-gap: 12px;
                    --mx-tabs-line-small-font-size: 12px;
                    --mx-tabs-line-small-font-weight: 500;
                    --mx-tabs-line-border-color: var(--color-border);
                    --mx-tabs-line-color: #333;
                    --mx-tabs-line-color-hover: var(--color-brand);
                    --mx-tabs-line-color-active: var(--color-brand);
                    --mx-tabs-line-bg-hover: var(--color-brand-opacity);
                    --mx-tabs-box-bg: var(--bg-highlight);
                    --mx-tabs-box-bg-hover: var(--bg-highlight-hover);
                    --mx-tabs-box-bg-active: var(--color-brand-opacity);
                    --mx-tabs-box-border: var(--border-highlight);
                    --mx-tabs-box-border-hover: var(--border-highlight-hover);
                    --mx-tabs-box-border-active: var(--border-highlight-active);
                    --mx-tabs-box-color: #666;
                    --mx-tabs-box-color-hover: #333;
                    --mx-tabs-box-color-active: var(--color-brand);
                    --mx-tabs-box-arrow: #999;
                    --mx-tabs-box-arrow-hover: #666;
                    --mx-tabs-box-arrow-active: var(--color-brand);
                    --mx-tabs-box-discrete-gap: 8px;
                    --mx-large-block-outer-gap: 16px;
                    --mx-large-block-v-gap: 12px;
                    --mx-large-block-h-gap: 12px;
                    --mx-large-block-line-height: 18px;
                    --mx-large-block-bg: transparent;
                    --mx-large-block-bg-hover: transparent;
                    --mx-large-block-bg-active: var(--color-brand-opacity5,var(--color-brand-opacity));
                    --mx-large-block-border: var(--color-border);
                    --mx-large-block-border-hover: var(--border-highlight-active);
                    --mx-large-block-border-active: var(--border-highlight-active);
                    --mx-tabs-menu-line-color: #c3c9d9;
                    --mx-tabs-menu-width: 160px;
                    --mx-tabs-menu-height: var(--input-height);
                    --mx-tabs-menu-padding-gap: 12px;
                    --mx-tabs-menu-margin-gap: 8px;
                    --mx-tabs-menu-icon-size: 16px;
                    --mx-tabs-menu-hover-color: var(--color-brand);
                    --mx-tabs-menu-hover-bg: var(--color-brand-opacity);
                    --mx-tabs-menu-hover-shadow: 0 none;
                    --mx-tabs-menu-selected-color: #fff;
                    --mx-tabs-menu-selected-bg: var(--color-brand);
                    --mx-tabs-menu-selected-shadow: var(--border-highlight-shadow-active);
                    --mx-popover-v-gap: var(--input-v-gap);
                    --mx-popover-h-gap: var(--input-h-gap);
                    --mx-popover-arrow-size: 8px;
                    --mx-popover-arrow-gap: 24px;
                    --mx-popover-bg: var(--output-bg,#fff);
                    --mx-popover-color: var(--output-color,var(--font-color,#333));
                    --mx-popover-color-border: var(--color-border);
                    --mx-popover-shaodow: 0 4px 8px 0 rgba(0,0,0,.06);
                    --mx-pagination-align: left;
                    --mx-switch-width: 36px;
                    --mx-switch-height: 20px;
                    --mx-switch-icon-size: 14px;
                    --mx-switch-border-radius: 10px;
                    --mx-header-other-height: 48px;
                    --mx-header-menu-height: 58px;
                    --mx-carousel-zindex: 3;
                    --mx-carousel-triggers-size: 24px;
                    --mx-carousel-triggers-fontsize: 16px;
                    --mx-carousel-trigger-color: #fff;
                    --mx-carousel-trigger-bg: #dde1eb;
                    --mx-carousel-trigger-gap: 8px;
                    --mx-carousel-line-size: 16px;
                    --mx-carousel-dot-size: 8px;
                    --mx-main-nav-v-gap: 16px;
                    --mx-main-nav-h-gap: 16px;
                    --mx-main-nav-footer-height: 80px;
                    --mx-main-nav-info-width: 240px;
                    --mx-grey-box-border: #e4e7f0;
                    --mx-grey-box-bg: #f8f9fa;
                    --mx-grey-box-border-hover: var(--color-brand-opacity50,var(--color-brand));
                    --mx-grey-box-bg-hover: #f0f2f5;
                    --mx-market-color: #f257a8;
                    --mx-market-color-gradient: #ff0036;
                    --mx-market-color-border: #fcd5e5;
                    --mx-market-color-bg: #fff5f8;
                    --mx-market-color-hover: #df2e8b;
                    --mx-market-color-hover-gradient: #e80c20;
                    --mx-market-color-hover-border: #fcd5e5;
                    --mx-market-color-hover-bg: #fee3eb;
                    --mx-market-color-bg5: linear-gradient(135deg,#fff2f5,#fef6fa);
                    --mx-market-color-bg10: linear-gradient(135deg,#ffe6eb,#fdeef6);
                    --mx-mask-black: rgba(0,0,0,.6);
                    --mx-mask-white: hsla(0,0%,100%,.6);
                    --mx-mask-backdrop-filter: blur(2px);
                    --mx-ai-color: #33f;
                    --mx-ai-color-gradient: #93f;
                    --mx-ai-color-anim: #3cf;
                    --mx-ai-color-hover: #0c0cff;
                    --mx-ai-color-hover-gradient: #850cff;
                    --mx-ai-color-hover-anim: #0cc2ff;
                    --mx-ai-color-line-width-number: 2;
                    --mx-ai-color100: #33f;
                    --mx-ai-color90: #4747ff;
                    --mx-ai-color80: #5b5bff;
                    --mx-ai-color70: #7070ff;
                    --mx-ai-color60: #8484ff;
                    --mx-ai-color50: #99f;
                    --mx-ai-color40: #adadff;
                    --mx-ai-color30: #c1c1ff;
                    --mx-ai-color20: #d6d6ff;
                    --mx-ai-color10: #eaeaff;
                    --mx-ai-color5: #f4f4ff;
                    --mx-ai-color-gradient100: #93f;
                    --mx-ai-color-gradient90: #a347ff;
                    --mx-ai-color-gradient80: #ad5bff;
                    --mx-ai-color-gradient70: #b770ff;
                    --mx-ai-color-gradient60: #c184ff;
                    --mx-ai-color-gradient50: #c9f;
                    --mx-ai-color-gradient40: #d6adff;
                    --mx-ai-color-gradient30: #e0c1ff;
                    --mx-ai-color-gradient20: #ead6ff;
                    --mx-ai-color-gradient10: #f4eaff;
                    --mx-ai-color-gradient5: #f9f4ff;
                    --mx-ai-color-anim100: #3cf;
                    --mx-ai-color-anim90: #47d1ff;
                    --mx-ai-color-anim80: #5bd6ff;
                    --mx-ai-color-anim70: #70dbff;
                    --mx-ai-color-anim60: #84e0ff;
                    --mx-ai-color-anim50: #99e5ff;
                    --mx-ai-color-anim40: #adeaff;
                    --mx-ai-color-anim30: #c1efff;
                    --mx-ai-color-anim20: #d6f4ff;
                    --mx-ai-color-anim10: #eaf9ff;
                    --mx-ai-color-anim5: #f4fcff;
                    --mx-ai-color-line: linear-gradient(135deg,#33f,#3cf,#93f);
                    --mx-ai-color-line100: linear-gradient(135deg,#33f,#3cf,#93f);
                    --mx-ai-color-line90: linear-gradient(135deg,#4747ff,#47d1ff,#a347ff);
                    --mx-ai-color-line80: linear-gradient(135deg,#5b5bff,#5bd6ff,#ad5bff);
                    --mx-ai-color-line70: linear-gradient(135deg,#7070ff,#70dbff,#b770ff);
                    --mx-ai-color-line60: linear-gradient(135deg,#8484ff,#84e0ff,#c184ff);
                    --mx-ai-color-line50: linear-gradient(135deg,#99f,#99e5ff,#c9f);
                    --mx-ai-color-line40: linear-gradient(135deg,#adadff,#adeaff,#d6adff);
                    --mx-ai-color-line30: linear-gradient(135deg,#c1c1ff,#c1efff,#e0c1ff);
                    --mx-ai-color-line20: linear-gradient(135deg,#d6d6ff,#d6f4ff,#ead6ff);
                    --mx-ai-color-line10: linear-gradient(135deg,#eaeaff,#eaf9ff,#f4eaff);
                    --mx-ai-color-line5: linear-gradient(135deg,#f4f4ff,#f4fcff,#f9f4ff);
                    --mx-ai-color-bg: linear-gradient(135deg,#33f,#3cf,#93f);
                    --mx-ai-color-bg100: linear-gradient(135deg,#33f,#3cf,#93f);
                    --mx-ai-color-bg90: linear-gradient(135deg,#4747ff,#47d1ff,#a347ff);
                    --mx-ai-color-bg80: linear-gradient(135deg,#5b5bff,#5bd6ff,#ad5bff);
                    --mx-ai-color-bg70: linear-gradient(135deg,#7070ff,#70dbff,#b770ff);
                    --mx-ai-color-bg60: linear-gradient(135deg,#8484ff,#84e0ff,#c184ff);
                    --mx-ai-color-bg50: linear-gradient(135deg,#99f,#99e5ff,#c9f);
                    --mx-ai-color-bg40: linear-gradient(135deg,#adadff,#adeaff,#d6adff);
                    --mx-ai-color-bg30: linear-gradient(135deg,#c1c1ff,#c1efff,#e0c1ff);
                    --mx-ai-color-bg20: linear-gradient(135deg,#d6d6ff,#d6f4ff,#ead6ff);
                    --mx-ai-color-bg10: linear-gradient(135deg,#eaeaff,#eaf9ff,#f4eaff);
                    --mx-ai-color-bg5: linear-gradient(135deg,#f4f4ff,#f4fcff,#f9f4ff);
                    --mx-ai-color-bg-primary: linear-gradient(135deg,#eaeaff,#eaf9ff,#f4eaff);
                    --mx-ai-color-bg-secondary: linear-gradient(135deg,#f4f4ff,#f4fcff,#f9f4ff);
                    --mx-ai-color-line-primary: linear-gradient(135deg,#33f,#3cf,#93f);
                    --mx-ai-color-line-secondary: linear-gradient(135deg,#d6d6ff,#d6f4ff,#ead6ff);
                    --mx-ai-color-line-width: 2px;
                    --app-brand: var(--color-brand);
                    --app-brand-gradient: var(--color-brand-gradient);
                    --mx-grid-shadow-hover: var(--mx-grid-shadow);
                    --mx-checkbox-color: var(--mx-checkbox-border);
                    --mx-checkbox-hover-color: var(--mx-checkbox-border-hover);
                    --mx-checkbox-hover-shadow: var(--mx-checkbox-shadow-hover);
                    --mx-tag-mode: var(--mx-effects-tag-mode);
                    --mx-tag-height: var(--mx-effects-tag-height);
                    --mx-tag-border-radius: var(--mx-effects-tag-border-radius);
                    --mx-tag-h-gap: var(--mx-effects-tag-h-gap);
                    --mx-tag-font-size: var(--mx-effects-tag-font-size);
                    --mx-tag-font-scale: var(--mx-effects-tag-font-scale);
                    --mx-input-gap-border: var(--input-gap-border);
                    --mx-effects-card-v-gap: var(--output-large-v-gap);
                    --mx-effects-card-h-gap: var(--output-large-h-gap);
                    --mx-effects-card-radius: var(--output-large-border-radius);
                    --mx-tab-box-gap-border: var(--input-gap-border);
                    --mx-tab-box-bg: var(--mx-tabs-box-bg);
                    --mx-tab-box-bg-active: var(--mx-tabs-box-bg-active);
                    --mx-tab-box-border: var(--mx-tabs-box-border);
                    --mx-tab-box-border-active: var(--mx-tabs-box-border-active);
                    --mx-tab-box-color: var(--mx-tabs-box-color);
                    --mx-tab-box-color-hover: var(--mx-tabs-box-color-hover);
                    --mx-tab-box-color-active: var(--mx-tabs-box-color-active);
                    --mx-tab-v-gap: var(--mx-tabs-line-v-gap);
                    --mx-tab-h-gap: var(--mx-tabs-line-h-gap);
                    --mx-tab-first-h-gap: var(--mx-grid-h-gap,24px);
                    --mx-tab-font-size: var(--mx-tabs-line-font-size);
                    --mx-tab-font-weight: var(--mx-tabs-line-font-weight);
                    --mx-tab-border-color: var(--mx-tabs-line-border-color);
                    --mx-tab-color: var(--mx-tabs-line-color);
                    --mx-tab-color-hover: var(--mx-tabs-line-color-hover);
                    --mx-tab-color-active: var(--mx-tabs-line-color-active);
                    --mx-tab-box-arrow-bg: var(--mx-tabs-box-arrow);
                    --mx-tab-box-arrow-bg-hover: var(--mx-tabs-box-arrow-hover);
                    --mx-tab-box-arrow-bg-active: var(--mx-tabs-box-arrow-active);
                    --mx-trigger-v-gap: var(--input-v-gap);
                    --mx-trigger-h-gap: var(--input-h-gap);
                    --mx-trigger-min-width: var(--input-min-width);
                    --mx-trigger-font-size: var(--input-font-size);
                    --mx-trigger-small-v-gap: var(--input-small-v-gap);
                    --mx-trigger-small-h-gap: var(--input-small-h-gap);
                    --mx-trigger-small-min-width: var(--input-small-min-width);
                    --mx-trigger-small-font-size: var(--input-small-font-size);
                    --mx-trigger-large-v-gap: var(--input-large-v-gap);
                    --mx-trigger-large-h-gap: var(--input-large-h-gap);
                    --mx-trigger-large-min-width: var(--input-large-min-width);
                    --mx-trigger-large-font-size: var(--input-large-font-size);
                    --mx-trigger-output-gap: var(--output-offset);
                    --mx-trigger-output-height: var(--output-item-height);
                    --mx-comp-v-gap: var(--output-v-gap);
                    --mx-comp-h-gap: var(--output-h-gap);
                    --mx-comp-shadow: var(--mx-dialog-shadow);
                    --mx-custom-layout-width: 80px;
                    --mx-custom-layout-h-gap: 16px;
                    --mx-custom-layout-v-gap: 16px;
                    --mx-custom-layout-icon-width: 32px;
                    --mx-custom-layout-icon-height: 32px;
                    --am26-font: "SF Pro Display", "SF Pro Text", "PingFang SC", "Microsoft YaHei", sans-serif;
                    --am26-mono: "SF Mono", "JetBrains Mono", "Menlo", "Monaco", "Consolas", monospace;
                    --am26-text: #1b2438;
                    --am26-text-soft: #505a74;
                    --am26-border: rgba(255, 255, 255, 0.4);
                    --am26-border-strong: rgba(255, 255, 255, 0.6);
                    --am26-surface: rgba(255, 255, 255, 0.25);
                    --am26-surface-strong: rgba(255, 255, 255, 0.45);
                    --am26-panel: linear-gradient(135deg, rgba(255, 255, 255, 0.4), rgba(255, 255, 255, 0.1));
                    --am26-panel-strong: linear-gradient(135deg, rgba(255, 255, 255, 0.6), rgba(255, 255, 255, 0.2));
                    --am26-primary: #2a5bff;
                    --am26-primary-strong: #1d3fcf;
                    --am26-primary-soft: rgba(42, 91, 255, 0.15);
                    --am26-success: #0ea86f;
                    --am26-warning: #e8a325;
                    --am26-danger: #ea4f4f;
                    --am26-shadow: 0 8px 32px 0 rgba(31, 38, 135, 0.15);
                    --am26-glow: inset 0 0 0 1px rgba(255, 255, 255, 0.3);
                    --mux-comp-disabled-opacity: 0.4;
                    --mux-comp-v-gap: 16px;
                    --mux-comp-h-gap: 24px;
                    --mux-comp-shadow: 0 2px 10px 0 rgba(0,0,0,0.16);
                    --mux-comp-shadow-border: 0 none;
                    --mux-comp-btn-gap: 8px;
                    --mux-trigger-tag-gap: 2px;
                    --mux-trigger-tag-height: calc(var(--input-height) - var(--mux-trigger-tag-gap)*4 - 2px);
                    --mux-trigger-tag-bg: #fff;
                    --mux-trigger-tag-bg-hover: #fff;
                    --mux-trigger-tag-bg-active: var(--color-brand-opacity);
                    --mux-trigger-tag-arrow-color: #999;
                    --mux-trigger-tag-arrow-color-hover: #666;
                    --mux-trigger-input-placeholder-color: #999;
                    --mux-trigger-prefix-icon: #666;
                    --mux-trigger-prefix-text: #666;
                    --mux-trigger-arrow-size: 16px;
                    --mux-trigger-arrow-color: #333;
                    --mux-trigger-arrow-color-hover: #333;
                    --mux-trigger-v-gap: 8px;
                    --mux-trigger-h-gap: 8px;
                    --mux-trigger-min-width: var(--btn-min-width);
                    --mux-trigger-font-size: var(--btn-font-size);
                    --mux-trigger-small-v-gap: 8px;
                    --mux-trigger-small-h-gap: 8px;
                    --mux-trigger-small-min-width: var(--btn-small-min-width);
                    --mux-trigger-small-font-size: var(--btn-small-font-size);
                    --mux-trigger-large-v-gap: 8px;
                    --mux-trigger-large-h-gap: 12px;
                    --mux-trigger-large-min-width: var(--btn-large-min-width);
                    --mux-trigger-large-font-size: var(--btn-large-font-size);
                    --mux-table-hover-color: #f5f6f8;
                    --mux-table-hover-expanded-row-bg: #eaecf1;
                    --mux-table-border-color: #dfdfdf;
                    --mux-table-size--large: 100px;
                    --mux-table-size--normal: 60px;
                    --mux-table-size--small: 40px;
                    --mux-table-expanded-row-height: 40px;
                    --mux-table-header-height--small: 50px;
                    --mux-table-header-background: #fff;
                    --mux-radio-color: #dadadb;
                    --mux-radio-shadow-color: rgba(0,0,0,0.16);
                    --mux-radio-gap: 8px;
                    --mux-checkbox-color: #9095a1;
                    --mux-checkbox-size: calc(var(--font-size) + 2px);
                    --mux-checkbox-border-radius: 4px;
                    --mux-tag-font-scale: 0.84;
                    --mux-nav-icon-gap: 12px;
                    --mux-nav-h-gap: 24px;
                    --mux-mask-bg: rgba(0,0,0,0.6);
                    --mux-mask-light-bg: hsla(0,0%,100%,0.6);
                    --mux-statistic-font-size-integer: 20px;
                    --mux-statistic-font-size-decimal: 14px;
                    --mux-field-color-error: var(--color-red);
                    --mux-field-color-warning: var(--color-warn);
                    --mux-field-color-success: var(--color-green);
                    --mux-field-color-highlight: var(--color-brand);
                    --mux-field-color-initial: transparent;
                    --mux-common-bg: transparent;
                    --mux-btn-h-gap: 12px;
                    --mux-process-color-success: var(--color-green);
                    --mux-process-color-suspend: var(--color-warn);
                    --mux-process-color-error: var(--color-red);
                    --color-brand-alpha-10: rgba(62,62,255,0.1);
                    --color-brand-alpha-50: rgba(62,62,255,0.5);
                    --color-brand-btn-shadow-hover: 0 2px 10px 0 rgba(62,62,255,0.4);
                    --border-huge-radius: 16px;
                    --border-highlight-active-error: rgba(237,0,0,0.5);
                    --border-highlight-shadow-active-error: 0 2px 4px 0 rgba(237,0,0,0.2);
                    --border-highlight-active-warning: rgba(255,136,0,0.5);
                    --border-highlight-shadow-active-warning: 0 2px 4px 0 rgba(255,136,0,0.2);
                    --border-highlight-active-success: rgba(0,175,116,0.5);
                    --border-highlight-shadow-active-success: 0 2px 4px 0 rgba(0,175,116,0.2);
                    --btn-error: #f44;
                    --btn-error-gradient: #f44;
                    --btn-error-text: #fff;
                    --btn-error-hover: #cc0909;
                    --btn-error-gradient-hover: #cc0909;
                    --btn-error-shadow-hover: 0 2px 10px 0 rgba(255,68,68,0.4);
                    --btn-error-text-hover: #fff;
                    --btn-error-border: #cf1c1c;
                    --btn-error-bg: #ffecec;
                    --btn-error-border-hover: #fd9b9b;
                    --btn-error-bg-hover: #fedadb;
                    --color-orange: #f50;
                    --color-gray: rgba(0,0,0,0.25);
                    --color-red-weaken: #c9817b;
                    --mux-ai-brand--color: #ae5cff;
                    --mux-ai-brand-gradient-color: #5c5cff;
                    --mux-ai-brand-gradient-tl-br: linear-gradient(135deg,#5c5cff,#ae5cff 95%);
                    --mux-ai-brand-gradient-tl-br-dark: linear-gradient(135deg,#3e3eff,#93f 95%);
                    --mux-ai-brand-gradient-tl-br-light: linear-gradient(135deg,#ebd7ff,#d7d7ff);
                    --mux-ai-brand-gradient-tl-br-slight: linear-gradient(117deg,#ececff,#e9fbff 48%,#f4eaff);
                    --mux-ai-brand-gradient-tl-br-lighter: linear-gradient(135deg,#f5f5ff,#f5fdff 50%,#faf5ff);
                    --mux-ai-brand-gradient-l-r-dark: linear-gradient(90deg,#3e3eff 5%,#93f 95%);
                    --mux-ai-brand-gradient-line: linear-gradient(135deg,#3e3eff,#1dd3ff,#8e28ff);
                    --mux-marketing-brand-color: #ff0036;
                    --mux-marketing-brand-gradient-color: #f257a8;
                    --mux-marketing-brand-gradient-t-b: linear-gradient(180deg,#f257a8 0,#ff0036);
                    --mux-marketing-brand-gradient-t-b-dark: linear-gradient(180deg,#df2e8b 0,#e80c20);
                    --mux-marketing-brand-gradient-t-b-light: linear-gradient(180deg,#fff,#ffccd7);
                    --mux-marketing-brand-gradient-t-b-lighter: linear-gradient(180deg,#fff,#ffe6eb);
                    --mux-marketing-brand-gradient-l-r: linear-gradient(90deg,#f257a8 0,#ff0036);
                    --mux-marketing-brand-gradient-l-r-dark: linear-gradient(90deg,#df2e8b 0,#e80c20);
                    --mux-marketing-brand-gradient-tl-br-light: linear-gradient(135deg,#ffe6eb,#fdeef6);
                    --mux-marketing-brand-gradient-tl-br-lighter: linear-gradient(135deg,#fff2f5,#fef6fa);
                    --mx-color-width: 224px;
                    --mx-color-slider-width: 18px;
                    --mx-color-picker-width: calc(var(--mx-color-width) - var(--mx-color-slider-width) - 10px);
                    -webkit-font-smoothing: antialiased;
                    color: var(--font-color,#333);
                    font-family: var(--font-family);
                    font-size: var(--font-size);
                    line-height: var(--line-height);
                    box-sizing: inherit;
                    -webkit-appearance: none;
                    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
                    outline: none;
                    bottom: 0;
                    position: relative;
                    width: 100%;
                }
            `;
            const style = document.createElement('style');
            style.id = 'am-helper-pro-v26-style';
            style.textContent = css;
            document.head.appendChild(style);
        },

        createElements() {
            const root = document.createElement('div');
            root.innerHTML = `
                <div id="am-helper-icon" title="ç‚¹å‡»å±•å¼€åŠ©æ‰‹é¢æ¿">
                    <svg viewBox="0 0 1024 1024" width="22" height="22" fill="currentColor"><path d="M852.1 432.8L542.4 69.2c-26.6-30.8-74.6-11.8-74.6 28.6v238H218c-36.2 0-60.6 37.8-44.4 69.4l270.2 522.4c18.6 36 71.8 23.4 71.8-17V681h249.6c36.2 0 60.8-38 44.6-69.6z"></path></svg>
                </div>
                <div id="am-helper-panel">
            <div class="am-resizer-left"></div>
            <div class="am-header">
                <span class="am-title">
                    <svg viewBox="0 0 1024 1024" width="16" height="16" fill="currentColor" style="margin-right:4px;"><path d="M852.1 432.8L542.4 69.2c-26.6-30.8-74.6-11.8-74.6 28.6v238H218c-36.2 0-60.6 37.8-44.4 69.4l270.2 522.4c18.6 36 71.8 23.4 71.8-17V681h249.6c36.2 0 60.8-38 44.6-69.6z"></path></svg>
                    é˜¿é‡ŒåŠ©æ‰‹ Pro
                    <span class="am-version">v${CURRENT_VERSION}</span>
                </span>
                <div class="am-close-btn" title="æœ€å°åŒ–">
                    <svg viewBox="0 0 1024 1024" style="width:1.2em;height:1.2em;vertical-align:middle;fill:currentColor;overflow:hidden;"><path d="M551.424 512l195.072-195.072c9.728-9.728 9.728-25.6 0-36.864l-1.536-1.536c-9.728-9.728-25.6-9.728-35.328 0L514.56 475.136 319.488 280.064c-9.728-9.728-25.6-9.728-35.328 0l-1.536 1.536c-9.728 9.728-9.728 25.6 0 36.864L477.696 512 282.624 707.072c-9.728 9.728-9.728 25.6 0 36.864l1.536 1.536c9.728 9.728 25.6 9.728 35.328 0L514.56 548.864l195.072 195.072c9.728 9.728 25.6 9.728 35.328 0l1.536-1.536c9.728-9.728 9.728-25.6 0-36.864L551.424 512z"></path></svg>
                </div>
            </div>
            <div class="am-body">
                <!-- Section 1: Tools -->
                <div class="am-tools-row">
                    <div class="am-tool-btn" id="am-trigger-optimizer">
                        <svg viewBox="0 0 1024 1024" width="16" height="16" fill="currentColor"><path d="M907.8 770.1c-60-96.1-137.9-178.6-227.1-241.6 8.3-43.1 7.1-88.9-5-131-29.2-101.5-121.1-177.3-227.5-188.9-10.4-1.2-18.7 8.3-15.3 18.2 24.5 70.3 5.4 152.1-51.5 209-56.9 56.9-138.7 76-209 51.5-9.9-3.4-19.4 4.8-18.2 15.3 11.6 106.4 87.4 198.3 188.9 227.5 42.1 12.1 87.9 13.3 131 5 63.1 89.2 145.5 167.1 241.6 227.1 21.6 13.5 49.3-3.9 46.2-28.7l-12.7-106.3c10.3 3.6 21 6.1 31.9 7.4 35.7 4.2 71.3-7.5 99.2-35.4 27.9-27.9 39.6-63.5 35.4-99.2-1.3-10.9-3.8-21.6-7.4-31.9l106.3 12.7c24.9 3.1 42.3-24.6 28.7-46.2zM512 512c-23.7 0-46.3-5-67.4-14.1-18.4-7.9-19-33.3-1-42.3 22.1-11 47.9-16.1 74.5-13.2 59.8 6.5 106.9 53.6 113.4 113.4 2.9 26.6-2.2 52.4-13.2 74.5-9 18-34.4 17.4-42.3-1-9.1-21.1-14.1-43.7-14.1-67.4z"></path></svg>
                        ç®—æ³•æŠ¤èˆª
                    </div>
                    <div class="am-tool-btn" id="am-trigger-keyword-plan-api">
                        <svg viewBox="0 0 1024 1024" width="16" height="16" fill="currentColor"><path d="M128 176a48 48 0 0 1 48-48h672a48 48 0 0 1 48 48v80H128v-80zm0 192h768v480a48 48 0 0 1-48 48H176a48 48 0 0 1-48-48V368zm160 96v64h448v-64H288zm0 160v64h288v-64H288z"></path></svg>
                        å…³é”®è¯å»ºè®¡åˆ’
                    </div>
                    <div class="am-tool-btn" id="am-trigger-magic-report">
                        <svg viewBox="0 0 1024 1024" width="16" height="16" fill="currentColor"><path d="M128 128h768v768H128z m60.8 60.8V835.2h646.4V188.8H188.8z M256 384h128v320H256V384z m192-128h128v448H448V256z m192 192h128v256H640V448z"></path></svg>
                        ä¸‡èƒ½æŸ¥æ•°
                    </div>
                    <div class="am-tool-btn" id="am-toggle-assist-display">
                        <svg viewBox="0 0 1024 1024" width="16" height="16" fill="currentColor"><path d="M512 208c219.8 0 401.4 124.4 472 302.2a23.7 23.7 0 0 1 0 17.6C913.4 705.6 731.8 830 512 830S110.6 705.6 40 527.8a23.7 23.7 0 0 1 0-17.6C110.6 332.4 292.2 208 512 208zm0 104c-110.6 0-200 89.4-200 200s89.4 200 200 200 200-89.4 200-200-89.4-200-200-200zm0 88a112 112 0 1 1 0 224 112 112 0 0 1 0-224z"></path></svg>
                        è¾…åŠ©æ˜¾ç¤º
                    </div>
                </div>

                <!-- Section 2: Settings -->
                <div id="am-assist-switches">
                    <div class="am-switches-grid">
                        <div class="am-switch-btn" data-key="showCost">è¯¢å•æˆæœ¬</div>
                        <div class="am-switch-btn" data-key="showCartCost">åŠ è´­æˆæœ¬</div>
                        <div class="am-switch-btn" data-key="showPercent">æ½œå®¢å æ¯”</div>
                        <div class="am-switch-btn" data-key="showCostRatio">èŠ±è´¹å æ¯”</div>
                        <div class="am-switch-btn" data-key="showBudget">é¢„ç®—è¿›åº¦</div>
                        <div class="am-switch-btn" data-key="autoSortCharge">èŠ±è´¹æ’åº</div>
                        <!-- <div class="am-switch-btn" data-key="autoClose">å¼¹çª—é€Ÿé—­</div> -->
                    </div>
                </div>
                <div class="am-log-section">
                    <div class="am-log-header">
                        <span>ğŸ“‹ è¿è¡Œæ—¥å¿—</span>
                        <div>
                            <span class="am-action-btn" id="am-log-clear">æ¸…ç©º</span>
                            <span class="am-action-btn" id="am-log-toggle">å±•å¼€</span>
                        </div>
                    </div>
                    <div id="am-log-content"></div>
                </div>
            </div>
        </div>
    `;
            document.body.appendChild(root);
            Logger.el = document.getElementById('am-log-content');
        },

        bindEvents() {
            const icon = document.getElementById('am-helper-icon');
            const panel = document.getElementById('am-helper-panel');
            const closeBtn = panel.querySelector('.am-close-btn');
            const resizer = panel.querySelector('.am-resizer-left');
            let hoverOpenBlockedUntil = 0;
            let autoHideTimer = null;

            const clearAutoHideTimer = () => {
                if (!autoHideTimer) return;
                clearTimeout(autoHideTimer);
                autoHideTimer = null;
            };

            // å±•å¼€/æ”¶èµ·åŠ¨ç”»
            const openPanel = (force = false) => {
                clearAutoHideTimer();
                if (!force && Date.now() < hoverOpenBlockedUntil) return;
                if (State.config.panelOpen) return;
                State.config.panelOpen = true;
                State.save();
                this.updateState();
            };
            const closePanel = (blockHoverOpen = false) => {
                clearAutoHideTimer();
                if (blockHoverOpen) hoverOpenBlockedUntil = Date.now() + 800;
                if (!State.config.panelOpen) return;
                State.config.panelOpen = false;
                State.save();
                this.updateState();
            };
            const scheduleAutoHide = (delay = 180) => {
                clearAutoHideTimer();
                autoHideTimer = setTimeout(() => {
                    autoHideTimer = null;
                    if (!State.config.panelOpen) return;
                    if (panel.matches(':hover') || icon.matches(':hover')) return;
                    closePanel(false);
                }, delay);
            };

            icon.onclick = () => openPanel(true);
            // é¼ æ ‡ç§»å…¥æ‚¬æµ®çƒæ—¶è‡ªåŠ¨å±•å¼€
            icon.onmouseenter = () => openPanel(false);
            panel.onmouseenter = clearAutoHideTimer;
            panel.onmouseleave = () => scheduleAutoHide();
            closeBtn.onclick = (e) => {
                e.stopPropagation();
                closePanel(true);
            };

            // ç‚¹å‡»é¢æ¿å¤–éƒ¨è‡ªåŠ¨æœ€å°åŒ–
            document.addEventListener('click', (e) => {
                if (State.config.panelOpen && !panel.contains(e.target) && !icon.contains(e.target)) {
                    closePanel(false);
                }
            });

            // åŠŸèƒ½æŒ‰é’®
            // åŠŸèƒ½å¼€å…³ (Settings)
            document.querySelectorAll('.am-switch-btn').forEach(btn => {
                btn.onclick = () => {
                    const key = btn.dataset.key;
                    State.config[key] = !State.config[key];
                    State.save();
                    this.updateState();
                    Logger.log(`${btn.textContent.trim()} ${State.config[key] ? 'âœ…' : 'âŒ'} `);
                    if (key !== 'autoClose') Core.run();
                };
            });

            // å·¥å…·æŒ‰é’® (Tools) - ä¸‡èƒ½æŸ¥æ•°
            const magicBtn = document.getElementById('am-trigger-magic-report');
            if (magicBtn) {
                magicBtn.onclick = () => {
                    MagicReport.toggle(true);
                };
            }

            const assistToggleBtn = document.getElementById('am-toggle-assist-display');
            if (assistToggleBtn) {
                assistToggleBtn.onclick = () => {
                    this.runtime.assistExpanded = !this.runtime.assistExpanded;
                    this.updateState();
                };
            }

            // ç®—æ³•æŠ¤èˆªæŒ‰é’®
            const optBtn = document.getElementById('am-trigger-optimizer');
            if (optBtn) {
                optBtn.onclick = () => {
                    // [ADD] ç‚¹å‡»æŠ¤èˆªæ—¶è‡ªåŠ¨æœ€å°åŒ–ä¸»é¢æ¿
                    State.config.panelOpen = false;
                    State.save();
                    this.updateState();

                    if (typeof window.__ALIMAMA_OPTIMIZER_TOGGLE__ === 'function') {
                        window.__ALIMAMA_OPTIMIZER_TOGGLE__();
                    } else {
                        Logger.log('âš ï¸ ç®—æ³•æŠ¤èˆªæ¨¡å—åˆå§‹åŒ–ä¸­...', true);
                        setTimeout(() => {
                            if (typeof window.__ALIMAMA_OPTIMIZER_TOGGLE__ === 'function') {
                                window.__ALIMAMA_OPTIMIZER_TOGGLE__();
                            } else {
                                alert('ç®—æ³•æŠ¤èˆªæ¨¡å—æ— æ³•åŠ è½½ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                            }
                        }, 1000);
                    }
                };
            }

            const keywordPlanBtn = document.getElementById('am-trigger-keyword-plan-api');
            if (keywordPlanBtn) {
                const resolveKeywordPlanApi = () => {
                    try {
                        if (KeywordPlanApi && typeof KeywordPlanApi.openWizard === 'function') {
                            return KeywordPlanApi;
                        }
                    } catch { }
                    try {
                        const fromWindow = window.__AM_WXT_KEYWORD_API__;
                        if (fromWindow && typeof fromWindow.openWizard === 'function') {
                            return fromWindow;
                        }
                    } catch { }
                    try {
                        const fromGlobal = globalThis.__AM_WXT_KEYWORD_API__;
                        if (fromGlobal && typeof fromGlobal.openWizard === 'function') {
                            return fromGlobal;
                        }
                    } catch { }
                    return null;
                };

                const openExistingKeywordOverlay = () => {
                    const overlay = document.getElementById('am-wxt-keyword-overlay');
                    if (!overlay) return false;
                    overlay.classList.add('open');
                    return true;
                };

                keywordPlanBtn.onclick = () => {
                    const api = resolveKeywordPlanApi();
                    if (api && typeof api.openWizard === 'function') {
                        api.openWizard();
                        return;
                    }
                    if (openExistingKeywordOverlay()) return;

                    Logger.log('âš ï¸ å…³é”®è¯å»ºè®¡åˆ’æ¨¡å—åˆå§‹åŒ–ä¸­...', true);
                    setTimeout(() => {
                        const retryApi = resolveKeywordPlanApi();
                        if (retryApi && typeof retryApi.openWizard === 'function') {
                            retryApi.openWizard();
                        } else if (openExistingKeywordOverlay()) {
                            Logger.log('â„¹ï¸ å·²æ‰“å¼€å…³é”®è¯è®¡åˆ’å¼¹çª—ï¼ˆå…œåº•ï¼‰');
                        } else {
                            alert('å…³é”®è¯å»ºè®¡åˆ’æ¨¡å—ä¸å¯ç”¨ï¼Œè¯·åˆ·æ–°é¡µé¢é‡è¯•');
                        }
                    }, 800);
                };
            }

            // æ—¥å¿—æ“ä½œ
            document.getElementById('am-log-clear').onclick = () => { Logger.clear(); Logger.log('æ—¥å¿—å·²æ¸…ç©º'); };
            document.getElementById('am-log-toggle').onclick = () => {
                State.config.logExpanded = !State.config.logExpanded;
                State.save();
                this.updateState();
            };

            // æ‹–æ‹½è°ƒæ•´å®½åº¦
            let isResizing = false, startX = 0, startWidth = 0;
            resizer.onmousedown = (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = panel.offsetWidth;
                document.body.style.userSelect = 'none';
                e.preventDefault();
            };
            document.addEventListener('mousemove', (e) => {
                if (isResizing) {
                    const newWidth = Math.min(500, Math.max(250, startWidth + startX - e.clientX));
                    panel.style.width = newWidth + 'px';
                }
            });
            document.addEventListener('mouseup', () => {
                isResizing = false;
                document.body.style.userSelect = '';
            });

            // äº¤äº’ç›‘å¬
            document.addEventListener('click', (e) => {
                // å¼¹çª—è‡ªåŠ¨å…³é—­
                if (State.config.autoClose) {
                    const target = e.target;
                    if (typeof target.className === 'string' && (target.className.includes('mask') || parseInt(target.style.zIndex) > 900)) {
                        const closeBtn = target.querySelector('[mx-click*="close"], .mx-iconfont.close');
                        if (closeBtn) { closeBtn.click(); Logger.log('ğŸ›¡ï¸ è‡ªåŠ¨é—­çª—'); }
                    }
                }

                const tabTexts = ['å…³é”®è¯', 'äººç¾¤', 'åˆ›æ„', 'èµ„æºä½', 'åœ°åŸŸ', 'æ—¶æ®µ'];
                const clickedText = e.target.textContent || '';
                const isTabClick = tabTexts.some(t => clickedText.includes(t)) &&
                    (e.target.closest('a[mx-click]') || e.target.closest('[class*="tab"]'));
                if (isTabClick) resetSortState('Tab åˆ‡æ¢');

                // è§¦å‘æ›´æ–°
                const updateKeywords = ['æŸ¥è¯¢', 'æœç´¢', 'ç¡®å®š', 'ç¿»é¡µ', 'åˆ†é¡µ'];
                const txt = e.target.textContent || '';
                if (updateKeywords.some(k => txt.includes(k))) {
                    Logger.log('ğŸ–±ï¸ è§¦å‘æ›´æ–°');
                }
            }, true);
        },

        updateState() {
            const { panelOpen, logExpanded } = State.config;
            const icon = document.getElementById('am-helper-icon');
            const panel = document.getElementById('am-helper-panel');
            const logContent = document.getElementById('am-log-content');
            const logToggle = document.getElementById('am-log-toggle');
            const assistPanel = document.getElementById('am-assist-switches');
            const assistToggleBtn = document.getElementById('am-toggle-assist-display');

            // é¢æ¿æ˜¾ç¤º/éšè—åŠ¨ç”»
            if (panelOpen) {
                panel.classList.remove('hidden');
                icon.style.display = 'none';
            } else {
                panel.classList.add('hidden');
                setTimeout(() => { icon.style.display = 'flex'; }, 300);
            }

            // åŠŸèƒ½å¼€å…³çŠ¶æ€
            document.querySelectorAll('.am-switch-btn').forEach(btn => {
                const key = btn.dataset.key;
                if (State.config[key]) btn.classList.add('active');
                else btn.classList.remove('active');
            });

            if (assistPanel) {
                assistPanel.classList.toggle('open', this.runtime.assistExpanded);
            }
            if (assistToggleBtn) {
                assistToggleBtn.classList.toggle('active', this.runtime.assistExpanded);
            }

            // æ—¥å¿—å±•å¼€/æŠ˜å 
            if (logExpanded) {
                logContent.classList.remove('collapsed');
                logToggle.textContent = 'éšè—';
            } else {
                logContent.classList.add('collapsed');
                logToggle.textContent = 'å±•å¼€';
            }
        }
    };

    // ==========================================
    // 5. ç½‘ç»œæ‹¦æˆªä¸æŠ¥è¡¨æŠ“å– (Interceptor)
    // ==========================================
    const Interceptor = {
        panel: null,
        keywords: CONSTANTS.DL_KEYWORDS,
        excludePatterns: [
            /videocloud\.cn-hangzhou\.log\.aliyuncs\.com\/logstores\/newplayer\/track(?:[/?#]|$)/i,
            /\/logstores\/[^/?#]+\/track(?:[/?#]|$)/i
        ],
        hooksRegistered: false,
        maxParseBytes: 1024 * 1024,
        parsableTypeHints: ['json', 'text', 'javascript', 'xml', 'html', 'csv', 'plain', 'event-stream'],
        debugHints: new Set(),

        init() {
            this.createPanel();
            this.registerHooks();
        },

        createPanel() {
            const div = document.createElement('div');
            div.id = 'am-report-capture-panel';
            // Inline fallback: even if style injection fails, ensure popup is visible and clickable.
            div.style.cssText = 'font-size:13px;position:fixed;right:20px;bottom:20px;z-index:2147483647;display:none;';
            document.body.appendChild(div);
            this.panel = div;
        },

        debugOnce(key, msg) {
            if (this.debugHints.has(key)) return;
            this.debugHints.add(key);
            console.debug(`[AM][Interceptor] ${msg} `);
        },

        sanitizeUrl(url) {
            if (typeof url !== 'string') return '';
            try {
                const parsed = new URL(url, window.location.origin);
                if (!/^https?:$/.test(parsed.protocol)) return '';
                return parsed.href;
            } catch {
                return '';
            }
        },

        isImageUrl(url) {
            if (typeof url !== 'string') return false;
            const clean = url.split('#')[0].split('?')[0].toLowerCase();
            return /\.(jpg|png|gif|jpeg|webp|svg|bmp)$/i.test(clean);
        },

        isExcludedUrl(url) {
            if (typeof url !== 'string') return false;
            return this.excludePatterns.some(pattern => pattern.test(url));
        },

        isDownloadUrl(url) {
            const safeUrl = this.sanitizeUrl(url);
            if (!safeUrl) return false;
            const lowerUrl = safeUrl.toLowerCase();
            if (this.isExcludedUrl(lowerUrl)) {
                this.debugOnce('exclude-non-download-url', `è¿‡æ»¤éä¸‹è½½åœ°å€: ${safeUrl} `);
                return false;
            }
            const hasKeyword = this.keywords.some(k => lowerUrl.includes(String(k).toLowerCase()));
            const hasFileExt = /\.(xlsx|xls|csv|zip|txt)(?:$|[?#])/i.test(lowerUrl);
            return (hasKeyword || hasFileExt) && !this.isImageUrl(lowerUrl);
        },

        inspectUrl(url, source) {
            if (!this.isDownloadUrl(url)) return;
            this.show(url, source);
        },

        shouldParseResponse(meta = {}) {
            const source = meta.source || 'Unknown';
            const responseType = String(meta.responseType || '');
            if (responseType && responseType !== 'text') {
                this.debugOnce(`${source}: responseType:${responseType} `, `${source} è·³è¿‡è§£æ: responseType = ${responseType} `);
                return false;
            }

            const contentType = String(meta.contentType || '').toLowerCase();
            if (!contentType) {
                this.debugOnce(`${source}: contentType: empty`, `${source} è·³è¿‡è§£æ: content - type ä¸ºç©º`);
                return false;
            }
            if (!this.parsableTypeHints.some(type => contentType.includes(type))) {
                this.debugOnce(`${source}: contentType:${contentType} `, `${source} è·³è¿‡è§£æ: content - type=${contentType} `);
                return false;
            }

            const contentLength = Number.parseInt(String(meta.contentLength || ''), 10);
            if (Number.isFinite(contentLength) && contentLength > this.maxParseBytes) {
                this.debugOnce(`${source}: contentLength`, `${source} è·³è¿‡è§£æ: content - length=${contentLength} è¶…è¿‡é™åˆ¶ ${this.maxParseBytes} `);
                return false;
            }

            if (typeof meta.textLength === 'number' && meta.textLength > this.maxParseBytes) {
                this.debugOnce(`${source}: textLength`, `${source} è·³è¿‡è§£æ: å“åº”æ–‡æœ¬é•¿åº¦ ${meta.textLength} è¶…è¿‡é™åˆ¶ ${this.maxParseBytes} `);
                return false;
            }

            return true;
        },

        show(url, source) {
            const safeUrl = this.sanitizeUrl(url);
            if (!safeUrl) {
                this.debugOnce('invalid-url', 'æ£€æµ‹åˆ°éæ³•åè®® URLï¼Œå·²å¿½ç•¥ä¸‹è½½å¼¹çª—æ¸²æŸ“');
                return;
            }

            if (this.panel.dataset.lastUrl === safeUrl && this.panel.style.display === 'block') return;
            this.panel.dataset.lastUrl = safeUrl;

            Logger.log(`ğŸ“‚ æ•è·æŠ¥è¡¨: ${source} `, true);

            this.panel.textContent = '';

            const header = document.createElement('div');
            header.className = 'am-download-header';
            const headerTitle = document.createElement('span');
            headerTitle.textContent = 'âœ… æ•è·æŠ¥è¡¨';
            const headerSource = document.createElement('span');
            headerSource.className = 'am-download-source';
            headerSource.textContent = source;
            header.appendChild(headerTitle);
            header.appendChild(headerSource);

            const urlBox = document.createElement('div');
            urlBox.className = 'am-download-url';
            urlBox.textContent = safeUrl;

            const actions = document.createElement('div');
            actions.className = 'am-download-actions';

            const dlLink = document.createElement('a');
            dlLink.href = safeUrl;
            dlLink.target = '_blank';
            dlLink.rel = 'noopener noreferrer';
            dlLink.className = 'am-download-link';
            dlLink.textContent = 'âš¡ ç›´è¿ä¸‹è½½';

            const copyBtn = document.createElement('button');
            copyBtn.className = 'am-download-btn am-download-copy';
            copyBtn.textContent = 'å¤åˆ¶';

            const closeBtn = document.createElement('button');
            closeBtn.className = 'am-download-btn am-download-close';
            closeBtn.textContent = 'X';

            actions.appendChild(dlLink);
            actions.appendChild(copyBtn);
            actions.appendChild(closeBtn);

            const hint = document.createElement('div');
            hint.className = 'am-download-hint';
            hint.textContent = 'æç¤ºï¼šå¦‚æœä¸‹è½½çš„æ–‡ä»¶åæ— åç¼€ï¼Œè¯·æ‰‹åŠ¨æ·»åŠ  .xlsx';

            this.panel.appendChild(header);
            this.panel.appendChild(urlBox);
            this.panel.appendChild(actions);
            this.panel.appendChild(hint);
            this.panel.style.display = 'block';

            copyBtn.onclick = function () {
                GM_setClipboard(safeUrl);
                this.innerText = 'å·²å¤åˆ¶';
                setTimeout(() => this.innerText = 'å¤åˆ¶', 1500);
            };
            closeBtn.onclick = () => this.panel.style.display = 'none';
        },

        // --- é€’å½’è§£æ JSON (Restored Original Logic) ---
        findUrlInObject(obj, source) {
            if (!obj) return;
            if (typeof obj === 'string') {
                if (obj.startsWith('http') && this.isDownloadUrl(obj)) {
                    this.show(obj, source);
                }
                return;
            }
            if (typeof obj === 'object') {
                for (let key in obj) {
                    this.findUrlInObject(obj[key], source);
                }
            }
        },

        handleResponse(text, source, meta = {}) {
            if (typeof text !== 'string' || !text) return;
            if (!this.shouldParseResponse({ ...meta, source, textLength: text.length })) return;

            try {
                const json = JSON.parse(text);
                this.findUrlInObject(json, `JSON:${source} `);
            } catch (e) {
                // Fallback Regex from original code
                if (text && this.keywords.some(k => text.includes(k))) {
                    const regex = /https?:\/\/[^"'\s\\]+(?:xlsx|csv|MAIN)[^"'\s\\]*/g;
                    const matches = text.match(regex);
                    if (matches) matches.forEach(m => {
                        if (this.isDownloadUrl(m)) this.show(m, `Regex:${source} `);
                    });
                }
            }
        },

        registerHooks() {
            if (this.hooksRegistered) return;
            const hooks = createHookManager();

            hooks.registerFetch(({ args, response }) => {
                const requestUrl = typeof args?.[0] === 'string' ? args[0] : args?.[0]?.url;
                const responseUrl = response?.url || '';
                this.inspectUrl(requestUrl, 'Fetch:RequestURL');
                this.inspectUrl(responseUrl, 'Fetch:ResponseURL');

                const contentType = response?.headers?.get('content-type') || '';
                const contentLength = response?.headers?.get('content-length') || '';
                if (!this.shouldParseResponse({ source: 'Fetch', contentType, contentLength })) return;

                const clone = response.clone();
                clone.text()
                    .then(text => this.handleResponse(text, 'Fetch', { contentType, contentLength }))
                    .catch(() => { });
            });

            hooks.registerXHROpen(({ url }) => {
                this.inspectUrl(url, 'XHR:OpenURL');
            });

            hooks.registerXHRLoad(({ xhr }) => {
                this.inspectUrl(xhr.responseURL || xhr.__amHookUrl, 'XHR:ResponseURL');

                const contentType = xhr.getResponseHeader?.('content-type') || '';
                const contentLength = xhr.getResponseHeader?.('content-length') || '';
                const responseType = xhr.responseType || '';
                const text = typeof xhr.responseText === 'string' ? xhr.responseText : '';

                if (responseType === 'json' && xhr.response && typeof xhr.response === 'object') {
                    this.findUrlInObject(xhr.response, 'JSON:XHR(response)');
                }

                this.handleResponse(text, 'XHR', { contentType, contentLength, responseType });
            });

            document.addEventListener('click', (e) => {
                const target = e.target;
                if (!(target instanceof Element)) return;

                const isExitModeBtn = !!target.closest('#mx_2517 > button');
                const textBtn = target.closest('button');
                const text = (textBtn?.textContent || '').trim();
                const isExitModeText = text.includes('é€€å‡ºæ¨¡å¼');

                if (isExitModeBtn || isExitModeText) {
                    if (this.panel) this.panel.style.display = 'none';
                }
            }, true);

            hooks.install();
            this.hooksRegistered = true;
        }
    };

    // ==========================================
    // 6. ä¸‡èƒ½æŸ¥æ•° (Magic Report) - iframe åµŒå…¥æ–¹æ¡ˆ
    // ==========================================
    const MagicReport = {
        popup: null,
        header: null,
        iframe: null,
        lastCampaignId: '',
        lastCampaignName: '',
        BASE_URL: 'https://one.alimama.com/index.html#!/report/ai-report',
        QUICK_PROMPTS: [
            { label: 'ğŸ“› è®¡åˆ’åï¼š{campaignName}', value: 'è®¡åˆ’åï¼š{campaignName}', type: 'action', autoSubmit: false, requireCampaignName: true },
            { label: 'ğŸ–±ï¸ ç‚¹å‡»åˆ†æ', value: 'è®¡åˆ’IDï¼š{campaignId} ç‚¹å‡»äººç¾¤åˆ†æ', type: 'query', autoSubmit: true, requireCampaignId: true },
            { label: 'ğŸ›’ åŠ è´­åˆ†æ', value: 'è®¡åˆ’IDï¼š{campaignId} åŠ è´­äººç¾¤åˆ†æ', type: 'query', autoSubmit: true, requireCampaignId: true },
            { label: 'ğŸ’° æˆäº¤åˆ†æ', value: 'è®¡åˆ’IDï¼š{campaignId} æˆäº¤äººç¾¤åˆ†æ', type: 'query', autoSubmit: true, requireCampaignId: true }
        ],

        // NOTE: iframe åŠ è½½åé€šè¿‡ JS æ¸…ç†é¡µé¢ï¼Œåªä¿ç•™ä¸‡èƒ½æŸ¥æ•°æ ¸å¿ƒå†…å®¹åŒº
        CLEANUP_CSS: `
            body { overflow: auto!important; margin: 0!important; padding: 0!important; }
            #universalBP_common_layout_main_content {
                margin: 0!important;
                padding: 16px!important;
                width: 100%!important;
                max-width: 100%!important;
            }
            div#app { min-width: 0!important; }
            /* éšè—ç€‘å¸ƒæµæ¨èåŒºåŸŸå’Œ Magix å¼¹å‡ºå±‚ */
            [id^="mx_"] > div.waterfall-masonry,
            [id^="mx_"] > div.mb16,
            .waterfall-masonry,
            [id^="popover_mx_"] { display: none!important; }
            /* æŸ¥è¯¢ç»“æœå®¹å™¨ä¸é™åˆ¶é«˜åº¦ */
            [id$="_query_result_container"] { max-height: none!important; }
            /* æœç´¢æ å’ŒæŸ¥è¯¢å¼¹å±‚å®½åº¦ç»Ÿä¸€ 100% */
            #ai-input-magic-report,
            .query-pop { width: 100%!important; }
            [id^="mx_"] > div.ivthphqCKy.search-bar-selected.mb8 > div.query-pop { top: 128px!important; }
            .bXMILLeECt,
            .bXMILLeECu { top: -135px!important; }
            #universalBP_common_layout > div.bXMILLeECt > div.bXMILLeECs { top: -150px!important; }
    `,

        getIframeDoc() {
            if (!this.iframe) return null;
            try {
                return this.iframe.contentDocument || this.iframe.contentWindow?.document || null;
            } catch {
                return null;
            }
        },

        buildIframeUrl(forceReload = false) {
            const rawUrl = this.iframe?.getAttribute('src') || this.BASE_URL;
            const url = new URL(rawUrl, window.location.href);
            if (forceReload) {
                url.searchParams.set('_am_refresh_ts', String(Date.now()));
            }
            return url.toString();
        },

        extractCampaignId(rawText) {
            const text = String(rawText || '').trim();
            if (!text) return '';

            const normalized = [];
            normalized.push(text);
            try {
                normalized.push(decodeURIComponent(text));
            } catch { }

            const patterns = [
                /(?:^|[?&#])campaignId=(\d{6,})/i,
                /(?:^|[?&#])campaign_id=(\d{6,})/i,
                /campaignId[ï¼š:\s=]+(\d{6,})/i,
                /campaign_id[ï¼š:\s=]+(\d{6,})/i,
                /è®¡åˆ’(?:ID|id)?[ï¼š:\s]+(\d{6,})/i
            ];

            for (const source of normalized) {
                for (const reg of patterns) {
                    const match = source.match(reg);
                    if (match?.[1]) return match[1];
                }
            }
            return '';
        },

        sanitizeCampaignName(rawName) {
            const normalized = String(rawName || '')
                .replace(/\s+/g, ' ')
                .replace(/^[`"'â€œâ€â€˜â€™]+|[`"'â€œâ€â€˜â€™]+$/g, '')
                .trim();
            if (!normalized) return '';

            const stripped = normalized
                .replace(/^è®¡åˆ’(?:å|åç§°)\s*[ï¼š:]\s*/i, '')
                .trim();
            if (!stripped) return '';
            if (/^\d{6,}$/.test(stripped)) return '';
            return stripped;
        },

        escapeRegExp(rawText) {
            return String(rawText || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        },

        isLikelyCampaignName(rawName) {
            const name = this.sanitizeCampaignName(rawName);
            if (!name) return false;
            if (name.length < 2 || name.length > 120) return false;
            if (/^\d+$/.test(name)) return false;
            if (/(?:æŸ¥æ•°è®¡åˆ’ID|è®¡åˆ’\s*(?:ID|id)|å½“å‰è®¡åˆ’ID|campaign[_\s-]*id)/i.test(name)) return false;
            if (!/[\u4e00-\u9fa5A-Za-z]/.test(name)) return false;
            if (/^(?:è®¡åˆ’|è®¡åˆ’id|è®¡åˆ’åç§°|è®¡åˆ’å|çŠ¶æ€|é¢„ç®—|æ—¥é™é¢|æ“ä½œ|æŸ¥æ•°|è·å–è®¡åˆ’å|é˜¿é‡Œå¦ˆå¦ˆ|ä¸‡è±¡æŸ¥æ•°|ä¸‡èƒ½æŸ¥æ•°)$/i.test(name)) return false;
            if (/^(?:å¹³å°æ¨è|æŠ¤èˆªå·²ç»“æŸ|ç›´æ¥æˆäº¤|è®¡åˆ’ç»„|æŠ•æ”¾è°ƒä¼˜.*)$/i.test(name)) return false;
            return true;
        },

        extractCampaignNameFromCompositeText(rawText, campaignId = '') {
            let text = String(rawText || '').replace(/\s+/g, ' ').trim();
            if (!text) return '';

            const directMatch = text.match(/è®¡åˆ’(?:å|åç§°)\s*[ï¼š:]\s*([^\n\r|,ï¼Œ;ï¼›]+)/i);
            if (directMatch?.[1]) {
                const directName = this.sanitizeCampaignName(directMatch[1]);
                if (this.isLikelyCampaignName(directName)) return directName;
            }

            if (campaignId) {
                const idPattern = this.escapeRegExp(campaignId);
                text = text
                    .replace(new RegExp(`è®¡åˆ’\\s*(?:ID|id)?\\s*[ï¼š:]?\\s*${idPattern}`, 'ig'), ' ')
                    .replace(new RegExp(idPattern, 'g'), ' ');
            }

            text = text
                .replace(/æŸ¥æ•°è®¡åˆ’ID|è®¡åˆ’ID|è·å–è®¡åˆ’å|ç‚¹å‡»åˆ†æ|åŠ è´­åˆ†æ|æˆäº¤åˆ†æ|æŸ¥æ•°|è®¡åˆ’å|è®¡åˆ’åç§°/gi, ' ')
                .replace(/[()[\]{}<>ã€ã€‘]/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
            if (!text) return '';

            const segments = text.split(/[|ï½œ/ï¼Œ,ï¼›;>Â»â†’]/).map(s => s.trim()).filter(Boolean);
            const candidates = segments.length ? segments : [text];
            const valid = candidates
                .map(s => this.sanitizeCampaignName(s))
                .filter(name => this.isLikelyCampaignName(name))
                .sort((a, b) => b.length - a.length);
            return valid[0] || '';
        },

        guessCampaignNameById(campaignId, seedElement = null) {
            const id = String(campaignId || '').trim();
            const idPattern = id ? this.escapeRegExp(id) : '';
            const textCandidates = [];

            const pushText = (raw) => {
                const text = String(raw || '').replace(/\s+/g, ' ').trim();
                if (!text) return;
                if (text.length > 600) return;
                const compact = text.replace(/\s+/g, '');
                const hasPlanHint = /è®¡åˆ’[:ï¼š]|è®¡åˆ’å|è®¡åˆ’åç§°|campaign[_\s-]*name|campaign[_\s-]*id/i.test(compact);
                if (!hasPlanHint && compact.length > 36) return;
                if (!hasPlanHint && /(?:å®è´ID|è®¡åˆ’ç»„[:ï¼š]|æŠ•æ”¾è°ƒä¼˜|æŠ¤èˆªå·²ç»“æŸ|å¹³å°æ¨è)/i.test(compact)) return;
                textCandidates.push(text);
            };

            const pickNameByPlanPrefix = (root) => {
                if (!(root instanceof Element)) return '';
                const strictAnchors = Array.from(root.querySelectorAll('span + a[title]'));
                for (const anchor of strictAnchors) {
                    if (!(anchor instanceof HTMLAnchorElement)) continue;
                    const prevRaw = (anchor.previousElementSibling?.textContent || '').replace(/\s+/g, '');
                    if (!/^è®¡åˆ’[:ï¼š]?$/.test(prevRaw)) continue;
                    const strictName = this.sanitizeCampaignName(anchor.getAttribute('title'));
                    if (this.isLikelyCampaignName(strictName)) return strictName;
                }

                const anchors = Array.from(root.querySelectorAll('a[title]'));
                for (const anchor of anchors) {
                    const titleName = this.sanitizeCampaignName(anchor.getAttribute('title'));
                    if (!this.isLikelyCampaignName(titleName)) continue;

                    const prevRaw = (anchor.previousElementSibling?.textContent || '').replace(/\s+/g, '');
                    const parentRaw = (anchor.parentElement?.textContent || '').replace(/\s+/g, '');
                    const nearRaw = (anchor.closest('.asiYysqLgo, .asiYysqLgr, .ellipsis, div, span, td, li')?.textContent || '').replace(/\s+/g, '');
                    const planWithName = `è®¡åˆ’ï¼š${titleName}`;
                    const planWithNameAlt = `è®¡åˆ’:${titleName}`;
                    if (
                        /^è®¡åˆ’[:ï¼š]?$/.test(prevRaw) ||
                        parentRaw.includes(planWithName) ||
                        parentRaw.includes(planWithNameAlt) ||
                        nearRaw.includes(planWithName) ||
                        nearRaw.includes(planWithNameAlt)
                    ) {
                        return titleName;
                    }
                }
                return '';
            };

            const scoreAnchor = (anchor) => {
                if (!(anchor instanceof HTMLAnchorElement)) return { name: '', score: -999 };
                const titleName = this.sanitizeCampaignName(anchor.getAttribute('title'));
                if (!this.isLikelyCampaignName(titleName)) return { name: '', score: -999 };

                const href = (anchor.getAttribute('href') || anchor.getAttribute('mx-href') || '').trim();
                const text = (anchor.textContent || '').trim();
                const cls = (anchor.className || '').toString();
                const prevText = (anchor.previousElementSibling?.textContent || '').replace(/\s+/g, '');
                const parentText = (anchor.parentElement?.textContent || '').replace(/\s+/g, '');
                const nearText = (anchor.closest('div,span,td,li')?.textContent || '').replace(/\s+/g, '');
                const exactPlanPattern = new RegExp(`è®¡åˆ’[:ï¼š]${this.escapeRegExp(titleName)}`);

                let score = 0;
                if (text && text === titleName) score += 15;
                if (id && idPattern && new RegExp(`(?:campaignId|campaign_id)=${idPattern}`).test(href)) score += 100;
                if (href.startsWith('javascript:')) score += 8;
                if (/^è®¡åˆ’[:ï¼š]?$/.test(prevText)) score += 140;
                if (exactPlanPattern.test(parentText)) score += 120;
                if (exactPlanPattern.test(nearText)) score += 100;
                if (/è®¡åˆ’[:ï¼š]/.test(parentText) || /è®¡åˆ’[:ï¼š]/.test(nearText)) score += 30;
                if (/wO_WXndakU/.test(cls)) score += 60;
                if (/wO_WXndw/.test(cls)) score -= 220;
                if (/å¹³å°æ¨è|æŠ¤èˆªå·²ç»“æŸ|æŠ•æ”¾è°ƒä¼˜|ç›´æ¥æˆäº¤|è®¡åˆ’ç»„|å®è´ID/i.test(parentText + nearText)) score -= 60;

                return { name: titleName, score };
            };

            const pickBestNameFromRoot = (root, minScore = 110) => {
                if (!(root instanceof Element)) return '';
                const anchors = Array.from(root.querySelectorAll('a[title]'));
                let best = { name: '', score: -999 };
                anchors.forEach((anchor) => {
                    const current = scoreAnchor(anchor);
                    if (current.score > best.score) best = current;
                });
                return best.score >= minScore ? best.name : '';
            };

            const pickNameNearElement = (el) => {
                if (!(el instanceof Element)) return '';
                let cursor = el;
                for (let depth = 0; cursor && depth < 10; depth++) {
                    const strictName = pickNameByPlanPrefix(cursor);
                    if (strictName) return strictName;
                    const name = pickBestNameFromRoot(cursor, 120);
                    if (name) return name;
                    cursor = cursor.parentElement;
                }
                return '';
            };

            if (seedElement instanceof Element) {
                const nearName = pickNameNearElement(seedElement);
                if (nearName) return nearName;
            }

            const collectFromElement = (el) => {
                if (!(el instanceof Element)) return;
                pushText(el.getAttribute('data-campaign-name'));
                pushText(el.getAttribute('campaignname'));
                pushText(el.getAttribute('title'));
                pushText(el.getAttribute('aria-label'));
                const text = String(el.textContent || '').trim();
                if (/è®¡åˆ’[:ï¼š]|è®¡åˆ’å|è®¡åˆ’åç§°|campaign[_\s-]*name|campaign[_\s-]*id/i.test(text)) {
                    pushText(text);
                }
            };

            const collectAround = (el) => {
                if (!(el instanceof Element)) return;
                collectFromElement(el);
                collectFromElement(el.previousElementSibling);
                collectFromElement(el.nextElementSibling);
                collectFromElement(el.parentElement);
                const row = el.closest('tr, [role="row"], li, [class*="row"], [class*="item"]');
                if (row) {
                    collectFromElement(row);
                    row.querySelectorAll('[data-campaign-name], [campaignname], [title]').forEach(node => collectFromElement(node));
                }
            };

            if (seedElement) collectAround(seedElement);

            if (id) {
                const strictByButton = Array.from(document.querySelectorAll(`.am-campaign-search-btn[data-campaign-id="${id}"]`))
                    .map(btn => btn.closest('div[mxa*="wO_WXndqs:l"], .flex-1.min-width-0, [class*="wO_WXnd"]'))
                    .filter(Boolean);
                for (const root of strictByButton) {
                    if (!(root instanceof Element)) continue;
                    const exactNode = root.querySelector('span.wO_WXndakU + a[title].wO_WXndakU, span[class*="wO_WXndakU"] + a[title][href="javascript:;"], .asiYysqLgo .ellipsis a[title][href="javascript:;"]');
                    if (exactNode instanceof HTMLAnchorElement) {
                        const exactName = this.sanitizeCampaignName(exactNode.getAttribute('title'));
                        if (this.isLikelyCampaignName(exactName)) return exactName;
                    }
                }

                const selectors = [
                    `.am-campaign-search-btn[data-campaign-id="${id}"]`,
                    `[data-campaign-id="${id}"]`,
                    `[campaignid="${id}"]`,
                    `a[href*="campaignId=${id}"]`,
                    `a[href*="campaign_id=${id}"]`,
                    `input[type="checkbox"][value="${id}"]`
                ];
                selectors.forEach((selector) => {
                    document.querySelectorAll(selector).forEach(node => {
                        const rowRoot = node.closest('tr, [role="row"], li, [class*="row"], [class*="item"], [mxa*="wO_WXndqs"]') || node.parentElement;
                        const strictName = pickNameByPlanPrefix(rowRoot);
                        if (strictName) {
                            textCandidates.push(`è®¡åˆ’åï¼š${strictName}`);
                            return;
                        }

                        const nearName = pickNameNearElement(node) || pickBestNameFromRoot(rowRoot, 100);
                        if (nearName) {
                            textCandidates.push(`è®¡åˆ’åï¼š${nearName}`);
                            return;
                        }
                        collectAround(node);
                    });
                });

                const allTitleAnchors = Array.from(document.querySelectorAll(`a[href*="campaignId=${id}"][title], a[href*="campaign_id=${id}"][title], a[mx-href*="campaignId=${id}"][title], a[mx-href*="campaign_id=${id}"][title]`));
                if (allTitleAnchors.length) {
                    const best = allTitleAnchors
                        .map(anchor => scoreAnchor(anchor))
                        .sort((a, b) => b.score - a.score)[0];
                    if (best && best.score >= 80 && this.isLikelyCampaignName(best.name)) {
                        return best.name;
                    }
                }
            }

            for (const candidateText of textCandidates) {
                const fromPattern = this.extractCampaignName(candidateText);
                if (this.isLikelyCampaignName(fromPattern)) return fromPattern;

                const fromComposite = this.extractCampaignNameFromCompositeText(candidateText, id);
                if (this.isLikelyCampaignName(fromComposite)) return fromComposite;
            }

            const titleName = this.extractCampaignNameFromCompositeText(document.title, id);
            if (this.isLikelyCampaignName(titleName)) return titleName;

            return '';
        },

        extractCampaignName(rawText) {
            const text = String(rawText || '').trim();
            if (!text) return '';

            const sources = [text];
            try {
                sources.push(decodeURIComponent(text));
            } catch { }

            const patterns = [
                /(?:^|[?&#])campaignName=([^&#]+)/i,
                /(?:^|[?&#])campaign_name=([^&#]+)/i,
                /è®¡åˆ’[ï¼š:]\s*([^\n\r|,ï¼Œ;ï¼›]+)/i,
                /è®¡åˆ’(?:å|åç§°)[ï¼š:\s]+([^\n\r;ï¼›|]+)/i
            ];

            for (const source of sources) {
                for (const reg of patterns) {
                    const match = source.match(reg);
                    if (!match?.[1]) continue;
                    const raw = String(match[1] || '').trim();
                    if (!raw) continue;
                    let decoded = raw;
                    try {
                        decoded = decodeURIComponent(raw);
                    } catch { }
                    const name = this.sanitizeCampaignName(decoded);
                    if (name) return name;
                }
            }

            return '';
        },

        extractCampaignIdFromElement(el) {
            if (!(el instanceof Element)) return '';

            const candidates = [
                el.getAttribute('data-campaign-id'),
                el.getAttribute('campaignid'),
                el.getAttribute('data-id'),
                el.getAttribute('href'),
                el.getAttribute('mx-href'),
                el.id
            ];
            if (el instanceof HTMLInputElement) candidates.push(el.value);

            for (const item of candidates) {
                const id = this.extractCampaignId(item);
                if (id) return id;
            }

            const nearestLink = el.closest('a[href*="campaignId="], a[href*="campaign_id="]') || el.querySelector?.('a[href*="campaignId="], a[href*="campaign_id="]');
            if (nearestLink) {
                const id = this.extractCampaignId(nearestLink.getAttribute('href') || nearestLink.href);
                if (id) return id;
            }

            return '';
        },

        extractCampaignNameFromElement(el) {
            if (!(el instanceof Element)) return '';
            const classText = (el.className || '').toString();
            if (/wO_WXndw/.test(classText)) return '';

            const candidates = [
                el.getAttribute('data-campaign-name'),
                el.getAttribute('campaignname'),
                el.getAttribute('data-name'),
                el.getAttribute('title'),
                el.getAttribute('aria-label'),
                el.getAttribute('placeholder')
            ];
            if (el instanceof HTMLInputElement) candidates.push(el.value);

            for (const item of candidates) {
                const name = this.extractCampaignName(item);
                if (this.isLikelyCampaignName(name)) return name;
                const plainName = this.sanitizeCampaignName(item);
                if (this.isLikelyCampaignName(plainName)) return plainName;
            }

            const ownText = this.sanitizeCampaignName(el.textContent);
            const hasPlanContext = /è®¡åˆ’[:ï¼š]|è®¡åˆ’å|è®¡åˆ’åç§°/.test(String(el.textContent || ''))
                || /wO_WXndakU|campaign-name|campaignName|plan-name|planName/.test(classText);
            if (ownText && this.isLikelyCampaignName(ownText) && ownText.length <= 80 && hasPlanContext) {
                return ownText;
            }

            return '';
        },

        getCurrentCampaignId() {
            const sourceCandidates = [
                window.location.href,
                window.location.hash,
                window.location.search
            ];
            for (const source of sourceCandidates) {
                const id = this.extractCampaignId(source);
                if (id) {
                    this.lastCampaignId = id;
                    return id;
                }
            }

            const checkedBox = document.querySelector('input[type="checkbox"][value]:checked');
            if (checkedBox) {
                const id = this.extractCampaignIdFromElement(checkedBox);
                if (id) {
                    this.lastCampaignId = id;
                    return id;
                }
            }

            const selectedSelectors = [
                'tr[class*="selected"]',
                'tr[class*="active"]',
                'tr[class*="current"]',
                '[class*="selected"][role="row"]',
                '[class*="active"][role="row"]',
                '[aria-current="true"]'
            ];
            for (const selector of selectedSelectors) {
                const selectedEl = document.querySelector(selector);
                if (!selectedEl) continue;
                const id = this.extractCampaignIdFromElement(selectedEl);
                if (id) {
                    this.lastCampaignId = id;
                    return id;
                }
            }

            const allCampaignIds = new Set();
            document.querySelectorAll('a[href*="campaignId="], a[href*="campaign_id="], input[type="checkbox"][value]').forEach(el => {
                const id = this.extractCampaignIdFromElement(el);
                if (id) allCampaignIds.add(id);
            });
            if (allCampaignIds.size === 1) {
                const [id] = Array.from(allCampaignIds);
                this.lastCampaignId = id;
                return id;
            }

            return this.lastCampaignId || '';
        },

        getCurrentCampaignName() {
            const sourceCandidates = [
                window.location.href,
                window.location.hash,
                window.location.search
            ];
            for (const source of sourceCandidates) {
                const name = this.extractCampaignName(source);
                if (name) {
                    this.lastCampaignName = name;
                    return name;
                }
            }

            const currentCampaignId = this.getCurrentCampaignId();
            if (currentCampaignId) {
                const guessedFirst = this.guessCampaignNameById(currentCampaignId);
                if (guessedFirst) {
                    this.lastCampaignName = guessedFirst;
                    return guessedFirst;
                }
            }

            const checkedBox = document.querySelector('input[type="checkbox"][value]:checked');
            if (checkedBox) {
                const row = checkedBox.closest('tr, [role="row"], li, [class*="row"], [class*="item"]');
                if (row) {
                    const strictNameNode = row.querySelector('span.wO_WXndakU + a[title].wO_WXndakU, span[class*="wO_WXndakU"] + a[title][href="javascript:;"], .asiYysqLgo .ellipsis a[title][href="javascript:;"]');
                    if (strictNameNode) {
                        const strictName = this.extractCampaignNameFromElement(strictNameNode);
                        if (strictName) {
                            this.lastCampaignName = strictName;
                            return strictName;
                        }
                    }

                    const nameNode = row.querySelector('[data-campaign-name], [campaignname], [class*="campaign-name"], [class*="campaignName"], [class*="plan-name"], [class*="planName"], a[title][href="javascript:;"], span[title], div[title]');
                    if (nameNode) {
                        const name = this.extractCampaignNameFromElement(nameNode);
                        if (name) {
                            this.lastCampaignName = name;
                            return name;
                        }
                    }
                }
            }

            const selectedSelectors = [
                'tr[class*="selected"]',
                'tr[class*="active"]',
                'tr[class*="current"]',
                '[class*="selected"][role="row"]',
                '[class*="active"][role="row"]',
                '[aria-current="true"]',
                '[data-campaign-name]',
                '[campaignname]'
            ];
            for (const selector of selectedSelectors) {
                const selectedEl = document.querySelector(selector);
                if (!selectedEl) continue;
                const name = this.extractCampaignNameFromElement(selectedEl);
                if (name) {
                    this.lastCampaignName = name;
                    return name;
                }
            }

            if (currentCampaignId) {
                const byIdSelectors = [
                    `[data-campaign-id="${currentCampaignId}"]`,
                    `[campaignid="${currentCampaignId}"]`,
                    `a[href*="campaignId=${currentCampaignId}"]`,
                    `a[href*="campaign_id=${currentCampaignId}"]`,
                    `input[type="checkbox"][value="${currentCampaignId}"]`
                ];
                for (const selector of byIdSelectors) {
                    const node = document.querySelector(selector);
                    if (!node) continue;

                    const directName = this.extractCampaignNameFromElement(node);
                    if (directName && directName !== currentCampaignId) {
                        this.lastCampaignName = directName;
                        return directName;
                    }

                    const row = node.closest('tr, [role="row"], li, [class*="row"], [class*="item"]');
                    if (row) {
                        const candidates = row.querySelectorAll('[data-campaign-name], [campaignname], [class*="campaign-name"], [class*="campaignName"], [class*="plan-name"], [class*="planName"], a, span, div');
                        for (const candidate of candidates) {
                            const name = this.extractCampaignNameFromElement(candidate);
                            if (!name) continue;
                            if (name === currentCampaignId) continue;
                            if (name.includes('è®¡åˆ’ID') || name.includes('æŸ¥æ•°')) continue;
                            this.lastCampaignName = name;
                            return name;
                        }
                    }
                }
            }

            if (currentCampaignId) {
                const guessed = this.guessCampaignNameById(currentCampaignId);
                if (guessed) {
                    this.lastCampaignName = guessed;
                    return guessed;
                }
            }

            const titleGuess = this.guessCampaignNameById('', null);
            if (titleGuess) {
                this.lastCampaignName = titleGuess;
                return titleGuess;
            }

            return this.lastCampaignName || '';
        },

        resolvePromptLabel(promptItem) {
            const template = String(promptItem?.label || '').trim();
            if (!template) return '';

            let resolved = template;
            if (resolved.includes('{campaignName}')) {
                const campaignName = this.getCurrentCampaignName() || this.lastCampaignName;
                resolved = resolved.replace(/\{campaignName\}/g, campaignName || 'æœªè¯†åˆ«');
            }
            if (resolved.includes('{campaignId}')) {
                const campaignId = this.getCurrentCampaignId() || this.lastCampaignId;
                resolved = resolved.replace(/\{campaignId\}/g, campaignId || '--');
            }
            return resolved;
        },

        refreshQuickPromptLabels() {
            if (!this.popup) return;
            const quickPrompts = this.popup.querySelector('#am-magic-quick-prompts');
            if (!quickPrompts) return;

            quickPrompts.querySelectorAll('.am-quick-prompt').forEach((btn) => {
                if (!(btn instanceof HTMLElement)) return;
                const idx = Number(btn.dataset.index);
                const item = this.QUICK_PROMPTS[idx];
                if (!item) return;
                btn.textContent = this.resolvePromptLabel(item);
            });
        },

        resolvePromptText(promptItem) {
            const template = String(promptItem?.value || '').trim();
            if (!template) return '';

            let resolved = template;

            if (resolved.includes('{campaignId}')) {
                const campaignId = this.getCurrentCampaignId();
                if (!campaignId) {
                    Logger.log('âš ï¸ æœªè¯†åˆ«åˆ°å½“å‰è®¡åˆ’IDï¼Œè¯·å…ˆè¿›å…¥è®¡åˆ’è¯¦æƒ…é¡µæˆ–å‹¾é€‰è®¡åˆ’åé‡è¯•', true);
                    return '';
                }
                resolved = resolved.replace(/\{campaignId\}/g, campaignId);
            }

            if (resolved.includes('{campaignName}')) {
                const campaignName = this.getCurrentCampaignName();
                if (!campaignName) {
                    Logger.log('âš ï¸ æœªè¯†åˆ«åˆ°å½“å‰è®¡åˆ’åç§°ï¼Œè¯·å…ˆè¿›å…¥è®¡åˆ’è¯¦æƒ…é¡µæˆ–å‹¾é€‰è®¡åˆ’åé‡è¯•', true);
                    return '';
                }
                resolved = resolved.replace(/\{campaignName\}/g, campaignName);
            }

            return resolved;
        },

        isEditablePromptElement(el) {
            if (!el) return false;
            if (el instanceof HTMLTextAreaElement) return true;
            if (el instanceof HTMLInputElement) {
                const t = (el.type || 'text').toLowerCase();
                return t === 'text' || t === 'search';
            }
            return !!el.isContentEditable;
        },

        isVisibleElement(el) {
            if (!(el instanceof Element)) return false;
            const style = el.ownerDocument?.defaultView?.getComputedStyle(el);
            if (!style) return true;
            if (style.display === 'none' || style.visibility === 'hidden') return false;
            const rect = el.getBoundingClientRect();
            return rect.width > 0 && rect.height > 0;
        },

        findPromptInput(iframeDoc) {
            const selectors = [
                '#ai-input-magic-report textarea',
                '#ai-input-magic-report input[type="text"]',
                '#ai-input-magic-report input[type="search"]',
                '#ai-input-magic-report [contenteditable="true"]',
                'textarea#ai-input-magic-report',
                'input#ai-input-magic-report[type="text"]',
                'input#ai-input-magic-report[type="search"]',
                '[id="ai-input-magic-report"][contenteditable="true"]'
            ];

            for (const selector of selectors) {
                const el = iframeDoc.querySelector(selector);
                if (this.isEditablePromptElement(el)) return el;
            }

            const fallback = Array.from(iframeDoc.querySelectorAll('textarea, input[type="text"], input[type="search"], [contenteditable="true"]'))
                .find(el => {
                    const id = (el.id || '').toLowerCase();
                    const cls = (el.className || '').toLowerCase();
                    const placeholder = (el.getAttribute('placeholder') || '').toLowerCase();
                    const ariaLabel = (el.getAttribute('aria-label') || '').toLowerCase();
                    return (id.includes('magic') || cls.includes('magic') || placeholder.includes('æé—®') || placeholder.includes('è¾“å…¥') || ariaLabel.includes('è¾“å…¥'))
                        && this.isEditablePromptElement(el)
                        && this.isVisibleElement(el);
                });

            if (fallback) return fallback;

            return Array.from(iframeDoc.querySelectorAll('textarea, input[type="text"], input[type="search"], [contenteditable="true"]'))
                .find(el => this.isEditablePromptElement(el) && this.isVisibleElement(el)) || null;
        },

        setPromptInputValue(inputEl, promptText) {
            if (!this.isEditablePromptElement(inputEl)) return false;

            inputEl.focus();
            if (inputEl.isContentEditable) {
                inputEl.textContent = '';
                inputEl.textContent = promptText;
                inputEl.dispatchEvent(new InputEvent('input', { bubbles: true, inputType: 'insertText', data: promptText }));
                inputEl.dispatchEvent(new Event('change', { bubbles: true }));
                return true;
            }

            const proto = inputEl instanceof HTMLTextAreaElement ? HTMLTextAreaElement.prototype : HTMLInputElement.prototype;
            const valueSetter = Object.getOwnPropertyDescriptor(proto, 'value')?.set;
            if (valueSetter) {
                valueSetter.call(inputEl, promptText);
            } else {
                inputEl.value = promptText;
            }

            inputEl.dispatchEvent(new InputEvent('input', { bubbles: true, inputType: 'insertText', data: promptText }));
            inputEl.dispatchEvent(new Event('change', { bubbles: true }));
            return (inputEl.value || '').trim() === promptText.trim();
        },

        triggerClick(el) {
            if (!(el instanceof Element)) return;
            const mouseOpts = { bubbles: true, cancelable: true };
            ['mousedown', 'mouseup', 'click'].forEach(type => {
                try {
                    el.dispatchEvent(new MouseEvent(type, mouseOpts));
                } catch {
                    try {
                        el.dispatchEvent(new Event(type, { bubbles: true, cancelable: true }));
                    } catch { }
                }
            });
            if (typeof el.click === 'function') el.click();
        },

        findQueryTrigger(iframeDoc, inputEl) {
            const roots = [];
            const nearest = inputEl?.closest('[id*="magic"], [class*="magic"], [class*="query"], form');
            if (nearest) roots.push(nearest);
            roots.push(iframeDoc);

            const triggerSelectors = [
                'button[type="submit"]',
                'button[mx-click*="query"]',
                'button[mx-click*="search"]',
                'button[mx-click*="send"]',
                '[role="button"][mx-click*="query"]',
                '[role="button"][mx-click*="search"]',
                '[role="button"][mx-click*="send"]',
                '[mx-click*="query"]',
                '[mx-click*="search"]',
                '[mx-click*="send"]',
                'button[class*="query"]',
                'button[class*="search"]',
                'button[class*="send"]',
                '.next-btn-primary',
                '.next-btn'
            ];

            const seen = new Set();
            const candidates = [];
            roots.forEach(root => {
                triggerSelectors.forEach(selector => {
                    root.querySelectorAll(selector).forEach(el => {
                        if (seen.has(el) || !this.isVisibleElement(el)) return;
                        if (el.hasAttribute('disabled')) return;
                        if (el.getAttribute('aria-disabled') === 'true') return;
                        seen.add(el);
                        candidates.push(el);
                    });
                });
            });
            if (!candidates.length) return null;

            const scoreOf = (el) => {
                const text = (el.textContent || '').trim();
                const title = (el.getAttribute('title') || '').trim();
                const aria = (el.getAttribute('aria-label') || '').trim();
                const mx = (el.getAttribute('mx-click') || '').trim();
                const cls = (el.className || '').toString();
                const id = (el.id || '').trim();
                const merged = `${text} ${title} ${aria} ${mx} ${cls} ${id} `;
                let score = 0;

                if (text === 'æŸ¥è¯¢' || text === 'å‘é€' || text === 'æé—®' || text === 'ç«‹å³æŸ¥è¯¢') score += 100;
                if (text.includes('æŸ¥è¯¢')) score += 90;
                if (text.includes('å‘é€') || text.includes('æé—®')) score += 80;
                if (/query|search|send|submit/i.test(merged)) score += 40;
                if (/next-btn-primary/.test(cls)) score += 15;
                if (inputEl?.form && el.closest('form') === inputEl.form) score += 20;
                return score;
            };

            return candidates
                .map(el => ({ el, score: scoreOf(el) }))
                .sort((a, b) => b.score - a.score)[0]?.el || null;
        },

        trySubmitPrompt(promptText) {
            const iframeDoc = this.getIframeDoc();
            if (!iframeDoc) return { ok: false, reason: 'iframe-not-ready' };

            const inputEl = this.findPromptInput(iframeDoc);
            if (!inputEl) return { ok: false, reason: 'input-not-found' };

            if (!this.setPromptInputValue(inputEl, promptText)) {
                return { ok: false, reason: 'input-set-failed' };
            }

            const trigger = this.findQueryTrigger(iframeDoc, inputEl);
            if (trigger && typeof trigger.click === 'function') {
                this.triggerClick(trigger);
                return { ok: true, method: 'button' };
            }

            if (inputEl.form && typeof inputEl.form.requestSubmit === 'function') {
                inputEl.form.requestSubmit();
                return { ok: true, method: 'form-submit' };
            }

            const keyOptions = { key: 'Enter', code: 'Enter', which: 13, keyCode: 13, bubbles: true, cancelable: true };
            inputEl.dispatchEvent(new KeyboardEvent('keydown', keyOptions));
            inputEl.dispatchEvent(new KeyboardEvent('keypress', keyOptions));
            inputEl.dispatchEvent(new KeyboardEvent('keyup', keyOptions));
            return { ok: true, method: 'enter-fallback', uncertain: true };
        },

        runQuickPrompt(promptText) {
            const maxRetries = 16;
            const tryRun = (retriesLeft) => {
                const result = this.trySubmitPrompt(promptText);
                if (result.ok) {
                    if (result.uncertain) {
                        Logger.log(`ğŸ”® å·²å›è½¦å°è¯•æäº¤ï¼š${promptText} `);
                    } else {
                        Logger.log(`ğŸ”® å¿«æ·æŸ¥è¯¢å·²æ‰§è¡Œï¼š${promptText} `);
                    }
                    return;
                }
                if (retriesLeft <= 0) {
                    if (result.reason === 'input-not-found' || result.reason === 'iframe-not-ready') {
                        Logger.log('âš ï¸ ä¸‡èƒ½æŸ¥æ•°å°šæœªåŠ è½½å®Œæˆï¼Œè¯·ç¨åé‡è¯•', true);
                    } else {
                        Logger.log('âš ï¸ æœªè¯†åˆ«åˆ°å¯ç”¨æŸ¥è¯¢æŒ‰é’®ï¼Œè¯·æ‰‹åŠ¨ç‚¹ä¸€æ¬¡æŸ¥è¯¢åé‡è¯•', true);
                    }
                    return;
                }
                setTimeout(() => tryRun(retriesLeft - 1), 500);
            };
            tryRun(maxRetries);
        },

        buildPromptByCampaignId(campaignId, promptType = 'click') {
            const id = String(campaignId || '').trim();
            if (!/^\d{6,}$/.test(id)) return '';

            const prompts = {
                'click': `è®¡åˆ’IDï¼š${id} ç‚¹å‡»äººç¾¤åˆ†æ`,
                'conversion': `è®¡åˆ’IDï¼š${id} è½¬åŒ–äººç¾¤åˆ†æ`,
                'diagnose': `è®¡åˆ’IDï¼š${id} æ·±åº¦è¯Šæ–­`
            };

            return prompts[promptType] || prompts['click'];
        },

        trySubmitPromptInDocument(doc, promptText) {
            if (!doc || typeof doc.querySelector !== 'function') {
                return { ok: false, reason: 'doc-not-ready' };
            }

            const inputEl = this.findPromptInput(doc);
            if (!inputEl) return { ok: false, reason: 'input-not-found' };

            if (!this.setPromptInputValue(inputEl, promptText)) {
                return { ok: false, reason: 'input-set-failed' };
            }

            const trigger = this.findQueryTrigger(doc, inputEl);
            if (trigger && typeof trigger.click === 'function') {
                this.triggerClick(trigger);
                return { ok: true, method: 'button' };
            }

            if (inputEl.form && typeof inputEl.form.requestSubmit === 'function') {
                inputEl.form.requestSubmit();
                return { ok: true, method: 'form-submit' };
            }

            const eventView = doc.defaultView || window;
            const keyOptions = { key: 'Enter', code: 'Enter', which: 13, keyCode: 13, bubbles: true, cancelable: true, view: eventView };
            inputEl.dispatchEvent(new KeyboardEvent('keydown', keyOptions));
            inputEl.dispatchEvent(new KeyboardEvent('keypress', keyOptions));
            inputEl.dispatchEvent(new KeyboardEvent('keyup', keyOptions));
            return { ok: true, method: 'enter-fallback', uncertain: true };
        },

        async openNativeAndSubmit(campaignId, promptText) {
            const id = String(campaignId || '').trim();
            if (!/^\d{6,}$/.test(id)) return false;

            const pickNativeEntry = () => {
                const selectors = ['button', 'a', '[role="button"]', '[mx-click]'];
                const nodes = document.querySelectorAll(selectors.join(','));
                const candidates = [];
                const seen = new Set();

                nodes.forEach(el => {
                    if (!(el instanceof Element) || seen.has(el)) return;
                    if (el.closest('#am-helper-panel, #am-magic-report-popup, #alimama-escort-helper-ui, #am-report-capture-panel')) return;
                    if (!this.isVisibleElement(el)) return;
                    if (el.hasAttribute('disabled') || el.getAttribute('aria-disabled') === 'true') return;

                    const text = (el.textContent || '').trim();
                    const title = (el.getAttribute('title') || '').trim();
                    const aria = (el.getAttribute('aria-label') || '').trim();
                    const mx = (el.getAttribute('mx-click') || '').trim();
                    const cls = (el.className || '').toString();
                    const idText = (el.id || '').trim();
                    const merged = `${text} ${title} ${aria} ${mx} ${cls} ${idText}`.toLowerCase();

                    let score = 0;
                    if (merged.includes('ä¸‡è±¡æŸ¥æ•°')) score += 400;
                    else if (merged.includes('ä¸‡èƒ½æŸ¥æ•°')) score += 300;
                    else if (merged.includes('å…¨èƒ½æ•°æ®æŸ¥')) score += 200;
                    else if (merged.includes('æŸ¥æ•°')) score += 120;
                    else return;

                    if (merged.includes('ä¸‡è±¡')) score += 40;
                    if (merged.includes('report')) score += 10;
                    if (el.tagName === 'BUTTON') score += 6;
                    if (merged.includes('ai')) score += 4;

                    seen.add(el);
                    candidates.push({ el, score });
                });

                return candidates.sort((a, b) => b.score - a.score)[0]?.el || null;
            };

            const entry = pickNativeEntry();
            if (!entry) return false;

            this.triggerClick(entry);

            for (let i = 0; i < 12; i++) {
                const result = this.trySubmitPromptInDocument(document, promptText);
                if (result.ok) {
                    Logger.log(`ğŸ” åŸç”ŸæŸ¥æ•°å·²æ‰§è¡Œï¼š${promptText}`);
                    return true;
                }
                await new Promise(resolve => setTimeout(resolve, 350));
            }

            return false;
        },

        async openWithCampaignId(campaignId, options = {}) {
            const id = String(campaignId || '').trim();
            if (!/^\d{6,}$/.test(id)) {
                Logger.log(`âš ï¸ è®¡åˆ’IDæ— æ•ˆï¼Œå·²å¿½ç•¥å¿«æ·æŸ¥æ•°ï¼š${id || '-'} `, true);
                return false;
            }

            this.lastCampaignId = id;
            const promptText = this.buildPromptByCampaignId(id, options.promptType || 'click');
            if (!promptText) {
                Logger.log(`âš ï¸ è®¡åˆ’IDæ— æ•ˆï¼Œå·²å¿½ç•¥å¿«æ·æŸ¥æ•°ï¼š${id} `, true);
                return false;
            }

            const preferNative = options.preferNative !== false;
            if (preferNative) {
                try {
                    const nativeOk = await this.openNativeAndSubmit(id, promptText);
                    if (nativeOk) return true;
                } catch {
                    // ignore and fallback
                }
                Logger.log('âš ï¸ åŸç”Ÿä¸‡è±¡æŸ¥æ•°ä¸å¯ç”¨ï¼Œå·²å›é€€ä¸‡èƒ½æŸ¥æ•°', true);
            }

            this.toggle(true);
            this.runQuickPrompt(promptText);
            return true;
        },

        /**
         * åœ¨ iframe ä¸­æ¸…ç†éæ ¸å¿ƒå…ƒç´ 
         * ç­–ç•¥ï¼šæ‰¾åˆ°ç›®æ ‡å…ƒç´ ï¼Œæ²¿çˆ¶çº§é“¾å‘ä¸Šï¼Œéšè—æ¯ä¸€å±‚çš„å…„å¼ŸèŠ‚ç‚¹
         */
        cleanupIframe(iframeDoc) {
            const target = iframeDoc.getElementById('universalBP_common_layout_main_content');
            if (!target) {
                Logger.warn('ğŸ”® æœªæ‰¾åˆ° #universalBP_common_layout_main_contentï¼Œè·³è¿‡æ¸…ç†');
                return;
            }

            // æ²¿çˆ¶çº§é“¾å‘ä¸Šï¼Œéšè—æ¯ä¸€çº§çš„å…„å¼ŸèŠ‚ç‚¹
            let current = target;
            while (current && current !== iframeDoc.body) {
                const parent = current.parentElement;
                if (parent) {
                    Array.from(parent.children).forEach(child => {
                        if (child !== current && child.tagName !== 'SCRIPT' && child.tagName !== 'STYLE' && child.tagName !== 'LINK') {
                            child.style.setProperty('display', 'none', 'important');
                        }
                    });
                }
                current = parent;
            }

            // æ³¨å…¥åŸºç¡€ CSS
            const style = iframeDoc.createElement('style');
            style.id = 'am-cleanup-css';
            style.textContent = MagicReport.CLEANUP_CSS;
            iframeDoc.head.appendChild(style);

            Logger.info('ğŸ”® ä¸‡èƒ½æŸ¥æ•° iframe æ¸…ç†å®Œæˆ');
        },

        createPopup() {
            if (this.popup) return;

            const div = document.createElement('div');
            div.id = 'am-magic-report-popup';
            div.style.cssText = `
                position: fixed; top: 30px; left: 50%; transform: translateX(-50%);
                z-index: 1000001; border-radius: 18px;
                width: 900px; height: 85vh;
                display: none; overflow: hidden;
                flex-direction: column;
                font-family: var(--am26-font);
            `;

            const style = document.createElement('style');
            style.textContent = `
                #am-magic-report-popup .am-magic-header {
                    padding: 10px 20px 8px;
                    display: flex; flex-direction: column; gap: 8px;
                    cursor: move; border-bottom: 1px solid var(--am26-border);
                    flex-shrink: 0;
                }
                #am-magic-report-popup .am-magic-header .am-magic-header-main {
                    display: flex; justify-content: space-between; align-items: center;
                    width: 100%;
                }
                #am-magic-report-popup .am-magic-header .am-title-area {
                    display: flex; align-items: center;
                }
                #am-magic-report-popup .am-magic-header .am-title-area .asiYysqLCh {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    max-width: 560px;
                }
                #am-magic-report-popup .am-magic-header .am-title-area .asiYysqLCt {
                    width: 18px;
                    height: 18px;
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    margin-right: 0;
                    flex-shrink: 0;
                }
                #am-magic-report-popup .am-magic-header .am-title-area .asiYysqLCt img {
                    position: relative;
                    left: 0;
                    top: 0;
                    width: 100%;
                    height: 100%;
                    display: block;
                    object-fit: contain;
                }
                #am-magic-report-popup .am-magic-header .am-title-area .asiYysqLCj {
                    color: #333;
                    font-size: 13px;
                    font-weight: 600;
                    line-height: 1.45;
                    white-space: nowrap;
                    overflow: hidden;
                    text-overflow: ellipsis;
                }
                #am-magic-report-popup .am-magic-header .am-btn-group {
                    display: flex; align-items: center; gap: 4px; border-left: 1px solid rgba(0,0,0,0.06); padding-left: 12px;
                }
                #am-magic-report-popup .am-magic-header .am-btn-group span {
                    width: 32px; height: 32px; cursor: pointer; display: flex; align-items: center; justify-content: center;
                    border-radius: 8px; color: #666; font-size: 18px; transition: all 0.2s;
                }
                #am-magic-report-popup .am-magic-header .am-btn-group #am-magic-refresh {
                    font-size: 20px; font-weight: bold;
                }
                #am-magic-report-popup .am-magic-header .am-btn-group span:hover {
                    background: rgba(0,0,0,0.05); color: var(--am26-primary);
                }
                #am-magic-report-popup .am-magic-header .am-btn-group #am-magic-close:hover {
                    background: rgba(234, 79, 79, 0.1); color: var(--am26-danger);
                }
                #am-magic-report-popup .am-magic-header .am-quick-prompts {
                    display: flex; flex-wrap: wrap; gap: 6px; cursor: default;
                }
                #am-magic-report-popup .am-magic-header .am-quick-prompt {
                    border: 1px solid var(--am26-border); background: var(--am26-surface); color: var(--am26-text-soft);
                    border-radius: 999px; padding: 4px 12px; font-size: 11px; font-weight: 500;
                    line-height: 1.4; cursor: pointer; transition: all 0.2s;
                    max-width: 280px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis;
                    display: flex; align-items: center; gap: 4px;
                }
                #am-magic-report-popup .am-magic-header .am-quick-prompt:hover {
                    background: rgba(42, 91, 255, 0.12); border-color: rgba(42, 91, 255, 0.34); color: var(--am26-primary);
                    transform: translateY(-1px);
                }
                #am-magic-report-popup .am-magic-header .am-quick-prompt.type-action {
                    background: rgba(255, 159, 24, 0.1); border-color: rgba(255, 159, 24, 0.3); color: #d48806;
                }
                #am-magic-report-popup .am-magic-header .am-quick-prompt.type-action:hover {
                    background: rgba(255, 159, 24, 0.2); border-color: rgba(255, 159, 24, 0.5); color: #ad6800;
                }
                #am-magic-report-popup .am-magic-header .am-quick-prompt.active {
                    background: rgba(42, 91, 255, 0.16); border-color: rgba(42, 91, 255, 0.44); color: var(--am26-primary-strong);
                }
                #am-magic-report-popup .am-magic-content {
                    position: relative; flex: 1; min-height: 0;
                    background: rgba(255, 255, 255, 0.4);
                    backdrop-filter: blur(10px);
                }
                #am-magic-report-popup .am-iframe-loading {
                    position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
                    display: flex; flex-direction: column; align-items: center; gap: 12px;
                    color: var(--am26-primary); font-size: 14px;
                }
                #am-magic-report-popup .am-iframe-loading .am-spinner {
                    width: 32px; height: 32px; border: 3px solid rgba(42, 91, 255, 0.18);
                    border-top-color: var(--am26-primary); border-radius: 50%;
                    animation: am-spin 0.8s linear infinite;
                }
                @keyframes am-spin { to { transform: rotate(360deg); } }
            `;
            document.head.appendChild(style);

            const quickPromptHtml = this.QUICK_PROMPTS
                .map((item, idx) => {
                    const typeClass = item.type === 'action' ? 'type-action' : 'type-query';
                    return `<button type="button" class="am-quick-prompt ${typeClass}" data-index="${idx}" title="${item.value}">${this.resolvePromptLabel(item)}</button>`;
                })
                .join('');

            div.innerHTML = `
                <div class="am-magic-header">
                    <div class="am-magic-header-main">
                        <div class="am-title-area">
                            <div mxv="" class="asiYysqLCh mxgc-highlight-texts" style="--mx-title-shadow-color: var(--mx-ai-color); --mx-title-shadow-color-gradient: var(--mx-ai-color-gradient);">
                                <span mxs="asiYysqLa:_" class="asiYysqLCt">
                                    <img src="https://img.alicdn.com/imgextra/i4/O1CN015N7XhL24rrnhJGD58_!!6000000007445-2-tps-1040-1040.png" alt="ä¸‡èƒ½æŸ¥æ•°">
                                </span>
                                <span class="asiYysqLCj asiYysqLCl font-special asiYysqLCm">ä¸‡èƒ½æŸ¥æ•°è¾“å…¥æ‚¨æƒ³è¦äº†è§£çš„æ•°æ®ï¼Œå°ä¸‡å¸®æ‚¨æ”¶é›†</span>
                            </div>
                        </div>
                        <div class="am-btn-group">
                            <span id="am-magic-refresh" title="åˆ·æ–°">
                                <svg viewBox="0 0 1024 1024" style="width:0.65em;height:0.65em;vertical-align:middle;fill:currentColor;overflow:hidden;"><path d="M959.667298 800.651143l-33.843806-157.556409c-0.064468-0.224104 0-0.388856-0.029676-0.587378l-2.611477-10.637268c-1.434675-5.9055-5.15644-10.539031-9.918907-13.248745-4.767584-2.804882-10.638291-3.686972-16.416901-1.956561l-10.538007 3.067872c-0.164752 0.029676-0.328481 0.163729-0.557702 0.25992L729.110271 669.726278c-11.618619 3.362584-18.664082 15.634072-15.829524 27.412326l2.64627 8.879228c2.838651 11.743462 17.358343 15.370059 28.976962 12.006452l100.167351-32.18912c-2.316765 4.496407-4.728698 8.943696-7.227612 13.325493-50.845015 89.318258-137.646963 153.181775-238.125399 175.209464-94.868671 20.790512-225.597061 3.428076-307.410392-48.981574-81.779561-52.344159-137.517003-136.410809-158.308539-231.274364-3.551896-16.152888-19.510356-26.4013-35.668361-22.844288-16.152888 3.527336-26.400277 19.515473-22.809495 35.669384 24.178679 110.532419 89.252767 207.876468 184.510294 268.90031 95.257527 60.993143 242.041592 81.256652 352.540242 57.046251 116.955712-25.683962 218.022549-100.089579 277.32212-204.126051 0.652869-1.154289 1.288343-2.320858 1.932002-3.479241l18.071587 85.813434c2.870374 11.782348 14.618952 18.568914 26.237571 15.140839l8.384971-0.876973C956.17373 821.927725 962.502879 812.369022 959.667298 800.651143zM96.961844 395.962194l2.610454 10.654664c1.439792 5.90857 5.15644 10.525728 9.924024 13.252839 4.76349 2.787486 10.637268 3.669576 16.412808 1.957585l10.507308-3.086291c0.199545-0.029676 0.358157-0.177032 0.557702-0.2415l156.64055-49.751101c11.618619-3.393283 18.697851-15.634072 15.859199-27.41335l-2.871397-7.978718c-2.870374-11.747555-17.134239-16.300244-28.717042-12.906961l-100.582813 32.301683c5.130857-11.68411 10.870582-23.094998 17.173125-34.111912 50.90539-89.366354 136.895857-150.277632 237.309824-172.304298 94.863555-20.790512 225.595015-3.41068 307.374576 48.997947 81.814354 52.361555 138.299833 133.48927 159.121044 228.386594 3.558036 16.153912 19.48068 26.350135 35.668361 22.810518 11.294231-2.482541 19.709901-11.048637 22.485107-21.50478 1.206478-4.473895 1.404999-9.30083 0.323365-14.164604-24.213471-110.51093-90.030479-204.973348-185.288007-265.961374-95.291297-61.011562-242.045685-81.261769-352.543312-57.029878-116.891244 25.618471-217.210044 97.05036-276.470729 201.085808-4.179183 7.325849-8.151657 14.809287-11.908214 22.416546l-17.690918-84.010369c-2.905166-11.765975-13.900591-21.262256-25.51921-17.868973l-8.385994 0.916882c-11.618619 3.429099-18.697851 15.69547-15.859199 27.412326l33.805944 157.552316C96.996636 395.58664 96.896352 395.767765 96.961844 395.962194z"></path></svg>
                            </span>
                            <span id="am-magic-close" title="å…³é—­">
                                <svg viewBox="0 0 1024 1024" style="width:1.2em;height:1.2em;vertical-align:middle;fill:currentColor;overflow:hidden;"><path d="M551.424 512l195.072-195.072c9.728-9.728 9.728-25.6 0-36.864l-1.536-1.536c-9.728-9.728-25.6-9.728-35.328 0L514.56 475.136 319.488 280.064c-9.728-9.728-25.6-9.728-35.328 0l-1.536 1.536c-9.728 9.728-9.728 25.6 0 36.864L477.696 512 282.624 707.072c-9.728 9.728-9.728 25.6 0 36.864l1.536 1.536c9.728 9.728 25.6 9.728 35.328 0L514.56 548.864l195.072 195.072c9.728 9.728 25.6 9.728 35.328 0l1.536-1.536c9.728-9.728 9.728-25.6 0-36.864L551.424 512z"></path></svg>
                            </span>
                        </div>
                    </div>
                    <div class="am-quick-prompts" id="am-magic-quick-prompts">
                        ${quickPromptHtml}
                    </div>
                </div>
                <div class="am-magic-content">
                    <div class="am-iframe-loading" id="am-magic-loading">
                        <div class="am-spinner"></div>
                        <span>æ­£åœ¨åŠ è½½ä¸‡èƒ½æŸ¥æ•°...</span>
                    </div>
                    <iframe id="am-magic-iframe"
                        src="${this.buildIframeUrl(false)}"
                        style="width: 100%; height: 100%; border: none; opacity: 0; transition: opacity 0.3s;"
                        allow="clipboard-write"
                    ></iframe>
                </div>
            `;

            document.body.appendChild(div);
            this.popup = div;
            this.header = div.querySelector('.am-magic-header');
            this.iframe = div.querySelector('#am-magic-iframe');
            this.refreshQuickPromptLabels();

            // iframe åŠ è½½å®Œæˆåå…ˆæ¸…ç†ï¼Œå†æ˜¾ç¤ºï¼Œé¿å…é¦–å±é—ªç°æ•´é¡µå†…å®¹
            this.iframe.onload = () => {
                const loading = div.querySelector('#am-magic-loading');
                this.iframe.style.opacity = '0';

                const revealIframe = () => {
                    if (loading) loading.style.display = 'none';
                    this.iframe.style.opacity = '1';
                };

                // å°è¯•æ¸…ç†ï¼ˆåŒæºæ‰èƒ½æˆåŠŸï¼Œå¤±è´¥ä¹Ÿä¸å½±å“ä½¿ç”¨ï¼‰
                try {
                    const iframeDoc = this.iframe.contentDocument || this.iframe.contentWindow.document;
                    const rootEl = iframeDoc.documentElement || iframeDoc.body;
                    if (rootEl) rootEl.style.setProperty('visibility', 'hidden', 'important');

                    // SPA å»¶è¿ŸåŠ è½½ï¼šç¼©çŸ­è½®è¯¢é—´éš”ï¼Œæœ€å¤§çº¦ 2.4 ç§’ï¼Œé¿å…å¡ä½
                    const maxRetries = 20;
                    const retryInterval = 120;
                    const tryCleanup = (retries = 0) => {
                        try {
                            const target = iframeDoc.getElementById('universalBP_common_layout_main_content');
                            if (target) {
                                this.cleanupIframe(iframeDoc);
                                if (rootEl) rootEl.style.removeProperty('visibility');
                                revealIframe();
                                return;
                            }
                        } catch {
                            if (rootEl) rootEl.style.removeProperty('visibility');
                            revealIframe();
                            return;
                        }

                        if (retries >= maxRetries) {
                            if (rootEl) rootEl.style.removeProperty('visibility');
                            revealIframe();
                            return;
                        }

                        setTimeout(() => tryCleanup(retries + 1), retryInterval);
                    };

                    tryCleanup();
                } catch (e) {
                    // è·¨åŸŸæ— æ³•æ¸…ç†ï¼Œä¸å½±å“æ ¸å¿ƒåŠŸèƒ½
                    revealIframe();
                }
            };
            this.iframe.onerror = () => {
                const loading = div.querySelector('#am-magic-loading');
                if (loading) loading.style.display = 'none';
                this.iframe.style.opacity = '1';
                Logger.warn('âš ï¸ ä¸‡èƒ½æŸ¥æ•°åˆ·æ–°å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç™»å½•çŠ¶æ€æˆ–ç½‘ç»œåé‡è¯•');
            };

            // å…³é—­æŒ‰é’®
            div.querySelector('#am-magic-close').onclick = () => this.toggle(false);

            // åˆ·æ–°æŒ‰é’®
            div.querySelector('#am-magic-refresh').onclick = () => {
                const loading = div.querySelector('#am-magic-loading');
                if (loading) loading.style.display = 'flex';
                this.iframe.style.opacity = '0';
                this.iframe.src = this.buildIframeUrl(true);
            };

            // å¤´éƒ¨å¿«æ·è¯æœ¯
            const quickPrompts = div.querySelector('#am-magic-quick-prompts');
            if (quickPrompts) {
                quickPrompts.addEventListener('click', (e) => {
                    const target = e.target;
                    if (!(target instanceof Element)) return;
                    const btn = target.closest('.am-quick-prompt');
                    if (!btn) return;
                    e.stopPropagation();

                    const promptItem = this.QUICK_PROMPTS[Number(btn.dataset.index)];
                    if (!promptItem) return;

                    this.refreshQuickPromptLabels();

                    quickPrompts.querySelectorAll('.am-quick-prompt').forEach(node => node.classList.remove('active'));
                    btn.classList.add('active');
                    setTimeout(() => btn.classList.remove('active'), 1200);

                    const promptText = this.resolvePromptText(promptItem);
                    if (!promptText) return;

                    if (promptItem.autoSubmit) {
                        this.runQuickPrompt(promptText);
                    } else {
                        // åªå¡«å……ä¸æäº¤
                        const iframeDoc = this.getIframeDoc();
                        if (iframeDoc) {
                            const inputEl = this.findPromptInput(iframeDoc);
                            if (inputEl) {
                                this.setPromptInputValue(inputEl, promptText);
                                inputEl.focus();
                                if (promptItem.requireCampaignId) {
                                    const id = this.extractCampaignId(promptText);
                                    if (id) Logger.log(`ğŸ†” å½“å‰è®¡åˆ’ID: ${id} `);
                                }
                                if (promptItem.requireCampaignName) {
                                    const name = this.extractCampaignName(promptText);
                                    if (name) Logger.log(`ğŸ“› å½“å‰è®¡åˆ’å: ${name} `);
                                }
                            }
                        }
                    }
                });
            }

            // æ‹–æ‹½é€»è¾‘
            let isDragging = false;
            let startX, startY, initialLeft, initialTop;

            this.header.onmousedown = (e) => {
                const target = e.target;
                if (!(target instanceof Element)) return;
                if (target.closest('.am-btn-group') || target.closest('.am-quick-prompts')) return;
                isDragging = true;
                startX = e.clientX;
                startY = e.clientY;
                // é¦–æ¬¡æ‹–æ‹½æ—¶ç§»é™¤ transform å®šä½ï¼Œåˆ‡æ¢ä¸º left/top
                if (div.style.transform) {
                    const rect = div.getBoundingClientRect();
                    div.style.left = `${rect.left}px`;
                    div.style.top = `${rect.top}px`;
                    div.style.transform = 'none';
                }
                initialLeft = div.offsetLeft;
                initialTop = div.offsetTop;
                div.style.transition = 'none';
                document.body.style.userSelect = 'none';
            };

            document.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                div.style.left = `${initialLeft + e.clientX - startX}px`;
                div.style.top = `${initialTop + e.clientY - startY}px`;
            });

            document.addEventListener('mouseup', () => {
                if (isDragging) {
                    isDragging = false;
                    div.style.transition = '';
                    document.body.style.userSelect = '';
                }
            });
        },

        toggle(show) {
            if (this.popup) {
                this.popup.style.display = show ? 'flex' : 'none';
            } else if (show) {
                this.createPopup();
                this.popup.style.display = 'flex';
            }

            if (show) {
                this.refreshQuickPromptLabels();
            }

            State.config.magicReportOpen = show;
            State.save();
            UI.updateState();
        }
    };

    const CampaignIdQuickEntry = {
        initialized: false,
        IGNORE_SELECTOR: '#am-helper-panel, #am-magic-report-popup, #alimama-escort-helper-ui, #am-report-capture-panel',
        TEXT_PATTERN: /è®¡åˆ’\s*(?:ID|id)?\s*[ï¼š:]\s*(\d{6,})/g,
        ICON_SVG: `
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" aria-hidden="true" focusable="false">
                <path fill="currentColor" d="M770.99008 637.242027c14.86848 14.199467 31.3344 29.463893 47.26784 45.335893 57.869653 57.603413 115.602773 115.397973 173.267627 173.19936 41.53344 41.601707 43.39712 100.27008 4.601173 139.4688-39.130453 39.601493-98.399573 37.730987-140.663467-4.46464-69.864107-69.864107-139.933013-139.598507-209.46944-209.865387-8.669867-8.731307-14.199467-9.332053-25.197227-3.331413-248.66816 136.997547-548.870827 1.467733-611.068587-275.531093-50.333013-224.13312 99.997013-449.733973 329.40032-494.26432 236.264107-45.800107 464.800427 123.467093 490.134187 362.530133 9.530027 90.002773-8.198827 173.93664-52.736 252.463787-1.467733 2.60096-2.935467 5.133653-4.1984 7.80288C771.857067 631.637333 771.857067 632.838827 770.99008 637.242027zM415.39584 703.904427c161.000107-1.201493 289.532587-129.80224 288.802133-289.068373-0.730453-159.136427-131.66592-287.798613-291.403093-286.53568C254.859947 129.6384 127.720107 260.23936 128.587093 420.174507 129.39264 575.03744 260.85376 705.10592 415.39584 703.904427zM193.1264 415.17056c0.197973-132.068693 113.937067-226.269867 222.405973-221.463893 0.26624 5.065387 0.79872 10.267307 0.79872 15.40096 0.136533 15.264427 0.068267 30.53568 0.068267 45.602133-103.99744 8.997547-156.071253 79.598933-161.000107 160.467627C235.055787 415.17056 214.657707 415.17056 193.1264 415.17056z"></path>
            </svg>
        `,

        init() {
            if (window.top !== window.self) return;
            if (this.initialized) return;
            document.addEventListener('click', (e) => {
                const target = e.target;
                if (!(target instanceof Element)) return;

                const btn = target.closest('.am-campaign-search-btn[data-am-campaign-quick="1"]');
                if (!btn) return;

                e.preventDefault();
                e.stopPropagation();

                const id = this.normalizeCampaignId(btn.getAttribute('data-campaign-id') || btn.dataset.campaignId);
                if (!id) {
                    Logger.log('âš ï¸ è®¡åˆ’IDæ— æ•ˆï¼Œå·²å¿½ç•¥å¿«æ·æŸ¥æ•°', true);
                    return;
                }

                const guessedName = MagicReport.guessCampaignNameById(id, btn);
                if (guessedName) {
                    MagicReport.lastCampaignName = guessedName;
                }

                MagicReport.openWithCampaignId(id, { preferNative: false, promptType: 'click' }).catch((err) => {
                    Logger.log(`âš ï¸ å¿«æ·æŸ¥æ•°å¤±è´¥ï¼š${err?.message || 'æœªçŸ¥é”™è¯¯'} `, true);
                });
            }, true);

            this.initialized = true;
        },

        normalizeCampaignId(rawId) {
            const id = String(rawId || '').trim();
            return /^\d{6,}$/.test(id) ? id : '';
        },

        isInIgnoredArea(el) {
            if (!(el instanceof Element)) return true;
            return !!el.closest(this.IGNORE_SELECTOR);
        },

            createButton(campaignId) {
                const id = this.normalizeCampaignId(campaignId);
                if (!id) return null;

            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'am-campaign-search-btn';
            btn.setAttribute('data-am-campaign-quick', '1');
                btn.setAttribute('data-campaign-id', id);
                btn.dataset.campaignId = id;
                btn.title = `æŸ¥æ•°è®¡åˆ’IDï¼š${id}`;
                btn.setAttribute('aria-label', `æŸ¥æ•°è®¡åˆ’IDï¼š${id}`);
                btn.innerHTML = this.ICON_SVG.trim();
                btn.addEventListener('click', (e) => {
                    e.preventDefault();
                    e.stopPropagation();
                    const guessedName = MagicReport.guessCampaignNameById(id, btn);
                    if (guessedName) {
                        MagicReport.lastCampaignName = guessedName;
                    }
                    MagicReport.openWithCampaignId(id, { preferNative: false, promptType: 'click' }).catch((err) => {
                        Logger.log(`âš ï¸ å¿«æ·æŸ¥æ•°å¤±è´¥ï¼š${err?.message || 'æœªçŸ¥é”™è¯¯'} `, true);
                    });
                });
                return btn;
            },

        run() {
            if (window.top !== window.self) return;
            if (!document.body) return;
            this.enhanceTextNodes();
            this.enhanceLinkNodes();
        },

        enhanceTextNodes() {
            const walker = document.createTreeWalker(
                document.body,
                NodeFilter.SHOW_TEXT,
                {
                    acceptNode: (node) => {
                        const parent = node.parentElement;
                        if (!parent) return NodeFilter.FILTER_REJECT;
                        if (this.isInIgnoredArea(parent)) return NodeFilter.FILTER_REJECT;
                        if (parent.closest('.am-campaign-id-token, .am-campaign-search-btn')) return NodeFilter.FILTER_REJECT;
                        if (parent.closest('a, button, [role="button"], [mx-click]')) return NodeFilter.FILTER_REJECT;
                        const tag = parent.tagName;
                        if (['SCRIPT', 'STYLE', 'NOSCRIPT', 'TEXTAREA', 'INPUT'].includes(tag)) return NodeFilter.FILTER_REJECT;
                        const text = node.nodeValue || '';
                        if (!text || !text.includes('è®¡åˆ’')) return NodeFilter.FILTER_REJECT;
                        if (!/è®¡åˆ’\s*(?:ID|id)?\s*[ï¼š:]\s*\d{6,}/.test(text)) return NodeFilter.FILTER_REJECT;
                        return NodeFilter.FILTER_ACCEPT;
                    }
                }
            );

            const textNodes = [];
            let node = walker.nextNode();
            while (node) {
                textNodes.push(node);
                node = walker.nextNode();
            }

            textNodes.forEach((textNode) => {
                const rawText = textNode.nodeValue || '';
                const regex = new RegExp(this.TEXT_PATTERN.source, 'g');
                let match;
                let cursor = 0;
                let hasMatch = false;
                const frag = document.createDocumentFragment();

                while ((match = regex.exec(rawText))) {
                    const fullText = match[0];
                    const campaignId = this.normalizeCampaignId(match[1]);
                    const start = match.index;

                    if (start > cursor) {
                        frag.appendChild(document.createTextNode(rawText.slice(cursor, start)));
                    }

                    if (campaignId) {
                        const token = document.createElement('span');
                        token.className = 'am-campaign-id-token';
                        token.textContent = fullText;
                        frag.appendChild(token);

                        const btn = this.createButton(campaignId);
                        if (btn) frag.appendChild(btn);
                        hasMatch = true;
                    } else {
                        frag.appendChild(document.createTextNode(fullText));
                    }

                    cursor = start + fullText.length;
                }

                if (!hasMatch) return;
                if (cursor < rawText.length) {
                    frag.appendChild(document.createTextNode(rawText.slice(cursor)));
                }
                textNode.parentNode?.replaceChild(frag, textNode);
            });
        },

        enhanceLinkNodes() {
            const selector = [
                'a[href*="campaignId="]',
                'a[href*="campaign_id="]',
                '[mx-href*="campaignId="]',
                '[mx-href*="campaign_id="]'
            ].join(',');

            document.querySelectorAll(selector).forEach((el) => {
                if (!(el instanceof Element) || this.isInIgnoredArea(el)) return;
                if (el.closest('.am-campaign-id-token')) return;

                const raw = el.getAttribute('href') || el.getAttribute('mx-href') || '';
                const id = this.normalizeCampaignId(MagicReport.extractCampaignId(raw));
                if (!id) return;

                const next = el.nextElementSibling;
                if (next?.matches?.('.am-campaign-search-btn[data-am-campaign-quick="1"]') &&
                    next.getAttribute('data-campaign-id') === id) {
                    return;
                }

                const btn = this.createButton(id);
                if (!btn) return;
                el.insertAdjacentElement('afterend', btn);
            });
        }
    };

    // ==========================================
    // 7. å¯åŠ¨ç¨‹åº
    // ==========================================
    function main() {
        UI.init();
        Interceptor.init();
        CampaignIdQuickEntry.init();
        // NOTE: MagicReport é‡‡ç”¨ iframe æ–¹æ¡ˆï¼Œæ— éœ€ initï¼ŒæŒ‰éœ€åˆ›å»º

        Logger.log(`ğŸš€ é˜¿é‡ŒåŠ©æ‰‹ Pro v${CURRENT_VERSION} å·²å¯åŠ¨`);

        let lastUrl = window.location.href;
        let lastUrlResetAt = 0;
        const checkUrlChange = () => {
            if (window.location.href !== lastUrl) {
                lastUrl = window.location.href;
                const now = Date.now();
                if (now - lastUrlResetAt < 300) return;
                lastUrlResetAt = now;
                resetSortState('é¡µé¢åˆ‡æ¢');
            }
        };
        window.addEventListener('hashchange', checkUrlChange);
        window.addEventListener('popstate', checkUrlChange);

        let timer;
        let hasExecuted = false;
        const runCore = () => {
            Core.run();
            CampaignIdQuickEntry.run();
            hasExecuted = true;
        };
        const observer = new MutationObserver((mutations) => {
            if (timer) return;
            timer = setTimeout(() => {
                runCore();
                timer = null;
            }, 1000);
        });

        observer.observe(document.body, { childList: true, subtree: true });

        setTimeout(() => {
            if (hasExecuted || timer) return;
            runCore();
        }, 1000);
    }

    main();

})();
// ==========================================
// 7. ç®—æ³•æŠ¤èˆªæ¨¡å— (Merged from alimama-auto-optimizer.user.js)
// ==========================================

/**
 * v2.4.1 (2026-02-06)
 * - ğŸ› ä¿®å¤ actionInfo å…¼å®¹æ€§å´©æºƒ
 * - âœ¨ æ”¯æŒè¯·æ±‚å–æ¶ˆä¸é‡å¤è¿è¡Œä¿æŠ¤
 * - âœ¨ SSE æµå¼è§£ææ›´ç¨³å¥
 * - âœ¨ UI è¾“å‡ºç»Ÿä¸€è½¬ä¹‰ï¼Œé˜² XSS
 * - âœ¨ å»é™¤å†…è”äº‹ä»¶ï¼Œæå‡ CSP å…¼å®¹
 * - ğŸ”§ æœ¬åœ°æ—¥æœŸæäº¤ï¼Œé¿å… UTC è·¨æ—¥åç§»
 * - ğŸ”§ æ”¾å®½ campaignId è¯†åˆ«èŒƒå›´
 *
 * v2.4 (2026-02-06)
 * - âœ¨ å¹¶å‘æ‰§è¡Œï¼šæ”¯æŒåŒæ—¶å¤„ç†å¤šä¸ªè®¡åˆ’ï¼Œå¹¶å‘æ•°å¯é…ç½®
 * - âœ¨ æ—¥å¿—åˆ†ç»„ï¼šæ¯ä¸ªè®¡åˆ’ç‹¬ç«‹å¡ç‰‡æ˜¾ç¤ºï¼Œæ”¯æŒæŠ˜å 
 * - âœ¨ çŠ¶æ€å¾½ç« ï¼šå®æ—¶æ˜¾ç¤ºå¤„ç†çŠ¶æ€ï¼ˆè¯Šæ–­ä¸­/æˆåŠŸ/å¤±è´¥ï¼‰
 *
 * v2.3 (2026-02-05)
 * - âœ¨ UI æ”¹è¿›ï¼šé»˜è®¤æœ€å°åŒ–ï¼Œç‚¹å‡»å±•å¼€ï¼›ç»“æœå¼¹çª—å…¨å±æ¨¡æ€
 * - ğŸ”§ è¯·æ±‚æ¨¡å—é‡å†™ï¼šä½¿ç”¨åŸç”Ÿ fetch APIï¼Œè§£å†³è·¨åŸŸæ‹¦æˆªé—®é¢˜
 *
 * v1.8 (2026-02-03)
 * - ğŸ”§ å¢å¼º API æ—¥å¿—ï¼šè¯·æ±‚ID/çŠ¶æ€ç /å“åº”é•¿åº¦/è€—æ—¶
 * - ğŸ› ä¼˜åŒ–è¶…æ—¶å¤„ç†ã€DOM æ‰«æã€é”™è¯¯é‡è¯•
 *
 * v1.6 (2026-01-31)
 * - âœ¨ API è¯·æ±‚è¶…æ—¶å¤„ç†ï¼ˆé»˜è®¤ 30 ç§’ï¼‰
 * - âœ¨ è¯·æ±‚å¤±è´¥è‡ªåŠ¨é‡è¯•ï¼ˆæœ€å¤š 3 æ¬¡ï¼‰
 */

(function () {
    'use strict';

    // å±€éƒ¨ç‰ˆæœ¬ç®¡ç† (ç¡®ä¿è¯¥æ¨¡å—ä¹Ÿèƒ½è¯»å–åˆ°æ­£ç¡®ç‰ˆæœ¬å·)
    const CURRENT_VERSION = typeof globalThis !== 'undefined' && typeof globalThis.__AM_GET_SCRIPT_VERSION__ === 'function'
        ? globalThis.__AM_GET_SCRIPT_VERSION__()
        : resolveScriptVersion();

    // ==================== é…ç½®æ¨¡å— ====================
    const CONFIG = {
        UI_ID: 'alimama-escort-helper-ui',
        VERSION: CURRENT_VERSION,
        DEFAULT: {
            bizCode: 'universalBP',
            customPrompt: 'å¸®æˆ‘è¿›è¡Œæ·±åº¦è¯Šæ–­',
            concurrency: 3
        }
    };

    let userConfig = { ...CONFIG.DEFAULT, ...GM_getValue('config', {}) };

    // ==================== æ—¥å¿—æ¨¡å— ====================
    const Logger = {
        prefix: '[EscortAPI]',
        debug: (msg, ...args) => console.log(`${Logger.prefix} ğŸ” ${msg}`, ...args),
        info: (msg, ...args) => console.log(`${Logger.prefix} ${msg}`, ...args),
        warn: (msg, ...args) => console.warn(`${Logger.prefix} ${msg}`, ...args),
        error: (msg, ...args) => console.error(`${Logger.prefix} ${msg}`, ...args),
    };

    // ==================== çŠ¶æ€ç®¡ç† ====================
    const State = {
        tokens: { dynamicToken: '', loginPointId: '', csrfID: '' },
        currentRunId: 0,
        runAbortController: null
    };

    // ==================== å·¥å…·å‡½æ•°æ¨¡å— ====================
    const Utils = {
        delay: (ms) => new Promise(r => setTimeout(r, ms)),
        escapeHtml: (value) => {
            const str = value === null || value === undefined ? '' : String(value);
            return str.replace(/[&<>"']/g, ch => {
                const map = { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' };
                return map[ch] || ch;
            });
        },
        toLocalYMD: (date = new Date()) => {
            const pad = (n) => String(n).padStart(2, '0');
            return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())}`;
        },

        // å¹¶å‘é™åˆ¶æ‰§è¡Œå™¨
        concurrentLimit: async (tasks, limit = 3) => {
            const results = [];
            const executing = new Set();

            for (const task of tasks) {
                const p = Promise.resolve().then(() => task());
                results.push(p);
                executing.add(p);

                const clean = () => executing.delete(p);
                p.then(clean, clean);

                if (executing.size >= limit) {
                    await Promise.race(executing);
                }
            }

            return Promise.allSettled(results);
        },

        // ç”Ÿæˆ UUID
        uuid: () => 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
            const r = Math.random() * 16 | 0;
            return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
        }),

        // è‡ªåŠ¨è·å– campaignGroupId
        getCampaignGroupId: () => {
            // ä» URL/hash è·å–
            const urlMatch = window.location.href.match(/campaignGroupId=(\d+)/i);
            if (urlMatch) return urlMatch[1];

            const hashMatch = window.location.hash.match(/campaignGroupId[=:](\d+)/i);
            if (hashMatch) return hashMatch[1];

            // ä»å…¨å±€å˜é‡è·å–
            for (const src of [window.g_config, window.PageConfig, window.__magix_data__]) {
                if (src?.campaignGroupId) return src.campaignGroupId;
                if (src?.data?.campaignGroupId) return src.data.campaignGroupId;
            }

            // ä»é¡µé¢å…ƒç´ è·å–
            const input = document.querySelector('input[name="campaignGroupId"]');
            if (input?.value) return input.value;

            return '';
        },

        // ä» actionInfo æå–è¯¦æƒ…
        extractDetail: (item) => {
            if (item.redirectUrl) return 'è·³è½¬é“¾æ¥';
            if (!item.actionInfo) return '-';

            try {
                const info = typeof item.actionInfo === 'string'
                    ? JSON.parse(item.actionInfo) : item.actionInfo;

                // æå– rawPrompt ä¸­"çš„"åé¢çš„å†…å®¹
                if (info.rawPrompt) {
                    const match = info.rawPrompt.match(/è®¡åˆ’[ï¼š:]\d+çš„(.+)/);
                    if (match?.[1]) return match[1].trim();

                    const simpleMatch = info.rawPrompt.match(/çš„([^çš„]+)$/);
                    if (simpleMatch?.[1]) return simpleMatch[1].trim();
                }

                // layerTextï¼ˆç®—æ³•æŠ¤èˆªæç¤ºï¼‰
                if (info.layerText) {
                    return info.layerText.substring(0, 25).replace(/[ã€ã€‘]/g, '') +
                        (info.layerText.length > 25 ? '...' : '');
                }

                if (info.target) return info.target;
                return '-';
            } catch {
                return '-';
            }
        },

        // è·å–æ–¹æ¡ˆåç§°
        getActionName: (action) => {
            if (action.actionName) return action.actionName;

            if (action.adjustInfo) {
                try {
                    const info = typeof action.adjustInfo === 'string'
                        ? JSON.parse(action.adjustInfo) : action.adjustInfo;
                    const typeMap = {
                        'putRoiTarget': 'æŠ•äº§æ¯”ç›®æ ‡è°ƒæ•´',
                        'dayBudget': 'æ—¥é¢„ç®—è°ƒæ•´',
                        'timeBudget': 'åˆ†æ—¶é¢„ç®—è°ƒæ•´',
                        'price': 'å‡ºä»·è°ƒæ•´',
                        'crowd': 'äººç¾¤å®šå‘è°ƒæ•´'
                    };
                    if (info.adjustType) return typeMap[info.adjustType] || info.adjustType;
                } catch { }
            }

            return action.actionTitle || action.title || action.actionText || 'æœªçŸ¥æ–¹æ¡ˆ';
        },

        // åˆ¤æ–­æ˜¯å¦ä¸ºæœ‰æ•ˆæ–¹æ¡ˆï¼ˆéæœªçŸ¥ï¼‰
        isValidAction: (name) => name && name !== 'æœªçŸ¥æ–¹æ¡ˆ' && name !== 'æœªçŸ¥'
    };

    // ==================== Token ç®¡ç†æ¨¡å— ====================
    const TokenManager = {
        hookReady: false,
        isStrongCsrf: (value) => {
            const v = value === null || value === undefined ? '' : String(value).trim();
            if (!v) return false;
            // one å¹³å°æœ‰æ•ˆ csrfId é€šå¸¸åŒ…å«ä¸‹åˆ’çº¿å¹¶ä¸”é•¿åº¦è¾ƒé•¿ï¼Œä¾‹å¦‚: xxxxx_1_1_1
            if (v.includes('_') && v.length >= 12) return true;
            // å…¼å®¹éƒ¨åˆ†åœºæ™¯ï¼šé•¿åº¦è¾ƒé•¿çš„éçº¯æ•°å­— token ä¹Ÿè§†ä¸ºæœ‰æ•ˆ
            if (!/^\d+$/.test(v) && v.length >= 16) return true;
            return false;
        },
        applyCsrf: (value) => {
            const next = value === null || value === undefined ? '' : String(value).trim();
            if (!next) return;
            const prev = State.tokens.csrfID === null || State.tokens.csrfID === undefined
                ? '' : String(State.tokens.csrfID).trim();
            if (!prev || TokenManager.isStrongCsrf(next) || !TokenManager.isStrongCsrf(prev)) {
                State.tokens.csrfID = next;
            }
        },

        // Hook XHR æ•è· Token
        hookXHR: () => {
            if (TokenManager.hookReady) return;
            const hooks = window.__AM_HOOK_MANAGER__;
            if (!hooks) {
                Logger.warn('ç»Ÿä¸€ Hook ç®¡ç†å™¨ä¸å¯ç”¨ï¼Œå·²è·³è¿‡ Token Hook æ³¨å…¥');
                return;
            }

            const syncFromUrl = (rawUrl) => {
                try {
                    if (!rawUrl
                        || (!rawUrl.includes('dynamicToken')
                            && !rawUrl.includes('loginPointId')
                            && !rawUrl.includes('csrfId')
                            && !rawUrl.includes('csrfID'))) return;
                    const urlObj = new URL(rawUrl, window.location.origin);
                    State.tokens.dynamicToken = urlObj.searchParams.get('dynamicToken') || State.tokens.dynamicToken;
                    State.tokens.loginPointId = urlObj.searchParams.get('loginPointId') || State.tokens.loginPointId;
                    TokenManager.applyCsrf(urlObj.searchParams.get('csrfId') || urlObj.searchParams.get('csrfID'));
                } catch { }
            };

            const syncFromBody = (body) => {
                if (!body || typeof body !== 'string') return;
                try {
                    const json = JSON.parse(body);
                    State.tokens.dynamicToken = json.dynamicToken || State.tokens.dynamicToken;
                    State.tokens.loginPointId = json.loginPointId || State.tokens.loginPointId;
                    TokenManager.applyCsrf(json.csrfId || json.csrfID);
                } catch {
                    const params = new URLSearchParams(body);
                    State.tokens.dynamicToken = params.get('dynamicToken') || State.tokens.dynamicToken;
                    State.tokens.loginPointId = params.get('loginPointId') || State.tokens.loginPointId;
                    TokenManager.applyCsrf(params.get('csrfId') || params.get('csrfID'));
                }
            };

            hooks.registerXHROpen(({ xhr, url }) => {
                xhr._url = url;
                syncFromUrl(url);
            });

            hooks.registerXHRSend(({ data, url }) => {
                syncFromUrl(url);
                syncFromBody(data);
            });

            TokenManager.hookReady = true;
            Logger.info('XHR Hook å·²æ¥å…¥ç»Ÿä¸€ç®¡ç†å™¨');
        },

        // æ·±åº¦æœç´¢å…¨å±€å˜é‡
        deepSearch: () => {
            if (State.tokens.dynamicToken && State.tokens.loginPointId && TokenManager.isStrongCsrf(State.tokens.csrfID)) return;

            const findInObj = (obj, depth = 0) => {
                if (!obj || depth > 3) return;
                try {
                    for (const key in obj) {
                        if (key === 'dynamicToken') State.tokens.dynamicToken = obj[key];
                        if (key === 'loginPointId') State.tokens.loginPointId = obj[key];
                        if (key === 'csrfId' || key === 'csrfID') TokenManager.applyCsrf(obj[key]);
                        if (key === 'user' && obj[key]?.accessInfo) {
                            State.tokens.dynamicToken = obj[key].accessInfo.dynamicToken || State.tokens.dynamicToken;
                            State.tokens.loginPointId = obj[key].accessInfo.loginPointId || State.tokens.loginPointId;
                            TokenManager.applyCsrf(obj[key].accessInfo.csrfId || obj[key].accessInfo.csrfID);
                        }
                        if (typeof obj[key] === 'object') findInObj(obj[key], depth + 1);
                    }
                } catch { }
            };

            [window.g_config, window.PageConfig, window.mm, window.FEED_CONFIG, window.__magix_data__]
                .forEach(c => findInObj(c));
        },

        // åˆ·æ–° Token
        refresh: () => {
            TokenManager.deepSearch();

            // ä» URL å‚æ•°è¡¥å…… CSRFï¼ˆå¦‚æœå­˜åœ¨ï¼‰
            try {
                const href = window.location.href || '';
                const urlObj = new URL(href, window.location.origin);
                TokenManager.applyCsrf(urlObj.searchParams.get('csrfId') || urlObj.searchParams.get('csrfID'));
                if (window.location.hash && window.location.hash.includes('?')) {
                    const hashQuery = window.location.hash.split('?')[1] || '';
                    const hashParams = new URLSearchParams(hashQuery);
                    TokenManager.applyCsrf(hashParams.get('csrfId') || hashParams.get('csrfID'));
                }
            } catch { }

            // ä» cookie è·å– CSRF
            const csrfMatch = document.cookie.match(/_tb_token_=([^;]+)/);
            if (csrfMatch) {
                // ä»…å½“å½“å‰æœªæ‹¿åˆ°æœ‰æ•ˆ csrfId æ—¶ï¼Œæ‰ç”¨ _tb_token_ å…œåº•ï¼Œé¿å…è¦†ç›–çœŸå® csrfId
                if (!TokenManager.isStrongCsrf(State.tokens.csrfID)) {
                    State.tokens.csrfID = csrfMatch[1];
                }
            }

            // ä» Magix Vframe è·å–
            if (window.Magix?.Vframe) {
                try {
                    const vframes = window.Magix.Vframe.all();
                    for (const id in vframes) {
                        const info = vframes[id]?.view?.user?.accessInfo ||
                            vframes[id]?.$v?.$d?.$d?.user?.accessInfo;
                        if (info) {
                            State.tokens.dynamicToken = info.dynamicToken || State.tokens.dynamicToken;
                            State.tokens.loginPointId = info.loginPointId || State.tokens.loginPointId;
                            TokenManager.applyCsrf(info.csrfId || info.csrfID);
                        }
                    }
                } catch { }
            }
        }
    };

    const recordApiRequestToHookHistory = (url, method = 'POST', data = null, source = 'api_fetch_manual') => {
        const requestUrl = String(url || '').trim();
        if (!requestUrl) return;
        const requestMethod = String(method || 'POST').trim().toUpperCase() || 'POST';
        let body = data;
        if (data !== undefined && data !== null && typeof data !== 'string') {
            try {
                body = JSON.stringify(data);
            } catch {
                body = data;
            }
        }
        const candidates = [];
        const addCandidate = (manager) => {
            if (!manager || typeof manager.recordRequest !== 'function') return;
            if (candidates.includes(manager)) return;
            candidates.push(manager);
        };
        try {
            addCandidate(window.__AM_HOOK_MANAGER__);
        } catch { }
        try {
            if (typeof unsafeWindow !== 'undefined' && unsafeWindow) {
                addCandidate(unsafeWindow.__AM_HOOK_MANAGER__);
            }
        } catch { }
        if (!candidates.length && typeof createHookManager === 'function') {
            try {
                addCandidate(createHookManager());
            } catch { }
        }
        candidates.forEach(manager => {
            try {
                manager.recordRequest({
                    method: requestMethod,
                    url: requestUrl,
                    body,
                    source
                });
            } catch { }
        });
    };

    // ==================== API è¯·æ±‚æ¨¡å— ====================
    const API = {
        /**
         * å•æ¬¡è¯·æ±‚ï¼ˆä½¿ç”¨åŸç”Ÿ fetch APIï¼‰
         * NOTE: ç”±äº GM_xmlhttpRequest åœ¨æŸäº›æ²¹çŒ´ç®¡ç†å™¨ä¸­å­˜åœ¨è·¨åŸŸé—®é¢˜ï¼Œ
         * è¿™é‡Œæ”¹ç”¨é¡µé¢åŸç”Ÿçš„ fetch APIã€‚é˜¿é‡Œå¦ˆå¦ˆç½‘ç«™æœ¬èº«åº”è¯¥å·²é…ç½® CORS å…è®¸å­åŸŸè¯·æ±‚ã€‚
         */
        _singleRequest: async (url, data, timeout = 30000, signal) => {
            const startTime = Date.now();
            const reqId = Math.random().toString(36).substring(2, 8);

            Logger.debug(`[${reqId}] å‘èµ·è¯·æ±‚:`, { url, timeout: `${timeout}ms` });
            Logger.debug(`[${reqId}] è¯·æ±‚æ•°æ®:`, data);

            // åˆ›å»º AbortController ç”¨äºè¶…æ—¶æ§åˆ¶
            const controller = new AbortController();
            let timedOut = false;
            const timeoutId = setTimeout(() => {
                timedOut = true;
                controller.abort();
            }, timeout);
            if (signal) {
                if (signal.aborted) controller.abort();
                else signal.addEventListener('abort', () => controller.abort(), { once: true });
            }

            try {
                Logger.debug(`[${reqId}] ä½¿ç”¨åŸç”Ÿ fetch å‘é€è¯·æ±‚...`);
                recordApiRequestToHookHistory(url, 'POST', data, 'api_fetch_preflight');

                const response = await fetch(url, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Accept': 'application/json, text/event-stream, */*'
                    },
                    body: JSON.stringify(data),
                    credentials: 'include',  // è‡ªåŠ¨æºå¸¦ Cookie
                    signal: controller.signal
                });

                clearTimeout(timeoutId);
                const elapsed = Date.now() - startTime;

                Logger.debug(`[${reqId}] å“åº”çŠ¶æ€:`, {
                    status: response.status,
                    statusText: response.statusText,
                    elapsed: `${elapsed}ms`
                });

                if (!response.ok) {
                    const errorText = await response.text().catch(() => '');
                    throw new Error(`HTTP ${response.status}: ${response.statusText}${errorText ? ` - ${errorText.substring(0, 200)}` : ''}`);
                }

                const contentType = (response.headers.get('content-type') || '').toLowerCase();
                if (contentType.includes('text/event-stream') && response.body?.getReader) {
                    const reader = response.body.getReader();
                    const decoder = new TextDecoder();
                    let buffer = '';
                    const chunks = [];

                    while (true) {
                        const { value, done } = await reader.read();
                        if (done) break;
                        buffer += decoder.decode(value, { stream: true });

                        const lines = buffer.split(/\r?\n/);
                        buffer = lines.pop() || '';
                        lines.forEach(line => {
                            const trimmed = line.trim();
                            if (!trimmed.startsWith('data:')) return;
                            const payload = trimmed.substring(5).trim();
                            if (!payload) return;
                            try { chunks.push(JSON.parse(payload)); } catch { }
                        });
                    }

                    if (buffer.trim().startsWith('data:')) {
                        const payload = buffer.trim().substring(5).trim();
                        if (payload) {
                            try { chunks.push(JSON.parse(payload)); } catch { }
                        }
                    }

                    if (chunks.length) {
                        Logger.debug(`[${reqId}] SSE æµè§£æ: ${chunks.length} æ¡æ•°æ® (${Date.now() - startTime}ms)`);
                        return { isStream: true, chunks };
                    }
                    throw new Error('SSE å“åº”ä¸ºç©º');
                }

                const responseText = await response.text();
                Logger.debug(`[${reqId}] å“åº”å†…å®¹ (${responseText.length}å­—ç¬¦):`, responseText.substring(0, 500));

                // å°è¯•è§£æ JSON
                try {
                    const result = JSON.parse(responseText);
                    Logger.debug(`[${reqId}] è¯·æ±‚æˆåŠŸ (${elapsed}ms)`);
                    return result;
                } catch {
                    // å°è¯•è§£æ SSE æµæ ¼å¼
                    if (responseText.includes('data:')) {
                        const chunks = responseText.split('\n')
                            .filter(line => line.trim().startsWith('data:'))
                            .map(line => {
                                try { return JSON.parse(line.substring(5).trim()); }
                                catch { return null; }
                            })
                            .filter(Boolean);

                        if (chunks.length) {
                            Logger.debug(`[${reqId}] SSE æµè§£æ: ${chunks.length} æ¡æ•°æ® (${elapsed}ms)`);
                            return { isStream: true, chunks };
                        }
                    }
                    throw new Error(`è§£æå“åº”å¤±è´¥: ${responseText.substring(0, 100)}`);
                }

            } catch (err) {
                clearTimeout(timeoutId);
                const elapsed = Date.now() - startTime;

                if (err.name === 'AbortError') {
                    if (timedOut) {
                        Logger.error(`[${reqId}] è¯·æ±‚è¶…æ—¶ (${elapsed}ms, é…ç½®${timeout}ms)`);
                        throw new Error(`è¯·æ±‚è¶…æ—¶ (>${timeout}ms)`);
                    }
                    const abortErr = new Error('è¯·æ±‚å·²å–æ¶ˆ');
                    abortErr.name = 'AbortError';
                    throw abortErr;
                }

                Logger.error(`[${reqId}] è¯·æ±‚å¤±è´¥ (${elapsed}ms):`, {
                    error: err.message,
                    name: err.name,
                    stack: err.stack?.split('\n').slice(0, 3).join('\n')
                });
                throw err;
            }
        },

        // å¸¦é‡è¯•çš„è¯·æ±‚
        request: async (url, data, options = {}) => {
            const { maxRetries = 3, timeout = 30000, retryDelay = 2000, signal } = options;
            let lastError = null;

            Logger.info(`ğŸ“¡ APIè¯·æ±‚: ${url.split('/').pop()}`, { maxRetries, timeout });

            for (let attempt = 1; attempt <= maxRetries; attempt++) {
                try {
                    const result = await API._singleRequest(url, data, timeout, signal);
                    Logger.info(`âœ“ è¯·æ±‚æˆåŠŸ (ç¬¬${attempt}æ¬¡)`);
                    return result;
                } catch (err) {
                    lastError = err;
                    if (err.name === 'AbortError') throw err;
                    Logger.warn(`âœ— è¯·æ±‚å¤±è´¥ (ç¬¬${attempt}/${maxRetries}æ¬¡): ${err.message}`);

                    if (attempt < maxRetries) {
                        Logger.info(`â³ ${retryDelay / 1000}ç§’åé‡è¯•...`);
                        await Utils.delay(retryDelay);
                    }
                }
            }

            Logger.error(`âŒ è¯·æ±‚æœ€ç»ˆå¤±è´¥: ${lastError.message}`, { url, attempts: maxRetries });
            throw lastError;
        }
    };

    // ==================== æ— ç•Œå…³é”®è¯å»ºè®¡åˆ’ API ====================
    const KeywordPlanApi = (() => {
        const TAG = '[KeywordPlanAPI]';
        const BUILD_VERSION = '2026-02-18 04:00';
        const SESSION_DRAFT_KEY = 'am.wxt.keyword_plan_wizard.draft';
        const SESSION_DRAFT_SCHEMA_VERSION = 2;
        const WIZARD_MAX_ITEMS = 30;
        const DEFAULTS = {
            bizCode: 'onebpSearch',
            promotionScene: 'promotion_scene_search_user_define',
            itemSelectedMode: 'user_define',
            subPromotionType: 'item',
            promotionType: 'item',
            bidTypeV2: 'smart_bid',
            bidTargetV2: 'conv',
            dmcType: 'day_average',
            keywordMode: 'mixed',
            useWordPackage: true,
            recommendCount: 20,
            matchScope: 4,
            keywordOnlineStatus: 1,
            chunkSize: 10,
            batchRetry: 1,
            recommendCrowdLabelIds: ['3000949', '3000950', '3000951', '3000952', '3000953', '3000980', '3000995']
        };
        const SCENE_SYNC_DEFAULT_ITEM_ID = '682357641421';
        const REPAIR_DEFAULTS = {
            coverageMode: 'scene_goal_option_full',
            conflictPolicy: 'auto_stop_retry',
            stopScope: 'same_item_only',
            postCleanup: 'delete',
            fallbackPolicy: 'auto',
            itemId: SCENE_SYNC_DEFAULT_ITEM_ID
        };
        const WIZARD_FORCE_API_ONLY_SCENE_CONFIG = true;
        const API_ONLY_CREATE_OPTIONS = Object.freeze({
            syncSceneRuntime: false,
            applySceneSpec: false,
            strictSceneRuntimeMatch: false,
            conflictPolicy: 'auto_stop_retry',
            stopScope: 'same_item_only'
        });
        const SCENE_DEFAULT_PROMOTION_SCENE = {
            'è´§å“å…¨ç«™æ¨å¹¿': 'promotion_scene_site',
            'å…³é”®è¯æ¨å¹¿': 'promotion_scene_search_user_define',
            'äººç¾¤æ¨å¹¿': 'promotion_scene_display_laxin',
            'å†…å®¹è¥é”€': 'scene_live_room',
            'çº¿ç´¢æ¨å¹¿': 'leads_collection'
        };
        const SCENE_FALLBACK_BID_TARGET = {};
        const SCENE_BIDTYPE_V2_ONLY = new Set(['å…³é”®è¯æ¨å¹¿', 'äººç¾¤æ¨å¹¿']);
        const SCENE_BIDTYPE_V2_DEFAULT = {
            'å…³é”®è¯æ¨å¹¿': 'smart_bid',
            'äººç¾¤æ¨å¹¿': 'custom_bid'
        };
        const ENDPOINTS = {
            solutionAddList: '/solution/addList.json',
            solutionBusinessAddList: '/solution/business/addList.json',
            componentFindList: '/component/' + 'findList.json',
            materialFindPage: '/material/item/findPage.json',
            bidwordSuggestDefault: '/bidword/suggest/default/list.json',
            bidwordSuggestKr: '/bidword/suggest/kr/list.json',
            wordPackageSuggestDefault: '/wordpackage/suggest/default/list.json',
            bidwordAdd: '/bidword/add.json',
            labelFindList: '/label/findList.json'
        };
        const runtimeCache = {
            value: null,
            ts: 0,
            magix: null,
            magixPending: null
        };
        const componentConfigCache = {
            data: null,
            key: '',
            ts: 0
        };
        const COMPONENT_CONFIG_CACHE_TTL_MS = 10 * 60 * 1000;
        const wizardState = {
            mounted: false,
            visible: false,
            draft: null,
            sceneProfiles: {},
            candidateSource: 'all',
            candidates: [],
            addedItems: [],
            crowdList: [],
            debugVisible: false,
            itemSplitExpanded: false,
            candidateListExpanded: false,
            strategyList: [],
            editingStrategyId: '',
            detailVisible: false,
            sceneSyncTimer: 0,
            sceneSyncInFlight: false,
            sceneSyncPendingToken: '',
            repairRunToken: 0,
            repairRunning: false,
            repairStopRequested: false,
            repairLastSummary: null,
            manualKeywordDelegatedBound: false,
            manualKeywordPanelCollapsed: true,
            keywordMetricMap: {},
            els: {}
        };

        const log = {
            info: (...args) => console.log(TAG, ...args),
            warn: (...args) => console.warn(TAG, ...args),
            error: (...args) => console.error(TAG, ...args)
        };

        const isPlainObject = (value) => Object.prototype.toString.call(value) === '[object Object]';
        const deepClone = (value) => value === undefined ? value : JSON.parse(JSON.stringify(value));
        const toNumber = (value, fallback = 0) => {
            const num = Number(value);
            return Number.isFinite(num) ? num : fallback;
        };
        const toIdValue = (value) => {
            const n = Number(value);
            if (Number.isFinite(n) && n > 0) return n;
            const s = value === null || value === undefined ? '' : String(value).trim();
            return s;
        };
        const uniqueBy = (list, getKey) => {
            const map = new Map();
            (list || []).forEach(item => {
                const key = getKey(item);
                if (!key && key !== 0) return;
                if (!map.has(key)) map.set(key, item);
            });
            return Array.from(map.values());
        };
        const hasOwn = (obj, key) => Object.prototype.hasOwnProperty.call(obj || {}, key);
        const chunk = (list, size) => {
            const out = [];
            if (!Array.isArray(list) || !list.length) return out;
            const chunkSize = Math.max(1, toNumber(size, DEFAULTS.chunkSize));
            for (let i = 0; i < list.length; i += chunkSize) {
                out.push(list.slice(i, i + chunkSize));
            }
            return out;
        };
        const sleep = (ms) => new Promise(resolve => setTimeout(resolve, ms));
        const todayStamp = () => {
            const d = new Date();
            const pad = (n) => String(n).padStart(2, '0');
            return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}`;
        };
        const nowStampSeconds = () => {
            const d = new Date();
            const pad = (n) => String(n).padStart(2, '0');
            return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
        };
        const nowDateTimeStamp = () => {
            const d = new Date();
            const pad = (n) => String(n).padStart(2, '0');
            const datePart = `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}`;
            const timePart = `${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
            return `${datePart}_${timePart}`;
        };
        const buildSceneTimePrefix = (sceneName = '') => {
            const scene = String(sceneName || '').trim() || 'å…³é”®è¯æ¨å¹¿';
            return `${scene}_${nowDateTimeStamp()}`;
        };
        const BUDGET_FIELDS = ['dayBudget', 'dayAverageBudget', 'totalBudget', 'futureBudget'];
        const DMC_BUDGET_FIELD_MAP = {
            normal: 'dayBudget',
            total: 'totalBudget',
            day_freeze: 'futureBudget',
            day_average: 'dayAverageBudget'
        };
        const BUDGET_FIELD_DMC_MAP = {
            dayBudget: 'normal',
            totalBudget: 'total',
            futureBudget: 'day_freeze',
            dayAverageBudget: 'day_average'
        };

        const sniffCsrfFromPerformance = () => {
            try {
                const entries = performance.getEntriesByType('resource') || [];
                for (let i = entries.length - 1; i >= 0; i--) {
                    const name = entries[i]?.name || '';
                    if (!name || !name.includes('alimama.com')) continue;
                    const match = name.match(/[?&]csrfId=([^&]+)/i) || name.match(/[?&]csrfID=([^&]+)/i);
                    if (!match || !match[1]) continue;
                    return decodeURIComponent(match[1]);
                }
            } catch { }
            return '';
        };
        const sniffAemUidFromPerformance = () => {
            try {
                const entries = performance.getEntriesByType('resource') || [];
                for (let i = entries.length - 1; i >= 0; i--) {
                    const name = entries[i]?.name || '';
                    if (!name || !name.includes('alimama.com')) continue;
                    const match = name.match(/[?&]_aem_uid=([^&]+)/i);
                    if (!match || !match[1]) continue;
                    return decodeURIComponent(match[1]);
                }
            } catch { }
            return '';
        };
        const resolveAemUid = (input = '') => {
            const direct = String(input || '').trim();
            if (direct) return direct;
            try {
                const fromLocation = new URL(window.location.href).searchParams.get('_aem_uid');
                if (fromLocation) return String(fromLocation).trim();
            } catch { }
            try {
                const hash = String(window.location.hash || '');
                const match = hash.match(/[?&]_aem_uid=([^&]+)/i);
                if (match && match[1]) return decodeURIComponent(match[1]);
            } catch { }
            const fromPerf = sniffAemUidFromPerformance();
            if (fromPerf) return fromPerf;
            return '';
        };

        const mergeDeep = (target, ...sources) => {
            const out = isPlainObject(target) ? { ...target } : {};
            sources.forEach(src => {
                if (!isPlainObject(src)) return;
                Object.keys(src).forEach(key => {
                    const srcVal = src[key];
                    const curVal = out[key];
                    if (isPlainObject(srcVal)) {
                        out[key] = mergeDeep(isPlainObject(curVal) ? curVal : {}, srcVal);
                    } else if (Array.isArray(srcVal)) {
                        out[key] = srcVal.slice();
                    } else {
                        out[key] = srcVal;
                    }
                });
            });
            return out;
        };

        const ensureTokens = () => {
            TokenManager.refresh();
            if (!TokenManager.isStrongCsrf(State.tokens.csrfID)) {
                const perfCsrf = sniffCsrfFromPerformance();
                if (perfCsrf) TokenManager.applyCsrf(perfCsrf);
            }
            const { dynamicToken, loginPointId, csrfID } = State.tokens;
            if (!loginPointId || !csrfID) {
                throw new Error('Token æœªå°±ç»ªï¼Œè¯·å…ˆåœ¨é¡µé¢ä»»æ„ä½ç½®ç‚¹å‡»ä¸€æ¬¡åé‡è¯•');
            }
            return { dynamicToken, loginPointId, csrfId: csrfID };
        };

        const buildOneApiUrl = (path, bizCode) => {
            const { csrfId } = ensureTokens();
            const hasQuery = path.includes('?');
            return `https://one.alimama.com${path}${hasQuery ? '&' : '?'}csrfId=${encodeURIComponent(csrfId)}&bizCode=${encodeURIComponent(bizCode)}`;
        };

        const isResponseOk = (res) => {
            if (!res || typeof res !== 'object') return false;
            if (res.success === false || res.ok === false) return false;
            if (res.info && res.info.ok === false) return false;
            if (res.info && res.info.errorCode) return false;
            if (Array.isArray(res.ret) && res.ret.length) {
                const retTokens = res.ret.map(item => String(item || '').trim()).filter(Boolean);
                const hasRetFail = retTokens.some(token => /^FAIL[_:]/i.test(token));
                const hasRetSuccess = retTokens.some(token => /^SUCCESS(?:$|[:_])/i.test(token) || token.includes('è°ƒç”¨æˆåŠŸ'));
                if (hasRetFail && !hasRetSuccess) return false;
            }
            return true;
        };

        const assertResponseOk = (res, action) => {
            if (isResponseOk(res)) return;
            const retMessage = Array.isArray(res?.ret) && res.ret.length
                ? res.ret.map(item => String(item || '').trim()).filter(Boolean).join(' | ')
                : '';
            const punishUrl = String(res?.data?.url || '').trim();
            const isRiskChallenge = punishUrl.includes('/_____tmd_____/punish');
            const fallbackMessage = isRiskChallenge
                ? `${action}å¤±è´¥ï¼šè§¦å‘é£æ§éªŒè¯ï¼Œè¯·åœ¨é¡µé¢å®ŒæˆäººæœºéªŒè¯åé‡è¯•`
                : `${action}å¤±è´¥`;
            const msg = res?.info?.message || res?.message || retMessage || fallbackMessage;
            throw new Error(msg);
        };

        const requestOne = async (path, bizCode, payload = {}, options = {}) => {
            const token = ensureTokens();
            const url = buildOneApiUrl(path, bizCode);
            const body = {
                ...payload,
                csrfId: token.csrfId,
                loginPointId: token.loginPointId
            };
            const res = await API.request(url, body, options);
            assertResponseOk(res, path);
            return res;
        };
        const requestOneGet = async (path, query = {}, options = {}) => {
            const token = ensureTokens();
            const mergedQuery = {
                ...query,
                csrfId: query?.csrfId || token.csrfId,
                bizCode: query?.bizCode || DEFAULTS.bizCode
            };
            const params = new URLSearchParams();
            Object.keys(mergedQuery).forEach(key => {
                const value = mergedQuery[key];
                if (value === undefined || value === null || value === '') return;
                params.set(key, String(value));
            });
            const url = `https://one.alimama.com${path}${path.includes('?') ? '&' : '?'}${params.toString()}`;
            recordApiRequestToHookHistory(url, 'GET', null, 'api_fetch_get');
            const response = await fetch(url, {
                method: 'GET',
                credentials: 'include',
                headers: {
                    Accept: 'application/json, text/plain, */*'
                },
                signal: options?.signal
            });
            if (!response.ok) {
                const text = await response.text().catch(() => '');
                throw new Error(`HTTP ${response.status}: ${response.statusText}${text ? ` - ${text.slice(0, 220)}` : ''}`);
            }
            const json = await response.json().catch(() => ({}));
            assertResponseOk(json, path);
            return json;
        };

        const pickMaterialFields = (material = {}) => ({
            materialId: material.materialId,
            materialName: material.materialName,
            promotionType: material.promotionType,
            subPromotionType: material.subPromotionType,
            fromTab: material.fromTab,
            linkUrl: material.linkUrl,
            goalLifeCycleList: material.goalLifeCycleList,
            shopId: material.shopId,
            shopName: material.shopName,
            bidCount: material.bidCount,
            categoryLevel1: material.categoryLevel1
        });

        const sanitizeCampaign = (campaign = {}) => {
            const out = {};
            Object.keys(campaign || {}).forEach(key => {
                if (key.startsWith('mx_')) return;
                if (key === 'adgroupList') return;
                if (key === 'couponId' && !campaign[key]) return;
                out[key] = campaign[key];
            });
            return out;
        };

        const sanitizeAdgroup = (adgroup = {}) => {
            const out = {};
            Object.keys(adgroup || {}).forEach(key => {
                if (key.startsWith('mx_')) return;
                if (key === 'material') {
                    out.material = pickMaterialFields(adgroup.material || {});
                    return;
                }
                out[key] = adgroup[key];
            });
            return out;
        };

        const purgeCreateTransientFields = (value) => {
            const dropKeys = new Set(['campaignId', 'adgroupId', 'copyCampaignId', 'copyAdgroupId', 'id', 'gmtCreate', 'gmtModified', 'createTime', 'modifyTime']);
            if (Array.isArray(value)) return value.map(v => purgeCreateTransientFields(v));
            if (!isPlainObject(value)) return value;
            const out = {};
            Object.keys(value).forEach(key => {
                if (key.startsWith('mx_')) return;
                if (dropKeys.has(key)) return;
                out[key] = purgeCreateTransientFields(value[key]);
            });
            return out;
        };

        const getMagixInstance = async () => {
            if (window.Magix?.Vframe?.all) return window.Magix;
            if (runtimeCache.magix?.Vframe?.all) return runtimeCache.magix;
            if (!window.seajs || typeof window.seajs.use !== 'function') return null;
            if (runtimeCache.magixPending) return runtimeCache.magixPending;
            runtimeCache.magixPending = new Promise(resolve => {
                try {
                    window.seajs.use(['magix'], (magixRef) => resolve(magixRef || null));
                } catch (err) {
                    log.warn('seajs åŠ è½½ magix å¤±è´¥:', err?.message || err);
                    resolve(null);
                }
            }).then((magixRef) => {
                if (magixRef?.Vframe?.all) runtimeCache.magix = magixRef;
                runtimeCache.magixPending = null;
                return magixRef;
            }).catch(() => {
                runtimeCache.magixPending = null;
                return null;
            });
            return runtimeCache.magixPending;
        };

        const getAllVframes = async () => {
            const magixRef = await getMagixInstance();
            if (!magixRef?.Vframe?.all) return {};
            try {
                return magixRef.Vframe.all() || {};
            } catch (err) {
                log.warn('è¯»å– Vframe åˆ—è¡¨å¤±è´¥:', err?.message || err);
                return {};
            }
        };

        const parseRouteParamFromHash = (param = '', hash = '') => {
            const key = String(param || '').trim();
            if (!key) return '';
            const raw = String(hash || window.location.hash || '').trim();
            if (!raw) return '';
            const escaped = key.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const match = raw.match(new RegExp(`[?&]${escaped}=([^&#]+)`, 'i'));
            if (!match || !match[1]) return '';
            try {
                return decodeURIComponent(match[1]);
            } catch {
                return String(match[1] || '').trim();
            }
        };

        const invokeSolutionDataViaPageBridge = async (expectedBizCode = '', options = {}) => {
            const timeoutMs = Math.max(1200, toNumber(options.timeoutMs, 5800));
            const bridgeKey = `am_wxt_solution_bridge_${Date.now()}_${Math.random().toString(36).slice(2)}`;
            const expected = String(expectedBizCode || '').trim();
            return new Promise((resolve) => {
                let settled = false;
                let timer = null;
                const cleanup = () => {
                    if (timer) {
                        clearTimeout(timer);
                        timer = null;
                    }
                    window.removeEventListener('message', onMessage);
                };
                const finalize = (payload) => {
                    if (settled) return;
                    settled = true;
                    cleanup();
                    resolve(payload || null);
                };
                const onMessage = (event) => {
                    try {
                        if (event.source !== window) return;
                    } catch { }
                    const data = event.data || {};
                    if (!data || data.__amWxtBridgeKey !== bridgeKey) return;
                    finalize(data.ok ? (data.result || null) : null);
                };
                window.addEventListener('message', onMessage);
                timer = setTimeout(() => finalize(null), timeoutMs);
                try {
                    const payload = JSON.stringify({
                        key: bridgeKey,
                        expectedBizCode: expected
                    });
                    const script = document.createElement('script');
                    script.type = 'text/javascript';
                    script.textContent = `;(() => {
                        const payload = ${payload};
                        const aliasMap = {
                            onebpSite: 'onebpSite',
                            onebpSearch: 'onebpSearch',
                            onebpDisplay: 'onebpDisplay',
                            onebpShopMarketing: 'onebpStarShop',
                            onebpStarShop: 'onebpStarShop',
                            onebpContentMarketing: 'onebpLive',
                            onebpLive: 'onebpLive',
                            onebpAdStrategyLiuZi: 'onebpAdStrategyLiuZi'
                        };
                        const normalizeBiz = (biz) => {
                            const value = String(biz || '').trim();
                            if (!value) return '';
                            return String(aliasMap[value] || value).trim();
                        };
                        const serialize = (value) => {
                            try { return JSON.parse(JSON.stringify(value)); } catch { return null; }
                        };
                        const post = (ok, result) => {
                            window.postMessage({ __amWxtBridgeKey: payload.key, ok: !!ok, result: serialize(result) }, '*');
                        };
                        const run = async () => {
                            let magixRef = window.Magix && window.Magix.Vframe && window.Magix.Vframe.all
                                ? window.Magix
                                : null;
                            if (!magixRef && window.seajs && typeof window.seajs.use === 'function') {
                                try {
                                    magixRef = await new Promise((resolve) => {
                                        window.seajs.use(['magix'], (ref) => resolve(ref || null));
                                    });
                                } catch { }
                            }
                            if (!magixRef || !magixRef.Vframe || typeof magixRef.Vframe.all !== 'function') {
                                post(true, null);
                                return;
                            }
                            const all = magixRef.Vframe.all() || {};
                            const ids = Object.keys(all || {});
                            if (!ids.length) {
                                post(true, null);
                                return;
                            }
                            const expectedBiz = normalizeBiz(payload.expectedBizCode || '');
                            const rankedIds = [
                                ...ids.filter(id => id.includes('universalBP_common_layout_main_content')),
                                ...ids.filter(id => !id.includes('universalBP_common_layout_main_content') && id.includes('main_content')),
                                ...ids.filter(id => !id.includes('main_content') && id.includes('universalBP_common_layout')),
                                ...ids.filter(id => !id.includes('universalBP_common_layout') && id.toLowerCase().includes('onebp')),
                                ...ids.filter(id => !id.toLowerCase().includes('onebp'))
                            ];
                            const tried = new Set();
                            let fallback = null;
                            for (const id of rankedIds) {
                                if (tried.has(id)) continue;
                                tried.add(id);
                                const vf = all[id];
                                if (!vf || typeof vf.invoke !== 'function') continue;
                                try {
                                    const res = await vf.invoke('getSolutionData');
                                    if (!res || !Array.isArray(res.solutionList) || !res.solutionList.length) continue;
                                    if (!expectedBiz) {
                                        post(true, res);
                                        return;
                                    }
                                    const storeBiz = normalizeBiz((res.storeData && res.storeData.bizCode) || res.bizCode || '');
                                    const matched = res.solutionList.some((solution) => (
                                        normalizeBiz((solution && solution.bizCode) || storeBiz) === expectedBiz
                                    )) || (storeBiz && storeBiz === expectedBiz);
                                    if (matched) {
                                        post(true, res);
                                        return;
                                    }
                                    if (!fallback) fallback = res;
                                } catch { }
                            }
                            if (!expectedBiz && fallback) {
                                post(true, fallback);
                                return;
                            }
                            post(true, null);
                        };
                        run().catch(() => post(false, null));
                    })();`;
                    (document.documentElement || document.head || document.body).appendChild(script);
                    script.remove();
                } catch {
                    finalize(null);
                }
            });
        };

        const invokeMainVframe = async (method, ...args) => {
            const all = await getAllVframes();
            const ids = Object.keys(all);
            if (!ids.length) return null;
            const expectedBizCode = method === 'getSolutionData'
                ? normalizeSceneBizCode(parseRouteParamFromHash('bizCode'))
                : '';

            const rankedIds = [
                ...ids.filter(id => id.includes('universalBP_common_layout_main_content')),
                ...ids.filter(id => !id.includes('universalBP_common_layout_main_content') && id.includes('main_content')),
                ...ids.filter(id => !id.includes('main_content') && id.includes('universalBP_common_layout')),
                ...ids.filter(id => !id.includes('universalBP_common_layout') && id.toLowerCase().includes('onebp')),
                ...ids.filter(id => !id.toLowerCase().includes('onebp'))
            ];

            const tried = new Set();
            let fallbackSolutionData = null;
            for (const id of rankedIds) {
                if (tried.has(id)) continue;
                tried.add(id);
                const vf = all[id];
                if (!vf || typeof vf.invoke !== 'function') continue;
                try {
                    const result = await vf.invoke(method, ...args);
                    if (method === 'getSolutionData') {
                        if (result && Array.isArray(result.solutionList) && result.solutionList.length) {
                            if (!expectedBizCode) return result;
                            const storeBizCode = normalizeSceneBizCode(result?.storeData?.bizCode || result?.bizCode || '');
                            const hasExpectedBizCode = result.solutionList.some(solution => (
                                normalizeSceneBizCode(solution?.bizCode || solution?.campaign?.bizCode || storeBizCode) === expectedBizCode
                            )) || (storeBizCode && storeBizCode === expectedBizCode);
                            if (hasExpectedBizCode) return result;
                            if (!fallbackSolutionData) fallbackSolutionData = result;
                            continue;
                        }
                        if (result !== null && result !== undefined && !expectedBizCode) {
                            return result;
                        }
                    } else if (result !== null && result !== undefined) {
                        return result;
                    }
                } catch { }
            }
            if (method === 'getSolutionData') {
                if (!expectedBizCode && fallbackSolutionData) return fallbackSolutionData;
                return null;
            }
            return null;
        };

        const readCheckedValue = (acceptedValues = []) => {
            const checked = Array.from(document.querySelectorAll('input[type="radio"]:checked'));
            const found = checked.find(el => acceptedValues.includes(el.value));
            return found ? found.value : '';
        };

        const inferRuntimeFromDom = () => {
            const routeBizCode = normalizeSceneBizCode(parseRouteParamFromHash('bizCode') || DEFAULTS.bizCode);
            const useKeywordDefaults = !routeBizCode || routeBizCode === DEFAULTS.bizCode;
            const routePromotionScene = parseRouteParamFromHash('promotionScene');
            const promotionScene = routePromotionScene || readCheckedValue([
                'promotion_scene_search_user_define',
                'promotion_scene_search_detent',
                'promotion_scene_search_trend',
                'promotion_scene_golden_traffic_card_package'
            ]) || (useKeywordDefaults ? DEFAULTS.promotionScene : '');
            const itemSelectedMode = readCheckedValue(['user_define', 'shop']) || (useKeywordDefaults ? DEFAULTS.itemSelectedMode : '');
            const bidTypeV2 = readCheckedValue(['smart_bid', 'custom_bid']) || (useKeywordDefaults ? DEFAULTS.bidTypeV2 : '');
            const dmcType = readCheckedValue(['normal', 'total', 'day_freeze', 'day_average']) || DEFAULTS.dmcType;
            const budgetInput = document.querySelector('input[placeholder*="é¢„ç®—"], input[aria-label*="é¢„ç®—"], input[title*="é¢„ç®—"]');
            const budgetValue = budgetInput ? toNumber(budgetInput.value, NaN) : NaN;
            const dayAverageBudget = Number.isFinite(budgetValue) && budgetValue > 0 ? budgetValue : '';
            return {
                bizCode: routeBizCode || DEFAULTS.bizCode,
                promotionScene,
                itemSelectedMode,
                bidTypeV2,
                dmcType,
                dayAverageBudget
            };
        };

        const getRuntimeDefaults = async (forceRefresh = false) => {
            if (!forceRefresh && runtimeCache.value) {
                return deepClone(runtimeCache.value);
            }

            const routeBizCode = normalizeSceneBizCode(parseRouteParamFromHash('bizCode'));
            const domDefaults = inferRuntimeFromDom();
            const runtime = {
                ...DEFAULTS,
                ...domDefaults,
                solutionTemplate: null,
                storeData: null
            };
            if (routeBizCode) {
                runtime.bizCode = routeBizCode;
                if (routeBizCode !== DEFAULTS.bizCode) {
                    runtime.promotionScene = domDefaults.promotionScene || '';
                    runtime.itemSelectedMode = domDefaults.itemSelectedMode || '';
                    runtime.bidTypeV2 = domDefaults.bidTypeV2 || '';
                    runtime.bidTargetV2 = '';
                    runtime.optimizeTarget = '';
                }
            }

            let solutionData = await invokeMainVframe('getSolutionData');
            if ((!solutionData || !Array.isArray(solutionData.solutionList) || !solutionData.solutionList.length)) {
                const bridgedSolutionData = await invokeSolutionDataViaPageBridge(routeBizCode, {
                    timeoutMs: 6200
                });
                if (bridgedSolutionData && Array.isArray(bridgedSolutionData.solutionList) && bridgedSolutionData.solutionList.length) {
                    solutionData = bridgedSolutionData;
                }
            }
            if (solutionData && Array.isArray(solutionData.solutionList) && solutionData.solutionList.length) {
                const matchedSolution = routeBizCode
                    ? solutionData.solutionList.find(solution => normalizeSceneBizCode(
                        solution?.bizCode || solution?.campaign?.bizCode || solutionData?.storeData?.bizCode || ''
                    ) === routeBizCode)
                    : null;
                const firstSolution = deepClone(matchedSolution || solutionData.solutionList[0]);
                const templateBizCode = normalizeSceneBizCode(
                    firstSolution?.bizCode || firstSolution?.campaign?.bizCode || solutionData?.storeData?.bizCode || ''
                );
                // è·¯ç”±å·²çŸ¥æ—¶ï¼Œæ¨¡æ¿å¿…é¡»æºå¸¦åŒåœºæ™¯ bizCode æ‰å¯å¤ç”¨ï¼Œé¿å…ä¸²ç”¨ä¸Šä¸€ä¸ªåœºæ™¯æ¨¡æ¿ã€‚
                const shouldUseTemplate = !routeBizCode || (templateBizCode && templateBizCode === routeBizCode);
                if (shouldUseTemplate && firstSolution) {
                    runtime.solutionTemplate = {
                        bizCode: templateBizCode || runtime.bizCode,
                        campaign: sanitizeCampaign(firstSolution.campaign || {}),
                        adgroupList: Array.isArray(firstSolution.adgroupList)
                            ? firstSolution.adgroupList.map(sanitizeAdgroup)
                            : []
                    };
                }

                const storeData = deepClone(solutionData.storeData || {});
                const storeDataBizCode = normalizeSceneBizCode(storeData?.bizCode || runtime?.solutionTemplate?.bizCode || '');
                if (!routeBizCode || (storeDataBizCode && storeDataBizCode === routeBizCode)) {
                    runtime.storeData = storeData;
                }

                runtime.bizCode = normalizeSceneBizCode(runtime.solutionTemplate?.bizCode || runtime.bizCode);
                runtime.itemSelectedMode = runtime.storeData?.itemSelectedMode || runtime.itemSelectedMode;
                runtime.promotionScene = runtime.storeData?.promotionScene || runtime.promotionScene;
                runtime.bidTypeV2 = runtime.storeData?.bidTypeV2 || runtime.bidTypeV2;
                runtime.bidTargetV2 = runtime.storeData?.bidTargetV2 || runtime.bidTargetV2;
                runtime.dmcType = runtime.storeData?.dmcType || runtime.solutionTemplate?.campaign?.dmcType || runtime.dmcType;
                BUDGET_FIELDS.forEach(field => {
                    if (runtime.storeData?.[field] !== undefined && runtime.storeData?.[field] !== null && runtime.storeData?.[field] !== '') {
                        runtime[field] = runtime.storeData[field];
                    } else if (runtime.solutionTemplate?.campaign?.[field] !== undefined && runtime.solutionTemplate?.campaign?.[field] !== null && runtime.solutionTemplate?.campaign?.[field] !== '') {
                        runtime[field] = runtime.solutionTemplate.campaign[field];
                    }
                });
                if (runtime.storeData?.dayAverageBudget) {
                    runtime.dayAverageBudget = runtime.storeData.dayAverageBudget;
                }
            }

            runtimeCache.value = runtime;
            runtimeCache.ts = Date.now();
            return deepClone(runtime);
        };

        const SCENE_NAME_LIST = ['è´§å“å…¨ç«™æ¨å¹¿', 'å…³é”®è¯æ¨å¹¿', 'äººç¾¤æ¨å¹¿', 'åº—é“ºç›´è¾¾', 'å†…å®¹è¥é”€', 'çº¿ç´¢æ¨å¹¿'];
        const SCENE_BIZCODE_HINT_FALLBACK = {
            'è´§å“å…¨ç«™æ¨å¹¿': 'onebpSite',
            'å…³é”®è¯æ¨å¹¿': 'onebpSearch',
            'äººç¾¤æ¨å¹¿': 'onebpDisplay',
            'åº—é“ºç›´è¾¾': 'onebpStarShop',
            'å†…å®¹è¥é”€': 'onebpLive',
            'çº¿ç´¢æ¨å¹¿': 'onebpAdStrategyLiuZi'
        };
        const SCENE_BIZCODE_ALIAS_MAP = {
            onebpSite: 'onebpSite',
            onebpSearch: 'onebpSearch',
            onebpDisplay: 'onebpDisplay',
            onebpShopMarketing: 'onebpStarShop',
            onebpStarShop: 'onebpStarShop',
            onebpContentMarketing: 'onebpLive',
            onebpLive: 'onebpLive',
            onebpAdStrategyLiuZi: 'onebpAdStrategyLiuZi'
        };
        const normalizeSceneBizCode = (bizCode = '') => {
            const normalized = String(bizCode || '').trim();
            if (!normalized) return '';
            return String(SCENE_BIZCODE_ALIAS_MAP[normalized] || normalized).trim();
        };
        const resolveRuntimeBizCode = (runtime = {}) => {
            const candidates = [
                runtime?.solutionTemplate?.bizCode,
                runtime?.storeData?.bizCode,
                runtime?.bizCode
            ];
            for (const candidate of candidates) {
                const normalized = normalizeSceneBizCode(candidate);
                if (normalized) return normalized;
            }
            return '';
        };
        const isRuntimeBizCodeMatched = (runtime = {}, expectedBizCode = '', options = {}) => {
            const expected = normalizeSceneBizCode(expectedBizCode);
            if (!expected) return true;
            const coreCandidates = [
                runtime?.bizCode,
                runtime?.solutionTemplate?.bizCode,
                runtime?.storeData?.bizCode
            ].map(item => normalizeSceneBizCode(item)).filter(Boolean);
            if (coreCandidates.length) {
                return coreCandidates.includes(expected);
            }
            if (options?.includeRoute === false) return false;
            const routeBizCode = normalizeSceneBizCode(parseRouteParamFromHash('bizCode'));
            return !!routeBizCode && routeBizCode === expected;
        };
        const SCENE_REQUIRE_ITEM_FALLBACK = {
            'è´§å“å…¨ç«™æ¨å¹¿': true,
            'å…³é”®è¯æ¨å¹¿': true,
            'äººç¾¤æ¨å¹¿': true,
            'åº—é“ºç›´è¾¾': false,
            'å†…å®¹è¥é”€': false,
            'çº¿ç´¢æ¨å¹¿': true
        };
        const SCENE_FORCE_ADGROUP_MATERIAL = {
            'è´§å“å…¨ç«™æ¨å¹¿': true,
            'å…³é”®è¯æ¨å¹¿': true,
            'åº—é“ºç›´è¾¾': true,
            'å†…å®¹è¥é”€': true
        };
        const SCENE_SKIP_TEXT_RE = /^(ä¸Šæ‰‹æŒ‡å—|äº†è§£æ›´å¤š|äº†è§£è¯¦æƒ…|æ€è€ƒè¿‡ç¨‹|ç«‹å³æŠ•æ”¾|ç”Ÿæˆå…¶ä»–ç­–ç•¥|åˆ›å»ºå®Œæˆ|ä¿å­˜å¹¶å…³é—­|æ¸…ç©º|å‡çº§|æ”¶èµ·|å±•å¼€)$/;
        const SCENE_FIELD_LABEL_RE = /^(åœºæ™¯åç§°|è¥é”€ç›®æ ‡|è¥é”€åœºæ™¯|è®¡åˆ’åç§°|é¢„ç®—ç±»å‹|å‡ºä»·æ–¹å¼|å‡ºä»·ç›®æ ‡|ç›®æ ‡æŠ•äº§æ¯”|å‡€ç›®æ ‡æŠ•äº§æ¯”|ROIç›®æ ‡å€¼|å‡ºä»·ç›®æ ‡å€¼|çº¦æŸå€¼|é€‰å“æ–¹å¼|å…³é”®è¯è®¾ç½®|æ ¸å¿ƒè¯è®¾ç½®|å…³é”®è¯åŒ¹é…æ–¹å¼|é»˜è®¤åŒ¹é…æ–¹å¼|åŒ¹é…æ–¹å¼|æµé‡æ™ºé€‰|å¼€å¯å†·å¯åŠ é€Ÿ|å†·å¯åŠ é€Ÿ|äººç¾¤è®¾ç½®|åˆ›æ„è®¾ç½®|æ·»åŠ å•†å“|é€‰æ‹©æ¨å¹¿å•†å“|é€‰æ‹©è§£å†³æ–¹æ¡ˆ|è®¾ç½®è®¡åˆ’ç»„|è®¡åˆ’ç»„|æ”¶é›†é”€å”®çº¿ç´¢|æŠ•æ”¾èµ„æºä½\/æŠ•æ”¾åœ°åŸŸ\/æŠ•æ”¾æ—¶é—´|æ¨å¹¿æ¨¡å¼|æŠ•æ”¾ç­–ç•¥|æŠ•æ”¾è°ƒä¼˜|ä¼˜åŒ–æ¨¡å¼|ä¼˜åŒ–ç›®æ ‡|æŠ•æ”¾æ—¥æœŸ|æŠ•æ”¾æ—¶é—´|å‘å¸ƒæ—¥æœŸ|æŠ•æ”¾åœ°åŸŸ|èµ·é‡æ—¶é—´åœ°åŸŸè®¾ç½®|é€‰æ‹©å¡ä½æ–¹æ¡ˆ|å¡ä½æ–¹å¼|ç§å­äººç¾¤|å¥—é¤åŒ…|é€‰æ‹©æ‹‰æ–°æ–¹æ¡ˆ|é€‰æ‹©æ–¹å¼|é€‰æ‹©æ–¹æ¡ˆ|é€‰æ‹©ä¼˜åŒ–æ–¹å‘|é€‰æ‹©æ¨å¹¿ä¸»ä½“|è®¾ç½®æ‹‰æ–°äººç¾¤|è®¾ç½®è¯åŒ…|è®¾ç½®äººç¾¤|è®¾ç½®åˆ›æ„|è®¾ç½®è½åœ°é¡µ|è®¾ç½®å®è´è½åœ°é¡µ|è®¾ç½®å‡ºä»·åŠé¢„ç®—|è®¾ç½®é¢„ç®—åŠæ’æœŸ|è®¾ç½®å•†å“æ¨å¹¿æ–¹æ¡ˆ)$/;
        const SCENE_SECTION_ONLY_LABEL_RE = /^(è¥é”€åœºæ™¯ä¸ç›®æ ‡|è¥é”€åœºæ™¯|æ¨å¹¿æ–¹æ¡ˆè®¾ç½®(?:-.+)?|æ¨å¹¿æ–¹æ¡ˆè®¾ç½®|è®¾ç½®é¢„ç®—(?:åŠæ’æœŸ)?|è®¾ç½®åŸºç¡€ä¿¡æ¯|é«˜çº§è®¾ç½®|åˆ›å»ºå®Œæˆ|æ”¶é›†é”€å”®çº¿ç´¢|è¡Œä¸šè§£å†³æ–¹æ¡ˆ|è‡ªå®šä¹‰æ–¹æ¡ˆ)$/;
        const SCENE_LABEL_NOISE_RE = /[ï¼Œã€‚,ï¼ï¼Ÿ!ï¼›;]/;
        const SCENE_LABEL_NOISE_PREFIX_RE = /^(è¯·|å»ºè®®|æ”¯æŒ|ç®—æ³•|æœªæ·»åŠ |å¦‚æœ‰|å½“å‰|å®Œæˆå|ç¬¦åˆæ¡ä»¶|åœ¨æŠ•å•†å“|æƒ³æ¢æµ‹|å¡ä½å®¢æˆ·éƒ½åœ¨ç©|æµé‡è§„æ¨¡)/;
        const SCENE_LABEL_NOISE_CONTENT_RE = /(ä¸Šæ‰‹æŒ‡å—|äº†è§£|å¯è¦†ç›–|é¢„è®¡|æå‡|å®Œæˆæ·»åŠ å|å®Œæˆåå¯|é»˜è®¤å±è”½|ç³»ç»Ÿé»˜è®¤|ä»…éœ€|ä¸€é”®åˆ›å»º|æŠ•æ”¾æ•ˆæœ|æ™ºèƒ½åˆ†é…|ä»‹ç»|è¯´æ˜|æç¤º|æ”»ç•¥)/;
        const SCENE_OPTION_NOISE_RE = /(æ­¥éª¤|è¿‘\d+å¤©|ä¸Šæ¶¨|è¯¦æƒ…|ä¸€é”®|åˆ†æ|ç­–ç•¥å±æ€§|æ¡ˆä¾‹|æ¡ˆä¾‹é­”æ–¹|å¸®æˆ‘å¿«é€Ÿ|ç«äº‰æ¡ˆä¾‹|æœæ›´å¤š|å®Œæˆ|ä¸»æ’­|ä¸»æ’­ID|IDï¼š|HOT|NEW|æ€è€ƒè¿‡ç¨‹|ä¸Šæ‰‹æŒ‡å—|äº†è§£æ›´å¤š|ç‚¹å‡»æŸ¥çœ‹|æ¨èç†ç”±|è¦†ç›–|æ½œåŠ›|åŒæ¯”|ç¯æ¯”|ä¸€ç«™å¼|èƒ½åŠ›ä»‹ç»|å®šåˆ¶æŠ•æ”¾ç­–ç•¥|åˆ†è¡Œä¸šå®šåˆ¶)/i;
        const SCENE_DYNAMIC_FIELD_BLOCK_RE = /(æ­¥éª¤|æ¡ˆä¾‹|åŒè¡Œ|ä¸Šæ¶¨|å…³é”®ä½œç”¨|å…¨é“¾è·¯|æ‰“é€ |åŒå‡ºä»·æ¨¡å¼|è¿‘\d+å¤©|ä¸€é”®|è¯¦æƒ…|ä¸»æ’­|ID|HOT|NEW|åˆ†æ|ç­–ç•¥å±æ€§|åŒ¹é…åˆ°|å®Œæˆ|è¦†ç›–|æ½œåŠ›|åŒæ¯”|ç¯æ¯”|å¸®æˆ‘å¿«é€Ÿ|ç«äº‰æ¡ˆä¾‹|å·²è®¾ç½®\d+ä¸ªå…³é”®è¯|ä¿®æ”¹åŒ¹é…æ–¹æ¡ˆ)/i;
        const SCENE_KEYWORD_HINT_RE = /(è®¾ç½®|é€‰æ‹©|é¢„ç®—|å‡ºä»·|å…³é”®è¯|äººç¾¤|åˆ›æ„|å•†å“|æŠ•æ”¾|è½åœ°é¡µ|çº¿ç´¢|è®¡åˆ’|æ–¹æ¡ˆ|ç›®æ ‡|èµ„æºä½|åœ°åŸŸ|æ—¶é—´|åº—é“º|å†…å®¹|è´§å“)/;
        const SCENE_FORBIDDEN_ACTION_RE = /(åˆ›å»ºå®Œæˆ|ç«‹å³æŠ•æ”¾|ä¿å­˜å¹¶å…³é—­|ç¡®è®¤æäº¤|æäº¤å¹¶æŠ•æ”¾|æäº¤è®¡åˆ’|ç¡®è®¤æŠ•æ”¾|åˆ›å»ºè®¡åˆ’|ç¡®å®šæäº¤|æäº¤å®¡æ ¸)/;
        const SCENE_SECTION_HINT_RE = /(è¥é”€åœºæ™¯ä¸ç›®æ ‡|æ¨å¹¿æ–¹æ¡ˆè®¾ç½®|é€‰æ‹©æ¨å¹¿å•†å“|è®¾ç½®å‡ºä»·åŠé¢„ç®—|è®¾ç½®é¢„ç®—åŠæ’æœŸ|è®¾ç½®åŸºç¡€ä¿¡æ¯|é«˜çº§è®¾ç½®|è®¾ç½®å•†å“æ¨å¹¿æ–¹æ¡ˆ|è®¾ç½®è½åœ°é¡µ|æ”¶é›†é”€å”®çº¿ç´¢|è®¾ç½®åˆ›æ„|è®¾ç½®æ¨å¹¿æ–¹æ¡ˆ|è®¾ç½®è®¡åˆ’ç»„|æ ¸å¿ƒè¯è®¾ç½®|è®¾ç½®æ‹‰æ–°äººç¾¤|æŠ•æ”¾æ—¥æœŸ|æŠ•æ”¾æ—¶é—´|è®¾ç½®äººç¾¤|é€‰æ‹©è§£å†³æ–¹æ¡ˆ)/;
        const SCENE_REQUIRED_GUESS_RE = /(é¢„ç®—|å‡ºä»·|ç›®æ ‡|è®¡åˆ’åç§°|è®¡åˆ’å|å•†å“|å…³é”®è¯|äººç¾¤|æŠ•æ”¾|åˆ›æ„|æ–¹å¼|ç±»å‹|è½åœ°é¡µ|çº¿ç´¢|æ–¹æ¡ˆ)/;
        const SCENE_GOAL_GROUP_HINT_RE = /(è¥é”€ç›®æ ‡|ä¼˜åŒ–ç›®æ ‡|æŠ•æ”¾ç›®æ ‡|ç›®æ ‡)/;
        const SCENE_GOAL_OPTION_HINT_RE = /(å¡ä½|è¶‹åŠ¿|é‡‘å¡|è‡ªå®šä¹‰|æ‹‰æ–°|æˆäº¤|ç‚¹å‡»|æ”¶è—|åŠ è´­|æ¸—é€|æŠ•äº§|ROI|çº¿ç´¢|ç•™èµ„|è§‚çœ‹|è½¬åŒ–|æ›å…‰|å¼•æµ|ä¿ƒæ´»|åº—é“º|å†…å®¹|ç›´æ’­|æ”¶é›†)/i;
        const SCENE_GOAL_OPTION_SKIP_RE = /(æ·»åŠ å•†å“|æ·»åŠ å…³é”®è¯|æ·»åŠ ç§å­äººç¾¤|è®¾ç½®åŸºç¡€ä¿¡æ¯|é«˜çº§è®¾ç½®|é¢„ç®—|å‡ºä»·|è®¡åˆ’åç§°|è®¡åˆ’å|ä¸Šæ‰‹æŒ‡å—|äº†è§£æ›´å¤š|æ€è€ƒè¿‡ç¨‹|ä¿å­˜å¹¶å…³é—­|åˆ›å»ºå®Œæˆ|ç«‹å³æŠ•æ”¾|åœºæ™¯åç§°|è¥é”€åœºæ™¯ä¸ç›®æ ‡|è®¾ç½®é¢„ç®—|è®¾ç½®å‡ºä»·|è®¾ç½®æ¨å¹¿|æŠ•æ”¾æ—¶é—´|æŠ•æ”¾èµ„æºä½)/;
        const SCENE_GOAL_LABEL_HINTS = [
            'è´§å“å…¨ç«™æ¨å¹¿',
            'å…³é”®è¯æ¨å¹¿',
            'äººç¾¤æ¨å¹¿',
            'åº—é“ºç›´è¾¾',
            'å†…å®¹è¥é”€',
            'çº¿ç´¢æ¨å¹¿',
            'æœç´¢å¡ä½',
            'è¶‹åŠ¿æ˜æ˜Ÿ',
            'æµé‡é‡‘å¡',
            'è‡ªå®šä¹‰æ¨å¹¿',
            'é«˜æ•ˆæ‹‰æ–°',
            'ç«åº—æ‹‰æ–°',
            'å€ŸåŠ¿è½¬åŒ–',
            'æœºä¼šäººç¾¤æ‹‰æ–°',
            'è·¨ç±»ç›®æ‹‰æ–°',
            'ç›´æ’­é—´æˆé•¿',
            'å•†å“æ‰“çˆ†',
            'æ‹‰æ–°å¢ç²‰',
            'å…¨ç«™æ¨å¹¿',
            'æ”¶é›†é”€å”®çº¿ç´¢',
            'è¡Œä¸šè§£å†³æ–¹æ¡ˆ'
        ];
        const SCENE_GOAL_RUNTIME_KEYS = [
            'bizCode',
            'promotionScene',
            'optimizeTarget',
            'bidTypeV2',
            'bidTargetV2',
            'orderChargeType',
            'dmcType',
            'itemSelectedMode',
            'subPromotionType',
            'promotionType',
            'promotionModel',
            'promotionModelMarketing'
        ];
        const SCENE_CREATE_ENDPOINT_FALLBACK = '/solution/addList.json';
        const SCENE_BIZCODE_TO_NAME_FALLBACK = Object.keys(SCENE_BIZCODE_HINT_FALLBACK).reduce((acc, sceneName) => {
            const bizCode = String(SCENE_BIZCODE_HINT_FALLBACK[sceneName] || '').trim();
            if (!bizCode || acc[bizCode]) return acc;
            acc[bizCode] = sceneName;
            return acc;
        }, {});
        const GOAL_CONTRACT_RUNTIME_PATCH_KEYS = [
            'promotionScene',
            'optimizeTarget',
            'bidTypeV2',
            'bidTargetV2',
            'orderChargeType',
            'dmcType',
            'itemSelectedMode',
            'subPromotionType',
            'promotionType',
            'promotionModel',
            'promotionModelMarketing',
            'selectedTargetBizCode',
            'dmpSolutionId',
            'activityId',
            'specialSourceForMainStep',
            'bpStrategyId',
            'bpStrategyType',
            'subOptimizeTarget'
        ];
        const SCENE_SPEC_CACHE_STORAGE_KEY = 'am.wxt.plan_api.scene_spec_cache.v2';
        const SCENE_SPEC_CACHE_TTL_MS = 12 * 60 * 60 * 1000;
        const SCENE_CREATE_CONTRACT_CACHE_STORAGE_KEY = 'am.wxt.plan_api.scene_contract_cache.v1';
        const SCENE_CREATE_CONTRACT_CACHE_TTL_MS = 12 * 60 * 60 * 1000;
        const SCENE_LIFECYCLE_CONTRACT_CACHE_STORAGE_KEY = 'am.wxt.plan_api.lifecycle_contract_cache.v1';
        const SCENE_LIFECYCLE_CONTRACT_CACHE_TTL_MS = 12 * 60 * 60 * 1000;
        const LIFECYCLE_ACTION_LIST = ['create', 'list_conflict', 'pause', 'delete'];
        const SCENE_SPEC_FIELD_FALLBACK = {
            'è´§å“å…¨ç«™æ¨å¹¿': {
                è¥é”€ç›®æ ‡: 'è´§å“å…¨ç«™æ¨å¹¿',
                è¥é”€åœºæ™¯: 'å…¨åŸŸæŠ•æ”¾ Â· ROIç¡®å®šäº¤ä»˜',
                é€‰å“æ–¹å¼: 'è‡ªå®šä¹‰é€‰å“',
                å‡ºä»·æ–¹å¼: 'æ§æŠ•äº§æ¯”æŠ•æ”¾',
                å‡ºä»·ç›®æ ‡: 'å¢åŠ å‡€æˆäº¤é‡‘é¢',
                ç›®æ ‡æŠ•äº§æ¯”: '5',
                é¢„ç®—ç±»å‹: 'ä¸é™é¢„ç®—',
                æŠ•æ”¾è°ƒä¼˜: 'å¤šç›®æ ‡ä¼˜åŒ–',
                ä¼˜åŒ–ç›®æ ‡: 'ä¼˜åŒ–åŠ è´­',
                å¤šç›®æ ‡é¢„ç®—: '50',
                ä¸€é”®èµ·é‡é¢„ç®—: '50',
                æŠ•æ”¾æ—¶é—´: 'é•¿æœŸæŠ•æ”¾',
                æŠ•æ”¾åœ°åŸŸ: 'å…¨éƒ¨åœ°åŸŸ',
                è®¡åˆ’ç»„: 'ä¸è®¾ç½®è®¡åˆ’ç»„'
            },
            'å…³é”®è¯æ¨å¹¿': {
                è¥é”€ç›®æ ‡: 'è‡ªå®šä¹‰æ¨å¹¿',
                å‡ºä»·æ–¹å¼: 'æ™ºèƒ½å‡ºä»·',
                å‡ºä»·ç›®æ ‡: 'è·å–æˆäº¤é‡',
                é¢„ç®—ç±»å‹: 'æ¯æ—¥é¢„ç®—',
                æ ¸å¿ƒè¯è®¾ç½®: 'æ·»åŠ å…³é”®è¯',
                åŒ¹é…æ–¹å¼: 'å¹¿æ³›',
                æµé‡æ™ºé€‰: 'å¼€å¯',
                å¼€å¯å†·å¯åŠ é€Ÿ: 'å¼€å¯',
                å¡ä½æ–¹å¼: 'æŠ¢é¦–æ¡'
            },
            'äººç¾¤æ¨å¹¿': {
                è¥é”€ç›®æ ‡: 'é«˜æ•ˆæ‹‰æ–°',
                é€‰å“æ–¹å¼: 'è‡ªå®šä¹‰é€‰å“',
                é¢„ç®—ç±»å‹: 'æ¯æ—¥é¢„ç®—'
            },
            'åº—é“ºç›´è¾¾': {
                æ¨å¹¿æ¨¡å¼: 'æŒç»­æ¨å¹¿',
                é¢„ç®—ç±»å‹: 'æ¯æ—¥é¢„ç®—'
            },
            'å†…å®¹è¥é”€': {
                è¥é”€ç›®æ ‡: 'ç›´æ’­é—´æˆé•¿',
                ä¼˜åŒ–ç›®æ ‡: 'å¢åŠ å‡€æˆäº¤é‡‘é¢',
                å‡ºä»·æ–¹å¼: 'æœ€å¤§åŒ–æ‹¿é‡',
                é¢„ç®—ç±»å‹: 'æ¯æ—¥é¢„ç®—'
            },
            'çº¿ç´¢æ¨å¹¿': {
                è¥é”€ç›®æ ‡: 'æ”¶é›†é”€å”®çº¿ç´¢',
                è§£å†³æ–¹æ¡ˆ: 'è¡Œä¸šè§£å†³æ–¹æ¡ˆ',
                å‡ºä»·æ–¹å¼: 'æœ€å¤§åŒ–æ‹¿é‡',
                ä¼˜åŒ–ç›®æ ‡: 'ä¼˜åŒ–ç•™èµ„è·å®¢æˆæœ¬',
                é¢„ç®—ç±»å‹: 'æ¯æ—¥é¢„ç®—'
            }
        };
        const SCENE_MARKETING_GOAL_FALLBACK_OPTIONS = {
            'è´§å“å…¨ç«™æ¨å¹¿': ['è´§å“å…¨ç«™æ¨å¹¿'],
            'å…³é”®è¯æ¨å¹¿': ['æœç´¢å¡ä½', 'è¶‹åŠ¿æ˜æ˜Ÿ', 'æµé‡é‡‘å¡', 'è‡ªå®šä¹‰æ¨å¹¿'],
            'äººç¾¤æ¨å¹¿': ['é«˜æ•ˆæ‹‰æ–°', 'ç«åº—æ‹‰æ–°', 'å€ŸåŠ¿è½¬åŒ–', 'æœºä¼šäººç¾¤æ‹‰æ–°', 'è·¨ç±»ç›®æ‹‰æ–°'],
            'åº—é“ºç›´è¾¾': ['åº—é“ºç›´è¾¾'],
            'å†…å®¹è¥é”€': ['ç›´æ’­é—´æˆé•¿', 'å•†å“æ‰“çˆ†', 'æ‹‰æ–°å¢ç²‰'],
            'çº¿ç´¢æ¨å¹¿': ['æ”¶é›†é”€å”®çº¿ç´¢', 'è¡Œä¸šè§£å†³æ–¹æ¡ˆ']
        };
        const KEYWORD_GOAL_RUNTIME_FALLBACK_MAP = [
            {
                pattern: /(æµé‡é‡‘å¡|é‡‘å¡)/,
                promotionScene: 'promotion_scene_golden_traffic_card_package',
                itemSelectedMode: 'shop',
                bidTargetV2: 'click'
            },
            {
                pattern: /(æœç´¢å¡ä½|å¡ä½)/,
                promotionScene: 'promotion_scene_search_detent',
                itemSelectedMode: 'search_detent',
                bidTargetV2: 'search_rank'
            },
            {
                pattern: /(è¶‹åŠ¿æ˜æ˜Ÿ|è¶‹åŠ¿|æ¸—é€)/,
                promotionScene: 'promotion_scene_search_trend',
                itemSelectedMode: 'trend',
                bidTargetV2: 'market_penetration'
            },
            {
                pattern: /(è‡ªå®šä¹‰æ¨å¹¿|è‡ªå®šä¹‰|æ‰‹åŠ¨)/,
                promotionScene: 'promotion_scene_search_user_define',
                itemSelectedMode: 'user_define',
                bidTargetV2: 'conv'
            }
        ];
        const SCENE_GOAL_FIELD_ROW_FALLBACK = {
            'è´§å“å…¨ç«™æ¨å¹¿': [
                { label: 'è¥é”€åœºæ™¯', options: ['å…¨åŸŸæŠ•æ”¾ Â· ROIç¡®å®šäº¤ä»˜'], defaultValue: 'å…¨åŸŸæŠ•æ”¾ Â· ROIç¡®å®šäº¤ä»˜' },
                { label: 'é€‰å“æ–¹å¼', options: ['è‡ªå®šä¹‰é€‰å“', 'è¡Œä¸šæ¨èé€‰å“'], defaultValue: 'è‡ªå®šä¹‰é€‰å“' },
                { label: 'å‡ºä»·æ–¹å¼', options: ['æ§æŠ•äº§æ¯”æŠ•æ”¾', 'æœ€å¤§åŒ–æ‹¿é‡'], defaultValue: 'æ§æŠ•äº§æ¯”æŠ•æ”¾' },
                { label: 'å‡ºä»·ç›®æ ‡', options: ['å¢åŠ æ€»æˆäº¤é‡‘é¢', 'å¢åŠ å‡€æˆäº¤é‡‘é¢'], defaultValue: 'å¢åŠ å‡€æˆäº¤é‡‘é¢' },
                { label: 'é¢„ç®—ç±»å‹', options: ['ä¸é™é¢„ç®—', 'æ¯æ—¥é¢„ç®—', 'æ—¥å‡é¢„ç®—'], defaultValue: 'ä¸é™é¢„ç®—' },
                { label: 'æŠ•æ”¾è°ƒä¼˜', options: ['å¤šç›®æ ‡ä¼˜åŒ–', 'æ—¥å¸¸ä¼˜åŒ–'], defaultValue: 'å¤šç›®æ ‡ä¼˜åŒ–' },
                { label: 'å‘å¸ƒæ—¥æœŸ', options: ['é•¿æœŸæŠ•æ”¾', 'ç«‹å³æŠ•æ”¾'], defaultValue: 'é•¿æœŸæŠ•æ”¾' },
                { label: 'æŠ•æ”¾æ—¶é—´', options: ['é•¿æœŸæŠ•æ”¾', 'ä¸é™æ—¶æ®µ', 'å›ºå®šæ—¶æ®µ'], defaultValue: 'é•¿æœŸæŠ•æ”¾' },
                { label: 'æŠ•æ”¾åœ°åŸŸ', options: ['å…¨éƒ¨åœ°åŸŸ'], defaultValue: 'å…¨éƒ¨åœ°åŸŸ' },
                { label: 'è®¡åˆ’ç»„', options: ['ä¸è®¾ç½®è®¡åˆ’ç»„'], defaultValue: 'ä¸è®¾ç½®è®¡åˆ’ç»„' }
            ],
            'å…³é”®è¯æ¨å¹¿': {
                __default: [
                    { label: 'å‡ºä»·æ–¹å¼', options: ['æ™ºèƒ½å‡ºä»·', 'æ‰‹åŠ¨å‡ºä»·'], defaultValue: 'æ™ºèƒ½å‡ºä»·' },
                    { label: 'å‡ºä»·ç›®æ ‡', options: ['è·å–æˆäº¤é‡', 'ç›¸ä¼¼å“è·ŸæŠ•', 'æŠ¢å æœç´¢å¡ä½', 'æå‡å¸‚åœºæ¸—é€', 'å¢åŠ æ”¶è—åŠ è´­é‡', 'å¢åŠ ç‚¹å‡»é‡', 'ç¨³å®šæŠ•äº§æ¯”'], defaultValue: 'è·å–æˆäº¤é‡' },
                    { label: 'æ ¸å¿ƒè¯è®¾ç½®', options: ['æ·»åŠ å…³é”®è¯', 'ç³»ç»Ÿæ¨èè¯', 'æ‰‹åŠ¨è‡ªé€‰è¯'], defaultValue: 'æ·»åŠ å…³é”®è¯' },
                    { label: 'åŒ¹é…æ–¹å¼', options: ['å¹¿æ³›', 'ä¸­å¿ƒè¯', 'ç²¾å‡†'], defaultValue: 'å¹¿æ³›' },
                    { label: 'æµé‡æ™ºé€‰', options: ['å¼€å¯', 'å…³é—­'], defaultValue: 'å¼€å¯' },
                    { label: 'å¼€å¯å†·å¯åŠ é€Ÿ', options: ['å¼€å¯', 'å…³é—­'], defaultValue: 'å¼€å¯' },
                    { label: 'å¡ä½æ–¹å¼', options: ['æŠ¢é¦–æ¡', 'æŠ¢å‰ä¸‰', 'æŠ¢é¦–é¡µ', 'ä½ç½®ä¸é™æå‡å¸‚åœºæ¸—é€'], defaultValue: 'æŠ¢é¦–æ¡' },
                    { label: 'æ·»åŠ å•†å“', options: ['å…¨éƒ¨å•†å“', 'æœºä¼šå“æ¨è', 'è‡ªå®šä¹‰é€‰å“'], defaultValue: 'å…¨éƒ¨å•†å“' },
                    { label: 'é¢„ç®—ç±»å‹', options: ['æ¯æ—¥é¢„ç®—', 'æ—¥å‡é¢„ç®—'], defaultValue: 'æ¯æ—¥é¢„ç®—' }
                ],
                æœç´¢å¡ä½: [
                    { label: 'å¡ä½æ–¹å¼', options: ['æŠ¢é¦–æ¡', 'æŠ¢å‰ä¸‰', 'æŠ¢é¦–é¡µ', 'ä½ç½®ä¸é™æå‡å¸‚åœºæ¸—é€'], defaultValue: 'æŠ¢é¦–æ¡' },
                    { label: 'åŒ¹é…æ–¹å¼', options: ['å¹¿æ³›', 'ä¸­å¿ƒè¯', 'ç²¾å‡†'], defaultValue: 'å¹¿æ³›' }
                ],
                è¶‹åŠ¿æ˜æ˜Ÿ: [
                    { label: 'å¡ä½æ–¹å¼', options: ['æŠ¢é¦–æ¡', 'æŠ¢å‰ä¸‰', 'æŠ¢é¦–é¡µ', 'ä½ç½®ä¸é™æå‡å¸‚åœºæ¸—é€'], defaultValue: 'æŠ¢å‰ä¸‰' },
                    { label: 'åŒ¹é…æ–¹å¼', options: ['å¹¿æ³›', 'ä¸­å¿ƒè¯', 'ç²¾å‡†'], defaultValue: 'å¹¿æ³›' }
                ],
                æµé‡é‡‘å¡: [
                    { label: 'å¡ä½æ–¹å¼', options: ['æŠ¢é¦–æ¡', 'æŠ¢å‰ä¸‰', 'æŠ¢é¦–é¡µ'], defaultValue: 'æŠ¢é¦–é¡µ' },
                    { label: 'åŒ¹é…æ–¹å¼', options: ['å¹¿æ³›', 'ä¸­å¿ƒè¯', 'ç²¾å‡†'], defaultValue: 'å¹¿æ³›' }
                ],
                è‡ªå®šä¹‰æ¨å¹¿: [
                    { label: 'å¡ä½æ–¹å¼', options: ['æŠ¢é¦–æ¡', 'æŠ¢å‰ä¸‰', 'æŠ¢é¦–é¡µ'], defaultValue: 'æŠ¢é¦–æ¡' },
                    { label: 'åŒ¹é…æ–¹å¼', options: ['å¹¿æ³›', 'ä¸­å¿ƒè¯', 'ç²¾å‡†'], defaultValue: 'å¹¿æ³›' }
                ]
            },
            'äººç¾¤æ¨å¹¿': [
                { label: 'é€‰æ‹©æ¨å¹¿å•†å“', options: ['è‡ªå®šä¹‰é€‰å“', 'è¡Œä¸šæ¨èé€‰å“'], defaultValue: 'è‡ªå®šä¹‰é€‰å“' },
                { label: 'ä¼˜åŒ–ç›®æ ‡', options: ['æ‹‰æ–°æ¸—é€', 'æ‰©å¤§æ–°å®¢è§„æ¨¡', 'ç¨³å®šæ–°å®¢æŠ•äº§æ¯”', 'æ–°å®¢æ”¶è—åŠ è´­'], defaultValue: 'æ‹‰æ–°æ¸—é€' },
                { label: 'é¢„ç®—ç±»å‹', options: ['æ¯æ—¥é¢„ç®—', 'æ—¥å‡é¢„ç®—'], defaultValue: 'æ¯æ—¥é¢„ç®—' }
            ],
            'åº—é“ºç›´è¾¾': [
                { label: 'å‡ºä»·æ–¹å¼', options: ['æ™ºèƒ½å‡ºä»·', 'æ‰‹åŠ¨å‡ºä»·'], defaultValue: 'æ™ºèƒ½å‡ºä»·' },
                { label: 'å‡ºä»·ç›®æ ‡', options: ['è·å–æˆäº¤é‡', 'ç¨³å®šæŠ•äº§æ¯”', 'å¢åŠ ç‚¹å‡»é‡'], defaultValue: 'è·å–æˆäº¤é‡' },
                { label: 'é¢„ç®—ç±»å‹', options: ['æ¯æ—¥é¢„ç®—', 'æ—¥å‡é¢„ç®—'], defaultValue: 'æ¯æ—¥é¢„ç®—' }
            ],
            'å†…å®¹è¥é”€': [
                { label: 'å‡ºä»·æ–¹å¼', options: ['æœ€å¤§åŒ–æ‹¿é‡', 'æ§æˆæœ¬'], defaultValue: 'æœ€å¤§åŒ–æ‹¿é‡' },
                { label: 'ä¼˜åŒ–ç›®æ ‡', options: ['å¢åŠ å‡€æˆäº¤é‡‘é¢', 'å¢åŠ æˆäº¤é‡‘é¢', 'å¢åŠ è§‚çœ‹æ¬¡æ•°', 'å¢åŠ è§‚çœ‹æ—¶é•¿'], defaultValue: 'å¢åŠ å‡€æˆäº¤é‡‘é¢' },
                { label: 'é¢„ç®—ç±»å‹', options: ['æ¯æ—¥é¢„ç®—', 'æ—¥å‡é¢„ç®—'], defaultValue: 'æ¯æ—¥é¢„ç®—' }
            ],
            'çº¿ç´¢æ¨å¹¿': [
                { label: 'é€‰æ‹©è§£å†³æ–¹æ¡ˆ', options: ['è¡Œä¸šè§£å†³æ–¹æ¡ˆ', 'è‡ªå®šä¹‰æ–¹æ¡ˆ'], defaultValue: 'è¡Œä¸šè§£å†³æ–¹æ¡ˆ' },
                { label: 'å‡ºä»·æ–¹å¼', options: ['æœ€å¤§åŒ–æ‹¿é‡', 'æ§æˆæœ¬'], defaultValue: 'æœ€å¤§åŒ–æ‹¿é‡' },
                { label: 'ä¼˜åŒ–ç›®æ ‡', options: ['ä¼˜åŒ–ç•™èµ„è·å®¢æˆæœ¬', 'è·å–æˆäº¤é‡'], defaultValue: 'ä¼˜åŒ–ç•™èµ„è·å®¢æˆæœ¬' },
                { label: 'é¢„ç®—ç±»å‹', options: ['æ¯æ—¥é¢„ç®—', 'æ—¥å‡é¢„ç®—'], defaultValue: 'æ¯æ—¥é¢„ç®—' }
            ]
        };
        const sceneSpecCache = {
            loaded: false,
            map: {}
        };
        const sceneCreateContractCache = {
            loaded: false,
            map: {}
        };
        const sceneLifecycleContractCache = {
            loaded: false,
            map: {}
        };

        const normalizeText = (text = '') => String(text || '').replace(/\s+/g, ' ').trim();
        const normalizeSceneOptionText = (text = '') => normalizeText(text).replace(/[ï¼š:]+$/g, '').trim();
        const normalizeSceneLabelToken = (text = '') => normalizeText(String(text || '').replace(/[ï¼š:]/g, ''));
        const normalizeSceneFieldKey = (label = '') => {
            const raw = String(label || '').trim();
            if (!raw) return 'field';
            // Keep explicit API paths for direct field passthrough.
            if (/^(campaign|adgroup)\./i.test(raw)) return raw.replace(/\s+/g, '');
            const normalized = raw
                .replace(/[^\u4e00-\u9fa5A-Za-z0-9]+/g, '_')
                .replace(/^_+|_+$/g, '');
            return normalized || 'field';
        };
        const isSceneLabelMatch = (left = '', right = '') => {
            const a = normalizeSceneLabelToken(left);
            const b = normalizeSceneLabelToken(right);
            if (!a || !b) return false;
            return a === b || a.includes(b) || b.includes(a);
        };
        const isLikelySceneOptionValue = (text = '') => {
            const value = normalizeSceneOptionText(text);
            if (!value) return false;
            if (value.length < 1 || value.length > 22) return false;
            if (SCENE_SKIP_TEXT_RE.test(value)) return false;
            if (SCENE_LABEL_NOISE_RE.test(value) || value.includes('Â·')) return false;
            if (/^\d+(?:[./-]\d+)?$/.test(value)) return false;
            if (/^\d+\s*[.)ã€]/.test(value)) return false;
            if (SCENE_OPTION_NOISE_RE.test(value)) return false;
            if (SCENE_LABEL_NOISE_PREFIX_RE.test(value)) return false;
            if (SCENE_LABEL_NOISE_CONTENT_RE.test(value) && value.length > 6) return false;
            return true;
        };
        const normalizeGoalLabel = (text = '') => normalizeText(text).replace(/^\d+\s*/, '').trim();
        const normalizeGoalCandidateLabel = (text = '') => {
            const normalized = normalizeGoalLabel(text);
            if (!normalized) return '';
            const exact = SCENE_GOAL_LABEL_HINTS.find(item => item === normalized);
            if (exact) return exact;
            const included = SCENE_GOAL_LABEL_HINTS
                .filter(item => normalized.includes(item))
                .sort((a, b) => b.length - a.length)[0];
            if (included) return included;
            const segments = normalized
                .split(/[ï¼Œ,ã€‚ï¼›;ï¼!ï¼Ÿ?ï¼š:ã€|/]/)
                .map(item => normalizeGoalLabel(item))
                .filter(Boolean);
            const segmentPicked = segments.find(item => item.length >= 2 && item.length <= 24) || '';
            const compact = normalizeGoalLabel(segmentPicked || normalized);
            return compact.length > 22 ? compact.slice(0, 22) : compact;
        };
        const normalizeGoalKey = (text = '') => {
            const normalized = normalizeGoalCandidateLabel(text)
                .toLowerCase()
                .replace(/[^\w\u4e00-\u9fa5]+/g, '_')
                .replace(/^_+|_+$/g, '');
            return normalized || 'default_goal';
        };
        const getSceneMarketingGoalFallbackList = (sceneName = '') => {
            const scene = String(sceneName || '').trim();
            const isKeywordScene = scene === 'å…³é”®è¯æ¨å¹¿';
            const list = Array.isArray(SCENE_MARKETING_GOAL_FALLBACK_OPTIONS[scene])
                ? SCENE_MARKETING_GOAL_FALLBACK_OPTIONS[scene]
                : [];
            return uniqueBy(
                list
                    .map(item => (isKeywordScene ? normalizeGoalCandidateLabel(item) : normalizeGoalLabel(item)))
                    .filter(Boolean),
                item => item
            ).slice(0, 20);
        };
        const getSceneGoalFieldRowFallback = (sceneName = '', goalLabel = '') => {
            const scene = String(sceneName || '').trim();
            const normalizedGoalLabel = normalizeGoalLabel(goalLabel || '');
            const config = SCENE_GOAL_FIELD_ROW_FALLBACK[scene];
            let rows = [];
            if (Array.isArray(config)) {
                rows = config.slice();
            } else if (isPlainObject(config)) {
                const defaultRows = Array.isArray(config.__default)
                    ? config.__default
                    : (Array.isArray(config.default) ? config.default : []);
                let goalRows = [];
                if (normalizedGoalLabel) {
                    let matchedGoalKey = '';
                    Object.keys(config).forEach(key => {
                        if (!key || key === '__default' || key === 'default') return;
                        if (matchedGoalKey) return;
                        const normalizedKey = normalizeGoalCandidateLabel(key);
                        if (!normalizedKey) return;
                        if (
                            normalizedKey === normalizeGoalCandidateLabel(normalizedGoalLabel)
                            || normalizedKey.includes(normalizedGoalLabel)
                            || normalizedGoalLabel.includes(normalizedKey)
                        ) {
                            matchedGoalKey = key;
                        }
                    });
                    if (matchedGoalKey && Array.isArray(config[matchedGoalKey])) {
                        goalRows = config[matchedGoalKey];
                    }
                }
                const mergedRows = [].concat(defaultRows, goalRows);
                const dedupMap = {};
                mergedRows.forEach(row => {
                    const labelKey = normalizeSceneFieldKey(normalizeSceneOptionText(row?.label || ''));
                    if (!labelKey) return;
                    dedupMap[labelKey] = row;
                });
                rows = Object.values(dedupMap);
            }
            return rows.map((row, idx) => ({
                label: normalizeSceneOptionText(row?.label || ''),
                options: uniqueBy(
                    (Array.isArray(row?.options) ? row.options : [])
                        .map(item => normalizeSceneSettingValue(item))
                        .filter(Boolean),
                    item => item
                ).slice(0, 24),
                defaultValue: normalizeSceneSettingValue(row?.defaultValue || ''),
                dependsOn: normalizedGoalLabel ? ['è¥é”€ç›®æ ‡'] : [],
                triggerPath: `fallback:${normalizedGoalLabel || 'default'}>${String(row?.label || `field_${idx + 1}`).trim()}`
            })).filter(row => row.label && row.options.length >= 2);
        };
        const buildFallbackGoalSpecList = (sceneName = '') => {
            const targetScene = String(sceneName || '').trim();
            if (!targetScene) return [];
            const fallbackGoalLabels = getSceneMarketingGoalFallbackList(targetScene);
            if (!fallbackGoalLabels.length) return [];
            const defaultGoalLabel = normalizeGoalCandidateLabel(
                SCENE_SPEC_FIELD_FALLBACK?.[targetScene]?.è¥é”€ç›®æ ‡
                || fallbackGoalLabels[0]
                || ''
            );
            return fallbackGoalLabels.map((goalLabel, idx) => {
                const normalizedGoal = normalizeGoalCandidateLabel(goalLabel);
                const fieldRows = normalizeGoalFieldRows(getSceneGoalFieldRowFallback(targetScene, normalizedGoal));
                const fieldMatrix = fieldRows.reduce((acc, row) => {
                    acc[row.label] = {
                        options: row.options.slice(0, 48),
                        defaultValue: row.defaultValue || '',
                        requiredGuess: !!row.requiredGuess,
                        criticalGuess: !!row.criticalGuess,
                        dependsOn: row.dependsOn.slice(0, 16),
                        triggerPath: row.triggerPath || ''
                    };
                    return acc;
                }, {});
                const runtimeSnapshot = {};
                if (targetScene === 'å…³é”®è¯æ¨å¹¿') {
                    const keywordRuntime = resolveKeywordGoalRuntimeFallback(normalizedGoal);
                    if (keywordRuntime.promotionScene) runtimeSnapshot.promotionScene = keywordRuntime.promotionScene;
                    if (keywordRuntime.itemSelectedMode) runtimeSnapshot.itemSelectedMode = keywordRuntime.itemSelectedMode;
                    if (keywordRuntime.bidTargetV2) runtimeSnapshot.bidTargetV2 = keywordRuntime.bidTargetV2;
                    if (keywordRuntime.optimizeTarget || keywordRuntime.bidTargetV2) {
                        runtimeSnapshot.optimizeTarget = keywordRuntime.optimizeTarget || keywordRuntime.bidTargetV2;
                    }
                }
                const defaultCampaign = {};
                if (runtimeSnapshot.promotionScene) defaultCampaign.promotionScene = runtimeSnapshot.promotionScene;
                if (runtimeSnapshot.itemSelectedMode) defaultCampaign.itemSelectedMode = runtimeSnapshot.itemSelectedMode;
                if (runtimeSnapshot.bidTargetV2) defaultCampaign.bidTargetV2 = runtimeSnapshot.bidTargetV2;
                if (runtimeSnapshot.optimizeTarget) defaultCampaign.optimizeTarget = runtimeSnapshot.optimizeTarget;
                return {
                    goalKey: normalizeGoalKey(normalizedGoal),
                    goalLabel: normalizedGoal,
                    isDefault: normalizedGoal === defaultGoalLabel || (!defaultGoalLabel && idx === 0),
                    runtimeSnapshot,
                    createContract: {
                        method: 'POST',
                        endpoint: '/solution/addList.json',
                        requestKeys: [],
                        campaignKeyPaths: Object.keys(defaultCampaign),
                        adgroupKeyPaths: [],
                        defaultCampaign,
                        defaultAdgroup: {}
                    },
                    loadContracts: [],
                    triggerPath: `fallback_goal:${targetScene}>${normalizedGoal}`,
                    groupKey: 'fallback',
                    groupLabel: 'è¥é”€ç›®æ ‡',
                    fieldRows,
                    fieldMatrix,
                    fieldCoverage: {
                        fieldCount: fieldRows.length,
                        optionCount: fieldRows.reduce((sum, row) => sum + (Array.isArray(row.options) ? row.options.length : 0), 0),
                        requiredCount: fieldRows.filter(row => row.requiredGuess).length,
                        criticalCount: fieldRows.filter(row => row.criticalGuess).length,
                        sectionCount: 0,
                        snapshotCount: 0,
                        scanMode: 'fallback'
                    },
                    sectionOrder: uniqueBy(fieldRows.map(row => normalizeText(row.label)).filter(Boolean), item => item).slice(0, 80)
                };
            });
        };
        const normalizeLifecycleAction = (action = '') => {
            const raw = String(action || '').trim().toLowerCase();
            if (!raw) return '';
            if (raw === 'create' || raw === 'add' || raw === 'submit') return 'create';
            if (raw === 'list_conflict' || raw === 'conflict_list' || raw === 'listconflict' || raw === 'list') return 'list_conflict';
            if (raw === 'pause' || raw === 'stop' || raw === 'offline' || raw === 'suspend') return 'pause';
            if (raw === 'delete' || raw === 'remove' || raw === 'del') return 'delete';
            return '';
        };
        const isLifecycleAction = (action = '') => LIFECYCLE_ACTION_LIST.includes(normalizeLifecycleAction(action));
        const isLikelyGoalOptionText = (text = '') => {
            const normalized = normalizeGoalCandidateLabel(text);
            if (!normalized) return false;
            if (normalized.length < 2 || normalized.length > 22) return false;
            if (SCENE_SKIP_TEXT_RE.test(normalized)) return false;
            if (SCENE_GOAL_OPTION_SKIP_RE.test(normalized)) return false;
            if (SCENE_GOAL_OPTION_HINT_RE.test(normalized)) return true;
            return SCENE_GOAL_LABEL_HINTS.some(item => item.includes(normalized) || normalized.includes(item));
        };
        const isLikelyGoalGroup = (group = {}) => {
            const label = normalizeText(group?.groupLabel || '');
            const options = Array.isArray(group?.options) ? group.options : [];
            const optionTexts = options.map(item => normalizeGoalLabel(item?.optionText || '')).filter(Boolean);
            if (optionTexts.length < 2) return false;
            if (/åœºæ™¯åç§°/.test(label)) return false;
            if (label && /é¢„ç®—|å‡ºä»·|è®¡åˆ’åç§°|è®¡åˆ’å|æŠ•æ”¾æ—¶é—´|é¢„ç®—ç±»å‹|å‡ºä»·æ–¹å¼|å‡ºä»·ç›®æ ‡/.test(label)) return false;
            if (SCENE_GOAL_GROUP_HINT_RE.test(label)) return true;
            if (optionTexts.some(text => isLikelyGoalOptionText(text))) return true;
            return false;
        };
        const scoreGoalGroup = (group = {}) => {
            const label = normalizeText(group?.groupLabel || '');
            const options = Array.isArray(group?.options) ? group.options : [];
            const optionTexts = options.map(item => normalizeGoalLabel(item?.optionText || '')).filter(Boolean);
            let score = 0;
            if (SCENE_GOAL_GROUP_HINT_RE.test(label)) score += 120;
            if (/è¥é”€ç›®æ ‡/.test(label)) score += 80;
            if (/ä¼˜åŒ–ç›®æ ‡/.test(label)) score += 40;
            if (optionTexts.some(text => isLikelyGoalOptionText(text))) score += 30;
            if (Number.isFinite(group?.top) && group.top >= 100 && group.top <= 560) score += 16;
            if (optionTexts.length >= 2 && optionTexts.length <= 8) score += 12;
            if (optionTexts.some(text => /é¢„ç®—|å‡ºä»·|æŠ•æ”¾æ—¶é—´/.test(text))) score -= 45;
            return score;
        };
        const collectMarketingGoalCandidates = (root) => {
            const collectFromDataCards = () => {
                const targetRoot = root || pickPlanConfigRoot();
                const cards = Array.from(targetRoot.querySelectorAll('[data-card*="_card_"]'));
                const candidates = cards.map(card => {
                    if (!isElementVisible(card)) return null;
                    const dataCard = String(card.getAttribute('data-card') || '').trim();
                    if (!dataCard) return null;
                    if (!/(promotion_scene|goal|target|optimize|order_charge|solution|promotion_model)/i.test(dataCard)) return null;
                    const fullText = normalizeText(card.textContent || '');
                    if (!fullText) return null;
                    const byHints = SCENE_GOAL_LABEL_HINTS
                        .filter(item => fullText.includes(item))
                        .sort((a, b) => b.length - a.length)[0] || '';
                    const optionText = normalizeGoalLabel(
                        byHints
                        || normalizeGoalCandidateLabel(getOwnText(card) || '')
                        || normalizeGoalCandidateLabel(
                            Array.from(card.querySelectorAll('span,div,strong,label'))
                                .map(el => normalizeGoalCandidateLabel(getOwnText(el) || ''))
                                .find(Boolean)
                        )
                        || ''
                    );
                    const goalLabel = normalizeGoalCandidateLabel(optionText);
                    if (!goalLabel || SCENE_GOAL_OPTION_SKIP_RE.test(goalLabel)) return null;
                    const labelText = normalizeText(findNearestLabelText(card) || '');
                    const groupLabel = SCENE_GOAL_GROUP_HINT_RE.test(labelText) ? labelText : 'è¥é”€ç›®æ ‡';
                    const rect = card.getBoundingClientRect();
                    const clickEl = card.querySelector?.('label,[role="radio"],button,[role="button"],input[type="radio"]') || card;
                    const selected = isLikelySelectedElement(card)
                        || isLikelySelectedElement(clickEl)
                        || String(card.getAttribute('aria-checked') || '') === 'true';
                    const disabled = String(card.getAttribute('aria-disabled') || '') === 'true';
                    return {
                        groupKey: `${groupLabel}_${Math.round(rect.top / 24)}_${Math.round(rect.left / 80)}`,
                        groupLabel,
                        optionText,
                        goalLabel,
                        selected,
                        disabled,
                        top: Math.round(rect.top),
                        left: Math.round(rect.left),
                        clickEl
                    };
                }).filter(Boolean);
                return uniqueBy(
                    candidates,
                    item => `${item.groupLabel}::${item.goalLabel || item.optionText}`
                ).slice(0, 18);
            };
            const groups = collectLayerControlGroups(root)
                .filter(group => isLikelyGoalGroup(group))
                .map(group => ({ ...group, _goalScore: scoreGoalGroup(group) }))
                .sort((a, b) => (b._goalScore - a._goalScore) || (a.top - b.top));
            const fromGroups = groups.length
                ? groups[0].options
                .map(option => ({
                    groupKey: groups[0].groupKey,
                    groupLabel: groups[0].groupLabel,
                    optionText: normalizeGoalLabel(option.optionText || ''),
                    goalLabel: normalizeGoalCandidateLabel(option.optionText || ''),
                    selected: !!option.selected,
                    disabled: !!option.disabled,
                    top: groups[0].top,
                    left: groups[0].left
                }))
                .filter(option => option.optionText && !option.disabled)
                .filter(option => !SCENE_GOAL_OPTION_SKIP_RE.test(option.goalLabel || option.optionText))
                .filter(option => isLikelyGoalOptionText(option.goalLabel || option.optionText) || option.selected)
                .slice(0, 12)
                : [];
            const fromCards = collectFromDataCards();
            const merged = uniqueBy(
                fromGroups.concat(fromCards.map(item => ({
                    groupKey: item.groupKey,
                    groupLabel: item.groupLabel,
                    optionText: item.optionText,
                    goalLabel: item.goalLabel,
                    selected: !!item.selected,
                    disabled: !!item.disabled,
                    top: item.top,
                    left: item.left
                }))),
                item => `${item.groupLabel || ''}::${item.goalLabel || item.optionText}`
            ).slice(0, 16);
            return merged;
        };
        const parseCaptureBody = (rawBody) => {
            if (rawBody === undefined || rawBody === null || rawBody === '') return null;
            if (isPlainObject(rawBody)) return rawBody;
            if (typeof rawBody !== 'string') {
                try {
                    const text = String(rawBody);
                    if (!text) return null;
                    rawBody = text;
                } catch {
                    return null;
                }
            }
            const text = String(rawBody || '').trim();
            if (!text) return null;
            try {
                return JSON.parse(text);
            } catch { }
            try {
                const params = new URLSearchParams(text);
                const out = {};
                for (const [key, value] of params.entries()) out[key] = value;
                return Object.keys(out).length ? out : null;
            } catch {
                return null;
            }
        };
        const flattenCaptureKeyPaths = (value, options = {}) => {
            const maxDepth = Math.max(1, Math.min(12, toNumber(options.maxDepth, 8)));
            const maxPaths = Math.max(20, Math.min(4000, toNumber(options.maxPaths, 1200)));
            const maxArrayItems = Math.max(1, Math.min(6, toNumber(options.maxArrayItems, 2)));
            const output = [];
            const pushPath = (path = '') => {
                const text = String(path || '').trim();
                if (!text) return;
                output.push(text);
            };
            const walk = (node, basePath = '', depth = 0) => {
                if (output.length >= maxPaths || depth > maxDepth) return;
                if (Array.isArray(node)) {
                    const listPath = basePath ? `${basePath}[]` : '[]';
                    pushPath(listPath);
                    for (let i = 0; i < node.length && i < maxArrayItems; i++) {
                        const item = node[i];
                        if (isPlainObject(item) || Array.isArray(item)) {
                            walk(item, listPath, depth + 1);
                        }
                        if (output.length >= maxPaths) break;
                    }
                    return;
                }
                if (!isPlainObject(node)) return;
                const keys = Object.keys(node).slice(0, 240);
                for (let i = 0; i < keys.length; i++) {
                    const key = String(keys[i] || '').trim();
                    if (!key) continue;
                    const nextPath = basePath ? `${basePath}.${key}` : key;
                    pushPath(nextPath);
                    if (output.length >= maxPaths) break;
                    const child = node[key];
                    if (isPlainObject(child) || Array.isArray(child)) {
                        walk(child, nextPath, depth + 1);
                        if (output.length >= maxPaths) break;
                    }
                }
            };
            walk(value, '', 0);
            return uniqueBy(output, item => item).slice(0, maxPaths);
        };
        const normalizeCaptureMethod = (method = '') => {
            const normalized = String(method || '').trim().toUpperCase();
            return normalized || 'POST';
        };
        const normalizeCapturePath = (rawUrl = '') => {
            try {
                const url = new URL(String(rawUrl || ''), window.location.origin);
                return String(url.pathname || '').trim();
            } catch {
                return '';
            }
        };
        const listHookManagers = () => {
            const managers = [];
            const pushManager = (manager) => {
                if (!manager || typeof manager.install !== 'function') return;
                if (managers.includes(manager)) return;
                managers.push(manager);
            };
            try { pushManager(window.__AM_HOOK_MANAGER__); } catch { }
            try {
                if (typeof unsafeWindow !== 'undefined' && unsafeWindow) {
                    pushManager(unsafeWindow.__AM_HOOK_MANAGER__);
                }
            } catch { }
            if (!managers.length && typeof createHookManager === 'function') {
                try {
                    pushManager(createHookManager());
                } catch { }
            }
            return managers;
        };
        const getHookManager = () => listHookManagers()[0] || null;
        const createGoalCaptureSession = (options = {}) => {
            const hookManagers = listHookManagers();
            const hooks = hookManagers[0];
            if (!hooks || typeof hooks.install !== 'function') {
                throw new Error('hook_manager_unavailable');
            }
            hookManagers.forEach(manager => {
                try { manager.install(); } catch { }
            });
            const includePattern = options.includePattern instanceof RegExp
                ? options.includePattern
                : /\.json(?:$|\?)/i;
            const records = [];
            let historySinceTs = Date.now();
            const pushRecord = (entry = {}) => {
                const path = normalizeCapturePath(entry?.url || '');
                if (!path || !includePattern.test(path)) return;
                const body = parseCaptureBody(entry?.body);
                const bodyKeyPaths = body && typeof body === 'object'
                    ? flattenCaptureKeyPaths(body, {
                        maxDepth: 10,
                        maxPaths: 1400,
                        maxArrayItems: 3
                    })
                    : [];
                records.push({
                    ts: Date.now(),
                    method: normalizeCaptureMethod(entry?.method),
                    path,
                    queryKeys: (() => {
                        try {
                            const url = new URL(String(entry?.url || ''), window.location.origin);
                            return uniqueBy(Array.from(url.searchParams.keys()).filter(Boolean), item => item).slice(0, 80);
                        } catch {
                            return [];
                        }
                    })(),
                    bodyKeys: body && typeof body === 'object'
                        ? uniqueBy(Object.keys(body).filter(Boolean), item => item).slice(0, 160)
                        : [],
                    bodyKeyPaths: bodyKeyPaths.slice(0, 1400),
                    sampleBody: body && typeof body === 'object'
                        ? Object.keys(body).slice(0, 24).reduce((acc, key) => {
                            acc[key] = body[key];
                            return acc;
                        }, {})
                        : null
                });
            };
            const pullHistoryRecords = () => {
                hookManagers.forEach(manager => {
                    if (!manager || typeof manager.getRequestHistory !== 'function') return;
                    let history = [];
                    try {
                        history = manager.getRequestHistory({
                            includePattern,
                            since: Math.max(0, toNumber(historySinceTs, 0) + 1),
                            limit: 6000
                        });
                    } catch {
                        history = [];
                    }
                    if (!Array.isArray(history) || !history.length) return;
                    history.forEach(entry => {
                        const ts = toNumber(entry?.ts, 0);
                        if (ts > historySinceTs) historySinceTs = ts;
                        pushRecord({
                            method: entry?.method || 'POST',
                            url: entry?.url || '',
                            body: entry?.body
                        });
                    });
                });
            };
            const offFetch = hooks.registerFetch(({ args, response }) => {
                const first = args?.[0];
                const second = args?.[1];
                const method = second?.method
                    || first?.method
                    || 'GET';
                const url = typeof first === 'string'
                    ? first
                    : first?.url || response?.url || '';
                const body = second?.body || first?.body || '';
                pushRecord({ method, url, body });
            });
            const offXhrSend = hooks.registerXHRSend(({ method, url, data }) => {
                pushRecord({
                    method: method || 'POST',
                    url,
                    body: data
                });
            });
            let cursor = 0;
            return {
                records,
                mark() {
                    pullHistoryRecords();
                    cursor = records.length;
                    return cursor;
                },
                sliceFrom(start = cursor) {
                    pullHistoryRecords();
                    const idx = Number.isFinite(start) && start >= 0 ? Math.floor(start) : 0;
                    return records.slice(idx).map(item => ({ ...item }));
                },
                stop() {
                    pullHistoryRecords();
                    try { offFetch?.(); } catch { }
                    try { offXhrSend?.(); } catch { }
                }
            };
        };
        const summarizeGoalLoadContracts = (records = []) => {
            if (!Array.isArray(records) || !records.length) return [];
            const map = new Map();
            records.forEach(record => {
                const method = normalizeCaptureMethod(record?.method);
                const path = normalizeCapturePath(record?.path || '');
                if (!path) return;
                const key = `${method} ${path}`;
                if (!map.has(key)) {
                    map.set(key, {
                        method,
                        path,
                        count: 0,
                        queryKeys: new Set(),
                        bodyKeys: new Set(),
                        bodyKeyPaths: new Set(),
                        sampleBody: null
                    });
                }
                const bucket = map.get(key);
                bucket.count += 1;
                (record?.queryKeys || []).forEach(item => bucket.queryKeys.add(item));
                (record?.bodyKeys || []).forEach(item => bucket.bodyKeys.add(item));
                (record?.bodyKeyPaths || []).forEach(item => bucket.bodyKeyPaths.add(item));
                if (!bucket.sampleBody && isPlainObject(record?.sampleBody)) {
                    bucket.sampleBody = deepClone(record.sampleBody);
                }
            });
            return Array.from(map.values())
                .map(item => ({
                    method: item.method,
                    path: item.path,
                    count: item.count,
                    queryKeys: Array.from(item.queryKeys).slice(0, 80),
                    bodyKeys: Array.from(item.bodyKeys).slice(0, 160),
                    bodyKeyPaths: Array.from(item.bodyKeyPaths).slice(0, 1400),
                    sampleBody: item.sampleBody || null
                }))
                .sort((a, b) => b.count - a.count || a.path.localeCompare(b.path))
                .slice(0, 120);
        };
        const mergeContractSummaries = (contracts = []) => {
            if (!Array.isArray(contracts) || !contracts.length) return [];
            const map = new Map();
            contracts.forEach(contract => {
                const method = normalizeCaptureMethod(contract?.method);
                const path = normalizeCapturePath(contract?.path || '');
                if (!path) return;
                const key = `${method} ${path}`;
                if (!map.has(key)) {
                    map.set(key, {
                        method,
                        path,
                        count: 0,
                        queryKeys: new Set(),
                        bodyKeys: new Set(),
                        bodyKeyPaths: new Set(),
                        sampleBody: null
                    });
                }
                const bucket = map.get(key);
                bucket.count += Math.max(1, toNumber(contract?.count, 1));
                (contract?.queryKeys || []).forEach(item => {
                    const text = normalizeText(item);
                    if (text) bucket.queryKeys.add(text);
                });
                (contract?.bodyKeys || []).forEach(item => {
                    const text = normalizeText(item);
                    if (text) bucket.bodyKeys.add(text);
                });
                (contract?.bodyKeyPaths || []).forEach(item => {
                    const text = normalizeText(item);
                    if (text) bucket.bodyKeyPaths.add(text);
                });
                if (!bucket.sampleBody && isPlainObject(contract?.sampleBody)) {
                    bucket.sampleBody = deepClone(contract.sampleBody);
                }
            });
            return Array.from(map.values()).map(item => ({
                method: item.method,
                path: item.path,
                count: item.count,
                queryKeys: Array.from(item.queryKeys).slice(0, 120),
                bodyKeys: Array.from(item.bodyKeys).slice(0, 240),
                bodyKeyPaths: Array.from(item.bodyKeyPaths).slice(0, 1600),
                sampleBody: item.sampleBody || null
            })).sort((a, b) => b.count - a.count || a.path.localeCompare(b.path));
        };
        const isGoalCreateSubmitPath = (path = '') => /\/solution\/(?:business\/)?addList\.json$/i.test(String(path || '').trim());
        const pickGoalCreateSubmitContract = (contracts = []) => {
            const list = (Array.isArray(contracts) ? contracts : [])
                .filter(item => isGoalCreateSubmitPath(item?.path || ''))
                .sort((a, b) => {
                    const countDiff = toNumber(b?.count, 0) - toNumber(a?.count, 0);
                    if (countDiff !== 0) return countDiff;
                    const aBusiness = /\/solution\/business\/addList\.json$/i.test(String(a?.path || '')) ? 1 : 0;
                    const bBusiness = /\/solution\/business\/addList\.json$/i.test(String(b?.path || '')) ? 1 : 0;
                    return bBusiness - aBusiness;
                });
            return list[0] || null;
        };
        const tryParseMaybeJSON = (raw) => {
            if (isPlainObject(raw) || Array.isArray(raw)) return raw;
            const text = String(raw || '').trim();
            if (!text) return null;
            try {
                return JSON.parse(text);
            } catch {
                return null;
            }
        };
        const findSolutionPayloadFromSample = (sampleBody = null) => {
            if (!isPlainObject(sampleBody)) return { requestBody: {}, solution: {} };
            const directSolutionList = Array.isArray(sampleBody.solutionList) ? sampleBody.solutionList : tryParseMaybeJSON(sampleBody.solutionList);
            if (Array.isArray(directSolutionList) && isPlainObject(directSolutionList[0])) {
                return {
                    requestBody: sampleBody,
                    solution: directSolutionList[0]
                };
            }
            const nestedCandidates = [
                sampleBody.request,
                sampleBody.params,
                sampleBody.data,
                sampleBody.payload
            ].filter(isPlainObject);
            for (const nested of nestedCandidates) {
                const nestedSolutionList = Array.isArray(nested.solutionList) ? nested.solutionList : tryParseMaybeJSON(nested.solutionList);
                if (Array.isArray(nestedSolutionList) && isPlainObject(nestedSolutionList[0])) {
                    return {
                        requestBody: nested,
                        solution: nestedSolutionList[0]
                    };
                }
            }
            return {
                requestBody: sampleBody,
                solution: {}
            };
        };
        const summarizeCreateInterfacesFromContracts = (contracts = []) => {
            const createContracts = mergeContractSummaries(contracts || [])
                .filter(item => isGoalCreateSubmitPath(item?.path || ''));
            return createContracts.map(item => {
                const payloadSample = findSolutionPayloadFromSample(item?.sampleBody || null);
                const requestBody = isPlainObject(payloadSample?.requestBody) ? payloadSample.requestBody : {};
                const solution = isPlainObject(payloadSample?.solution) ? payloadSample.solution : {};
                const campaign = isPlainObject(solution?.campaign) ? solution.campaign : {};
                const adgroup = Array.isArray(solution?.adgroupList) && isPlainObject(solution.adgroupList[0])
                    ? solution.adgroupList[0]
                    : {};
                const requestKeys = Object.keys(requestBody || {}).slice(0, 240);
                const solutionKeys = Object.keys(solution || {}).slice(0, 240);
                const requestKeyPaths = flattenCaptureKeyPaths(requestBody, {
                    maxDepth: 10,
                    maxPaths: 1800,
                    maxArrayItems: 3
                });
                const solutionKeyPaths = flattenCaptureKeyPaths(solution, {
                    maxDepth: 10,
                    maxPaths: 1400,
                    maxArrayItems: 3
                });
                const campaignKeyPaths = flattenCaptureKeyPaths(campaign, {
                    maxDepth: 10,
                    maxPaths: 1200,
                    maxArrayItems: 3
                });
                const adgroupKeyPaths = flattenCaptureKeyPaths(adgroup, {
                    maxDepth: 10,
                    maxPaths: 1200,
                    maxArrayItems: 3
                });
                return {
                    method: normalizeCaptureMethod(item?.method || 'POST'),
                    path: normalizeCapturePath(item?.path || ''),
                    count: toNumber(item?.count, 0),
                    requestKeys: requestKeys.length ? requestKeys : (Array.isArray(item?.bodyKeys) ? item.bodyKeys.slice(0, 240) : []),
                    requestKeyPaths: requestKeyPaths.length
                        ? requestKeyPaths
                        : (Array.isArray(item?.bodyKeyPaths) ? item.bodyKeyPaths.slice(0, 1600) : []),
                    solutionKeys,
                    solutionKeyPaths,
                    campaignKeys: Object.keys(campaign || {}).slice(0, 240),
                    campaignKeyPaths,
                    adgroupKeys: Object.keys(adgroup || {}).slice(0, 240),
                    adgroupKeyPaths,
                    sampleBody: isPlainObject(item?.sampleBody) ? deepClone(item.sampleBody) : null
                };
            }).slice(0, 80);
        };
        const mergeInterfaceKeyList = (lists = [], limit = 320) => uniqueBy(
            (Array.isArray(lists) ? lists : [])
                .flatMap(list => (Array.isArray(list) ? list : []))
                .map(item => normalizeText(item))
                .filter(Boolean),
            item => item
        ).slice(0, limit);
        const summarizeCreateInterfaceHints = (createInterfaces = []) => {
            const list = Array.isArray(createInterfaces) ? createInterfaces : [];
            if (!list.length) {
                return {
                    method: 'POST',
                    path: '',
                    count: 0,
                    requestKeys: [],
                    requestKeyPaths: [],
                    solutionKeys: [],
                    solutionKeyPaths: [],
                    campaignKeys: [],
                    campaignKeyPaths: [],
                    adgroupKeys: [],
                    adgroupKeyPaths: []
                };
            }
            const sorted = list.slice().sort((a, b) => toNumber(b?.count, 0) - toNumber(a?.count, 0));
            const first = sorted[0] || {};
            return {
                method: normalizeCaptureMethod(first?.method || 'POST'),
                path: normalizeCapturePath(first?.path || ''),
                count: sorted.reduce((sum, item) => sum + Math.max(1, toNumber(item?.count, 1)), 0),
                requestKeys: mergeInterfaceKeyList(sorted.map(item => item?.requestKeys), 320),
                requestKeyPaths: mergeInterfaceKeyList(sorted.map(item => item?.requestKeyPaths), 1600),
                solutionKeys: mergeInterfaceKeyList(sorted.map(item => item?.solutionKeys), 320),
                solutionKeyPaths: mergeInterfaceKeyList(sorted.map(item => item?.solutionKeyPaths), 1400),
                campaignKeys: mergeInterfaceKeyList(sorted.map(item => item?.campaignKeys), 320),
                campaignKeyPaths: mergeInterfaceKeyList(sorted.map(item => item?.campaignKeyPaths), 1200),
                adgroupKeys: mergeInterfaceKeyList(sorted.map(item => item?.adgroupKeys), 320),
                adgroupKeyPaths: mergeInterfaceKeyList(sorted.map(item => item?.adgroupKeyPaths), 1200)
            };
        };
        const rememberSceneCreateInterfaces = (sceneName = '', goalLabel = '', createInterfaces = [], extra = {}) => {
            const scene = String(sceneName || '').trim();
            if (!scene || !Array.isArray(createInterfaces) || !createInterfaces.length) return null;
            const summary = summarizeCreateInterfaceHints(createInterfaces);
            const endpoint = normalizeCapturedCreateEndpoint(summary.path || '');
            const contract = {
                sceneName: scene,
                goalLabel: normalizeGoalCandidateLabel(goalLabel || ''),
                method: summary.method || 'POST',
                endpoint: endpoint || '',
                requestKeys: summary.requestKeys.slice(0, 320),
                requestKeyPaths: summary.requestKeyPaths.slice(0, 1600),
                solutionKeys: summary.solutionKeys.slice(0, 320),
                solutionKeyPaths: summary.solutionKeyPaths.slice(0, 1400),
                campaignKeys: summary.campaignKeys.slice(0, 320),
                campaignKeyPaths: summary.campaignKeyPaths.slice(0, 1200),
                adgroupKeys: summary.adgroupKeys.slice(0, 320),
                adgroupKeyPaths: summary.adgroupKeyPaths.slice(0, 1200),
                count: summary.count || 0,
                sampledAt: new Date().toISOString(),
                source: normalizeText(extra?.source || 'network_capture'),
                createInterfaces: deepClone(createInterfaces).slice(0, 80)
            };
            setCachedSceneCreateContract(scene, contract.goalLabel, contract);
            // åœºæ™¯çº§å…œåº•åˆåŒï¼ˆæ— è¥é”€ç›®æ ‡ï¼‰ã€‚
            setCachedSceneCreateContract(scene, '', contract);
            return contract;
        };
        const resolveGoalCreateEndpoint = (loadContracts = []) => {
            const list = Array.isArray(loadContracts) ? loadContracts : [];
            const createCandidate = list.find(item => /\/solution\/business\/addList\.json$/i.test(item?.path || ''))
                || list.find(item => /\/solution\/addList\.json$/i.test(item?.path || ''));
            return normalizeCapturePath(createCandidate?.path || '') || SCENE_CREATE_ENDPOINT_FALLBACK;
        };

        const collectSceneBizCodeHintsFromPage = () => {
            const map = { ...SCENE_BIZCODE_HINT_FALLBACK };
            try {
                const cards = Array.from(document.querySelectorAll('[data-card*="_card_"]'));
                cards.forEach(card => {
                    const dataCard = String(card.getAttribute('data-card') || '').trim();
                    const suffix = dataCard.replace(/^.*_card_/, '').trim();
                    const mappedBizCode = SCENE_BIZCODE_ALIAS_MAP[suffix] || suffix;
                    if (!mappedBizCode) return;
                    const mappedSceneByBiz = SCENE_BIZCODE_TO_NAME_FALLBACK[mappedBizCode];
                    if (mappedSceneByBiz) {
                        map[mappedSceneByBiz] = mappedBizCode;
                        return;
                    }

                    // å…œåº•ï¼šä»…åœ¨å¡ç‰‡æ–‡æœ¬ä¸­å”¯ä¸€å‘½ä¸­ä¸€ä¸ªåœºæ™¯åæ—¶æ‰é‡‡çº³ï¼Œé¿å…æ•´æ®µå®¹å™¨æ–‡æœ¬å¯¼è‡´ä¸²åœºæ™¯ã€‚
                    const text = normalizeText(card.textContent || '');
                    const matchedScenes = SCENE_NAME_LIST.filter(sceneName => text.includes(sceneName));
                    if (matchedScenes.length === 1) {
                        map[matchedScenes[0]] = mappedBizCode;
                    }
                });
            } catch { }
            return map;
        };

        const resolveSceneBizCodeHint = (sceneName = '') => {
            const normalizedScene = String(sceneName || '').trim();
            if (!normalizedScene) return '';
            const map = collectSceneBizCodeHintsFromPage();
            return normalizeSceneBizCode(map[normalizedScene] || '');
        };

        const resolveSceneDefaultPromotionScene = (sceneName = '', fallback = '') => {
            const normalizedScene = String(sceneName || '').trim();
            if (!normalizedScene) return String(fallback || '').trim();
            return String(SCENE_DEFAULT_PROMOTION_SCENE[normalizedScene] || fallback || '').trim();
        };

        const isLikelySectionTitle = (text = '') => {
            if (!text) return false;
            if (text.length < 2 || text.length > 26) return false;
            if (SCENE_SKIP_TEXT_RE.test(text)) return false;
            if (SCENE_FIELD_LABEL_RE.test(text)) return true;
            if (/^(è®¾ç½®.+|é€‰æ‹©.+|.+æ–¹æ¡ˆè®¾ç½®.*|.+è®¾ç½®)$/.test(text)) return true;
            if (SCENE_KEYWORD_HINT_RE.test(text) && text.length <= 14) return true;
            return false;
        };

        const isLikelyFieldLabel = (text = '') => {
            if (!text) return false;
            if (text.length < 2 || text.length > 28) return false;
            if (SCENE_SKIP_TEXT_RE.test(text)) return false;
            if (SCENE_SECTION_ONLY_LABEL_RE.test(text)) return false;
            if (/^\d+\s*[.)ã€‚ã€]/.test(text)) return false;
            if (SCENE_LABEL_NOISE_RE.test(text)) return false;
            if (text.includes('Â·')) return false;
            if (SCENE_LABEL_NOISE_PREFIX_RE.test(text)) return false;
            if (SCENE_LABEL_NOISE_CONTENT_RE.test(text)) return false;
            if (SCENE_DYNAMIC_FIELD_BLOCK_RE.test(text)) return false;
            if (SCENE_FIELD_LABEL_RE.test(text)) return true;
            if (!SCENE_KEYWORD_HINT_RE.test(text)) return false;
            return /^(?:(?:è®¾ç½®|é€‰æ‹©).+|.+(?:åç§°|ç›®æ ‡|æ–¹å¼|ç±»å‹|è®¾ç½®|é¢„ç®—|å‡ºä»·|å…³é”®è¯|äººç¾¤|åˆ›æ„|æŠ•æ”¾|è½åœ°é¡µ|çº¿ç´¢|è®¡åˆ’|æ–¹æ¡ˆ|è®¡åˆ’ç»„|æ¨¡å¼))$/.test(text);
        };

        const isElementVisible = (el) => {
            if (!el || !(el instanceof Element)) return false;
            if (el.closest('#am-wxt-keyword-overlay')) return false;
            const style = window.getComputedStyle(el);
            if (style.display === 'none' || style.visibility === 'hidden') return false;
            if (Number(style.opacity) === 0) return false;
            const rect = el.getBoundingClientRect();
            return rect.width > 0 && rect.height > 0
                && rect.bottom > 0 && rect.right > 0
                && rect.top < window.innerHeight && rect.left < window.innerWidth;
        };

        const getOwnText = (el) => {
            if (!el) return '';
            let text = '';
            const nodes = el.childNodes || [];
            for (let i = 0; i < nodes.length; i++) {
                const node = nodes[i];
                if (node?.nodeType === Node.TEXT_NODE) text += node.textContent || '';
            }
            return normalizeText(text);
        };

        const findNearestLabelText = (el) => {
            if (!el) return '';
            const explicit = normalizeText(el.getAttribute?.('aria-label') || el.getAttribute?.('title') || '');
            if (explicit) return explicit;
            const wrapped = el.closest?.('label');
            if (wrapped) {
                const wrappedText = normalizeText(getOwnText(wrapped) || wrapped.textContent || '');
                if (wrappedText && wrappedText.length <= 40) return wrappedText;
            }

            let cursor = el;
            for (let depth = 0; depth < 5 && cursor; depth++) {
                const parent = cursor.parentElement;
                if (!parent) break;

                let prev = cursor.previousElementSibling;
                while (prev) {
                    const prevText = normalizeText(prev.textContent || '');
                    if (prevText && prevText.length <= 30) return prevText;
                    prev = prev.previousElementSibling;
                }

                const parentText = normalizeText(getOwnText(parent));
                if (parentText && parentText.length <= 24) return parentText;
                cursor = parent;
            }

            const placeholder = normalizeText(el.getAttribute?.('placeholder') || '');
            return placeholder;
        };

        const pickPlanConfigRoot = () => {
            const list = Array.from(document.querySelectorAll('div,section,form')).filter(el => {
                if (!isElementVisible(el)) return false;
                const text = normalizeText(el.innerText || el.textContent || '');
                if (!text || text.length < 60) return false;
                if (!text.includes('åœºæ™¯åç§°')) return false;
                const matchHints = [
                    'è®¾ç½®åŸºç¡€ä¿¡æ¯',
                    'åˆ›å»ºå®Œæˆ',
                    'é€‰æ‹©æ¨å¹¿å•†å“',
                    'è®¾ç½®å‡ºä»·åŠé¢„ç®—',
                    'è®¾ç½®é¢„ç®—åŠæ’æœŸ',
                    'è®¾ç½®å•†å“æ¨å¹¿æ–¹æ¡ˆ',
                    'è®¾ç½®è½åœ°é¡µ',
                    'é€‰æ‹©è§£å†³æ–¹æ¡ˆ'
                ].filter(item => text.includes(item)).length;
                if (matchHints < 2) return false;
                const rect = el.getBoundingClientRect();
                return rect.width >= 760 && rect.height >= 360 && rect.top < 560;
            });
            if (!list.length) return document.body;
            return list.sort((a, b) => {
                const ra = a.getBoundingClientRect();
                const rb = b.getBoundingClientRect();
                const areaA = ra.width * ra.height;
                const areaB = rb.width * rb.height;
                return areaA - areaB;
            })[0];
        };

        const collectVisibleTextEntries = (root) => {
            const out = [];
            const nodes = root.querySelectorAll('div,span,label,button,a,strong,h1,h2,h3,h4,p,li');
            nodes.forEach(el => {
                if (!isElementVisible(el)) return;
                let text = getOwnText(el);
                if (!text && el.childElementCount === 0) text = normalizeText(el.textContent || '');
                if (!text) return;
                if (text.length < 2 || text.length > 80) return;
                const rect = el.getBoundingClientRect();
                out.push({
                    text,
                    top: Math.round(rect.top),
                    left: Math.round(rect.left),
                    tag: el.tagName.toLowerCase()
                });
            });
            out.sort((a, b) => (a.top - b.top) || (a.left - b.left));
            return out;
        };

        const collectControlSchemaFromRoot = (root) => {
            const textEntries = collectVisibleTextEntries(root);
            const textSeen = new Set();
            const uniqueTexts = [];
            textEntries.forEach(entry => {
                if (textSeen.has(entry.text)) return;
                textSeen.add(entry.text);
                uniqueTexts.push(entry.text);
            });

            const radios = uniqueBy(
                Array.from(root.querySelectorAll('[role="radio"], input[type="radio"]')).map(el => {
                    if (!isElementVisible(el)) return null;
                    const text = normalizeText(el.getAttribute?.('aria-label') || el.textContent || findNearestLabelText(el));
                    if (!text) return null;
                    const checked = String(el.getAttribute?.('aria-checked') || '') === 'true'
                        || !!el.checked
                        || el.getAttribute?.('checked') !== null;
                    return {
                        label: findNearestLabelText(el),
                        text,
                        value: el.value || '',
                        checked
                    };
                }).filter(Boolean),
                item => `${item.text}::${item.value}`
            );

            const checkboxes = uniqueBy(
                Array.from(root.querySelectorAll('[role="checkbox"], input[type="checkbox"]')).map(el => {
                    if (!isElementVisible(el)) return null;
                    const text = normalizeText(el.getAttribute?.('aria-label') || el.textContent || findNearestLabelText(el));
                    if (!text) return null;
                    const checked = String(el.getAttribute?.('aria-checked') || '') === 'true'
                        || !!el.checked
                        || el.getAttribute?.('checked') !== null;
                    return {
                        label: findNearestLabelText(el),
                        text,
                        checked,
                        disabled: !!el.disabled || String(el.getAttribute?.('aria-disabled') || '') === 'true'
                    };
                }).filter(Boolean),
                item => item.text
            );

            const selects = Array.from(root.querySelectorAll('select')).filter(isElementVisible).map(el => ({
                label: findNearestLabelText(el),
                value: el.value || '',
                options: Array.from(el.options || []).map(opt => ({
                    label: normalizeText(opt.textContent || ''),
                    value: opt.value,
                    selected: !!opt.selected
                }))
            }));

            const inputs = uniqueBy(
                Array.from(root.querySelectorAll('input:not([type="radio"]):not([type="checkbox"]):not([type="hidden"]), textarea')).map(el => {
                    if (!isElementVisible(el)) return null;
                    return {
                        label: findNearestLabelText(el),
                        type: el.tagName.toLowerCase() === 'textarea' ? 'textarea' : (el.type || 'text'),
                        placeholder: normalizeText(el.getAttribute('placeholder') || ''),
                        value: normalizeText(el.value || ''),
                        disabled: !!el.disabled
                    };
                }).filter(Boolean),
                item => `${item.label}::${item.placeholder}::${item.type}`
            );

            const buttonLike = uniqueBy(
                Array.from(root.querySelectorAll('button, [role="button"], [role="tab"], a')).map(el => {
                    if (!isElementVisible(el)) return '';
                    return normalizeText(el.textContent || '');
                }).filter(text => {
                    if (!text) return false;
                    if (text.length > 24) return false;
                    if (SCENE_SKIP_TEXT_RE.test(text)) return false;
                    return true;
                }),
                text => text
            );

            const optionGroups = uniqueBy(
                Array.from(root.querySelectorAll('div,ul,section')).map(parent => {
                    if (!isElementVisible(parent)) return null;
                    const rect = parent.getBoundingClientRect();
                    if (rect.width < 120 || rect.width > 1300 || rect.height < 24 || rect.height > 280) return null;
                    const plainText = normalizeText(parent.textContent || '');
                    if (!plainText || plainText.length > 280) return null;

                    const options = uniqueBy(
                        Array.from(parent.children || []).map(child => {
                            if (!isElementVisible(child)) return '';
                            let text = getOwnText(child);
                            if (!text && child.childElementCount === 0) text = normalizeText(child.textContent || '');
                            if (!text) return '';
                            if (text.length < 2 || text.length > 20) return '';
                            if (SCENE_SKIP_TEXT_RE.test(text)) return '';
                            if (/^[0-9]+$/.test(text)) return '';
                            if (/[ï¼Œã€‚,.ï¼š:]/.test(text) && text.length > 12) return '';
                            return text;
                        }).filter(Boolean),
                        text => text
                    );
                    if (options.length < 2 || options.length > 12) return null;

                    const label = findNearestLabelText(parent);
                    if (!label && !options.some(item => SCENE_KEYWORD_HINT_RE.test(item))) return null;
                    return { label, options };
                }).filter(Boolean),
                item => `${item.label || ''}::${item.options.join('|')}`
            );

            const sectionHeadings = uniqueBy(
                textEntries
                    .filter(entry => entry.left < 620 && isLikelySectionTitle(entry.text))
                    .map(entry => ({ title: entry.text, top: entry.top, left: entry.left })),
                item => item.title
            ).sort((a, b) => a.top - b.top);

            const sections = sectionHeadings.map((heading, idx) => {
                const nextTop = sectionHeadings[idx + 1]?.top || (heading.top + 520);
                const options = uniqueBy(
                    textEntries
                        .filter(entry => entry.top > heading.top + 4 && entry.top < nextTop && entry.left >= heading.left - 20)
                        .map(entry => entry.text)
                        .filter(text => text.length <= 24 && text !== heading.title && !isLikelySectionTitle(text)),
                    text => text
                );
                return {
                    title: heading.title,
                    options
                };
            });

            const labels = uniqueBy(
                uniqueTexts.filter(text => isLikelyFieldLabel(text)),
                text => text
            );

            const optionTexts = uniqueBy(
                uniqueTexts.filter(text => {
                    if (text.length > 20) return false;
                    if (isLikelyFieldLabel(text)) return false;
                    if (SCENE_SKIP_TEXT_RE.test(text)) return false;
                    if (/^\d+$/.test(text)) return false;
                    return true;
                }),
                text => text
            );

            return {
                sectionTitles: sections.map(item => item.title),
                sections,
                labels,
                radios,
                checkboxes,
                selects,
                inputs,
                buttonLikeOptions: buttonLike,
                optionGroups,
                optionTexts,
                textSamples: uniqueTexts.slice(0, 300)
            };
        };

        const getSceneCardElement = (sceneName) => {
            const exactTextNodes = Array.from(document.querySelectorAll('div,span,a,button')).filter(el => {
                if (!isElementVisible(el)) return false;
                const text = normalizeText(el.textContent || '');
                if (text !== sceneName) return false;
                const rect = el.getBoundingClientRect();
                return rect.top >= 100 && rect.top <= 360 && rect.left >= 260;
            });

            const scored = [];
            exactTextNodes.forEach(node => {
                let cursor = node;
                for (let depth = 0; depth < 6 && cursor && cursor !== document.body; depth++) {
                    if (!isElementVisible(cursor)) {
                        cursor = cursor.parentElement;
                        continue;
                    }
                    const text = normalizeText(cursor.textContent || '');
                    const rect = cursor.getBoundingClientRect();
                    if (text.includes(sceneName)
                        && rect.top >= 100 && rect.top <= 360
                        && rect.left >= 260
                        && rect.width >= 120 && rect.width <= 280
                        && rect.height >= 70 && rect.height <= 180) {
                        const score = rect.width * rect.height - Math.abs(rect.top - 160) * 40;
                        scored.push({ el: cursor, score });
                    }
                    cursor = cursor.parentElement;
                }
            });

            if (scored.length) {
                scored.sort((a, b) => b.score - a.score);
                return scored[0].el;
            }

            const fallback = Array.from(document.querySelectorAll('a,button,li,div,span')).find(el => {
                if (!isElementVisible(el)) return false;
                const text = normalizeText(el.textContent || '');
                return text === sceneName;
            });
            return fallback || null;
        };

        const clickElement = (el) => {
            if (!el) return false;
            const rect = el.getBoundingClientRect();
            const clientX = rect.left + Math.max(3, Math.min(rect.width - 3, rect.width / 2));
            const clientY = rect.top + Math.max(3, Math.min(rect.height - 3, rect.height / 2));

            const dispatchPointerMouse = (type) => {
                const base = {
                    bubbles: true,
                    cancelable: true,
                    clientX,
                    clientY
                };
                try {
                    if (type.startsWith('pointer') && typeof PointerEvent === 'function') {
                        el.dispatchEvent(new PointerEvent(type, base));
                    } else {
                        el.dispatchEvent(new MouseEvent(type, base));
                    }
                    return true;
                } catch {
                    try {
                        el.dispatchEvent(new MouseEvent(type, {
                            bubbles: true,
                            cancelable: true
                        }));
                        return true;
                    } catch {
                        try {
                            el.dispatchEvent(new Event(type, {
                                bubbles: true,
                                cancelable: true
                            }));
                            return true;
                        } catch {
                            return false;
                        }
                    }
                }
            };

            ['pointerdown', 'mousedown', 'pointerup', 'mouseup', 'click'].forEach(type => {
                dispatchPointerMouse(type);
            });
            if (typeof el.click === 'function') el.click();
            return true;
        };

        const waitUntil = async (predicate, timeoutMs = 5000, intervalMs = 120) => {
            const start = Date.now();
            while (Date.now() - start < timeoutMs) {
                try {
                    if (predicate()) return true;
                } catch { }
                await sleep(intervalMs);
            }
            return false;
        };

        const waitForDomStable = async (options = {}) => {
            const timeoutMs = Math.max(300, toNumber(options.waitMs, 3600));
            const stabilizeMs = Math.max(120, toNumber(options.stabilizeMs, 420));
            const intervalMs = Math.max(80, toNumber(options.intervalMs, 130));
            const start = Date.now();
            let lastSignature = getCurrentSceneSignature();
            let stableSince = Date.now();
            while (Date.now() - start < timeoutMs) {
                await sleep(intervalMs);
                const current = getCurrentSceneSignature();
                if (current !== lastSignature) {
                    lastSignature = current;
                    stableSince = Date.now();
                    continue;
                }
                if (Date.now() - stableSince >= stabilizeMs) return true;
            }
            return false;
        };

        const parseBizCodeFromHash = (hash = '') => {
            const raw = String(hash || window.location.hash || '').trim();
            if (!raw) return '';
            const match = raw.match(/[?&]bizCode=([^&#]+)/i);
            if (!match || !match[1]) return '';
            return decodeURIComponent(match[1]);
        };

        const buildSceneRouteHash = (sceneName = '') => {
            const targetScene = String(sceneName || '').trim();
            if (!targetScene) return '';
            const bizCode = resolveSceneBizCodeHint(targetScene) || SCENE_BIZCODE_HINT_FALLBACK[targetScene] || '';
            if (!bizCode) return '';
            return `#!/main/index?bizCode=${encodeURIComponent(bizCode)}`;
        };

        const ensureSceneRoute = async (sceneName = '', options = {}) => {
            const targetScene = String(sceneName || '').trim();
            const routeHash = buildSceneRouteHash(targetScene);
            const targetBizCode = parseBizCodeFromHash(routeHash);
            const currentBizCode = parseBizCodeFromHash(window.location.hash);
            if (routeHash && targetBizCode && currentBizCode !== targetBizCode) {
                window.location.hash = routeHash;
                await waitUntil(() => parseBizCodeFromHash(window.location.hash) === targetBizCode, Math.max(1400, toNumber(options.waitMs, 4800)), 140);
                await waitForDomStable(options);
            }
            if (targetScene) {
                try {
                    await clickScene(targetScene, options);
                } catch { }
            }
            return {
                targetScene,
                routeHash,
                targetBizCode,
                currentBizCode: parseBizCodeFromHash(window.location.hash),
                location: window.location.href
            };
        };

        const getCurrentSceneSignature = () => {
            const root = pickPlanConfigRoot();
            if (!root) return '';
            const snapshot = normalizeText((root.innerText || root.textContent || '').slice(0, 1200));
            return snapshot;
        };

        const clickScene = async (sceneName, options = {}) => {
            const target = getSceneCardElement(sceneName);
            if (!target) throw new Error(`æœªæ‰¾åˆ°åœºæ™¯å¡ç‰‡ï¼š${sceneName}`);
            const before = getCurrentSceneSignature();
            clickElement(target);
            await sleep(Math.max(240, toNumber(options.clickDelay, 640)));
            await waitUntil(() => {
                const current = getCurrentSceneSignature();
                return current && current !== before;
            }, Math.max(1200, toNumber(options.waitTimeout, 5200)), 160);
            await sleep(Math.max(180, toNumber(options.settleDelay, 420)));
            return true;
        };

        // NOTE: è¿™äº›åœºæ™¯è¾…åŠ©å‡½æ•°éœ€è¦ç»™ openWizard ä½¿ç”¨ï¼Œå¿…é¡»æ”¾åœ¨å¤–å±‚ä½œç”¨åŸŸã€‚
        const inferCurrentSceneName = () => {
            for (const sceneName of SCENE_NAME_LIST) {
                const card = getSceneCardElement(sceneName);
                if (!card) continue;
                try {
                    const style = window.getComputedStyle(card);
                    const borderColor = String(style.borderColor || '');
                    const border = String(style.border || '');
                    if (borderColor.includes('69, 84, 229') || border.includes('69, 84, 229')) {
                        return sceneName;
                    }
                } catch { }
            }
            if (wizardState?.draft?.sceneName && SCENE_NAME_LIST.includes(wizardState.draft.sceneName)) {
                return wizardState.draft.sceneName;
            }
            return 'å…³é”®è¯æ¨å¹¿';
        };

        const applyRuntimeToDraft = (runtime = {}, sceneName = '') => {
            if (!wizardState.draft) wizardState.draft = wizardDefaultDraft();
            if (sceneName && SCENE_NAME_LIST.includes(sceneName)) wizardState.draft.sceneName = sceneName;
            if (runtime?.bizCode) wizardState.draft.bizCode = runtime.bizCode;
            if (runtime?.promotionScene) wizardState.draft.promotionScene = runtime.promotionScene;
        };

        const refreshSceneSelect = () => {
            if (!wizardState?.els?.sceneSelect) return;
            if (!wizardState.draft) wizardState.draft = wizardDefaultDraft();
            const draftSceneName = SCENE_NAME_LIST.includes(wizardState.draft.sceneName) ? wizardState.draft.sceneName : '';
            const inferredSceneName = inferCurrentSceneName();
            const sceneName = draftSceneName || (SCENE_NAME_LIST.includes(inferredSceneName) ? inferredSceneName : 'å…³é”®è¯æ¨å¹¿');
            wizardState.els.sceneSelect.value = sceneName;
            wizardState.draft.sceneName = sceneName;
        };

        const SCENE_LAYER_OPTION_SKIP_RE = /^(ä¸Šæ‰‹æŒ‡å—|äº†è§£æ›´å¤š|äº†è§£è¯¦æƒ…|æŸ¥çœ‹è¯¦æƒ…|æ€è€ƒè¿‡ç¨‹|ç«‹å³æŠ•æ”¾|ç”Ÿæˆå…¶ä»–ç­–ç•¥|åˆ›å»ºå®Œæˆ|ä¿å­˜å¹¶å…³é—­|æ¸…ç©º|å‡çº§|æ”¶èµ·|å±•å¼€|æ·»åŠ å•†å“|æ·»åŠ å…³é”®è¯|ä¿®æ”¹åŒ¹é…æ–¹æ¡ˆ|ä¸€é”®ä¸Šè½¦|æ¢å¤é»˜è®¤æ¨è|æ–°å»ºæ¨¡æ¿åˆ›æ„|ä»åˆ›æ„åº“æ·»åŠ |æ‰¹é‡ä¿®æ”¹è¯åŒ…æº¢ä»·æ¯”ä¾‹|æ·»åŠ ç§å­äººç¾¤|è®¾ç½®è®¡åˆ’ç»„|è¯¦æƒ…|ç§»é™¤|å›¾æœåŒæ¬¾|å¼€|å…³|ä»Šæ—¥|ä¸é™|new|NEW|HOT)$/;

        const isLikelySelectedElement = (el) => {
            if (!el || !(el instanceof Element)) return false;
            try {
                if (String(el.getAttribute?.('aria-checked') || '') === 'true') return true;
                if (String(el.getAttribute?.('aria-selected') || '') === 'true') return true;
                if (el.getAttribute?.('checked') !== null) return true;
                if (typeof el.checked === 'boolean' && el.checked) return true;
                const className = String(el.className || '');
                if (/(^|\\s)(active|selected|checked|current|is-active|is-selected|next-radio-checked|next-tab-active)(\\s|$)/i.test(className)) {
                    return true;
                }
            } catch { }
            return false;
        };

        const isValidLayerOptionText = (text = '') => {
            const normalized = normalizeText(text);
            if (!normalized) return false;
            if (normalized.length < 2 || normalized.length > 22) return false;
            if (SCENE_SKIP_TEXT_RE.test(normalized)) return false;
            if (SCENE_FORBIDDEN_ACTION_RE.test(normalized)) return false;
            if (SCENE_LAYER_OPTION_SKIP_RE.test(normalized)) return false;
            if (SCENE_NAME_LIST.includes(normalized)) return false;
            if (/^[\\d.%â€°\\-]+$/.test(normalized)) return false;
            if (/^(æ¨è|æ–°å“|æ½œåŠ›å“|æœºä¼šçˆ†å“)$/.test(normalized)) return false;
            return true;
        };

        const normalizeLayerGroupLabel = (label = '', optionText = '') => {
            const normalized = normalizeText(label);
            if (!normalized) return '';
            if (normalized === optionText) return '';
            if (normalized.includes(optionText) && optionText.length >= 4) return '';
            if (normalized.length > 26) return '';
            if (SCENE_SKIP_TEXT_RE.test(normalized)) return '';
            if (SCENE_LAYER_OPTION_SKIP_RE.test(normalized)) return '';
            if (SCENE_NAME_LIST.includes(normalized)) return '';
            return normalized;
        };

        const findLayerOptionContainer = (el, selectors = []) => {
            let cursor = el;
            for (let depth = 0; depth < 6 && cursor && cursor !== document.body; depth++) {
                const parent = cursor.parentElement;
                if (!parent) break;
                const rect = parent.getBoundingClientRect();
                if (rect.width < 120 || rect.width > 1300 || rect.height < 20 || rect.height > 340) {
                    cursor = parent;
                    continue;
                }
                let count = 0;
                selectors.forEach(selector => {
                    try {
                        count += parent.querySelectorAll(selector).length;
                    } catch { }
                });
                if (count >= 2) return parent;
                cursor = parent;
            }
            return el.parentElement || el;
        };

        const buildLayerCandidate = (el, type = 'button') => {
            if (!isElementVisible(el)) return null;
            const text = normalizeText(
                el.getAttribute?.('aria-label')
                || getOwnText(el)
                || el.textContent
                || findNearestLabelText(el)
            );
            if (!isValidLayerOptionText(text)) return null;
            const selectorList = type === 'radio'
                ? ['[role="radio"]', 'input[type="radio"]']
                : ['[role="tab"]', 'button', '[role="button"]'];
            const container = findLayerOptionContainer(el, selectorList);
            const containerLabel = normalizeText(findNearestLabelText(container) || '');
            const ownLabel = normalizeText(findNearestLabelText(el) || '');
            const groupLabel = normalizeLayerGroupLabel(containerLabel || ownLabel, text);
            const rect = (container || el).getBoundingClientRect();
            const groupKey = groupLabel || `${type}_${Math.round(rect.top / 28)}_${Math.round(rect.left / 80)}`;
            const clickEl = el.matches?.('input[type="radio"]')
                ? (el.closest('label,[role="radio"],button,[role="button"],div,span') || el)
                : (el.closest('[role="radio"],[role="tab"],button,[role="button"],label,div,span') || el);
            const selected = isLikelySelectedElement(el) || isLikelySelectedElement(container);
            const disabled = !!el.disabled
                || String(el.getAttribute?.('aria-disabled') || '') === 'true'
                || String(container?.getAttribute?.('aria-disabled') || '') === 'true';
            return {
                type,
                optionText: text,
                groupLabel,
                groupKey,
                selected,
                disabled,
                top: Math.round(rect.top),
                left: Math.round(rect.left),
                clickEl,
                el
            };
        };

        const collectLayerControlCandidates = (root) => {
            const targetRoot = root || pickPlanConfigRoot();
            const raw = [];
            Array.from(targetRoot.querySelectorAll('[role="radio"], input[type="radio"]')).forEach(el => {
                const candidate = buildLayerCandidate(el, 'radio');
                if (candidate) raw.push(candidate);
            });
            Array.from(targetRoot.querySelectorAll('[role="tab"], button, [role="button"]')).forEach(el => {
                const candidate = buildLayerCandidate(el, 'button');
                if (candidate) raw.push(candidate);
            });
            const dedup = new Map();
            raw.forEach(item => {
                const key = `${item.groupKey}::${item.optionText}`;
                const prev = dedup.get(key);
                if (!prev) {
                    dedup.set(key, item);
                    return;
                }
                if (!prev.selected && item.selected) {
                    dedup.set(key, item);
                    return;
                }
                if (prev.disabled && !item.disabled) {
                    dedup.set(key, item);
                }
            });
            return Array.from(dedup.values());
        };

        const collectLayerControlGroups = (root) => {
            const candidates = collectLayerControlCandidates(root);
            const groups = {};
            candidates.forEach(candidate => {
                if (!groups[candidate.groupKey]) {
                    groups[candidate.groupKey] = {
                        groupKey: candidate.groupKey,
                        groupLabel: candidate.groupLabel || '',
                        top: candidate.top,
                        left: candidate.left,
                        options: []
                    };
                }
                groups[candidate.groupKey].options.push({
                    optionText: candidate.optionText,
                    selected: !!candidate.selected,
                    disabled: !!candidate.disabled
                });
            });
            return Object.values(groups)
                .map(group => ({
                    ...group,
                    options: uniqueBy(group.options, item => item.optionText).slice(0, 12)
                }))
                .filter(group => group.options.length >= 2)
                .filter(group => {
                    const optionTextList = group.options.map(item => item.optionText);
                    const sceneOptionCount = optionTextList.filter(item => SCENE_NAME_LIST.includes(item)).length;
                    if (sceneOptionCount >= Math.min(4, SCENE_NAME_LIST.length - 1)) return false;
                    if (/åœºæ™¯åç§°/.test(group.groupLabel)) return false;
                    return true;
                })
                .sort((a, b) => (a.top - b.top) || (a.left - b.left));
        };

        const findLayerCandidateByStep = (step, root) => {
            const candidates = collectLayerControlCandidates(root);
            const targetText = normalizeText(step?.optionText || '');
            if (!targetText) return null;
            const normalizeMatchToken = (text = '') => normalizeText(text).replace(/[^\u4e00-\u9fa5a-zA-Z0-9]+/g, '').toLowerCase();
            const exact = candidates.filter(item => item.optionText === targetText);
            const matched = exact.length
                ? exact
                : candidates.filter(item => {
                    const candidateText = normalizeText(item?.optionText || '');
                    if (!candidateText) return false;
                    if (candidateText.includes(targetText) || targetText.includes(candidateText)) return true;
                    const compactCandidate = normalizeMatchToken(candidateText);
                    const compactTarget = normalizeMatchToken(targetText);
                    if (!compactCandidate || !compactTarget) return false;
                    return compactCandidate.includes(compactTarget) || compactTarget.includes(compactCandidate);
                });
            if (!matched.length) {
                const targetRoot = root || pickPlanConfigRoot();
                const cardCandidates = Array.from(targetRoot.querySelectorAll('[data-card*="_card_"]'))
                    .map(card => {
                        if (!isElementVisible(card)) return null;
                        const text = normalizeText(card.textContent || '');
                        if (!text) return null;
                        const compactCandidate = normalizeMatchToken(text);
                        const compactTarget = normalizeMatchToken(targetText);
                        if (!compactCandidate || !compactTarget) return null;
                        if (!compactCandidate.includes(compactTarget) && !compactTarget.includes(compactCandidate)) return null;
                        const labelText = normalizeText(findNearestLabelText(card) || '');
                        const rect = card.getBoundingClientRect();
                        return {
                            type: 'button',
                            optionText: targetText,
                            groupLabel: SCENE_GOAL_GROUP_HINT_RE.test(labelText) ? labelText : 'è¥é”€ç›®æ ‡',
                            groupKey: `data_card_${Math.round(rect.top / 24)}_${Math.round(rect.left / 80)}`,
                            selected: isLikelySelectedElement(card) || String(card.getAttribute('aria-checked') || '') === 'true',
                            disabled: String(card.getAttribute('aria-disabled') || '') === 'true',
                            top: Math.round(rect.top),
                            left: Math.round(rect.left),
                            clickEl: card.querySelector('label,[role="radio"],button,[role="button"],input[type="radio"]') || card,
                            el: card
                        };
                    })
                    .filter(Boolean)
                    .sort((a, b) => Number(a.disabled) - Number(b.disabled) || Number(a.selected) - Number(b.selected) || (a.top - b.top));
                return cardCandidates[0] || null;
            }
            const byGroupKey = step?.groupKey ? matched.filter(item => item.groupKey === step.groupKey) : [];
            const byGroupLabel = step?.groupLabel
                ? matched.filter(item => item.groupLabel === step.groupLabel || item.groupLabel.includes(step.groupLabel) || step.groupLabel.includes(item.groupLabel))
                : [];
            const list = (byGroupKey.length ? byGroupKey : (byGroupLabel.length ? byGroupLabel : matched)).slice();
            list.sort((a, b) => Number(a.disabled) - Number(b.disabled) || Number(a.selected) - Number(b.selected) || (a.top - b.top));
            return list[0] || null;
        };

        const clickLayerOptionByStep = async (step, options = {}) => {
            const root = pickPlanConfigRoot();
            const before = getCurrentSceneSignature();
            let candidate = findLayerCandidateByStep(step, root);
            if (!candidate) return false;
            if (candidate.disabled) return false;
            if (!candidate.selected) {
                clickElement(candidate.clickEl || candidate.el);
            }
            await sleep(Math.max(120, toNumber(options.layerClickDelay, 320)));
            await waitUntil(() => {
                const fresh = findLayerCandidateByStep(step, pickPlanConfigRoot());
                if (fresh && fresh.selected) return true;
                const current = getCurrentSceneSignature();
                return current && current !== before;
            }, Math.max(800, toNumber(options.layerWaitTimeout, 2800)), 140);
            await sleep(Math.max(100, toNumber(options.layerSettleDelay, 220)));
            candidate = findLayerCandidateByStep(step, pickPlanConfigRoot());
            return !!candidate;
        };

        const applySceneLayerPath = async (sceneName, layerPath = [], options = {}) => {
            await clickScene(sceneName, options);
            for (let i = 0; i < layerPath.length; i++) {
                const ok = await clickLayerOptionByStep(layerPath[i], options);
                if (!ok) {
                    const stepText = `${layerPath[i]?.groupLabel || 'åˆ†ç»„'} -> ${layerPath[i]?.optionText || ''}`;
                    throw new Error(`æœªæ‰¾åˆ°å±‚çº§é€‰é¡¹ï¼š${stepText}`);
                }
            }
        };

        const mergeSceneSchema = (target, schema = {}) => {
            target.sectionTitles = uniqueBy((target.sectionTitles || []).concat((schema.sectionTitles || []).map(item => normalizeText(item))).filter(Boolean), item => item).slice(0, 220);
            target.sections = uniqueBy(
                (target.sections || []).concat((schema.sections || []).map(item => ({
                    title: normalizeText(item?.title || ''),
                    options: uniqueBy((item?.options || []).map(opt => normalizeText(opt)).filter(Boolean), opt => opt).slice(0, 24)
                }))).filter(item => item.title),
                item => `${item.title}::${(item.options || []).join('|')}`
            ).slice(0, 180);
            target.labels = uniqueBy((target.labels || []).concat((schema.labels || []).map(item => normalizeText(item))).filter(Boolean), item => item).slice(0, 260);
            target.radios = uniqueBy(
                (target.radios || []).concat((schema.radios || []).map(item => ({
                    label: normalizeText(item?.label || ''),
                    text: normalizeText(item?.text || ''),
                    value: normalizeText(item?.value || ''),
                    checked: !!item?.checked
                }))).filter(item => item.text),
                item => `${item.label}::${item.text}::${item.value}`
            ).slice(0, 320);
            target.checkboxes = uniqueBy(
                (target.checkboxes || []).concat((schema.checkboxes || []).map(item => ({
                    label: normalizeText(item?.label || ''),
                    text: normalizeText(item?.text || ''),
                    checked: !!item?.checked,
                    disabled: !!item?.disabled
                }))).filter(item => item.text),
                item => `${item.label}::${item.text}`
            ).slice(0, 220);
            target.selects = uniqueBy(
                (target.selects || []).concat((schema.selects || []).map(item => ({
                    label: normalizeText(item?.label || ''),
                    value: normalizeText(item?.value || ''),
                    options: uniqueBy((item?.options || []).map(opt => ({
                        label: normalizeText(opt?.label || ''),
                        value: normalizeText(opt?.value || ''),
                        selected: !!opt?.selected
                    })).filter(opt => opt.label || opt.value), opt => `${opt.label}::${opt.value}`).slice(0, 30)
                }))),
                item => `${item.label}::${item.value}::${(item.options || []).map(opt => `${opt.label}|${opt.value}`).join(',')}`
            ).slice(0, 120);
            target.inputs = uniqueBy(
                (target.inputs || []).concat((schema.inputs || []).map(item => ({
                    label: normalizeText(item?.label || ''),
                    type: normalizeText(item?.type || ''),
                    placeholder: normalizeText(item?.placeholder || ''),
                    value: normalizeText(item?.value || ''),
                    disabled: !!item?.disabled
                }))),
                item => `${item.label}::${item.type}::${item.placeholder}`
            ).slice(0, 240);
            target.buttonLikeOptions = uniqueBy((target.buttonLikeOptions || []).concat((schema.buttonLikeOptions || []).map(item => normalizeText(item))).filter(Boolean), item => item).slice(0, 260);
            target.optionGroups = uniqueBy(
                (target.optionGroups || []).concat((schema.optionGroups || []).map(item => ({
                    label: normalizeText(item?.label || ''),
                    options: uniqueBy((item?.options || []).map(opt => normalizeText(opt)).filter(Boolean), opt => opt).slice(0, 24)
                })).filter(item => item.options.length >= 2)),
                item => `${item.label}::${item.options.join('|')}`
            ).slice(0, 200);
            target.optionTexts = uniqueBy((target.optionTexts || []).concat((schema.optionTexts || []).map(item => normalizeText(item))).filter(Boolean), item => item).slice(0, 320);
            target.textSamples = uniqueBy((target.textSamples || []).concat((schema.textSamples || []).map(item => normalizeText(item))).filter(Boolean), item => item).slice(0, 500);
        };

        const scanCurrentSceneSettings = (sceneName = '', extra = {}) => {
            const root = pickPlanConfigRoot();
            const schema = collectControlSchemaFromRoot(root);
            return {
                ok: true,
                sceneName: String(sceneName || '').trim(),
                location: window.location.href,
                scannedAt: new Date().toISOString(),
                signature: getCurrentSceneSignature(),
                ...schema,
                ...extra
            };
        };

        const scanSceneLayeredSettings = async (sceneName = '', options = {}) => {
            const targetSceneName = String(sceneName || '').trim();
            const maxDepth = Math.max(1, Math.min(3, toNumber(options.layerMaxDepth, 3)));
            const maxGroupsPerLevel = Math.max(1, Math.min(6, toNumber(options.layerMaxGroupsPerLevel, 4)));
            const maxOptionsPerGroup = Math.max(1, Math.min(8, toNumber(options.layerMaxOptionsPerGroup, 5)));
            const maxSnapshots = Math.max(1, Math.min(60, toNumber(options.layerMaxSnapshots, 28)));
            const seenPathSet = new Set();
            const pathErrors = [];
            const routeSet = new Set();
            const snapshots = [];
            const aggregate = {
                ok: true,
                sceneName: targetSceneName,
                location: window.location.href,
                scannedAt: new Date().toISOString(),
                sectionTitles: [],
                sections: [],
                labels: [],
                radios: [],
                checkboxes: [],
                selects: [],
                inputs: [],
                buttonLikeOptions: [],
                optionGroups: [],
                optionTexts: [],
                textSamples: [],
                layerSnapshots: [],
                layerSummary: {}
            };

            const toPathText = (layerPath = []) => layerPath.length
                ? layerPath.map(step => `${step.groupLabel || 'åˆ†ç»„'}:${step.optionText || ''}`).join(' > ')
                : '(æ ¹å±‚)';

            const scanPath = async (layerPath = []) => {
                if (snapshots.length >= maxSnapshots) return;
                const pathKey = layerPath.map(step => `${step.groupKey || ''}:${step.optionText || ''}`).join('>') || '__root__';
                if (seenPathSet.has(pathKey)) return;
                seenPathSet.add(pathKey);
                const depth = layerPath.length;

                try {
                    await applySceneLayerPath(targetSceneName, layerPath, options);
                } catch (err) {
                    pathErrors.push({
                        pathText: toPathText(layerPath),
                        error: err?.message || String(err)
                    });
                    if (typeof options.onProgress === 'function') {
                        try {
                            options.onProgress({
                                event: 'scene_layer_path_error',
                                sceneName: targetSceneName,
                                depth,
                                pathText: toPathText(layerPath),
                                error: err?.message || String(err)
                            });
                        } catch { }
                    }
                    return;
                }

                const snapshot = scanCurrentSceneSettings(targetSceneName, {
                    depth,
                    layerPath: layerPath.map(step => ({
                        groupKey: step.groupKey,
                        groupLabel: step.groupLabel,
                        optionText: step.optionText
                    })),
                    layerPathText: toPathText(layerPath)
                });
                snapshots.push(snapshot);
                mergeSceneSchema(aggregate, snapshot);
                routeSet.add(snapshot.location);
                if (typeof options.onProgress === 'function') {
                    try {
                        options.onProgress({
                            event: 'scene_layer_snapshot',
                            sceneName: targetSceneName,
                            depth,
                            pathText: snapshot.layerPathText,
                            snapshotIndex: snapshots.length,
                            maxSnapshots
                        });
                    } catch { }
                }

                if (depth >= maxDepth || snapshots.length >= maxSnapshots) return;
                const groups = collectLayerControlGroups(pickPlanConfigRoot())
                    .filter(group => !layerPath.some(step => step.groupKey === group.groupKey))
                    .slice(0, maxGroupsPerLevel);
                for (let gi = 0; gi < groups.length; gi++) {
                    const group = groups[gi];
                    const optionList = group.options
                        .filter(option => !option.disabled)
                        .slice(0, maxOptionsPerGroup);
                    for (let oi = 0; oi < optionList.length; oi++) {
                        if (snapshots.length >= maxSnapshots) return;
                        const option = optionList[oi];
                        const nextPath = layerPath.concat([{
                            groupKey: group.groupKey,
                            groupLabel: group.groupLabel,
                            optionText: option.optionText
                        }]);
                        await scanPath(nextPath);
                    }
                }
            };

            await scanPath([]);
            aggregate.layerSnapshots = snapshots.map(item => ({
                sceneName: item.sceneName,
                depth: item.depth,
                layerPath: item.layerPath || [],
                layerPathText: item.layerPathText || '',
                location: item.location,
                labels: item.labels || [],
                sectionTitles: item.sectionTitles || [],
                radios: item.radios || []
            }));
            aggregate.layerSummary = {
                maxDepth,
                maxGroupsPerLevel,
                maxOptionsPerGroup,
                maxSnapshots,
                snapshotCount: snapshots.length,
                exploredPathCount: seenPathSet.size,
                routeList: Array.from(routeSet),
                errorCount: pathErrors.length
            };
            if (pathErrors.length) {
                aggregate.layerErrors = pathErrors.slice(0, 30);
            }
            aggregate.location = window.location.href;
            aggregate.scannedAt = new Date().toISOString();
            return aggregate;
        };

        const scanAllSceneSettings = async (options = {}) => {
            const scenes = Array.isArray(options.scenes) && options.scenes.length
                ? uniqueBy(options.scenes.map(item => String(item || '').trim()).filter(Boolean), item => item)
                : SCENE_NAME_LIST.slice();
            const list = [];
            const beforeSignature = getCurrentSceneSignature();
            const useLayeredScan = options.layered !== false;

            for (let i = 0; i < scenes.length; i++) {
                const sceneName = scenes[i];
                try {
                    if (typeof options.onProgress === 'function') {
                        try { options.onProgress({ event: 'scene_start', index: i + 1, total: scenes.length, sceneName }); } catch { }
                    }
                    const scanned = useLayeredScan
                        ? await scanSceneLayeredSettings(sceneName, options)
                        : (await clickScene(sceneName, options), scanCurrentSceneSettings(sceneName));
                    list.push(scanned);
                    if (typeof options.onProgress === 'function') {
                        try {
                            options.onProgress({
                                event: 'scene_done',
                                index: i + 1,
                                total: scenes.length,
                                sceneName,
                                labels: (scanned.labels || []).length,
                                radios: (scanned.radios || []).length,
                                snapshots: scanned.layerSummary?.snapshotCount || 1
                            });
                        } catch { }
                    }
                } catch (err) {
                    list.push({
                        ok: false,
                        sceneName,
                        error: err?.message || String(err),
                        scannedAt: new Date().toISOString(),
                        location: window.location.href
                    });
                }
            }

            if (options.restoreSceneSignature && beforeSignature) {
                await waitUntil(() => getCurrentSceneSignature() === beforeSignature, 800, 200);
            }

            const result = {
                ok: list.every(item => item.ok),
                layered: useLayeredScan,
                sceneOrder: scenes,
                scannedAt: new Date().toISOString(),
                count: list.length,
                successCount: list.filter(item => item.ok).length,
                failCount: list.filter(item => !item.ok).length,
                list
            };

            window.__AM_WXT_LAST_SCENE_SCAN__ = result;
            if (options.copyToClipboard && navigator.clipboard?.writeText) {
                try {
                    await navigator.clipboard.writeText(JSON.stringify(result, null, 2));
                } catch { }
            }
            return result;
        };

        const normalizeSceneSpecFieldKey = (label = '') => {
            const text = String(label || '')
                .replace(/[ï¼š:]/g, ' ')
                .replace(/\s+/g, ' ')
                .trim();
            return text || 'field';
        };

        const isLikelyCriticalSceneField = (label = '') => /è®¡åˆ’åç§°|è®¡åˆ’å|é¢„ç®—|å‡ºä»·|ç›®æ ‡|å•†å“|å…³é”®è¯|äººç¾¤|è½åœ°é¡µ|çº¿ç´¢/.test(String(label || ''));

        const inferSceneFieldDependsOn = (label = '') => {
            const text = String(label || '');
            const deps = [];
            if (/å…³é”®è¯|æ ¸å¿ƒè¯/.test(text)) deps.push('æ·»åŠ å•†å“');
            if (/äººç¾¤/.test(text)) deps.push('è¥é”€ç›®æ ‡');
            if (/å‡ºä»·|é¢„ç®—|æŠ•æ”¾/.test(text)) deps.push('è¥é”€ç›®æ ‡');
            if (/åˆ›æ„/.test(text)) deps.push('é€‰æ‹©æ¨å¹¿å•†å“');
            return uniqueBy(deps, item => item);
        };

        const normalizeSceneSpecOptions = (options = {}) => {
            const scanMode = options.scanMode === 'visible' ? 'visible' : 'full_top_down';
            const unlockPolicy = ['auto_rollback', 'safe_only', 'manual'].includes(options.unlockPolicy)
                ? options.unlockPolicy
                : 'auto_rollback';
            const goalScan = options.goalScan === true
                || (options.goalScan !== false && scanMode === 'full_top_down');
            const goalFieldScan = options.goalFieldScan === true;
            const goalFieldScanMode = options.goalFieldScanMode === 'visible' ? 'visible' : 'full_top_down';
            return {
                scanMode,
                unlockPolicy,
                goalScan,
                goalFieldScan,
                goalFieldScanMode,
                goalFieldMaxDepth: Math.max(1, Math.min(4, toNumber(options.goalFieldMaxDepth, 2))),
                goalFieldMaxSnapshots: Math.max(1, Math.min(120, toNumber(options.goalFieldMaxSnapshots, 48))),
                goalFieldMaxGroupsPerLevel: Math.max(1, Math.min(10, toNumber(options.goalFieldMaxGroupsPerLevel, 6))),
                goalFieldMaxOptionsPerGroup: Math.max(1, Math.min(12, toNumber(options.goalFieldMaxOptionsPerGroup, 8))),
                maxDepth: Math.max(1, Math.min(4, toNumber(options.maxDepth, 3))),
                maxSnapshots: Math.max(1, Math.min(96, toNumber(options.maxSnapshots, 36))),
                maxGroupsPerLevel: Math.max(1, Math.min(8, toNumber(options.maxGroupsPerLevel, 5))),
                maxOptionsPerGroup: Math.max(1, Math.min(10, toNumber(options.maxOptionsPerGroup, 6))),
                waitMs: Math.max(300, toNumber(options.waitMs, 4200)),
                stabilizeMs: Math.max(120, toNumber(options.stabilizeMs, 420)),
                refresh: !!options.refresh,
                restore: options.restore !== false
            };
        };

        const buildSceneSpecCacheKey = (sceneName = '', bizCode = '') => {
            const scene = String(sceneName || '').trim();
            const biz = String(bizCode || '').trim();
            return `${scene}::${biz || 'unknown'}`;
        };

        const loadSceneSpecCache = () => {
            if (sceneSpecCache.loaded) return;
            sceneSpecCache.loaded = true;
            sceneSpecCache.map = {};
            try {
                const raw = sessionStorage.getItem(SCENE_SPEC_CACHE_STORAGE_KEY);
                if (!raw) return;
                const parsed = JSON.parse(raw);
                if (!isPlainObject(parsed)) return;
                Object.keys(parsed).forEach(key => {
                    const entry = parsed[key];
                    if (!isPlainObject(entry)) return;
                    const ts = toNumber(entry.ts, 0);
                    if (!ts || Date.now() - ts > SCENE_SPEC_CACHE_TTL_MS) return;
                    if (!isPlainObject(entry.data)) return;
                    sceneSpecCache.map[key] = {
                        ts,
                        data: entry.data
                    };
                });
            } catch { }
        };

        const persistSceneSpecCache = () => {
            try {
                sessionStorage.setItem(SCENE_SPEC_CACHE_STORAGE_KEY, JSON.stringify(sceneSpecCache.map || {}));
            } catch { }
        };

        const getCachedSceneSpec = (sceneName = '', bizCode = '') => {
            loadSceneSpecCache();
            const key = buildSceneSpecCacheKey(sceneName, bizCode);
            const entry = sceneSpecCache.map[key];
            if (!entry || !entry.ts || !entry.data) return null;
            if (Date.now() - entry.ts > SCENE_SPEC_CACHE_TTL_MS) {
                delete sceneSpecCache.map[key];
                persistSceneSpecCache();
                return null;
            }
            return deepClone(entry.data);
        };

        const setCachedSceneSpec = (sceneName = '', bizCode = '', spec = null) => {
            if (!sceneName || !isPlainObject(spec)) return;
            loadSceneSpecCache();
            const key = buildSceneSpecCacheKey(sceneName, bizCode);
            sceneSpecCache.map[key] = {
                ts: Date.now(),
                data: deepClone(spec)
            };
            persistSceneSpecCache();
        };

        const clearSceneSpecCache = (sceneName = '') => {
            loadSceneSpecCache();
            const targetScene = String(sceneName || '').trim();
            if (!targetScene) {
                sceneSpecCache.map = {};
                persistSceneSpecCache();
                return { ok: true, cleared: 'all' };
            }
            const keys = Object.keys(sceneSpecCache.map || {});
            let clearedCount = 0;
            keys.forEach(key => {
                if (!key.startsWith(`${targetScene}::`)) return;
                delete sceneSpecCache.map[key];
                clearedCount += 1;
            });
            persistSceneSpecCache();
            return { ok: true, cleared: targetScene, clearedCount };
        };

        const clearSceneCreateContractCache = (sceneName = '', goalLabel = '') => {
            loadSceneCreateContractCache();
            const targetScene = String(sceneName || '').trim();
            const targetGoal = normalizeGoalCandidateLabel(goalLabel || '');
            if (!targetScene && !targetGoal) {
                sceneCreateContractCache.map = {};
                persistSceneCreateContractCache();
                return { ok: true, cleared: 'all', clearedCount: 0 };
            }
            const keys = Object.keys(sceneCreateContractCache.map || {});
            let clearedCount = 0;
            keys.forEach(key => {
                const [scenePart, goalPartRaw] = String(key || '').split('::');
                const scenePartText = String(scenePart || '').trim();
                if (targetScene && scenePartText !== targetScene) return;
                const goalPart = String(goalPartRaw || '').trim();
                const normalizedGoalPart = goalPart === '__scene_default__'
                    ? ''
                    : normalizeGoalCandidateLabel(goalPart);
                if (targetGoal && normalizedGoalPart !== targetGoal) return;
                delete sceneCreateContractCache.map[key];
                clearedCount += 1;
            });
            persistSceneCreateContractCache();
            return {
                ok: true,
                clearedScene: targetScene || '',
                clearedGoal: targetGoal || '',
                clearedCount
            };
        };

        const loadSceneCreateContractCache = () => {
            if (sceneCreateContractCache.loaded) return;
            sceneCreateContractCache.loaded = true;
            sceneCreateContractCache.map = {};
            try {
                const raw = sessionStorage.getItem(SCENE_CREATE_CONTRACT_CACHE_STORAGE_KEY);
                if (!raw) return;
                const parsed = JSON.parse(raw);
                if (!isPlainObject(parsed)) return;
                Object.keys(parsed).forEach(key => {
                    const entry = parsed[key];
                    if (!isPlainObject(entry)) return;
                    const ts = toNumber(entry.ts, 0);
                    if (!ts || Date.now() - ts > SCENE_CREATE_CONTRACT_CACHE_TTL_MS) return;
                    const data = isPlainObject(entry.data) ? entry.data : null;
                    if (!data) return;
                    sceneCreateContractCache.map[key] = {
                        ts,
                        data
                    };
                });
            } catch { }
        };

        const persistSceneCreateContractCache = () => {
            try {
                sessionStorage.setItem(SCENE_CREATE_CONTRACT_CACHE_STORAGE_KEY, JSON.stringify(sceneCreateContractCache.map || {}));
            } catch { }
        };

        const buildSceneCreateContractCacheKey = (sceneName = '', goalLabel = '') => {
            const scene = String(sceneName || '').trim();
            const goal = normalizeGoalCandidateLabel(goalLabel || '');
            return `${scene}::${goal || '__scene_default__'}`;
        };

        const getCachedSceneCreateContract = (sceneName = '', goalLabel = '') => {
            loadSceneCreateContractCache();
            const key = buildSceneCreateContractCacheKey(sceneName, goalLabel);
            const entry = sceneCreateContractCache.map[key];
            if (!entry || !entry.ts || !isPlainObject(entry.data)) return null;
            if (Date.now() - entry.ts > SCENE_CREATE_CONTRACT_CACHE_TTL_MS) {
                delete sceneCreateContractCache.map[key];
                persistSceneCreateContractCache();
                return null;
            }
            return deepClone(entry.data);
        };

        const getSceneCreateContract = (sceneName = '', goalLabel = '') => {
            const targetScene = String(sceneName || inferCurrentSceneName() || '').trim();
            const targetGoal = normalizeGoalCandidateLabel(goalLabel || '');
            if (!targetScene) {
                return {
                    ok: false,
                    sceneName: '',
                    goalLabel: targetGoal || '',
                    contract: null,
                    error: 'ç¼ºå°‘ sceneName'
                };
            }
            const contract = getCachedSceneCreateContract(targetScene, targetGoal)
                || getCachedSceneCreateContract(targetScene, '');
            return {
                ok: !!contract,
                sceneName: targetScene,
                goalLabel: targetGoal || '',
                contract: contract ? deepClone(contract) : null,
                fallbackUsed: !targetGoal && !!contract,
                error: contract ? '' : 'scene_create_contract_not_cached'
            };
        };

        const setCachedSceneCreateContract = (sceneName = '', goalLabel = '', value = null) => {
            const scene = String(sceneName || '').trim();
            if (!scene || !isPlainObject(value)) return;
            loadSceneCreateContractCache();
            const key = buildSceneCreateContractCacheKey(scene, goalLabel);
            sceneCreateContractCache.map[key] = {
                ts: Date.now(),
                data: deepClone(value)
            };
            persistSceneCreateContractCache();
        };

        const loadSceneLifecycleContractCache = () => {
            if (sceneLifecycleContractCache.loaded) return;
            sceneLifecycleContractCache.loaded = true;
            sceneLifecycleContractCache.map = {};
            try {
                const raw = sessionStorage.getItem(SCENE_LIFECYCLE_CONTRACT_CACHE_STORAGE_KEY);
                if (!raw) return;
                const parsed = JSON.parse(raw);
                if (!isPlainObject(parsed)) return;
                Object.keys(parsed).forEach(key => {
                    const entry = parsed[key];
                    if (!isPlainObject(entry)) return;
                    const ts = toNumber(entry.ts, 0);
                    if (!ts || Date.now() - ts > SCENE_LIFECYCLE_CONTRACT_CACHE_TTL_MS) return;
                    const data = isPlainObject(entry.data) ? entry.data : null;
                    if (!data) return;
                    sceneLifecycleContractCache.map[key] = {
                        ts,
                        data
                    };
                });
            } catch { }
        };

        const persistSceneLifecycleContractCache = () => {
            try {
                sessionStorage.setItem(SCENE_LIFECYCLE_CONTRACT_CACHE_STORAGE_KEY, JSON.stringify(sceneLifecycleContractCache.map || {}));
            } catch { }
        };

        const buildSceneLifecycleContractCacheKey = (sceneName = '', action = '') => {
            const scene = String(sceneName || '').trim();
            const normalizedAction = normalizeLifecycleAction(action);
            return `${scene}::${normalizedAction}`;
        };

        const getCachedSceneLifecycleContract = (sceneName = '', action = '') => {
            const scene = String(sceneName || '').trim();
            const normalizedAction = normalizeLifecycleAction(action);
            if (!scene || !normalizedAction) return null;
            loadSceneLifecycleContractCache();
            const key = buildSceneLifecycleContractCacheKey(scene, normalizedAction);
            const entry = sceneLifecycleContractCache.map[key];
            if (!entry || !entry.ts || !isPlainObject(entry.data)) return null;
            if (Date.now() - entry.ts > SCENE_LIFECYCLE_CONTRACT_CACHE_TTL_MS) {
                delete sceneLifecycleContractCache.map[key];
                persistSceneLifecycleContractCache();
                return null;
            }
            return deepClone(entry.data);
        };

        const setCachedSceneLifecycleContract = (sceneName = '', action = '', contract = null) => {
            const scene = String(sceneName || '').trim();
            const normalizedAction = normalizeLifecycleAction(action);
            if (!scene || !normalizedAction || !isPlainObject(contract)) return;
            loadSceneLifecycleContractCache();
            const key = buildSceneLifecycleContractCacheKey(scene, normalizedAction);
            sceneLifecycleContractCache.map[key] = {
                ts: Date.now(),
                data: deepClone(contract)
            };
            persistSceneLifecycleContractCache();
        };

        const clearLifecycleContractCache = (sceneName = '') => {
            loadSceneLifecycleContractCache();
            const targetScene = String(sceneName || '').trim();
            if (!targetScene) {
                sceneLifecycleContractCache.map = {};
                persistSceneLifecycleContractCache();
                return { ok: true, cleared: 'all', clearedCount: 0 };
            }
            let clearedCount = 0;
            Object.keys(sceneLifecycleContractCache.map || {}).forEach(key => {
                if (!key.startsWith(`${targetScene}::`)) return;
                delete sceneLifecycleContractCache.map[key];
                clearedCount += 1;
            });
            persistSceneLifecycleContractCache();
            return {
                ok: true,
                cleared: targetScene,
                clearedCount
            };
        };

        const getLifecycleContract = (sceneName = '', action = '', options = {}) => {
            const targetScene = String(sceneName || inferCurrentSceneName() || '').trim();
            const normalizedAction = normalizeLifecycleAction(action);
            if (!targetScene || !normalizedAction) {
                return {
                    ok: false,
                    sceneName: targetScene || '',
                    action: normalizedAction || '',
                    contract: null,
                    error: !targetScene ? 'ç¼ºå°‘ sceneName' : 'ç¼ºå°‘ action'
                };
            }
            const direct = getCachedSceneLifecycleContract(targetScene, normalizedAction);
            if (direct) {
                return {
                    ok: true,
                    sceneName: targetScene,
                    action: normalizedAction,
                    contract: direct,
                    fallbackUsed: false,
                    error: ''
                };
            }
            if (normalizedAction === 'create') {
                const createContract = getSceneCreateContract(targetScene, options.goalLabel || '');
                if (createContract?.ok && createContract.contract) {
                    const normalized = {
                        sceneName: targetScene,
                        action: 'create',
                        method: normalizeCaptureMethod(createContract.contract.method || 'POST'),
                        endpoint: normalizeCapturePath(createContract.contract.endpoint || ''),
                        requestKeys: Array.isArray(createContract.contract.requestKeys) ? createContract.contract.requestKeys.slice(0, 320) : [],
                        requestKeyPaths: Array.isArray(createContract.contract.requestKeyPaths) ? createContract.contract.requestKeyPaths.slice(0, 1600) : [],
                        queryKeys: [],
                        bodyKeys: Array.isArray(createContract.contract.requestKeys) ? createContract.contract.requestKeys.slice(0, 320) : [],
                        bodyKeyPaths: Array.isArray(createContract.contract.requestKeyPaths) ? createContract.contract.requestKeyPaths.slice(0, 1600) : [],
                        responseShape: {},
                        sampleBody: null,
                        count: toNumber(createContract.contract.count, 0),
                        source: normalizeText(createContract.contract.source || 'scene_create_contract_cache'),
                        sampledAt: createContract.contract.sampledAt || new Date().toISOString()
                    };
                    setCachedSceneLifecycleContract(targetScene, 'create', normalized);
                    return {
                        ok: true,
                        sceneName: targetScene,
                        action: normalizedAction,
                        contract: normalized,
                        fallbackUsed: true,
                        error: ''
                    };
                }
            }
            return {
                ok: false,
                sceneName: targetScene,
                action: normalizedAction,
                contract: null,
                error: 'lifecycle_contract_not_cached'
            };
        };

        const collectTopDownSections = (root) => {
            if (!root) return [];
            const entries = collectVisibleTextEntries(root);
            const dedup = new Map();
            entries.forEach(entry => {
                const text = normalizeText(entry?.text || '');
                if (!text) return;
                if (SCENE_NAME_LIST.includes(text)) return;
                const likelySection = isLikelySectionTitle(text) || SCENE_SECTION_HINT_RE.test(text);
                if (!likelySection) return;
                if (SCENE_SKIP_TEXT_RE.test(text)) return;
                if (!dedup.has(text)) {
                    dedup.set(text, {
                        title: text,
                        top: entry.top,
                        left: entry.left
                    });
                } else {
                    const prev = dedup.get(text);
                    if (entry.top < prev.top) {
                        dedup.set(text, {
                            title: text,
                            top: entry.top,
                            left: entry.left
                        });
                    }
                }
            });
            const list = Array.from(dedup.values())
                .sort((a, b) => (a.top - b.top) || (a.left - b.left))
                .slice(0, 36);
            if (!list.length) {
                return [{
                    title: 'é¡µé¢æ ¹å±‚',
                    top: Math.round(root.getBoundingClientRect().top || 0),
                    left: Math.round(root.getBoundingClientRect().left || 0),
                    bottom: Math.round((root.getBoundingClientRect().bottom || 0))
                }];
            }
            return list.map((item, idx) => ({
                ...item,
                bottom: idx < list.length - 1 ? list[idx + 1].top - 1 : Number.MAX_SAFE_INTEGER
            }));
        };

        const resolveGroupSection = (group = {}, sections = []) => {
            if (!Array.isArray(sections) || !sections.length) return 'é¡µé¢æ ¹å±‚';
            const top = toNumber(group?.top, NaN);
            if (!Number.isFinite(top)) return sections[0].title;
            const matched = sections.find(section => top >= section.top && top <= section.bottom);
            return matched?.title || sections[sections.length - 1].title;
        };

        const toLayerPathText = (layerPath = []) => layerPath.length
            ? layerPath.map(step => `${step.groupLabel || 'åˆ†ç»„'}:${step.optionText || ''}`).join(' > ')
            : '(æ ¹å±‚)';

        const normalizeSnapshotLayerPath = (layerPath = []) => (Array.isArray(layerPath) ? layerPath : []).map(step => ({
            groupKey: step?.groupKey || '',
            groupLabel: step?.groupLabel || '',
            optionText: step?.optionText || ''
        }));

        const captureEditableState = (root) => {
            if (!root) return [];
            const controls = Array.from(root.querySelectorAll('input,textarea,select'))
                .filter(el => isElementVisible(el) && !el.disabled)
                .slice(0, 240);
            return controls.map(el => ({
                el,
                tag: el.tagName.toLowerCase(),
                type: String(el.type || '').toLowerCase(),
                label: findNearestLabelText(el),
                placeholder: normalizeText(el.getAttribute?.('placeholder') || ''),
                value: String(el.value ?? ''),
                checked: !!el.checked
            }));
        };

        const dispatchControlEvents = (el) => {
            try { el.dispatchEvent(new Event('input', { bubbles: true })); } catch { }
            try { el.dispatchEvent(new Event('change', { bubbles: true })); } catch { }
            try { el.dispatchEvent(new Event('blur', { bubbles: true })); } catch { }
        };

        const restoreEditableState = (stateList = []) => {
            if (!Array.isArray(stateList) || !stateList.length) return 0;
            let restoreCount = 0;
            stateList.forEach(item => {
                const el = item?.el;
                if (!el || !el.isConnected || el.disabled) return;
                try {
                    if (item.tag === 'input' && (item.type === 'checkbox' || item.type === 'radio')) {
                        if (el.checked !== !!item.checked) {
                            el.checked = !!item.checked;
                            dispatchControlEvents(el);
                            restoreCount += 1;
                        }
                        return;
                    }
                    const nextValue = String(item.value ?? '');
                    if (String(el.value ?? '') !== nextValue) {
                        el.value = nextValue;
                        dispatchControlEvents(el);
                        restoreCount += 1;
                    }
                } catch { }
            });
            return restoreCount;
        };

        const setInputValue = (el, value) => {
            if (!el || el.disabled) return false;
            const nextValue = String(value ?? '');
            if (String(el.value ?? '') === nextValue) return false;
            el.value = nextValue;
            dispatchControlEvents(el);
            return true;
        };

        const autoFillMinimumInputs = (root, sceneName = '') => {
            if (!root) return [];
            const actions = [];
            const inputs = Array.from(root.querySelectorAll('input:not([type="radio"]):not([type="checkbox"]):not([type="hidden"]), textarea'))
                .filter(el => isElementVisible(el) && !el.disabled)
                .slice(0, 120);
            inputs.forEach(el => {
                const label = normalizeText(findNearestLabelText(el));
                const placeholder = normalizeText(el.getAttribute?.('placeholder') || '');
                const token = `${label} ${placeholder}`;
                const current = String(el.value || '').trim();
                if (!current && /é¢„ç®—/.test(token)) {
                    if (setInputValue(el, '100')) {
                        actions.push({ type: 'fill_input', field: label || placeholder || 'é¢„ç®—', value: '100' });
                    }
                    return;
                }
                if (!current && /(è®¡åˆ’åç§°|è®¡åˆ’å)/.test(token)) {
                    const value = `${sceneName || 'è®¡åˆ’'}_${todayStamp()}`;
                    if (setInputValue(el, value)) {
                        actions.push({ type: 'fill_input', field: label || placeholder || 'è®¡åˆ’åç§°', value });
                    }
                }
            });
            return actions;
        };

        const findSafeClickTargetByText = (pattern) => {
            if (!pattern) return null;
            const matcher = pattern instanceof RegExp ? pattern : new RegExp(String(pattern || ''));
            const elements = Array.from(document.querySelectorAll('button,[role="button"],a,div,span'))
                .filter(isElementVisible);
            for (const el of elements) {
                const text = normalizeText(getOwnText(el) || el.textContent || el.getAttribute?.('aria-label') || '');
                if (!text) continue;
                if (SCENE_FORBIDDEN_ACTION_RE.test(text)) continue;
                if (!matcher.test(text)) continue;
                return el;
            }
            return null;
        };

        const tryTemporaryAddItem = async (sceneName = '', scanOptions = {}) => {
            const beforeIds = extractPageAddedItemIds();
            if (!isSceneLikelyRequireItem(sceneName) || beforeIds.length) {
                return {
                    beforeIds,
                    afterIds: beforeIds.slice(),
                    tempIds: [],
                    actions: []
                };
            }
            const actions = [];
            const addBtn = findSafeClickTargetByText(/^(\+)?\s*æ·»åŠ å•†å“(\s*\d+\s*\/\s*\d+)?$/);
            if (!addBtn) {
                return {
                    beforeIds,
                    afterIds: beforeIds.slice(),
                    tempIds: [],
                    actions
                };
            }

            clickElement(addBtn);
            actions.push({ type: 'click', text: 'æ·»åŠ å•†å“' });
            await waitForDomStable(scanOptions);

            const checkbox = Array.from(document.querySelectorAll('input[type="checkbox"]'))
                .find(el => isElementVisible(el) && !el.disabled && !el.checked);
            if (checkbox) {
                clickElement(checkbox.closest('label,[role="checkbox"],span,div') || checkbox);
                actions.push({ type: 'click', text: 'å‹¾é€‰å€™é€‰å•†å“' });
                await sleep(140);
            }

            const confirmBtn = findSafeClickTargetByText(/^(ç¡®è®¤æ·»åŠ |ç¡®å®š|å®Œæˆ|åŠ å…¥è®¡åˆ’|åŠ å…¥æŠ•æ”¾|æ·»åŠ )$/);
            if (confirmBtn) {
                clickElement(confirmBtn);
                actions.push({ type: 'click', text: normalizeText(confirmBtn.textContent || 'ç¡®è®¤æ·»åŠ ') });
                await waitForDomStable(scanOptions);
            }

            const afterIds = extractPageAddedItemIds();
            const tempIds = afterIds.filter(id => !beforeIds.includes(id));
            return {
                beforeIds,
                afterIds,
                tempIds,
                actions
            };
        };

        const rollbackTemporaryItems = async (unlockState = {}, scanOptions = {}) => {
            const beforeIds = Array.isArray(unlockState?.beforeIds) ? unlockState.beforeIds : [];
            const tempIds = Array.isArray(unlockState?.tempIds) ? unlockState.tempIds : [];
            if (beforeIds.length || !tempIds.length) return 0;
            let removed = 0;
            for (let i = 0; i < tempIds.length; i++) {
                const removeBtn = findSafeClickTargetByText(/^(ç§»é™¤|åˆ é™¤)$/);
                if (!removeBtn) break;
                clickElement(removeBtn);
                removed += 1;
                await sleep(120);
                const confirmBtn = findSafeClickTargetByText(/^(ç¡®å®š|ç¡®è®¤|åˆ é™¤)$/);
                if (confirmBtn) clickElement(confirmBtn);
                await waitForDomStable(scanOptions);
            }
            return removed;
        };

        const scanSceneTopDownSettings = async (sceneName = '', options = {}) => {
            const targetSceneName = String(sceneName || '').trim();
            const maxDepth = Math.max(1, Math.min(4, toNumber(options.maxDepth, 3)));
            const maxGroupsPerLevel = Math.max(1, Math.min(8, toNumber(options.maxGroupsPerLevel, 5)));
            const maxOptionsPerGroup = Math.max(1, Math.min(10, toNumber(options.maxOptionsPerGroup, 6)));
            const maxSnapshots = Math.max(1, Math.min(96, toNumber(options.maxSnapshots, 36)));
            const baseLayerPath = normalizeSnapshotLayerPath(
                Array.isArray(options.baseLayerPath) ? options.baseLayerPath : []
            );
            const baseLayerPathText = toLayerPathText(baseLayerPath);
            const seenPathSet = new Set();
            const pathErrors = [];
            const routeSet = new Set();
            const snapshots = [];
            const sectionTrails = [];
            const aggregate = {
                ok: true,
                sceneName: targetSceneName,
                location: window.location.href,
                scannedAt: new Date().toISOString(),
                sectionTitles: [],
                sections: [],
                labels: [],
                radios: [],
                checkboxes: [],
                selects: [],
                inputs: [],
                buttonLikeOptions: [],
                optionGroups: [],
                optionTexts: [],
                textSamples: [],
                layerSnapshots: [],
                layerSummary: {},
                sectionTraversal: []
            };

            const pushSnapshot = (sectionTitle = '', layerPath = []) => {
                const snapshot = scanCurrentSceneSettings(targetSceneName, {
                    depth: layerPath.length,
                    sectionTitle: sectionTitle || '',
                    layerPath: normalizeSnapshotLayerPath(layerPath),
                    layerPathText: toLayerPathText(layerPath),
                    triggerPath: toLayerPathText(layerPath)
                });
                snapshots.push(snapshot);
                mergeSceneSchema(aggregate, snapshot);
                routeSet.add(snapshot.location);
                sectionTrails.push({
                    sectionTitle: sectionTitle || '',
                    pathText: snapshot.layerPathText || '(æ ¹å±‚)',
                    depth: layerPath.length
                });
                if (typeof options.onProgress === 'function') {
                    try {
                        options.onProgress({
                            event: 'scene_top_down_snapshot',
                            sceneName: targetSceneName,
                            sectionTitle: sectionTitle || '',
                            depth: layerPath.length,
                            pathText: snapshot.layerPathText,
                            snapshotIndex: snapshots.length,
                            maxSnapshots
                        });
                    } catch { }
                }
            };

            const scanPath = async (sectionTitle = '', layerPath = []) => {
                if (snapshots.length >= maxSnapshots) return;
                const effectivePath = baseLayerPath.concat(layerPath);
                const pathKey = `${sectionTitle || 'æ ¹å±‚'}::${effectivePath.map(step => `${step.groupKey || ''}:${step.optionText || ''}`).join('>') || '__root__'}`;
                if (seenPathSet.has(pathKey)) return;
                seenPathSet.add(pathKey);
                const depth = layerPath.length;

                try {
                    await applySceneLayerPath(targetSceneName, effectivePath, options);
                    await waitForDomStable(options);
                } catch (err) {
                    pathErrors.push({
                        sectionTitle,
                        pathText: toLayerPathText(effectivePath),
                        error: err?.message || String(err)
                    });
                    return;
                }

                pushSnapshot(sectionTitle, effectivePath);
                if (depth >= maxDepth || snapshots.length >= maxSnapshots) return;

                const root = pickPlanConfigRoot();
                const sections = collectTopDownSections(root);
                const usedGroupKeys = new Set(effectivePath.map(step => String(step?.groupKey || '')).filter(Boolean));
                const nextGroups = collectLayerControlGroups(root)
                    .filter(group => !usedGroupKeys.has(String(group?.groupKey || '')))
                    .filter(group => {
                        if (!sectionTitle || depth > 0) return true;
                        return resolveGroupSection(group, sections) === sectionTitle;
                    })
                    .slice(0, maxGroupsPerLevel);
                for (let gi = 0; gi < nextGroups.length; gi++) {
                    const group = nextGroups[gi];
                    const optionList = group.options
                        .filter(option => !option.disabled && !SCENE_FORBIDDEN_ACTION_RE.test(option.optionText || ''))
                        .slice(0, maxOptionsPerGroup);
                    for (let oi = 0; oi < optionList.length; oi++) {
                        if (snapshots.length >= maxSnapshots) return;
                        const option = optionList[oi];
                        const nextPath = layerPath.concat([{
                            groupKey: group.groupKey,
                            groupLabel: group.groupLabel,
                            optionText: option.optionText
                        }]);
                        await scanPath(sectionTitle, nextPath);
                    }
                }
            };

            await ensureSceneRoute(targetSceneName, options);
            await waitForDomStable(options);
            if (baseLayerPath.length) {
                try {
                    await applySceneLayerPath(targetSceneName, baseLayerPath, options);
                    await waitForDomStable(options);
                } catch (err) {
                    pathErrors.push({
                        sectionTitle: 'é¡µé¢æ ¹å±‚',
                        pathText: baseLayerPathText,
                        error: err?.message || String(err)
                    });
                }
            }
            const root = pickPlanConfigRoot();
            const sections = collectTopDownSections(root);
            pushSnapshot('é¡µé¢æ ¹å±‚', baseLayerPath);
            const groups = collectLayerControlGroups(root);
            const baseGroupSet = new Set(baseLayerPath.map(step => String(step?.groupKey || '')).filter(Boolean));
            for (let si = 0; si < sections.length; si++) {
                const section = sections[si];
                const sectionGroups = groups
                    .filter(group => !baseGroupSet.has(String(group?.groupKey || '')))
                    .filter(group => resolveGroupSection(group, sections) === section.title)
                    .slice(0, maxGroupsPerLevel);
                for (let gi = 0; gi < sectionGroups.length; gi++) {
                    if (snapshots.length >= maxSnapshots) break;
                    const group = sectionGroups[gi];
                    const optionList = group.options
                        .filter(option => !option.disabled && !SCENE_FORBIDDEN_ACTION_RE.test(option.optionText || ''))
                        .slice(0, maxOptionsPerGroup);
                    for (let oi = 0; oi < optionList.length; oi++) {
                        if (snapshots.length >= maxSnapshots) break;
                        const option = optionList[oi];
                        await scanPath(section.title, [{
                            groupKey: group.groupKey,
                            groupLabel: group.groupLabel,
                            optionText: option.optionText
                        }]);
                    }
                }
                if (snapshots.length >= maxSnapshots) break;
            }

            aggregate.layerSnapshots = snapshots.map(item => ({
                sceneName: item.sceneName,
                depth: item.depth,
                sectionTitle: item.sectionTitle || '',
                layerPath: item.layerPath || [],
                layerPathText: item.layerPathText || '',
                triggerPath: item.triggerPath || '',
                location: item.location,
                labels: item.labels || [],
                sectionTitles: item.sectionTitles || [],
                radios: item.radios || [],
                selects: item.selects || [],
                inputs: item.inputs || []
            }));
            aggregate.sectionTraversal = sectionTrails.slice(0, 240);
            aggregate.layerSummary = {
                mode: 'full_top_down',
                maxDepth,
                maxGroupsPerLevel,
                maxOptionsPerGroup,
                maxSnapshots,
                snapshotCount: snapshots.length,
                exploredPathCount: seenPathSet.size,
                baseLayerPath: deepClone(baseLayerPath),
                baseLayerPathText,
                routeList: Array.from(routeSet),
                errorCount: pathErrors.length,
                sectionCount: sections.length
            };
            if (pathErrors.length) {
                aggregate.layerErrors = pathErrors.slice(0, 60);
            }
            aggregate.location = window.location.href;
            aggregate.scannedAt = new Date().toISOString();
            return aggregate;
        };

        const pickGoalRuntimeSnapshot = (runtime = {}) => {
            const campaign = runtime?.solutionTemplate?.campaign || {};
            const storeData = runtime?.storeData || {};
            const out = {};
            SCENE_GOAL_RUNTIME_KEYS.forEach(key => {
                const fromStore = storeData?.[key];
                const fromCampaign = campaign?.[key];
                const fromRuntime = runtime?.[key];
                const picked = fromStore !== undefined && fromStore !== null && fromStore !== ''
                    ? fromStore
                    : (fromCampaign !== undefined && fromCampaign !== null && fromCampaign !== ''
                        ? fromCampaign
                        : fromRuntime);
                if (picked === undefined || picked === null || picked === '') return;
                out[key] = deepClone(picked);
            });
            return out;
        };

        const normalizeGoalCreateEndpoint = (path = '') => {
            const raw = String(path || '').trim();
            const normalized = normalizeCapturePath(raw);
            // ç©ºå€¼åœ¨ URL å½’ä¸€åŒ–åä¼šå˜æˆ "/"ï¼Œéœ€è¦è§†ä¸ºæ— æ•ˆå¹¶å›é€€ã€‚
            if (!raw || !normalized || normalized === '/') return SCENE_CREATE_ENDPOINT_FALLBACK;
            if (!/\/solution\/.+addList\.json$/i.test(normalized)) return normalized;
            return normalized;
        };
        const normalizeCapturedCreateEndpoint = (path = '') => {
            const raw = String(path || '').trim();
            const normalized = normalizeCapturePath(raw);
            if (!raw || !normalized || normalized === '/') return '';
            return normalized;
        };

        const buildGoalCreateContract = ({ runtime = {}, loadContracts = [], networkOnly = false } = {}) => {
            const runtimeCampaign = purgeCreateTransientFields(sanitizeCampaign(runtime?.solutionTemplate?.campaign || {}));
            const runtimeAdgroup = purgeCreateTransientFields(sanitizeAdgroup(runtime?.solutionTemplate?.adgroupList?.[0] || {}));
            const mergedContracts = mergeContractSummaries(loadContracts || []);
            const createCapture = pickGoalCreateSubmitContract(mergedContracts);
            const endpoint = normalizeGoalCreateEndpoint(
                createCapture?.path
                || resolveGoalCreateEndpoint(mergedContracts)
                || SCENE_CREATE_ENDPOINT_FALLBACK
            );
            const payloadSample = findSolutionPayloadFromSample(createCapture?.sampleBody || null);
            const requestBody = isPlainObject(payloadSample.requestBody) ? payloadSample.requestBody : {};
            const sampledSolution = isPlainObject(payloadSample.solution) ? payloadSample.solution : {};
            const sampledCampaign = isPlainObject(sampledSolution.campaign) ? sampledSolution.campaign : {};
            const sampledAdgroup = Array.isArray(sampledSolution.adgroupList) && isPlainObject(sampledSolution.adgroupList[0])
                ? sampledSolution.adgroupList[0]
                : {};
            const campaign = Object.keys(sampledCampaign).length
                ? purgeCreateTransientFields(sanitizeCampaign(sampledCampaign))
                : (networkOnly ? {} : runtimeCampaign);
            const adgroup = Object.keys(sampledAdgroup).length
                ? purgeCreateTransientFields(sanitizeAdgroup(sampledAdgroup))
                : (networkOnly ? {} : runtimeAdgroup);
            const requestKeys = Object.keys(requestBody || {}).slice(0, 240);
            const solutionKeys = Object.keys(sampledSolution || {}).slice(0, 240);
            const requestKeyPaths = flattenCaptureKeyPaths(requestBody, {
                maxDepth: 10,
                maxPaths: 1800,
                maxArrayItems: 3
            });
            const solutionKeyPaths = flattenCaptureKeyPaths(sampledSolution, {
                maxDepth: 10,
                maxPaths: 1400,
                maxArrayItems: 3
            });
            const campaignKeyPaths = flattenCaptureKeyPaths(campaign, {
                maxDepth: 10,
                maxPaths: 1200,
                maxArrayItems: 3
            });
            const adgroupKeyPaths = flattenCaptureKeyPaths(adgroup, {
                maxDepth: 10,
                maxPaths: 1200,
                maxArrayItems: 3
            });
            if (networkOnly && !createCapture) {
                return {
                    endpoint: '',
                    method: 'POST',
                    requestKeys: [],
                    requestKeyPaths: [],
                    solutionKeys: [],
                    solutionKeyPaths: [],
                    campaignKeys: [],
                    campaignKeyPaths: [],
                    adgroupKeys: [],
                    adgroupKeyPaths: [],
                    defaultCampaign: {},
                    defaultAdgroup: {},
                    source: 'network_missing'
                };
            }
            return {
                endpoint,
                method: normalizeCaptureMethod(createCapture?.method || 'POST'),
                requestKeys: requestKeys.length
                    ? requestKeys
                    : (Array.isArray(createCapture?.bodyKeys) ? createCapture.bodyKeys.slice(0, 240) : ['bizCode', 'solutionList']),
                requestKeyPaths: requestKeyPaths.length
                    ? requestKeyPaths
                    : (Array.isArray(createCapture?.bodyKeyPaths) ? createCapture.bodyKeyPaths.slice(0, 1600) : []),
                solutionKeys: solutionKeys.length
                    ? solutionKeys
                    : (networkOnly ? [] : ['bizCode', 'campaign', 'adgroupList']),
                solutionKeyPaths: solutionKeyPaths.slice(0, 1400),
                campaignKeys: Object.keys(campaign || {}).slice(0, 240),
                campaignKeyPaths: campaignKeyPaths.slice(0, 1200),
                adgroupKeys: Object.keys(adgroup || {}).slice(0, 240),
                adgroupKeyPaths: adgroupKeyPaths.slice(0, 1200),
                defaultCampaign: deepClone(campaign || {}),
                defaultAdgroup: deepClone(adgroup || {}),
                source: createCapture ? 'network_capture' : (networkOnly ? 'network_missing' : 'runtime_fallback')
            };
        };

        const normalizeGoalFieldRows = (fieldRows = []) => uniqueBy(
            (Array.isArray(fieldRows) ? fieldRows : [])
                .map(field => {
                    const label = normalizeText(field?.label || field?.settingKey || '');
                    if (!label) return null;
                    const options = uniqueBy(
                        (Array.isArray(field?.options) ? field.options : [])
                            .map(item => normalizeText(item))
                            .filter(Boolean),
                        item => item
                    ).slice(0, 48);
                    return {
                        key: normalizeSceneSpecFieldKey(label),
                        label,
                        options,
                        defaultValue: normalizeSceneSettingValue(field?.defaultValue || ''),
                        dependsOn: uniqueBy((Array.isArray(field?.dependsOn) ? field.dependsOn : []).map(item => normalizeText(item)).filter(Boolean), item => item).slice(0, 16),
                        requiredGuess: !!field?.requiredGuess,
                        criticalGuess: !!field?.criticalGuess,
                        triggerPath: normalizeText(field?.triggerPath || ''),
                        pathHints: uniqueBy((Array.isArray(field?.pathHints) ? field.pathHints : []).map(item => normalizeText(item)).filter(Boolean), item => item).slice(0, 18),
                        source: uniqueBy((Array.isArray(field?.source) ? field.source : []).map(item => normalizeText(item)).filter(Boolean), item => item).slice(0, 18)
                    };
                })
                .filter(Boolean),
            item => `${item.key}::${item.label}`
        ).slice(0, 320);

        const buildGoalFieldRowsFromSceneScan = ({
            sceneName = '',
            runtime = {},
            scanResult = null,
            scanOptions = {}
        } = {}) => {
            const sceneSpec = buildSceneSpecFromScan({
                sceneName,
                runtime,
                scanResult,
                scanMeta: {
                    scanMode: scanOptions?.scanMode || 'full_top_down',
                    unlockPolicy: scanOptions?.unlockPolicy || 'safe_only',
                    goalSpecs: [],
                    goalWarnings: [],
                    unlockActions: [],
                    warnings: []
                }
            });
            const fieldRows = normalizeGoalFieldRows(sceneSpec?.fields || []);
            const fieldMatrix = fieldRows.reduce((acc, row) => {
                acc[row.label] = {
                    options: row.options.slice(0, 48),
                    defaultValue: row.defaultValue || '',
                    requiredGuess: !!row.requiredGuess,
                    criticalGuess: !!row.criticalGuess,
                    dependsOn: row.dependsOn.slice(0, 16),
                    triggerPath: row.triggerPath || ''
                };
                return acc;
            }, {});
            return {
                fieldRows,
                fieldMatrix,
                sectionOrder: Array.isArray(sceneSpec?.sectionOrder) ? sceneSpec.sectionOrder.slice(0, 80) : [],
                fieldCoverage: {
                    fieldCount: fieldRows.length,
                    optionCount: fieldRows.reduce((sum, row) => sum + (Array.isArray(row.options) ? row.options.length : 0), 0),
                    requiredCount: fieldRows.filter(row => row.requiredGuess).length,
                    criticalCount: fieldRows.filter(row => row.criticalGuess).length,
                    sectionCount: toNumber(sceneSpec?.coverage?.sectionCount, 0),
                    snapshotCount: toNumber(sceneSpec?.coverage?.snapshotCount, 0),
                    scanMode: sceneSpec?.scanMode || scanOptions?.scanMode || 'full_top_down'
                }
            };
        };

        const buildGoalSpecFromOption = ({
            option = {},
            runtime = {},
            loadContracts = [],
            triggerPath = '',
            contractMode = '',
            fieldRows = [],
            fieldMatrix = {},
            fieldCoverage = {},
            sectionOrder = []
        } = {}) => {
            const goalLabel = normalizeGoalCandidateLabel(option?.goalLabel || option?.optionText || '');
            const runtimeSnapshot = pickGoalRuntimeSnapshot(runtime);
            const createContract = buildGoalCreateContract({
                runtime,
                loadContracts,
                networkOnly: contractMode === 'network_only'
            });
            return {
                goalKey: normalizeGoalKey(goalLabel || option?.optionText || ''),
                goalLabel: goalLabel || normalizeGoalCandidateLabel(option?.goalLabel || option?.optionText || ''),
                isDefault: !!option?.selected,
                runtimeSnapshot,
                createContract,
                loadContracts,
                triggerPath: triggerPath || toLayerPathText([{
                    groupLabel: option?.groupLabel || '',
                    optionText: option?.optionText || ''
                }]),
                groupKey: option?.groupKey || '',
                groupLabel: option?.groupLabel || '',
                fieldRows: normalizeGoalFieldRows(fieldRows),
                fieldMatrix: isPlainObject(fieldMatrix) ? deepClone(fieldMatrix) : {},
                fieldCoverage: isPlainObject(fieldCoverage) ? deepClone(fieldCoverage) : {},
                sectionOrder: uniqueBy((Array.isArray(sectionOrder) ? sectionOrder : []).map(item => normalizeText(item)).filter(Boolean), item => item).slice(0, 80)
            };
        };

        const scanSceneGoalSpecs = async (sceneName = '', options = {}) => {
            const targetSceneName = String(sceneName || '').trim();
            if (!targetSceneName) {
                return {
                    ok: false,
                    sceneName: '',
                    goals: [],
                    warnings: ['ç¼ºå°‘ sceneNameï¼Œæ— æ³•é‡‡é›†è¥é”€ç›®æ ‡é…ç½®']
                };
            }
            await ensureSceneRoute(targetSceneName, options);
            await waitForDomStable(options);
            const root = pickPlanConfigRoot();
            const goalOptions = collectMarketingGoalCandidates(root);
            const warnings = [];
            const goals = [];
            const contractMode = String(options.contractMode || '').trim();
            const goalFieldScan = options.goalFieldScan !== false;
            const goalFieldScanMode = options.goalFieldScanMode === 'visible' ? 'visible' : 'full_top_down';
            const goalFieldScanOptions = {
                scanMode: goalFieldScanMode,
                unlockPolicy: options.unlockPolicy || 'safe_only',
                maxDepth: Math.max(1, Math.min(4, toNumber(options.goalFieldMaxDepth, 2))),
                maxSnapshots: Math.max(1, Math.min(120, toNumber(options.goalFieldMaxSnapshots, 48))),
                maxGroupsPerLevel: Math.max(1, Math.min(10, toNumber(options.goalFieldMaxGroupsPerLevel, 6))),
                maxOptionsPerGroup: Math.max(1, Math.min(12, toNumber(options.goalFieldMaxOptionsPerGroup, 8)))
            };
            const captureSession = createGoalCaptureSession({
                includePattern: /\.json(?:$|\?)/i
            });
            let mark = captureSession.mark();
            if (!goalOptions.length) {
                const runtime = await getRuntimeDefaults(true);
                const fallbackGoalLabel = normalizeGoalLabel(
                    runtime?.storeData?.promotionModelMarketing
                    || runtime?.storeData?.promotionModel
                    || runtime?.storeData?.optimizeTarget
                    || runtime?.storeData?.promotionScene
                    || SCENE_SPEC_FIELD_FALLBACK[targetSceneName]?.è¥é”€ç›®æ ‡
                    || ''
                );
                const loadContracts = summarizeGoalLoadContracts(captureSession.sliceFrom(mark));
                let goalFieldRows = [];
                let goalFieldMatrix = {};
                let goalFieldCoverage = {};
                let goalSectionOrder = [];
                if (goalFieldScan) {
                    try {
                        const visibleSnapshot = scanCurrentSceneSettings(targetSceneName, {
                            depth: 0,
                            sectionTitle: 'é¡µé¢æ ¹å±‚',
                            layerPath: [],
                            layerPathText: '(æ ¹å±‚)',
                            triggerPath: '(æ ¹å±‚)'
                        });
                        visibleSnapshot.layerSnapshots = [{
                            sceneName: targetSceneName,
                            depth: 0,
                            sectionTitle: 'é¡µé¢æ ¹å±‚',
                            layerPath: [],
                            layerPathText: '(æ ¹å±‚)',
                            triggerPath: '(æ ¹å±‚)',
                            labels: visibleSnapshot.labels || [],
                            sectionTitles: visibleSnapshot.sectionTitles || [],
                            radios: visibleSnapshot.radios || [],
                            selects: visibleSnapshot.selects || [],
                            inputs: visibleSnapshot.inputs || []
                        }];
                        visibleSnapshot.layerSummary = {
                            mode: 'visible',
                            snapshotCount: 1,
                            sectionCount: (visibleSnapshot.sectionTitles || []).length || 1
                        };
                        const goalFieldBundle = buildGoalFieldRowsFromSceneScan({
                            sceneName: targetSceneName,
                            runtime,
                            scanResult: visibleSnapshot,
                            scanOptions: {
                                scanMode: 'visible',
                                unlockPolicy: options.unlockPolicy || 'safe_only'
                            }
                        });
                        goalFieldRows = goalFieldBundle.fieldRows || [];
                        goalFieldMatrix = goalFieldBundle.fieldMatrix || {};
                        goalFieldCoverage = goalFieldBundle.fieldCoverage || {};
                        goalSectionOrder = goalFieldBundle.sectionOrder || [];
                    } catch (err) {
                        warnings.push(`è¥é”€ç›®æ ‡è¡Œé…ç½®é‡‡é›†å¤±è´¥ï¼šé»˜è®¤ç›®æ ‡ -> ${err?.message || err}`);
                    }
                }
                const fallbackGoal = buildGoalSpecFromOption({
                    option: {
                        optionText: fallbackGoalLabel || `é»˜è®¤ç›®æ ‡_${targetSceneName}`,
                        selected: true,
                        groupKey: 'fallback',
                        groupLabel: 'è¥é”€ç›®æ ‡'
                    },
                    runtime,
                    loadContracts,
                    triggerPath: '(æ ¹å±‚)',
                    contractMode,
                    fieldRows: goalFieldRows,
                    fieldMatrix: goalFieldMatrix,
                    fieldCoverage: goalFieldCoverage,
                    sectionOrder: goalSectionOrder
                });
                const fallbackGoalLabels = getSceneMarketingGoalFallbackList(targetSceneName);
                const fallbackGoals = [fallbackGoal];
                fallbackGoalLabels.forEach(label => {
                    if (!label) return;
                    if (normalizeGoalCandidateLabel(fallbackGoal.goalLabel || '') === label) return;
                    const clone = deepClone(fallbackGoal);
                    clone.goalLabel = label;
                    clone.goalKey = normalizeGoalKey(label);
                    clone.isDefault = false;
                    clone.triggerPath = `è¥é”€ç›®æ ‡:${label}`;
                    fallbackGoals.push(clone);
                });
                captureSession.stop();
                return {
                    ok: true,
                    sceneName: targetSceneName,
                    scannedAt: new Date().toISOString(),
                    goals: uniqueBy(fallbackGoals, goal => `${goal.goalKey}::${goal.goalLabel}`),
                    warnings: ['æœªè¯†åˆ«åˆ°å¯ç‚¹å‡»çš„è¥é”€ç›®æ ‡é€‰é¡¹ï¼Œå·²å›é€€å½“å‰è¿è¡Œæ—¶é»˜è®¤ç›®æ ‡']
                };
            }

            for (let i = 0; i < goalOptions.length; i++) {
                const option = goalOptions[i];
                try {
                    const goalStep = {
                        groupKey: option.groupKey,
                        groupLabel: option.groupLabel,
                        optionText: option.optionText
                    };
                    await applySceneLayerPath(targetSceneName, [goalStep], options);
                    await waitForDomStable(options);
                    const runtime = await getRuntimeDefaults(true);
                    let goalFieldRows = [];
                    let goalFieldMatrix = {};
                    let goalFieldCoverage = {};
                    let goalSectionOrder = [];
                    if (goalFieldScan) {
                        try {
                            let goalFieldScanResult = null;
                            if (goalFieldScanMode === 'visible') {
                                goalFieldScanResult = scanCurrentSceneSettings(targetSceneName, {
                                    depth: 1,
                                    sectionTitle: 'é¡µé¢æ ¹å±‚',
                                    layerPath: [goalStep],
                                    layerPathText: toLayerPathText([goalStep]),
                                    triggerPath: toLayerPathText([goalStep])
                                });
                                goalFieldScanResult.layerSnapshots = [{
                                    sceneName: targetSceneName,
                                    depth: 1,
                                    sectionTitle: 'é¡µé¢æ ¹å±‚',
                                    layerPath: [goalStep],
                                    layerPathText: toLayerPathText([goalStep]),
                                    triggerPath: toLayerPathText([goalStep]),
                                    labels: goalFieldScanResult.labels || [],
                                    sectionTitles: goalFieldScanResult.sectionTitles || [],
                                    radios: goalFieldScanResult.radios || [],
                                    selects: goalFieldScanResult.selects || [],
                                    inputs: goalFieldScanResult.inputs || []
                                }];
                                goalFieldScanResult.layerSummary = {
                                    mode: 'visible',
                                    snapshotCount: 1,
                                    sectionCount: (goalFieldScanResult.sectionTitles || []).length || 1
                                };
                            } else {
                                goalFieldScanResult = await scanSceneTopDownSettings(targetSceneName, {
                                    ...options,
                                    maxDepth: goalFieldScanOptions.maxDepth,
                                    maxSnapshots: goalFieldScanOptions.maxSnapshots,
                                    maxGroupsPerLevel: goalFieldScanOptions.maxGroupsPerLevel,
                                    maxOptionsPerGroup: goalFieldScanOptions.maxOptionsPerGroup,
                                    baseLayerPath: [goalStep]
                                });
                            }
                            const goalFieldBundle = buildGoalFieldRowsFromSceneScan({
                                sceneName: targetSceneName,
                                runtime,
                                scanResult: goalFieldScanResult,
                                scanOptions: goalFieldScanOptions
                            });
                            goalFieldRows = goalFieldBundle.fieldRows || [];
                            goalFieldMatrix = goalFieldBundle.fieldMatrix || {};
                            goalFieldCoverage = goalFieldBundle.fieldCoverage || {};
                            goalSectionOrder = goalFieldBundle.sectionOrder || [];
                        } catch (err) {
                            warnings.push(`è¥é”€ç›®æ ‡è¡Œé…ç½®é‡‡é›†å¤±è´¥ï¼š${option.optionText || 'æœªçŸ¥é€‰é¡¹'} -> ${err?.message || err}`);
                        }
                    }
                    const delta = captureSession.sliceFrom(mark);
                    mark = captureSession.mark();
                    const loadContracts = summarizeGoalLoadContracts(delta);
                    goals.push(buildGoalSpecFromOption({
                        option,
                        runtime,
                        loadContracts,
                        triggerPath: toLayerPathText([{
                            groupKey: option.groupKey,
                            groupLabel: option.groupLabel,
                            optionText: option.optionText
                        }]),
                        contractMode,
                        fieldRows: goalFieldRows,
                        fieldMatrix: goalFieldMatrix,
                        fieldCoverage: goalFieldCoverage,
                        sectionOrder: goalSectionOrder
                    }));
                } catch (err) {
                    warnings.push(`è¥é”€ç›®æ ‡é‡‡é›†å¤±è´¥ï¼š${option.optionText || 'æœªçŸ¥é€‰é¡¹'} -> ${err?.message || err}`);
                }
            }
            captureSession.stop();

            const dedupGoals = uniqueBy(
                goals.filter(goal => goal.goalLabel),
                goal => `${goal.goalKey}::${goal.goalLabel}`
            );
            const fallbackGoalLabels = getSceneMarketingGoalFallbackList(targetSceneName);
            if (fallbackGoalLabels.length && dedupGoals.length) {
                const existingGoalSet = new Set(
                    dedupGoals
                        .map(goal => normalizeGoalCandidateLabel(goal?.goalLabel || ''))
                        .filter(Boolean)
                );
                let addedFallbackCount = 0;
                fallbackGoalLabels.forEach(label => {
                    if (existingGoalSet.has(label)) return;
                    const sample = dedupGoals[0] || {};
                    const clone = deepClone(sample);
                    clone.goalLabel = label;
                    clone.goalKey = normalizeGoalKey(label);
                    clone.isDefault = false;
                    clone.triggerPath = clone.triggerPath || `è¥é”€ç›®æ ‡:${label}`;
                    dedupGoals.push(clone);
                    existingGoalSet.add(label);
                    addedFallbackCount += 1;
                });
                if (addedFallbackCount > 0) {
                    warnings.push(`åœºæ™¯ã€Œ${targetSceneName}ã€è¥é”€ç›®æ ‡è¯†åˆ«ä¸è¶³ï¼Œå·²è¡¥é½å…œåº•ç›®æ ‡ ${addedFallbackCount} æ¡`);
                }
            }
            if (dedupGoals.length && !dedupGoals.some(goal => goal.isDefault)) {
                dedupGoals[0].isDefault = true;
            }
            return {
                ok: true,
                sceneName: targetSceneName,
                scannedAt: new Date().toISOString(),
                goals: dedupGoals,
                warnings
            };
        };

        const deriveTemplateSceneSettings = (runtime = {}) => {
            const campaign = runtime?.solutionTemplate?.campaign || {};
            const out = {};
            const bidType = mapSceneBidTypeValue(campaign.bidTypeV2 || runtime.bidTypeV2 || '');
            const bidTarget = mapSceneBidTargetValue(campaign.bidTargetV2 || campaign.optimizeTarget || runtime.bidTargetV2 || '');
            const budgetType = mapSceneBudgetTypeValue(campaign.dmcType || runtime.dmcType || '');
            if (bidType === 'smart_bid') out.å‡ºä»·æ–¹å¼ = 'æ™ºèƒ½å‡ºä»·';
            if (bidType === 'manual_bid') out.å‡ºä»·æ–¹å¼ = 'æ‰‹åŠ¨å‡ºä»·';
            if (bidTarget) {
                const map = {
                    conv: 'è·å–æˆäº¤é‡',
                    roi: 'ç¨³å®šæŠ•äº§æ¯”',
                    click: 'å¢åŠ ç‚¹å‡»é‡',
                    fav_cart: 'å¢åŠ æ”¶è—åŠ è´­é‡',
                    coll_cart: 'å¢åŠ æ”¶è—åŠ è´­é‡',
                    market_penetration: 'æå‡å¸‚åœºæ¸—é€',
                    word_penetration_rate: 'æå‡å¸‚åœºæ¸—é€',
                    similar_item: 'ç›¸ä¼¼å“è·ŸæŠ•',
                    search_rank: 'æŠ¢å æœç´¢å¡ä½',
                    display_shentou: 'æ‹‰æ–°æ¸—é€'
                };
                out.å‡ºä»·ç›®æ ‡ = map[bidTarget] || '';
            }
            if (budgetType === 'day_average') out.é¢„ç®—ç±»å‹ = 'æ—¥å‡é¢„ç®—';
            if (budgetType === 'normal') out.é¢„ç®—ç±»å‹ = 'æ¯æ—¥é¢„ç®—';
            if (campaign.campaignName) out.è®¡åˆ’åç§° = String(campaign.campaignName).trim();
            return Object.keys(out).reduce((acc, key) => {
                if (!out[key]) return acc;
                acc[key] = out[key];
                return acc;
            }, {});
        };

        const buildSceneSpecFromScan = ({ sceneName = '', runtime = {}, scanResult = null, scanMeta = {} }) => {
            const targetScene = String(sceneName || '').trim();
            const source = isPlainObject(scanResult) ? scanResult : {};
            const snapshots = Array.isArray(source.layerSnapshots) ? source.layerSnapshots : [];
            const sections = collectTopDownSections(pickPlanConfigRoot());
            const templateDefaults = deriveTemplateSceneSettings(runtime);
            const fallbackDefaults = isPlainObject(SCENE_SPEC_FIELD_FALLBACK[targetScene]) ? SCENE_SPEC_FIELD_FALLBACK[targetScene] : {};
            const fieldMap = new Map();

            const pushField = (label = '', patch = {}) => {
                const fieldLabel = normalizeText(label);
                if (!fieldLabel || !isLikelyFieldLabel(fieldLabel)) return;
                const key = normalizeSceneSpecFieldKey(fieldLabel);
                const current = fieldMap.get(key) || {
                    key,
                    label: fieldLabel,
                    settingKey: fieldLabel,
                    options: [],
                    pathHints: [],
                    triggerPath: '',
                    dependsOn: inferSceneFieldDependsOn(fieldLabel),
                    requiredGuess: SCENE_REQUIRED_GUESS_RE.test(fieldLabel),
                    defaultValue: '',
                    source: []
                };
                const mergedOptions = uniqueBy((current.options || []).concat((patch.options || []).map(item => normalizeText(item)).filter(Boolean)), item => item).slice(0, 36);
                const mergedHints = uniqueBy((current.pathHints || []).concat((patch.pathHints || []).map(item => normalizeText(item)).filter(Boolean)), item => item).slice(0, 16);
                const mergedSource = uniqueBy((current.source || []).concat((patch.source || []).map(item => normalizeText(item)).filter(Boolean)), item => item).slice(0, 12);
                const defaultValue = normalizeSceneSettingValue(
                    patch.defaultValue
                    || current.defaultValue
                    || templateDefaults[fieldLabel]
                    || fallbackDefaults[fieldLabel]
                    || ''
                );
                fieldMap.set(key, {
                    ...current,
                    ...patch,
                    label: fieldLabel,
                    settingKey: fieldLabel,
                    options: mergedOptions,
                    pathHints: mergedHints,
                    source: mergedSource,
                    triggerPath: patch.triggerPath || current.triggerPath || '',
                    dependsOn: uniqueBy((current.dependsOn || []).concat((patch.dependsOn || []).map(item => normalizeText(item)).filter(Boolean)), item => item).slice(0, 10),
                    requiredGuess: patch.requiredGuess === true || current.requiredGuess === true,
                    defaultValue
                });
            };

            (source.labels || []).forEach(label => pushField(label, { source: ['label'] }));
            (source.sectionTitles || []).forEach(label => pushField(label, { source: ['section_title'], pathHints: [label] }));
            (source.sections || []).forEach(section => {
                pushField(section?.title || '', {
                    options: Array.isArray(section?.options) ? section.options : [],
                    source: ['section_options'],
                    pathHints: [section?.title || '']
                });
            });
            (source.selects || []).forEach(selectItem => {
                const selectedOption = (selectItem?.options || []).find(opt => opt?.selected) || null;
                pushField(selectItem?.label || '', {
                    options: (selectItem?.options || []).map(opt => opt?.label || opt?.value || ''),
                    defaultValue: selectedOption?.label || selectedOption?.value || selectItem?.value || '',
                    source: ['select']
                });
            });
            const radioMap = new Map();
            (source.radios || []).forEach(radio => {
                const label = normalizeText(radio?.label || '');
                if (!label) return;
                if (!radioMap.has(label)) {
                    radioMap.set(label, {
                        options: [],
                        selected: ''
                    });
                }
                const bucket = radioMap.get(label);
                const optionText = normalizeText(radio?.text || '');
                if (optionText) bucket.options.push(optionText);
                if (radio?.checked && optionText) bucket.selected = optionText;
            });
            radioMap.forEach((bucket, label) => {
                pushField(label, {
                    options: bucket.options,
                    defaultValue: bucket.selected,
                    source: ['radio']
                });
            });
            (source.inputs || []).forEach(input => {
                pushField(input?.label || '', {
                    defaultValue: input?.value || '',
                    source: ['input']
                });
            });

            snapshots.forEach(snapshot => {
                const pathText = String(snapshot?.layerPathText || '').trim();
                const sectionTitle = String(snapshot?.sectionTitle || '').trim();
                const labels = uniqueBy([
                    ...((snapshot?.labels || []).filter(Boolean)),
                    ...((snapshot?.sectionTitles || []).filter(Boolean)),
                    ...((snapshot?.selects || []).map(item => item?.label || '').filter(Boolean)),
                    ...((snapshot?.inputs || []).map(item => item?.label || '').filter(Boolean)),
                    ...((snapshot?.radios || []).map(item => item?.label || '').filter(Boolean))
                ], item => item);
                labels.forEach(label => {
                    const key = normalizeSceneSpecFieldKey(label);
                    if (!fieldMap.has(key)) return;
                    const current = fieldMap.get(key);
                    if (!current.triggerPath && pathText) {
                        current.triggerPath = pathText;
                    }
                    if (sectionTitle) {
                        current.pathHints = uniqueBy((current.pathHints || []).concat([sectionTitle]), item => item).slice(0, 16);
                    }
                    fieldMap.set(key, current);
                });
            });

            Object.keys(templateDefaults).forEach(label => {
                pushField(label, {
                    defaultValue: templateDefaults[label],
                    source: ['runtime_template']
                });
            });
            Object.keys(fallbackDefaults).forEach(label => {
                pushField(label, {
                    defaultValue: fallbackDefaults[label],
                    source: ['scene_fallback']
                });
            });

            const fields = Array.from(fieldMap.values())
                .map(field => ({
                    key: field.key,
                    label: field.label,
                    settingKey: field.settingKey,
                    options: field.options || [],
                    pathHints: field.pathHints || [],
                    triggerPath: field.triggerPath || '',
                    dependsOn: field.dependsOn || [],
                    requiredGuess: !!field.requiredGuess,
                    defaultValue: normalizeSceneSettingValue(field.defaultValue || ''),
                    source: (field.source || []).filter(Boolean),
                    criticalGuess: isLikelyCriticalSceneField(field.label)
                }))
                .sort((a, b) => {
                    const ai = a.pathHints?.[0] ? sections.findIndex(section => section.title === a.pathHints[0]) : -1;
                    const bi = b.pathHints?.[0] ? sections.findIndex(section => section.title === b.pathHints[0]) : -1;
                    if (ai !== bi) return (ai < 0 ? 999 : ai) - (bi < 0 ? 999 : bi);
                    return a.label.localeCompare(b.label, 'zh-CN');
                });

            const optionCount = fields.reduce((sum, field) => sum + (Array.isArray(field.options) ? field.options.length : 0), 0);
            const goals = uniqueBy(
                (Array.isArray(scanMeta?.goalSpecs) ? scanMeta.goalSpecs : [])
                    .map(goal => ({
                        goalKey: normalizeGoalKey(goal?.goalKey || goal?.goalLabel || ''),
                        goalLabel: normalizeGoalLabel(goal?.goalLabel || ''),
                        isDefault: !!goal?.isDefault,
                        runtimeSnapshot: isPlainObject(goal?.runtimeSnapshot) ? deepClone(goal.runtimeSnapshot) : {},
                        createContract: isPlainObject(goal?.createContract) ? deepClone(goal.createContract) : {},
                        loadContracts: Array.isArray(goal?.loadContracts) ? deepClone(goal.loadContracts) : [],
                        triggerPath: normalizeText(goal?.triggerPath || ''),
                        groupKey: normalizeText(goal?.groupKey || ''),
                        groupLabel: normalizeText(goal?.groupLabel || ''),
                        fieldRows: normalizeGoalFieldRows(goal?.fieldRows || goal?.settingsRows || []),
                        fieldMatrix: isPlainObject(goal?.fieldMatrix) ? deepClone(goal.fieldMatrix) : {},
                        fieldCoverage: isPlainObject(goal?.fieldCoverage) ? deepClone(goal.fieldCoverage) : {},
                        sectionOrder: uniqueBy((Array.isArray(goal?.sectionOrder) ? goal.sectionOrder : []).map(item => normalizeText(item)).filter(Boolean), item => item).slice(0, 80)
                    }))
                    .filter(goal => goal.goalLabel),
                goal => `${goal.goalKey}::${goal.goalLabel}`
            ).slice(0, 24);
            if (goals.length && !goals.some(goal => goal.isDefault)) {
                goals[0].isDefault = true;
            }
            const goalWarnings = Array.isArray(scanMeta?.goalWarnings)
                ? uniqueBy(scanMeta.goalWarnings.map(item => normalizeText(item)).filter(Boolean), item => item).slice(0, 80)
                : [];
            return {
                ok: true,
                sceneName: targetScene,
                bizCode: resolveSceneBizCodeHint(targetScene) || runtime?.bizCode || '',
                location: source.location || window.location.href,
                scannedAt: new Date().toISOString(),
                scanMode: scanMeta.scanMode || 'full_top_down',
                unlockPolicy: scanMeta.unlockPolicy || 'auto_rollback',
                fields,
                goals,
                sectionOrder: uniqueBy((sections || []).map(section => section.title).filter(Boolean), item => item),
                coverage: {
                    sectionCount: (sections || []).length || (source.sectionTitles || []).length,
                    fieldCount: fields.length,
                    optionCount,
                    goalCount: goals.length,
                    snapshotCount: source?.layerSummary?.snapshotCount || snapshots.length || 1,
                    unlockActions: Array.isArray(scanMeta.unlockActions) ? scanMeta.unlockActions.length : 0,
                    warnings: Array.isArray(scanMeta.warnings) ? scanMeta.warnings.slice(0, 80) : []
                },
                goalCoverage: {
                    goalCount: goals.length,
                    defaultGoal: (goals.find(goal => goal.isDefault) || goals[0] || null)?.goalLabel || '',
                    goalFieldCount: goals.reduce((sum, goal) => sum + (Array.isArray(goal?.fieldRows) ? goal.fieldRows.length : 0), 0),
                    goalOptionCount: goals.reduce((sum, goal) => sum + (Array.isArray(goal?.fieldRows)
                        ? goal.fieldRows.reduce((acc, field) => acc + (Array.isArray(field?.options) ? field.options.length : 0), 0)
                        : 0), 0),
                    goalsWithFieldRows: goals.filter(goal => Array.isArray(goal?.fieldRows) && goal.fieldRows.length > 0).length,
                    goalsWithOptionRows: goals.filter(goal => Array.isArray(goal?.fieldRows) && goal.fieldRows.some(field => Array.isArray(field?.options) && field.options.length >= 2)).length,
                    warnings: goalWarnings
                },
                rawSamples: {
                    labels: (source.labels || []).slice(0, 240),
                    sectionTitles: (source.sectionTitles || []).slice(0, 120),
                    sections: (source.sections || []).slice(0, 120),
                    radios: (source.radios || []).slice(0, 160),
                    selects: (source.selects || []).slice(0, 160),
                    inputs: (source.inputs || []).slice(0, 200),
                    layerSnapshots: snapshots.slice(0, 60)
                },
                triggerPaths: (source.sectionTraversal || []).slice(0, 240)
            };
        };

        const scanSceneSpec = async (sceneName, options = {}) => {
            const targetScene = String(sceneName || '').trim();
            if (!targetScene) {
                return {
                    ok: false,
                    sceneName: '',
                    error: 'ç¼ºå°‘ sceneName'
                };
            }
            const normalizedOptions = normalizeSceneSpecOptions(options);
            const sceneBizCode = resolveSceneBizCodeHint(targetScene) || SCENE_BIZCODE_HINT_FALLBACK[targetScene] || '';
            if (!normalizedOptions.refresh) {
                const cached = getCachedSceneSpec(targetScene, sceneBizCode);
                if (cached) return cached;
            }

            const initialHash = window.location.hash;
            const initialScene = inferCurrentSceneName();
            const initialRoot = pickPlanConfigRoot();
            const controlState = captureEditableState(initialRoot);
            const warnings = [];
            let unlockActions = [];
            let tempUnlockState = {
                beforeIds: [],
                afterIds: [],
                tempIds: [],
                actions: []
            };

            try {
                await ensureSceneRoute(targetScene, normalizedOptions);
                await waitForDomStable(normalizedOptions);
                const activeRoot = pickPlanConfigRoot();
                if (normalizedOptions.unlockPolicy !== 'manual') {
                    unlockActions = unlockActions.concat(autoFillMinimumInputs(activeRoot, targetScene));
                }
                if (normalizedOptions.unlockPolicy === 'auto_rollback') {
                    tempUnlockState = await tryTemporaryAddItem(targetScene, normalizedOptions);
                    unlockActions = unlockActions.concat(tempUnlockState.actions || []);
                }

                let scanResult = null;
                let goalSpecs = [];
                let goalWarnings = [];
                if (normalizedOptions.scanMode === 'visible') {
                    scanResult = scanCurrentSceneSettings(targetScene, {
                        depth: 0,
                        sectionTitle: 'é¡µé¢æ ¹å±‚',
                        layerPath: [],
                        layerPathText: '(æ ¹å±‚)',
                        triggerPath: '(æ ¹å±‚)'
                    });
                    scanResult.layerSnapshots = [{
                        sceneName: targetScene,
                        depth: 0,
                        sectionTitle: 'é¡µé¢æ ¹å±‚',
                        layerPath: [],
                        layerPathText: '(æ ¹å±‚)',
                        triggerPath: '(æ ¹å±‚)',
                        labels: scanResult.labels || [],
                        sectionTitles: scanResult.sectionTitles || [],
                        radios: scanResult.radios || [],
                        selects: scanResult.selects || [],
                        inputs: scanResult.inputs || []
                    }];
                    scanResult.layerSummary = {
                        mode: 'visible',
                        snapshotCount: 1,
                        sectionCount: (scanResult.sectionTitles || []).length || 1
                    };
                } else {
                    scanResult = await scanSceneTopDownSettings(targetScene, normalizedOptions);
                }
                if (normalizedOptions.goalScan) {
                    try {
                        const goalScanResult = await scanSceneGoalSpecs(targetScene, normalizedOptions);
                        if (Array.isArray(goalScanResult?.goals)) {
                            goalSpecs = goalScanResult.goals.slice(0, 24);
                        }
                        if (Array.isArray(goalScanResult?.warnings)) {
                            goalWarnings = goalScanResult.warnings
                                .map(item => normalizeText(item))
                                .filter(Boolean)
                                .slice(0, 80);
                        }
                    } catch (err) {
                        goalWarnings.push(`è¥é”€ç›®æ ‡é‡‡é›†å¤±è´¥: ${err?.message || err}`);
                    }
                }

                const runtime = await getRuntimeDefaults(false);
                const spec = buildSceneSpecFromScan({
                    sceneName: targetScene,
                    runtime,
                    scanResult,
                    scanMeta: {
                        scanMode: normalizedOptions.scanMode,
                        unlockPolicy: normalizedOptions.unlockPolicy,
                        unlockActions,
                        warnings,
                        goalSpecs,
                        goalWarnings
                    }
                });
                setCachedSceneSpec(targetScene, sceneBizCode, spec);
                return spec;
            } catch (err) {
                return {
                    ok: false,
                    sceneName: targetScene,
                    scannedAt: new Date().toISOString(),
                    location: window.location.href,
                    error: err?.message || String(err)
                };
            } finally {
                if (normalizedOptions.unlockPolicy === 'auto_rollback') {
                    try {
                        await rollbackTemporaryItems(tempUnlockState, normalizedOptions);
                    } catch (err) {
                        warnings.push(`å›æ»šä¸´æ—¶å•†å“å¤±è´¥: ${err?.message || err}`);
                    }
                    try {
                        restoreEditableState(controlState);
                    } catch (err) {
                        warnings.push(`å›æ»šè¾“å…¥å€¼å¤±è´¥: ${err?.message || err}`);
                    }
                }
                if (normalizedOptions.restore) {
                    try {
                        if (initialHash && window.location.hash !== initialHash) {
                            window.location.hash = initialHash;
                            await waitForDomStable(normalizedOptions);
                        }
                        if (initialScene && SCENE_NAME_LIST.includes(initialScene)) {
                            await clickScene(initialScene, normalizedOptions);
                        }
                    } catch { }
                }
            }
        };

        const scanAllSceneSpecs = async (options = {}) => {
            const normalizedOptions = normalizeSceneSpecOptions(options);
            const scenes = Array.isArray(options.scenes) && options.scenes.length
                ? uniqueBy(options.scenes.map(item => String(item || '').trim()).filter(Boolean), item => item)
                : SCENE_NAME_LIST.slice();
            const initialHash = window.location.hash;
            const initialScene = inferCurrentSceneName();
            const list = [];
            for (let i = 0; i < scenes.length; i++) {
                const sceneName = scenes[i];
                if (typeof options.onProgress === 'function') {
                    try { options.onProgress({ event: 'scene_spec_start', sceneName, index: i + 1, total: scenes.length }); } catch { }
                }
                const result = await scanSceneSpec(sceneName, {
                    ...normalizedOptions,
                    restore: false,
                    refresh: options.refresh === true
                });
                list.push(result);
                if (typeof options.onProgress === 'function') {
                    try {
                        options.onProgress({
                            event: 'scene_spec_done',
                            sceneName,
                            index: i + 1,
                            total: scenes.length,
                            ok: !!result?.ok,
                            fieldCount: result?.coverage?.fieldCount || 0,
                            snapshotCount: result?.coverage?.snapshotCount || 0
                        });
                    } catch { }
                }
            }

            if (normalizedOptions.restore) {
                try {
                    if (initialHash && window.location.hash !== initialHash) {
                        window.location.hash = initialHash;
                        await waitForDomStable(normalizedOptions);
                    }
                    if (initialScene && SCENE_NAME_LIST.includes(initialScene)) {
                        await clickScene(initialScene, normalizedOptions);
                    }
                } catch { }
            }

            return {
                ok: list.every(item => item?.ok),
                scannedAt: new Date().toISOString(),
                scanMode: normalizedOptions.scanMode,
                unlockPolicy: normalizedOptions.unlockPolicy,
                sceneOrder: scenes,
                count: list.length,
                successCount: list.filter(item => item?.ok).length,
                failCount: list.filter(item => !item?.ok).length,
                list
            };
        };

        const getSceneSpec = async (sceneName = '', options = {}) => {
            const targetScene = String(sceneName || inferCurrentSceneName() || '').trim();
            if (!targetScene) {
                return {
                    ok: false,
                    error: 'ç¼ºå°‘ sceneName'
                };
            }
            const sceneBizCode = resolveSceneBizCodeHint(targetScene) || SCENE_BIZCODE_HINT_FALLBACK[targetScene] || '';
            if (!options.refresh) {
                const cached = getCachedSceneSpec(targetScene, sceneBizCode);
                if (cached) return cached;
            }
            return scanSceneSpec(targetScene, {
                ...options,
                refresh: true
            });
        };

        const resolveGoalSpecForScene = ({
            sceneName = '',
            sceneSpec = null,
            marketingGoal = '',
            runtime = {}
        } = {}) => {
            const warnings = [];
            const targetScene = String(sceneName || '').trim();
            const requestGoalRaw = normalizeGoalCandidateLabel(marketingGoal);
            const availableGoals = Array.isArray(sceneSpec?.goals)
                ? sceneSpec.goals
                    .map(goal => ({
                        ...goal,
                        goalLabel: normalizeGoalCandidateLabel(goal?.goalLabel || ''),
                        goalKey: normalizeGoalKey(goal?.goalKey || goal?.goalLabel || '')
                    }))
                    .filter(goal => goal.goalLabel)
                : [];
            const fallbackDefaultLabel = normalizeGoalCandidateLabel(
                SCENE_SPEC_FIELD_FALLBACK[targetScene]?.è¥é”€ç›®æ ‡
                || runtime?.storeData?.promotionModelMarketing
                || runtime?.storeData?.promotionModel
                || runtime?.storeData?.optimizeTarget
                || runtime?.storeData?.promotionScene
                || ''
            );
            if (!availableGoals.length) {
                const resolved = requestGoalRaw || fallbackDefaultLabel || '';
                const fallbackUsed = !requestGoalRaw && !!resolved;
                if (!requestGoalRaw && resolved) {
                    warnings.push(`marketingGoal ç¼ºå¤±ï¼Œå·²å›é€€é»˜è®¤ç›®æ ‡ï¼š${resolved}`);
                } else if (requestGoalRaw && !resolved) {
                    warnings.push(`marketingGoalã€Œ${requestGoalRaw}ã€æ— æ³•è¯†åˆ«ï¼Œä¸”å½“å‰åœºæ™¯æ— å¯ç”¨é»˜è®¤ç›®æ ‡`);
                }
                return {
                    goalSpec: null,
                    resolvedMarketingGoal: resolved,
                    goalFallbackUsed: fallbackUsed,
                    goalWarnings: warnings,
                    availableGoalLabels: []
                };
            }

            const defaultGoal = availableGoals.find(goal => goal.isDefault) || availableGoals[0];
            if (!requestGoalRaw) {
                warnings.push(`marketingGoal ç¼ºå¤±ï¼Œå·²å›é€€é»˜è®¤ç›®æ ‡ï¼š${defaultGoal.goalLabel}`);
                return {
                    goalSpec: defaultGoal,
                    resolvedMarketingGoal: defaultGoal.goalLabel,
                    goalFallbackUsed: true,
                    goalWarnings: warnings,
                    availableGoalLabels: availableGoals.map(goal => goal.goalLabel)
                };
            }

            const normalizedRequestGoalKey = normalizeGoalKey(requestGoalRaw);
            const exactMatch = availableGoals.find(goal => goal.goalLabel === requestGoalRaw)
                || availableGoals.find(goal => goal.goalKey === normalizedRequestGoalKey);
            if (exactMatch) {
                return {
                    goalSpec: exactMatch,
                    resolvedMarketingGoal: exactMatch.goalLabel,
                    goalFallbackUsed: false,
                    goalWarnings: warnings,
                    availableGoalLabels: availableGoals.map(goal => goal.goalLabel)
                };
            }
            const fuzzyMatch = availableGoals.find(goal => goal.goalLabel.includes(requestGoalRaw) || requestGoalRaw.includes(goal.goalLabel));
            if (fuzzyMatch) {
                return {
                    goalSpec: fuzzyMatch,
                    resolvedMarketingGoal: fuzzyMatch.goalLabel,
                    goalFallbackUsed: false,
                    goalWarnings: warnings,
                    availableGoalLabels: availableGoals.map(goal => goal.goalLabel)
                };
            }

            warnings.push(`marketingGoalã€Œ${requestGoalRaw}ã€æœªå‘½ä¸­ï¼Œå·²å›é€€é»˜è®¤ç›®æ ‡ï¼š${defaultGoal.goalLabel}`);
            return {
                goalSpec: defaultGoal,
                resolvedMarketingGoal: defaultGoal.goalLabel,
                goalFallbackUsed: true,
                goalWarnings: warnings,
                availableGoalLabels: availableGoals.map(goal => goal.goalLabel)
            };
        };

        const buildGoalContractDefaults = (goalSpec = null, context = {}) => {
            const normalizedGoalSpec = isPlainObject(goalSpec) ? goalSpec : {};
            const runtimeSnapshot = isPlainObject(normalizedGoalSpec.runtimeSnapshot)
                ? normalizedGoalSpec.runtimeSnapshot
                : {};
            const createContract = isPlainObject(normalizedGoalSpec.createContract)
                ? normalizedGoalSpec.createContract
                : {};
            const sceneName = String(context?.sceneName || '').trim();
            const goalLabel = normalizeGoalCandidateLabel(
                context?.goalLabel
                || normalizedGoalSpec?.goalLabel
                || ''
            );
            const cachedContract = sceneName
                ? (
                    getCachedSceneCreateContract(sceneName, goalLabel)
                    || getCachedSceneCreateContract(sceneName, '')
                )
                : null;
            const defaultCampaign = isPlainObject(createContract.defaultCampaign)
                ? createContract.defaultCampaign
                : {};
            const defaultAdgroup = isPlainObject(createContract.defaultAdgroup)
                ? createContract.defaultAdgroup
                : {};
            const campaignOverride = {};
            const adgroupOverride = {};
            const runtimePatch = {};

            GOAL_CONTRACT_RUNTIME_PATCH_KEYS.forEach(key => {
                let value = runtimeSnapshot[key];
                if (value === undefined || value === null || value === '') {
                    value = defaultCampaign[key];
                }
                if (value === undefined || value === null || value === '') return;
                campaignOverride[key] = deepClone(value);
            });

            if (sceneName === 'å…³é”®è¯æ¨å¹¿') {
                const keywordGoalRuntime = resolveKeywordGoalRuntimeFallback(goalLabel);
                if (keywordGoalRuntime.promotionScene && !campaignOverride.promotionScene) {
                    campaignOverride.promotionScene = keywordGoalRuntime.promotionScene;
                }
                if (keywordGoalRuntime.itemSelectedMode && !campaignOverride.itemSelectedMode) {
                    campaignOverride.itemSelectedMode = keywordGoalRuntime.itemSelectedMode;
                }
                if (keywordGoalRuntime.bidTargetV2 && !campaignOverride.bidTargetV2) {
                    campaignOverride.bidTargetV2 = keywordGoalRuntime.bidTargetV2;
                }
                if (keywordGoalRuntime.optimizeTarget && !campaignOverride.optimizeTarget) {
                    campaignOverride.optimizeTarget = keywordGoalRuntime.optimizeTarget;
                }
            }

            if (campaignOverride.promotionScene) runtimePatch.promotionScene = campaignOverride.promotionScene;
            if (campaignOverride.itemSelectedMode) runtimePatch.itemSelectedMode = campaignOverride.itemSelectedMode;
            if (campaignOverride.bidTypeV2) runtimePatch.bidTypeV2 = campaignOverride.bidTypeV2;
            if (campaignOverride.bidTargetV2) runtimePatch.bidTargetV2 = campaignOverride.bidTargetV2;
            if (campaignOverride.dmcType) runtimePatch.dmcType = campaignOverride.dmcType;
            if (campaignOverride.subPromotionType) runtimePatch.subPromotionType = campaignOverride.subPromotionType;
            if (campaignOverride.promotionType) runtimePatch.promotionType = campaignOverride.promotionType;
            if (campaignOverride.optimizeTarget) runtimePatch.optimizeTarget = campaignOverride.optimizeTarget;

            if (Array.isArray(defaultAdgroup.rightList)) {
                adgroupOverride.rightList = deepClone(defaultAdgroup.rightList);
            }
            if (defaultAdgroup.smartCreative !== undefined && defaultAdgroup.smartCreative !== null && defaultAdgroup.smartCreative !== '') {
                adgroupOverride.smartCreative = deepClone(defaultAdgroup.smartCreative);
            }

            const endpoint = normalizeGoalCreateEndpoint(
                createContract.endpoint
                || cachedContract?.endpoint
                || resolveGoalCreateEndpoint(normalizedGoalSpec.loadContracts || [])
                || SCENE_CREATE_ENDPOINT_FALLBACK
            );
            const mergeContractKeys = (contractRef = null, key = '', limit = 320) => uniqueBy(
                (Array.isArray(createContract?.[key]) ? createContract[key] : [])
                    .concat(Array.isArray(contractRef?.[key]) ? contractRef[key] : [])
                    .map(item => normalizeText(item))
                    .filter(Boolean),
                item => item
            ).slice(0, Math.max(40, Math.min(2000, toNumber(limit, 320))));
            const contractHints = {
                source: normalizeText(createContract?.source || cachedContract?.source || ''),
                requestKeys: mergeContractKeys(cachedContract, 'requestKeys'),
                requestKeyPaths: mergeContractKeys(cachedContract, 'requestKeyPaths', 1600),
                solutionKeys: mergeContractKeys(cachedContract, 'solutionKeys'),
                solutionKeyPaths: mergeContractKeys(cachedContract, 'solutionKeyPaths', 1400),
                campaignKeys: mergeContractKeys(cachedContract, 'campaignKeys'),
                campaignKeyPaths: mergeContractKeys(cachedContract, 'campaignKeyPaths', 1200),
                adgroupKeys: mergeContractKeys(cachedContract, 'adgroupKeys'),
                adgroupKeyPaths: mergeContractKeys(cachedContract, 'adgroupKeyPaths', 1200)
            };

            return {
                campaignOverride,
                adgroupOverride,
                runtimePatch,
                endpoint,
                contractHints
            };
        };

        const mergeRuntimeWithGoalPatch = (runtime = {}, patch = {}) => {
            const output = deepClone(runtime || {});
            if (!isPlainObject(patch)) return output;
            Object.keys(patch).forEach(key => {
                const value = patch[key];
                if (value === undefined || value === null || value === '') return;
                output[key] = deepClone(value);
            });
            return output;
        };

        const resolveGoalContextForPlan = ({
            sceneName = '',
            sceneSpec = null,
            runtime = {},
            marketingGoal = '',
            planName = '',
            planIndex = 0
        } = {}) => {
            const resolution = resolveGoalSpecForScene({
                sceneName,
                sceneSpec,
                marketingGoal,
                runtime
            });
            const defaults = buildGoalContractDefaults(resolution.goalSpec, {
                sceneName: String(sceneName || '').trim(),
                goalLabel: resolution.resolvedMarketingGoal || marketingGoal || ''
            });
            const resolvedGoal = resolution.resolvedMarketingGoal || normalizeGoalLabel(marketingGoal) || '';
            const warningPrefix = planName
                ? `è®¡åˆ’ã€Œ${planName}ã€`
                : (Number.isFinite(planIndex) && planIndex >= 0 ? `plans[${planIndex}]` : 'request');
            const goalWarnings = Array.isArray(resolution.goalWarnings)
                ? resolution.goalWarnings
                    .map(msg => normalizeText(msg))
                    .filter(Boolean)
                    .map(msg => `${warningPrefix} ${msg}`)
                : [];
            return {
                goalSpec: resolution.goalSpec ? deepClone(resolution.goalSpec) : null,
                resolvedMarketingGoal: resolvedGoal,
                goalFallbackUsed: !!resolution.goalFallbackUsed,
                goalWarnings,
                availableGoalLabels: resolution.availableGoalLabels || [],
                campaignOverride: defaults.campaignOverride || {},
                adgroupOverride: defaults.adgroupOverride || {},
                runtimePatch: defaults.runtimePatch || {},
                endpoint: defaults.endpoint || SCENE_CREATE_ENDPOINT_FALLBACK,
                contractHints: isPlainObject(defaults.contractHints) ? deepClone(defaults.contractHints) : {}
            };
        };

        const getGoalSpec = async (sceneName = '', marketingGoal = '', options = {}) => {
            const targetScene = String(sceneName || inferCurrentSceneName() || '').trim();
            if (!targetScene) {
                return {
                    ok: false,
                    sceneName: '',
                    marketingGoal: normalizeGoalLabel(marketingGoal),
                    error: 'ç¼ºå°‘ sceneName'
                };
            }
            let sceneSpec = await getSceneSpec(targetScene, {
                ...options,
                scanMode: options.scanMode || 'full_top_down',
                unlockPolicy: options.unlockPolicy || 'safe_only',
                goalScan: options.goalScan !== false,
                refresh: !!options.refresh
            });
            if (!Array.isArray(sceneSpec?.goals) || !sceneSpec.goals.length) {
                sceneSpec = await scanSceneSpec(targetScene, {
                    ...options,
                    scanMode: options.scanMode || 'full_top_down',
                    unlockPolicy: options.unlockPolicy || 'safe_only',
                    goalScan: true,
                    refresh: true
                });
            }
            const shouldLoadGoalFields = options.goalFieldScan !== false;
            const hasGoalFieldRows = Array.isArray(sceneSpec?.goals)
                && sceneSpec.goals.some(goal => Array.isArray(goal?.fieldRows) && goal.fieldRows.length > 0);
            if (shouldLoadGoalFields && (!hasGoalFieldRows || options.refreshGoalFields === true)) {
                try {
                    const extracted = await extractSceneGoalSpecs(targetScene, {
                        ...options,
                        scanMode: options.goalFieldScanMode || options.scanMode || 'full_top_down',
                        unlockPolicy: options.unlockPolicy || 'safe_only',
                        goalScan: true,
                        goalFieldScan: true,
                        goalFieldScanMode: options.goalFieldScanMode || 'full_top_down',
                        goalFieldMaxDepth: toNumber(options.goalFieldMaxDepth, 2),
                        goalFieldMaxSnapshots: toNumber(options.goalFieldMaxSnapshots, 48),
                        goalFieldMaxGroupsPerLevel: toNumber(options.goalFieldMaxGroupsPerLevel, 6),
                        goalFieldMaxOptionsPerGroup: toNumber(options.goalFieldMaxOptionsPerGroup, 8),
                        refresh: options.refresh !== false
                    });
                    if (Array.isArray(extracted?.goals) && extracted.goals.length) {
                        sceneSpec = mergeDeep({}, sceneSpec || {}, {
                            goals: extracted.goals.slice(0, 24)
                        });
                    }
                } catch { }
            }
            let runtime = {};
            try {
                runtime = await getRuntimeDefaults(false);
            } catch { }
            const resolution = resolveGoalSpecForScene({
                sceneName: targetScene,
                sceneSpec,
                marketingGoal,
                runtime
            });
            return {
                ok: !!sceneSpec?.ok,
                sceneName: targetScene,
                marketingGoal: normalizeGoalLabel(marketingGoal),
                resolvedMarketingGoal: resolution.resolvedMarketingGoal || '',
                goalFallbackUsed: !!resolution.goalFallbackUsed,
                goalWarnings: resolution.goalWarnings || [],
                availableGoals: resolution.availableGoalLabels || [],
                goalSpec: resolution.goalSpec ? deepClone(resolution.goalSpec) : null,
                goalFieldRows: Array.isArray(resolution?.goalSpec?.fieldRows) ? deepClone(resolution.goalSpec.fieldRows) : [],
                goalFieldCoverage: isPlainObject(resolution?.goalSpec?.fieldCoverage) ? deepClone(resolution.goalSpec.fieldCoverage) : {},
                goalFieldMatrix: isPlainObject(resolution?.goalSpec?.fieldMatrix) ? deepClone(resolution.goalSpec.fieldMatrix) : {},
                sceneSpecMeta: sceneSpec?.coverage || null
            };
        };

        const networkCaptureRegistry = {
            seq: 0,
            sessions: new Map()
        };
        const normalizeGoalSpecContracts = (goals = []) => {
            const list = Array.isArray(goals) ? goals : [];
            return list.map(goal => {
                const fieldRows = normalizeGoalFieldRows(goal?.fieldRows || goal?.settingsRows || []);
                const matrixFromRows = fieldRows.reduce((acc, row) => {
                    acc[row.label] = {
                        options: row.options.slice(0, 48),
                        defaultValue: row.defaultValue || '',
                        requiredGuess: !!row.requiredGuess,
                        criticalGuess: !!row.criticalGuess,
                        dependsOn: row.dependsOn.slice(0, 16),
                        triggerPath: row.triggerPath || ''
                    };
                    return acc;
                }, {});
                const inputMatrix = isPlainObject(goal?.fieldMatrix) ? deepClone(goal.fieldMatrix) : {};
                const fieldMatrix = Object.keys(inputMatrix).length ? inputMatrix : matrixFromRows;
                const defaultFieldCoverage = {
                    fieldCount: fieldRows.length,
                    optionCount: fieldRows.reduce((sum, row) => sum + (Array.isArray(row.options) ? row.options.length : 0), 0),
                    requiredCount: fieldRows.filter(row => row.requiredGuess).length,
                    criticalCount: fieldRows.filter(row => row.criticalGuess).length
                };
                return {
                    fieldRows,
                    goalKey: normalizeGoalKey(goal?.goalKey || goal?.goalLabel || ''),
                    goalLabel: normalizeGoalLabel(goal?.goalLabel || ''),
                    isDefault: !!goal?.isDefault,
                    triggerPath: normalizeText(goal?.triggerPath || ''),
                    groupKey: normalizeText(goal?.groupKey || ''),
                    groupLabel: normalizeText(goal?.groupLabel || ''),
                    runtimeSnapshot: isPlainObject(goal?.runtimeSnapshot) ? deepClone(goal.runtimeSnapshot) : {},
                    createContract: isPlainObject(goal?.createContract) ? deepClone(goal.createContract) : {},
                    loadContracts: Array.isArray(goal?.loadContracts) ? deepClone(goal.loadContracts) : [],
                    fieldMatrix,
                    fieldCoverage: mergeDeep({}, defaultFieldCoverage, isPlainObject(goal?.fieldCoverage) ? goal.fieldCoverage : {}),
                    sectionOrder: uniqueBy((Array.isArray(goal?.sectionOrder) ? goal.sectionOrder : []).map(item => normalizeText(item)).filter(Boolean), item => item).slice(0, 80)
                };
            }).filter(goal => goal.goalLabel);
        };
        const summarizeSceneNetworkContractsFromGoals = (goals = []) => {
            const contracts = mergeContractSummaries(
                (Array.isArray(goals) ? goals : []).flatMap(goal => Array.isArray(goal?.loadContracts) ? goal.loadContracts : [])
            );
            const createContracts = contracts.filter(item => isGoalCreateSubmitPath(item?.path || ''));
            const createInterfaces = summarizeCreateInterfacesFromContracts(createContracts);
            return {
                contracts,
                createContracts,
                createInterfaces,
                createEndpoints: uniqueBy(
                    createContracts.map(item => `${normalizeCaptureMethod(item?.method)} ${normalizeCapturePath(item?.path || '')}`).filter(Boolean),
                    item => item
                )
            };
        };
        const startNetworkCapture = (options = {}) => {
            const includePattern = options.includePattern instanceof RegExp ? options.includePattern : /\.json(?:$|\?)/i;
            const session = createGoalCaptureSession({ includePattern });
            const captureId = `wxt_capture_${Date.now()}_${++networkCaptureRegistry.seq}`;
            const sceneName = String(options.sceneName || inferCurrentSceneName() || '').trim();
            const startedAtTs = Date.now();
            const startedAt = new Date().toISOString();
            networkCaptureRegistry.sessions.set(captureId, {
                captureId,
                sceneName,
                startedAtTs,
                startedAt,
                includePattern: String(includePattern),
                session
            });
            return {
                ok: true,
                captureId,
                sceneName,
                startedAtTs,
                startedAt,
                includePattern: String(includePattern)
            };
        };
        const getNetworkCapture = (captureId = '', options = {}) => {
            const id = String(captureId || '').trim();
            const entry = id ? networkCaptureRegistry.sessions.get(id) : null;
            if (!entry) {
                return {
                    ok: false,
                    captureId: id,
                    error: 'captureId ä¸å­˜åœ¨æˆ–å·²ç»“æŸ'
                };
            }
            const records = entry.session.sliceFrom(0);
            const contractsFromSession = summarizeGoalLoadContracts(records);
            const historySummary = options.includeHookHistory === false
                ? { contracts: [], snapshots: [] }
                : collectContractsFromHookHistory(entry.sceneName || '', {
                    includePattern: /\.json(?:$|\?)/i,
                    limit: Math.max(200, Math.min(30000, toNumber(options.historyLimit, 8000))),
                    since: Math.max(0, toNumber(entry.startedAtTs, 0))
                });
            const contracts = mergeContractSummaries(
                contractsFromSession.concat(Array.isArray(historySummary.contracts) ? historySummary.contracts : [])
            );
            const createInterfaces = summarizeCreateInterfacesFromContracts(contracts);
            const createEndpoints = uniqueBy(
                createInterfaces.map(item => `${normalizeCaptureMethod(item?.method)} ${normalizeCapturePath(item?.path || '')}`).filter(Boolean),
                item => item
            );
            const historyRecordCount = Array.isArray(historySummary.snapshots)
                ? historySummary.snapshots.reduce((sum, item) => sum + toNumber(item?.recordCount, 0), 0)
                : 0;
            return {
                ok: true,
                captureId: id,
                sceneName: entry.sceneName || '',
                startedAtTs: toNumber(entry.startedAtTs, 0),
                startedAt: entry.startedAt,
                includePattern: entry.includePattern,
                recordCount: Math.max(records.length, historyRecordCount),
                sessionRecordCount: records.length,
                hookHistoryRecordCount: historyRecordCount,
                contractCount: contracts.length,
                contracts,
                createInterfaceCount: createInterfaces.length,
                createInterfaces,
                createEndpoints,
                records: options.withRecords ? records : []
            };
        };
        const stopNetworkCapture = (captureId = '', options = {}) => {
            const snapshot = getNetworkCapture(captureId, options);
            if (!snapshot.ok) return snapshot;
            const id = String(captureId || '').trim();
            const entry = networkCaptureRegistry.sessions.get(id);
            try {
                entry?.session?.stop?.();
            } catch { }
            networkCaptureRegistry.sessions.delete(id);
            return {
                ...snapshot,
                stoppedAt: new Date().toISOString(),
                stopped: true
            };
        };
        const listNetworkCaptures = () => {
            const list = Array.from(networkCaptureRegistry.sessions.values()).map(item => ({
                captureId: item.captureId,
                sceneName: item.sceneName || '',
                startedAt: item.startedAt,
                includePattern: item.includePattern
            })).sort((a, b) => String(a.startedAt).localeCompare(String(b.startedAt)));
            return {
                ok: true,
                count: list.length,
                list
            };
        };
        const stopAllNetworkCaptures = (options = {}) => {
            const ids = Array.from(networkCaptureRegistry.sessions.keys());
            const list = ids.map(id => stopNetworkCapture(id, options));
            return {
                ok: list.every(item => item?.ok),
                count: list.length,
                list
            };
        };

        const LIFECYCLE_LIST_PATH_RE = /\/(?:campaign|solution|plan|bp)[^?]*?(?:list|query|find|get)[^?]*?\.json$/i;
        const LIFECYCLE_PAUSE_PATH_RE = /\/(?:campaign|solution|plan|bp)[^?]*?(?:pause|offline|stop|suspend|update(?:Batch)?Status|changeStatus|setStatus|onlineStatus)[^?]*?\.json$/i;
        const LIFECYCLE_DELETE_PATH_RE = /\/(?:campaign|solution|plan|bp)[^?]*?(?:delete|remove|batchDelete|del|recycle)[^?]*?\.json$/i;
        const LIFECYCLE_CONFLICT_LIST_PATH_RE = /\/campaign\/(?:horizontal\/findPage|diff\/findList)\.json$/i;
        const LIFECYCLE_IGNORE_PATH_RE = /\/(?:material\/item\/findPage|bidword\/suggest|wordpackage\/suggest|label\/findList)\.json$/i;

        const inferLifecycleActionFromContract = (contract = {}, options = {}) => {
            const path = normalizeCapturePath(contract?.path || contract?.endpoint || '');
            if (!path) return '';
            if (isGoalCreateSubmitPath(path)) return 'create';
            if (LIFECYCLE_IGNORE_PATH_RE.test(path)) return '';

            const bodyKeys = Array.isArray(contract?.bodyKeys)
                ? contract.bodyKeys
                : (Array.isArray(contract?.requestKeys) ? contract.requestKeys : []);
            const bodyKeyPaths = Array.isArray(contract?.bodyKeyPaths)
                ? contract.bodyKeyPaths
                : (Array.isArray(contract?.requestKeyPaths) ? contract.requestKeyPaths : []);
            const queryKeys = Array.isArray(contract?.queryKeys) ? contract.queryKeys : [];
            const mergedKeyText = bodyKeys.concat(bodyKeyPaths, queryKeys).map(item => String(item || '').toLowerCase()).join('|');
            const forceAction = normalizeLifecycleAction(options?.forceAction || '');
            if (forceAction) return forceAction;

            if (LIFECYCLE_DELETE_PATH_RE.test(path)) return 'delete';
            if (LIFECYCLE_PAUSE_PATH_RE.test(path)) return 'pause';
            if (LIFECYCLE_CONFLICT_LIST_PATH_RE.test(path)) return 'list_conflict';
            if (LIFECYCLE_LIST_PATH_RE.test(path)) {
                const hasListHint = /(itemid|materialid|campaignid|planid|status|online|offset|pagesize|page|keyword)/.test(mergedKeyText);
                if (hasListHint) return 'list_conflict';
            }

            if (/delete|remove|batchdelete|recycle/.test(mergedKeyText)) return 'delete';
            if (/(pause|offline|online|status|suspend)/.test(mergedKeyText)
                && /(campaignid|planid|campaignidlist|planidlist)/.test(mergedKeyText)) return 'pause';
            if (/(itemid|materialid)/.test(mergedKeyText)
                && /(list|query|find|get|search)/.test(path.toLowerCase())) return 'list_conflict';

            return '';
        };

        const scoreLifecycleContractCandidate = (action = '', contract = {}) => {
            const normalizedAction = normalizeLifecycleAction(action);
            if (!normalizedAction) return -1;
            const path = normalizeCapturePath(contract?.path || contract?.endpoint || '');
            const count = Math.max(1, toNumber(contract?.count, 1));
            const bodyKeys = Array.isArray(contract?.bodyKeys) ? contract.bodyKeys : [];
            const requestKeys = Array.isArray(contract?.requestKeys) ? contract.requestKeys : [];
            const bodyKeyPaths = Array.isArray(contract?.bodyKeyPaths) ? contract.bodyKeyPaths : [];
            const requestKeyPaths = Array.isArray(contract?.requestKeyPaths) ? contract.requestKeyPaths : [];
            const mergedKeyText = bodyKeys.concat(requestKeys, bodyKeyPaths, requestKeyPaths).map(item => String(item || '').toLowerCase()).join('|');
            let score = count * 10;
            if (normalizedAction === 'create') {
                if (isGoalCreateSubmitPath(path)) score += 300;
                if (/\/solution\/business\/addList\.json$/i.test(path)) score += 40;
            }
            if (normalizedAction === 'list_conflict') {
                if (LIFECYCLE_CONFLICT_LIST_PATH_RE.test(path)) score += 220;
                if (LIFECYCLE_LIST_PATH_RE.test(path)) score += 180;
                if (/(itemid|materialid)/.test(mergedKeyText)) score += 40;
                if (/(campaignid|planid)/.test(mergedKeyText)) score += 20;
            }
            if (normalizedAction === 'pause') {
                if (LIFECYCLE_PAUSE_PATH_RE.test(path)) score += 200;
                if (/(campaignid|planid)/.test(mergedKeyText)) score += 25;
                if (/(status|online)/.test(mergedKeyText)) score += 20;
            }
            if (normalizedAction === 'delete') {
                if (LIFECYCLE_DELETE_PATH_RE.test(path)) score += 220;
                if (/(campaignid|planid)/.test(mergedKeyText)) score += 25;
            }
            return score;
        };

        const normalizeLifecycleContract = (sceneName = '', action = '', contract = {}, extra = {}) => {
            const targetScene = String(sceneName || '').trim();
            const normalizedAction = normalizeLifecycleAction(action);
            if (!targetScene || !normalizedAction) return null;
            const endpoint = normalizeCapturePath(contract?.path || contract?.endpoint || '');
            if (!endpoint) return null;
            const requestKeys = Array.isArray(contract?.requestKeys)
                ? contract.requestKeys
                : [];
            const requestKeyPaths = Array.isArray(contract?.requestKeyPaths)
                ? contract.requestKeyPaths
                : [];
            const bodyKeys = Array.isArray(contract?.bodyKeys)
                ? contract.bodyKeys
                : requestKeys;
            const bodyKeyPaths = Array.isArray(contract?.bodyKeyPaths)
                ? contract.bodyKeyPaths
                : requestKeyPaths;
            return {
                sceneName: targetScene,
                action: normalizedAction,
                method: normalizeCaptureMethod(contract?.method || 'POST'),
                endpoint,
                requestKeys: uniqueBy(requestKeys.map(item => normalizeText(item)).filter(Boolean), item => item).slice(0, 320),
                requestKeyPaths: uniqueBy(requestKeyPaths.map(item => normalizeText(item)).filter(Boolean), item => item).slice(0, 1600),
                queryKeys: uniqueBy((Array.isArray(contract?.queryKeys) ? contract.queryKeys : [])
                    .map(item => normalizeText(item))
                    .filter(Boolean), item => item).slice(0, 120),
                bodyKeys: uniqueBy(bodyKeys.map(item => normalizeText(item)).filter(Boolean), item => item).slice(0, 320),
                bodyKeyPaths: uniqueBy(bodyKeyPaths.map(item => normalizeText(item)).filter(Boolean), item => item).slice(0, 1600),
                responseShape: isPlainObject(contract?.responseShape) ? deepClone(contract.responseShape) : {},
                sampleBody: isPlainObject(contract?.sampleBody) ? deepClone(contract.sampleBody) : null,
                count: Math.max(1, toNumber(contract?.count, 1)),
                source: normalizeText(extra?.source || contract?.source || 'network_listener'),
                sampledAt: extra?.sampledAt || new Date().toISOString()
            };
        };

        const mergeLifecycleContract = (base = null, next = null) => {
            if (!isPlainObject(next)) return isPlainObject(base) ? deepClone(base) : null;
            if (!isPlainObject(base)) return deepClone(next);
            const merged = deepClone(base);
            merged.method = normalizeCaptureMethod(next.method || merged.method || 'POST');
            merged.endpoint = normalizeCapturePath(next.endpoint || merged.endpoint || '');
            merged.requestKeys = uniqueBy(
                (Array.isArray(base.requestKeys) ? base.requestKeys : [])
                    .concat(Array.isArray(next.requestKeys) ? next.requestKeys : [])
                    .map(item => normalizeText(item))
                    .filter(Boolean),
                item => item
            ).slice(0, 320);
            merged.requestKeyPaths = uniqueBy(
                (Array.isArray(base.requestKeyPaths) ? base.requestKeyPaths : [])
                    .concat(Array.isArray(next.requestKeyPaths) ? next.requestKeyPaths : [])
                    .map(item => normalizeText(item))
                    .filter(Boolean),
                item => item
            ).slice(0, 1600);
            merged.queryKeys = uniqueBy(
                (Array.isArray(base.queryKeys) ? base.queryKeys : [])
                    .concat(Array.isArray(next.queryKeys) ? next.queryKeys : [])
                    .map(item => normalizeText(item))
                    .filter(Boolean),
                item => item
            ).slice(0, 120);
            merged.bodyKeys = uniqueBy(
                (Array.isArray(base.bodyKeys) ? base.bodyKeys : [])
                    .concat(Array.isArray(next.bodyKeys) ? next.bodyKeys : [])
                    .map(item => normalizeText(item))
                    .filter(Boolean),
                item => item
            ).slice(0, 320);
            merged.bodyKeyPaths = uniqueBy(
                (Array.isArray(base.bodyKeyPaths) ? base.bodyKeyPaths : [])
                    .concat(Array.isArray(next.bodyKeyPaths) ? next.bodyKeyPaths : [])
                    .map(item => normalizeText(item))
                    .filter(Boolean),
                item => item
            ).slice(0, 1600);
            merged.count = Math.max(
                toNumber(base.count, 0),
                toNumber(next.count, 0)
            );
            merged.source = normalizeText(next.source || base.source || '');
            merged.sampledAt = next.sampledAt || base.sampledAt || new Date().toISOString();
            if (!merged.sampleBody && isPlainObject(next.sampleBody)) {
                merged.sampleBody = deepClone(next.sampleBody);
            }
            return merged;
        };

        const rememberLifecycleContractsFromContractList = (sceneName = '', contracts = [], options = {}) => {
            const targetScene = String(sceneName || '').trim();
            if (!targetScene || !Array.isArray(contracts) || !contracts.length) return [];
            const mergedContracts = mergeContractSummaries(contracts);
            const remembered = [];
            mergedContracts.forEach(contract => {
                const action = inferLifecycleActionFromContract(contract, options);
                if (!isLifecycleAction(action)) return;
                const normalized = normalizeLifecycleContract(targetScene, action, contract, {
                    source: options.source || 'network_listener'
                });
                if (!normalized) return;
                const cached = getCachedSceneLifecycleContract(targetScene, action);
                const merged = mergeLifecycleContract(cached, normalized);
                if (!merged) return;
                setCachedSceneLifecycleContract(targetScene, action, merged);
                remembered.push({
                    action,
                    endpoint: merged.endpoint || '',
                    method: merged.method || 'POST'
                });
            });
            return remembered;
        };

        const collectContractsFromActiveCaptures = (sceneName = '') => {
            const targetScene = String(sceneName || '').trim();
            const contracts = [];
            const snapshots = [];
            Array.from(networkCaptureRegistry.sessions.values()).forEach(entry => {
                if (!entry?.captureId || !entry?.session) return;
                if (targetScene && entry.sceneName && entry.sceneName !== targetScene) return;
                const records = entry.session.sliceFrom(0);
                if (!records.length) return;
                const summary = summarizeGoalLoadContracts(records);
                if (summary.length) {
                    contracts.push(...summary);
                    snapshots.push({
                        captureId: entry.captureId,
                        sceneName: entry.sceneName || '',
                        contractCount: summary.length,
                        recordCount: records.length
                    });
                }
            });
            return { contracts, snapshots };
        };

        const collectContractsFromHookHistory = (sceneName = '', options = {}) => {
            const targetScene = String(sceneName || '').trim();
            const hookManagers = listHookManagers();
            if (!hookManagers.length) {
                return { contracts: [], snapshots: [] };
            }
            const includePattern = options.includePattern instanceof RegExp
                ? options.includePattern
                : /\.json(?:$|\?)/i;
            const targetBizCode = normalizeSceneBizCode(
                options.bizCode
                || resolveSceneBizCodeHint(targetScene)
                || SCENE_BIZCODE_HINT_FALLBACK[targetScene]
                || ''
            );
            const limit = Math.max(200, Math.min(20000, toNumber(options.limit, 3000)));
            const since = Math.max(0, toNumber(options.since, 0));
            const history = uniqueBy(
                hookManagers.flatMap(manager => {
                    if (!manager || typeof manager.getRequestHistory !== 'function') return [];
                    try {
                        const list = manager.getRequestHistory({
                            includePattern,
                            limit,
                            since
                        });
                        return Array.isArray(list) ? list : [];
                    } catch {
                        return [];
                    }
                }),
                item => `${toNumber(item?.ts, 0)}::${normalizeCaptureMethod(item?.method || 'POST')}::${String(item?.url || '').trim()}::${String(item?.source || '').trim()}`
            );
            if (!Array.isArray(history) || !history.length) {
                return { contracts: [], snapshots: [] };
            }
            const records = [];
            history.forEach(entry => {
                const method = normalizeCaptureMethod(entry?.method || 'POST');
                const url = String(entry?.url || '').trim();
                const path = normalizeCapturePath(url);
                if (!path) return;
                let queryKeys = [];
                let queryBizCode = '';
                try {
                    const parsed = new URL(url, window.location.origin);
                    queryKeys = uniqueBy(Array.from(parsed.searchParams.keys()).filter(Boolean), item => item).slice(0, 80);
                    queryBizCode = normalizeSceneBizCode(parsed.searchParams.get('bizCode') || '');
                } catch { }
                const body = parseCaptureBody(entry?.body);
                const bodyBizCode = normalizeSceneBizCode(body?.bizCode || body?.biz_code || '');
                if (targetBizCode) {
                    const matched = queryBizCode === targetBizCode
                        || bodyBizCode === targetBizCode
                        || queryBizCode === 'universalBP'
                        || bodyBizCode === 'universalBP'
                        || (!queryBizCode && !bodyBizCode);
                    if (!matched) return;
                }
                records.push({
                    method,
                    path,
                    queryKeys,
                    bodyKeys: body && typeof body === 'object'
                        ? uniqueBy(Object.keys(body).filter(Boolean), item => item).slice(0, 160)
                        : [],
                    bodyKeyPaths: body && typeof body === 'object'
                        ? flattenCaptureKeyPaths(body, {
                            maxDepth: 10,
                            maxPaths: 1400,
                            maxArrayItems: 3
                        })
                        : [],
                    sampleBody: body && typeof body === 'object'
                        ? Object.keys(body).slice(0, 24).reduce((acc, key) => {
                            acc[key] = body[key];
                            return acc;
                        }, {})
                        : null
                });
            });
            if (!records.length) {
                return { contracts: [], snapshots: [] };
            }
            const contracts = summarizeGoalLoadContracts(records);
            if (!contracts.length) {
                return { contracts: [], snapshots: [] };
            }
            return {
                contracts,
                snapshots: [{
                    source: 'hook_history',
                    sceneName: targetScene,
                    recordCount: records.length,
                    contractCount: contracts.length
                }]
            };
        };

        const extractLifecycleContracts = async (sceneName = '', options = {}) => {
            const targetScene = String(sceneName || inferCurrentSceneName() || '').trim();
            if (!targetScene) {
                return {
                    ok: false,
                    sceneName: '',
                    actions: [],
                    warnings: ['ç¼ºå°‘ sceneName']
                };
            }
            const warnings = [];
            const sourceContracts = [];
            const sourceNotes = [];

            if (options.fromSceneGoalSpecs !== false) {
                try {
                    const extracted = await extractSceneGoalSpecs(targetScene, {
                        scanMode: options.scanMode || 'full_top_down',
                        unlockPolicy: options.unlockPolicy || 'safe_only',
                        goalScan: true,
                        goalFieldScan: false,
                        refresh: !!options.refresh
                    });
                    if (Array.isArray(extracted?.contracts) && extracted.contracts.length) {
                        sourceContracts.push(...extracted.contracts);
                        sourceNotes.push(`scene_goal_specs:${extracted.contracts.length}`);
                    }
                } catch (err) {
                    warnings.push(`æå–åœºæ™¯åˆåŒå¤±è´¥ï¼š${err?.message || err}`);
                }
            }
            if (Array.isArray(options.contracts) && options.contracts.length) {
                sourceContracts.push(...options.contracts);
                sourceNotes.push(`input_contracts:${options.contracts.length}`);
            }
            if (options.includeActiveCaptures !== false) {
                const fromActive = collectContractsFromActiveCaptures(targetScene);
                if (fromActive.contracts.length) {
                    sourceContracts.push(...fromActive.contracts);
                    sourceNotes.push(`active_captures:${fromActive.contracts.length}`);
                }
            }
            if (options.includeHookHistory !== false) {
                const fromHistory = collectContractsFromHookHistory(targetScene, {
                    limit: Math.max(200, toNumber(options.historyLimit, 3000)),
                    since: Math.max(0, toNumber(options.historySince, 0))
                });
                if (fromHistory.contracts.length) {
                    sourceContracts.push(...fromHistory.contracts);
                    sourceNotes.push(`hook_history:${fromHistory.contracts.length}`);
                }
            }

            const mergedContracts = mergeContractSummaries(sourceContracts);
            const byAction = {
                create: [],
                list_conflict: [],
                pause: [],
                delete: []
            };
            mergedContracts.forEach(contract => {
                const action = inferLifecycleActionFromContract(contract, options);
                if (!isLifecycleAction(action)) return;
                byAction[action].push(contract);
            });

            // create æ²¡æœ‰åŒ¹é…æ—¶å°è¯•å¤ç”¨å·²ç¼“å­˜åˆ›å»ºåˆåŒï¼Œé¿å…é˜»æ–­ã€‚
            if (!byAction.create.length) {
                const createContract = getSceneCreateContract(targetScene, options.goalLabel || '');
                if (createContract?.ok && createContract.contract) {
                    byAction.create.push({
                        method: createContract.contract.method || 'POST',
                        path: createContract.contract.endpoint || '',
                        requestKeys: Array.isArray(createContract.contract.requestKeys) ? createContract.contract.requestKeys.slice(0, 320) : [],
                        requestKeyPaths: Array.isArray(createContract.contract.requestKeyPaths) ? createContract.contract.requestKeyPaths.slice(0, 1600) : [],
                        bodyKeys: Array.isArray(createContract.contract.requestKeys) ? createContract.contract.requestKeys.slice(0, 320) : [],
                        bodyKeyPaths: Array.isArray(createContract.contract.requestKeyPaths) ? createContract.contract.requestKeyPaths.slice(0, 1600) : [],
                        queryKeys: [],
                        count: toNumber(createContract.contract.count, 0),
                        sampleBody: null,
                        source: 'scene_create_contract_cache'
                    });
                }
            }

            const actionResults = LIFECYCLE_ACTION_LIST.map(action => {
                const list = Array.isArray(byAction[action]) ? byAction[action] : [];
                if (!list.length) {
                    return {
                        action,
                        ok: false,
                        error: 'not_detected',
                        contract: null
                    };
                }
                const picked = list.slice().sort((left, right) => {
                    const scoreDiff = scoreLifecycleContractCandidate(action, right) - scoreLifecycleContractCandidate(action, left);
                    if (scoreDiff !== 0) return scoreDiff;
                    return normalizeCapturePath(String(right?.path || '')).length - normalizeCapturePath(String(left?.path || '')).length;
                })[0];
                const normalized = normalizeLifecycleContract(targetScene, action, picked, {
                    source: 'network_listener'
                });
                if (!normalized) {
                    return {
                        action,
                        ok: false,
                        error: 'normalize_failed',
                        contract: null
                    };
                }
                const cached = getCachedSceneLifecycleContract(targetScene, action);
                const merged = mergeLifecycleContract(cached, normalized);
                if (merged) {
                    setCachedSceneLifecycleContract(targetScene, action, merged);
                }
                return {
                    action,
                    ok: !!merged,
                    contract: merged || null,
                    error: merged ? '' : 'cache_write_failed'
                };
            });

            const missingActions = actionResults.filter(item => !item.ok).map(item => item.action);
            if (missingActions.length) {
                warnings.push(`åœºæ™¯ã€Œ${targetScene}ã€ç”Ÿå‘½å‘¨æœŸåˆåŒç¼ºå¤±ï¼š${missingActions.join(', ')}`);
            }

            return {
                ok: actionResults.some(item => item.ok),
                sceneName: targetScene,
                scannedAt: new Date().toISOString(),
                source: 'network_listener',
                sourceNotes,
                contractCount: mergedContracts.length,
                actions: actionResults,
                warnings
            };
        };

        const extractSceneGoalSpecs = async (sceneName = '', options = {}) => {
            const targetScene = String(sceneName || inferCurrentSceneName() || '').trim();
            if (!targetScene) {
                return {
                    ok: false,
                    sceneName: '',
                    error: 'ç¼ºå°‘ sceneName'
                };
            }
            const goalResult = await scanSceneGoalSpecs(targetScene, {
                ...options,
                scanMode: options.scanMode || 'full_top_down',
                unlockPolicy: options.unlockPolicy || 'safe_only',
                goalScan: options.goalScan !== false,
                goalFieldScan: options.goalFieldScan !== false,
                goalFieldScanMode: options.goalFieldScanMode || (options.scanMode === 'visible' ? 'visible' : 'full_top_down'),
                goalFieldMaxDepth: toNumber(options.goalFieldMaxDepth, 2),
                goalFieldMaxSnapshots: toNumber(options.goalFieldMaxSnapshots, 48),
                goalFieldMaxGroupsPerLevel: toNumber(options.goalFieldMaxGroupsPerLevel, 6),
                goalFieldMaxOptionsPerGroup: toNumber(options.goalFieldMaxOptionsPerGroup, 8),
                contractMode: options.contractMode || 'network_only',
                refresh: options.refresh !== false
            });
            const goals = normalizeGoalSpecContracts(goalResult?.goals || []);
            const networkSummary = summarizeSceneNetworkContractsFromGoals(goals);
            if (networkSummary.createInterfaces.length) {
                rememberSceneCreateInterfaces(targetScene, '', networkSummary.createInterfaces, {
                    source: 'extract_scene_goal_specs'
                });
            }
            goals.forEach(goal => {
                const goalCreateContracts = mergeContractSummaries(
                    (Array.isArray(goal?.loadContracts) ? goal.loadContracts : [])
                        .filter(item => isGoalCreateSubmitPath(item?.path || ''))
                );
                const goalCreateInterfaces = summarizeCreateInterfacesFromContracts(goalCreateContracts);
                if (!goalCreateInterfaces.length) return;
                rememberSceneCreateInterfaces(targetScene, goal?.goalLabel || '', goalCreateInterfaces, {
                    source: 'extract_scene_goal_specs_goal'
                });
            });
            const goalFieldCount = goals.reduce((sum, goal) => sum + (Array.isArray(goal?.fieldRows) ? goal.fieldRows.length : 0), 0);
            const goalOptionCount = goals.reduce((sum, goal) => sum + ((goal?.fieldCoverage?.optionCount && Number.isFinite(goal.fieldCoverage.optionCount))
                ? toNumber(goal.fieldCoverage.optionCount, 0)
                : (Array.isArray(goal?.fieldRows) ? goal.fieldRows.reduce((acc, row) => acc + (Array.isArray(row?.options) ? row.options.length : 0), 0) : 0)), 0);
            const goalsWithFieldRows = goals.filter(goal => Array.isArray(goal?.fieldRows) && goal.fieldRows.length > 0).length;
            const goalsWithOptionRows = goals.filter(goal => Array.isArray(goal?.fieldRows) && goal.fieldRows.some(row => Array.isArray(row?.options) && row.options.length >= 2)).length;
            const extractWarnings = Array.isArray(goalResult?.warnings) ? goalResult.warnings.slice(0, 120) : [];
            if (!networkSummary.createContracts.length) {
                extractWarnings.push(`åœºæ™¯ã€Œ${targetScene}ã€æœªæ•è·åˆ°åˆ›å»ºæäº¤æ¥å£ï¼Œè¯·åœ¨å¼€å¯æŠ“åŒ…åæ‰§è¡Œä¸€æ¬¡â€œæ–°å»ºè®¡åˆ’æäº¤â€å†æå–`);
            }
            if (goals.length && goalsWithFieldRows < goals.length) {
                extractWarnings.push(`åœºæ™¯ã€Œ${targetScene}ã€å­˜åœ¨è¥é”€ç›®æ ‡æœªé‡‡é›†åˆ°è¡Œé…ç½®ï¼ˆ${goalsWithFieldRows}/${goals.length}ï¼‰`);
            }
            if (goals.length && goalsWithOptionRows < goals.length) {
                extractWarnings.push(`åœºæ™¯ã€Œ${targetScene}ã€å­˜åœ¨è¥é”€ç›®æ ‡æœªé‡‡é›†åˆ°å¯åˆ‡æ¢é€‰é¡¹ï¼ˆ${goalsWithOptionRows}/${goals.length}ï¼‰`);
            }
            return {
                ok: !!goalResult?.ok,
                source: 'network_listener',
                sceneName: targetScene,
                scannedAt: goalResult?.scannedAt || new Date().toISOString(),
                goalCount: goals.length,
                goals,
                contracts: networkSummary.contracts,
                createContracts: networkSummary.createContracts,
                createInterfaces: networkSummary.createInterfaces,
                createEndpoints: networkSummary.createEndpoints,
                goalCoverage: {
                    mode: 'network_listener',
                    goalCount: goals.length,
                    contractCount: networkSummary.contracts.length,
                    createContractCount: networkSummary.createContracts.length,
                    createInterfaceCount: networkSummary.createInterfaces.length
                },
                goalFieldCoverage: {
                    goalCount: goals.length,
                    goalsWithFieldRows,
                    goalsWithOptionRows,
                    fieldCount: goalFieldCount,
                    optionCount: goalOptionCount
                },
                coverage: {
                    source: 'network_listener'
                },
                warnings: uniqueBy(extractWarnings, item => item)
            };
        };

        const extractAllSceneGoalSpecs = async (options = {}) => {
            const scenes = Array.isArray(options.scenes) && options.scenes.length
                ? uniqueBy(options.scenes.map(item => String(item || '').trim()).filter(Boolean), item => item)
                : SCENE_NAME_LIST.slice();
            const list = [];
            for (let i = 0; i < scenes.length; i++) {
                const sceneName = scenes[i];
                if (typeof options.onProgress === 'function') {
                    try {
                        options.onProgress({
                            event: 'scene_goal_spec_start',
                            sceneName,
                            index: i + 1,
                            total: scenes.length
                        });
                    } catch { }
                }
                const result = await extractSceneGoalSpecs(sceneName, {
                    ...options,
                    refresh: options.refresh !== false
                });
                list.push(result);
                if (typeof options.onProgress === 'function') {
                    try {
                        options.onProgress({
                            event: 'scene_goal_spec_done',
                            sceneName,
                            index: i + 1,
                            total: scenes.length,
                            ok: !!result?.ok,
                            goalCount: result?.goalCount || 0
                        });
                    } catch { }
                }
            }
            return {
                ok: list.every(item => item?.ok),
                source: 'network_listener',
                scannedAt: new Date().toISOString(),
                sceneOrder: scenes,
                count: list.length,
                successCount: list.filter(item => item?.ok).length,
                failCount: list.filter(item => !item?.ok).length,
                goalCount: list.reduce((sum, item) => sum + toNumber(item?.goalCount, 0), 0),
                goalFieldCount: list.reduce((sum, item) => sum + toNumber(item?.goalFieldCoverage?.fieldCount, 0), 0),
                goalOptionCount: list.reduce((sum, item) => sum + toNumber(item?.goalFieldCoverage?.optionCount, 0), 0),
                goalsWithFieldRows: list.reduce((sum, item) => sum + toNumber(item?.goalFieldCoverage?.goalsWithFieldRows, 0), 0),
                goalsWithOptionRows: list.reduce((sum, item) => sum + toNumber(item?.goalFieldCoverage?.goalsWithOptionRows, 0), 0),
                contractCount: list.reduce((sum, item) => sum + toNumber(Array.isArray(item?.contracts) ? item.contracts.length : 0, 0), 0),
                createContractCount: list.reduce((sum, item) => sum + toNumber(Array.isArray(item?.createContracts) ? item.createContracts.length : 0, 0), 0),
                createInterfaceCount: list.reduce((sum, item) => sum + toNumber(Array.isArray(item?.createInterfaces) ? item.createInterfaces.length : 0, 0), 0),
                list
            };
        };
        const parseComponentFindListSummary = (payload = {}) => {
            const scenes = [];
            const goals = [];
            const fieldRows = [];
            const samplePaths = [];
            const seenRows = new Set();
            const sceneSet = new Set(SCENE_NAME_LIST);
            const goalHintSet = new Set(SCENE_GOAL_LABEL_HINTS);
            const pushRow = (label = '', options = [], path = '') => {
                const normalizedLabel = normalizeText(label).replace(/[ï¼š:]/g, '').trim();
                if (!normalizedLabel) return;
                const normalizedOptions = uniqueBy(
                    (Array.isArray(options) ? options : [])
                        .map(item => normalizeSceneOptionText(item))
                        .filter(item => isLikelySceneOptionValue(item)),
                    item => item
                ).slice(0, 36);
                if (normalizedOptions.length < 2) return;
                const rowKey = `${normalizeSceneFieldKey(normalizedLabel)}::${normalizedOptions.join('|')}`;
                if (seenRows.has(rowKey)) return;
                seenRows.add(rowKey);
                fieldRows.push({
                    label: normalizedLabel,
                    options: normalizedOptions,
                    path: path || ''
                });
            };
            const readOptionText = (item) => {
                if (item === undefined || item === null) return '';
                if (typeof item === 'string' || typeof item === 'number' || typeof item === 'boolean') {
                    return normalizeText(String(item)).trim();
                }
                if (!isPlainObject(item)) return '';
                return normalizeText(
                    item.label
                    || item.optionText
                    || item.title
                    || item.name
                    || item.text
                    || item.value
                    || ''
                ).trim();
            };
            const pickNodeOptions = (node = {}) => {
                const source = node.options || node.optionList || node.tabs || node.items || node.cards || node.cardList || node.children || [];
                if (!Array.isArray(source)) return [];
                return uniqueBy(source.map(readOptionText).filter(Boolean), item => item).slice(0, 60);
            };
            const markScalar = (text = '', path = '') => {
                const normalized = normalizeText(text).trim();
                if (!normalized) return;
                if (normalized.length <= 28 && sceneSet.has(normalized)) {
                    scenes.push(normalized);
                }
                const goalLabel = normalizeGoalCandidateLabel(normalized);
                if (goalLabel && goalHintSet.has(goalLabel)) {
                    goals.push(goalLabel);
                }
                if (path && samplePaths.length < 120 && /scene|goal|target|option|label|title|name|promotion|budget|bid|word|crowd/i.test(path)) {
                    samplePaths.push({
                        path,
                        value: normalized.slice(0, 140)
                    });
                }
            };
            const walk = (node, path = '', depth = 0) => {
                if (depth > 6 || node === null || node === undefined) return;
                if (typeof node === 'string' || typeof node === 'number' || typeof node === 'boolean') {
                    markScalar(String(node), path);
                    return;
                }
                if (Array.isArray(node)) {
                    node.slice(0, 60).forEach((item, idx) => {
                        walk(item, `${path}[${idx}]`, depth + 1);
                    });
                    return;
                }
                if (!isPlainObject(node)) return;
                const label = normalizeText(node.label || node.title || node.name || '').trim();
                if (label) {
                    markScalar(label, `${path}.label`);
                    const options = pickNodeOptions(node);
                    if (options.length >= 2) {
                        pushRow(label, options, `${path}.options`);
                    }
                }
                const entries = Object.entries(node).slice(0, 80);
                entries.forEach(([key, value]) => {
                    const nextPath = path ? `${path}.${key}` : key;
                    if (typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean') {
                        markScalar(String(value), nextPath);
                        return;
                    }
                    walk(value, nextPath, depth + 1);
                });
            };
            walk(payload, '$', 0);
            return {
                sceneOptions: uniqueBy(scenes, item => item),
                goalOptions: uniqueBy(goals, item => item),
                fieldRows: uniqueBy(fieldRows, row => normalizeSceneFieldKey(row.label)),
                samplePaths: samplePaths.slice(0, 120)
            };
        };
        const mergeComponentGoalFallbackOptions = (summary = {}) => {
            const goalOptions = Array.isArray(summary?.goalOptions)
                ? summary.goalOptions.map(item => normalizeGoalCandidateLabel(item)).filter(Boolean)
                : [];
            if (!goalOptions.length) return;
            const mergeGoals = (sceneName, seeds = []) => {
                const normalizedSeeds = uniqueBy(
                    (Array.isArray(seeds) ? seeds : [])
                        .map(item => normalizeGoalCandidateLabel(item))
                        .filter(Boolean),
                    item => item
                );
                if (!normalizedSeeds.length) return;
                const current = Array.isArray(SCENE_MARKETING_GOAL_FALLBACK_OPTIONS[sceneName])
                    ? SCENE_MARKETING_GOAL_FALLBACK_OPTIONS[sceneName]
                    : [];
                SCENE_MARKETING_GOAL_FALLBACK_OPTIONS[sceneName] = uniqueBy(current.concat(normalizedSeeds), item => item).slice(0, 24);
            };
            const pickByKeywords = (keywords = []) => goalOptions.filter(goal => (
                keywords.some(token => goal.includes(token))
            ));
            mergeGoals('å…³é”®è¯æ¨å¹¿', pickByKeywords(['å¡ä½', 'è¶‹åŠ¿', 'é‡‘å¡', 'è‡ªå®šä¹‰']));
            mergeGoals('äººç¾¤æ¨å¹¿', pickByKeywords(['æ‹‰æ–°', 'ç«åº—', 'å€ŸåŠ¿', 'æœºä¼šäººç¾¤', 'è·¨ç±»ç›®']));
            mergeGoals('å†…å®¹è¥é”€', pickByKeywords(['ç›´æ’­', 'æ‰“çˆ†', 'å¢ç²‰']));
            mergeGoals('çº¿ç´¢æ¨å¹¿', pickByKeywords(['çº¿ç´¢', 'è¡Œä¸šè§£å†³æ–¹æ¡ˆ']));
            mergeGoals('è´§å“å…¨ç«™æ¨å¹¿', pickByKeywords(['è´§å“å…¨ç«™']));
            mergeGoals('åº—é“ºç›´è¾¾', pickByKeywords(['åº—é“ºç›´è¾¾']));
        };
        const mergeComponentFieldFallbackOptions = (summary = {}) => {
            const rows = Array.isArray(summary?.fieldRows) ? summary.fieldRows : [];
            if (!rows.length) return;
            const mergeOptions = (target = [], incoming = []) => uniqueBy(
                (Array.isArray(target) ? target : []).concat(
                    (Array.isArray(incoming) ? incoming : [])
                        .map(item => normalizeSceneOptionText(item))
                        .filter(item => isLikelySceneOptionValue(item))
                ),
                item => item
            ).slice(0, 24);
            const sceneNames = Object.keys(SCENE_FALLBACK_OPTION_MAP || {});
            rows.forEach(row => {
                const label = normalizeText(row?.label || '').replace(/[ï¼š:]/g, '').trim();
                const options = Array.isArray(row?.options) ? row.options : [];
                if (!label || options.length < 2) return;
                sceneNames.forEach(sceneName => {
                    const sceneMap = SCENE_FALLBACK_OPTION_MAP[sceneName];
                    if (!isPlainObject(sceneMap)) return;
                    Object.keys(sceneMap).forEach(key => {
                        if (!isSceneLabelMatch(label, key)) return;
                        sceneMap[key] = mergeOptions(sceneMap[key], options);
                    });
                });
            });
        };
        const getNewPlanComponentConfig = async (options = {}) => {
            const componentCode = String(options.componentCode || 'b_onebp_main_step_one_scene').trim() || 'b_onebp_main_step_one_scene';
            const bizCode = String(options.bizCode || 'universalBP').trim() || 'universalBP';
            const cacheKey = `${componentCode}::${bizCode}`;
            const now = Date.now();
            if (!options.refresh && componentConfigCache.data && componentConfigCache.key === cacheKey && now - componentConfigCache.ts < COMPONENT_CONFIG_CACHE_TTL_MS) {
                return deepClone(componentConfigCache.data);
            }
            const aemUid = resolveAemUid(options.aemUid || '');
            const query = {
                componentCode,
                bizCode
            };
            if (aemUid) query._aem_uid = aemUid;
            const response = await requestOneGet(ENDPOINTS.componentFindList, query, options.requestOptions || {});
            const summary = parseComponentFindListSummary(response?.data || response || {});
            mergeComponentGoalFallbackOptions(summary);
            mergeComponentFieldFallbackOptions(summary);
            const result = {
                ok: true,
                source: 'component_findList',
                fetchedAt: new Date().toISOString(),
                componentCode,
                bizCode,
                aemUid,
                summary,
                raw: deepClone(response || {})
            };
            componentConfigCache.key = cacheKey;
            componentConfigCache.ts = Date.now();
            componentConfigCache.data = deepClone(result);
            return result;
        };
        const extractSceneCreateInterfaces = (sceneName = '', options = {}) => extractSceneGoalSpecs(sceneName, options);
        const extractAllSceneCreateInterfaces = (options = {}) => extractAllSceneGoalSpecs(options);
        const listCachedSceneCreateContracts = (sceneName = '') => {
            loadSceneCreateContractCache();
            const targetScene = String(sceneName || '').trim();
            const now = Date.now();
            const out = [];
            Object.keys(sceneCreateContractCache.map || {}).forEach(key => {
                const entry = sceneCreateContractCache.map[key];
                if (!isPlainObject(entry)) return;
                const ts = toNumber(entry.ts, 0);
                if (!ts || now - ts > SCENE_CREATE_CONTRACT_CACHE_TTL_MS) {
                    delete sceneCreateContractCache.map[key];
                    return;
                }
                const data = isPlainObject(entry.data) ? deepClone(entry.data) : null;
                if (!data) return;
                const parts = String(key || '').split('::');
                const scenePart = String(parts[0] || '').trim();
                const goalPartRaw = String(parts[1] || '').trim();
                if (!scenePart) return;
                if (targetScene && scenePart !== targetScene) return;
                const goalLabel = goalPartRaw === '__scene_default__'
                    ? ''
                    : normalizeGoalCandidateLabel(goalPartRaw);
                out.push({
                    sceneName: scenePart,
                    goalLabel,
                    contract: data,
                    sampledAt: data?.sampledAt || (new Date(ts).toISOString()),
                    ts
                });
            });
            persistSceneCreateContractCache();
            return out.sort((a, b) => Number(b.ts || 0) - Number(a.ts || 0));
        };
        const mergeApiDocKeys = (lists = [], limit = 320) => mergeInterfaceKeyList(lists, limit);
        const pickPrimaryCreateInterface = (list = []) => {
            const interfaces = Array.isArray(list) ? list : [];
            if (!interfaces.length) return null;
            return interfaces.slice().sort((left, right) => {
                const diff = toNumber(right?.count, 0) - toNumber(left?.count, 0);
                if (diff !== 0) return diff;
                const leftBusiness = /\/solution\/business\/addList\.json$/i.test(String(left?.path || '')) ? 1 : 0;
                const rightBusiness = /\/solution\/business\/addList\.json$/i.test(String(right?.path || '')) ? 1 : 0;
                return rightBusiness - leftBusiness;
            })[0] || null;
        };
        const buildGoalCreateApiDocRow = ({
            sceneName = '',
            goalLabel = '',
            goalSpec = null,
            cachedGoalContract = null,
            cachedSceneContract = null,
            hookHistoryContract = null
        } = {}) => {
            const normalizedGoalLabel = normalizeGoalCandidateLabel(goalLabel || goalSpec?.goalLabel || '');
            const goalCreateContract = isPlainObject(goalSpec?.createContract) ? deepClone(goalSpec.createContract) : {};
            const goalLoadContracts = mergeContractSummaries(Array.isArray(goalSpec?.loadContracts) ? goalSpec.loadContracts : []);
            const goalCreateInterfaces = summarizeCreateInterfacesFromContracts(
                goalLoadContracts.filter(item => isGoalCreateSubmitPath(item?.path || ''))
            );
            const interfaceSummary = summarizeCreateInterfaceHints(goalCreateInterfaces);
            const topInterface = pickPrimaryCreateInterface(goalCreateInterfaces);
            const endpoint = normalizeGoalCreateEndpoint(
                topInterface?.path
                || interfaceSummary.path
                || goalCreateContract.endpoint
                || cachedGoalContract?.endpoint
                || hookHistoryContract?.endpoint
                || cachedSceneContract?.endpoint
                || ''
            );
            const method = normalizeCaptureMethod(
                topInterface?.method
                || interfaceSummary.method
                || goalCreateContract.method
                || cachedGoalContract?.method
                || hookHistoryContract?.method
                || cachedSceneContract?.method
                || 'POST'
            );
            const requestKeys = mergeApiDocKeys([
                interfaceSummary.requestKeys,
                goalCreateContract.requestKeys,
                cachedGoalContract?.requestKeys,
                hookHistoryContract?.requestKeys,
                cachedSceneContract?.requestKeys
            ], 480);
            const requestKeyPaths = mergeApiDocKeys([
                interfaceSummary.requestKeyPaths,
                goalCreateContract.requestKeyPaths,
                cachedGoalContract?.requestKeyPaths,
                hookHistoryContract?.requestKeyPaths,
                cachedSceneContract?.requestKeyPaths
            ], 1800);
            const solutionKeys = mergeApiDocKeys([
                interfaceSummary.solutionKeys,
                goalCreateContract.solutionKeys,
                cachedGoalContract?.solutionKeys,
                hookHistoryContract?.solutionKeys,
                cachedSceneContract?.solutionKeys
            ], 480);
            const solutionKeyPaths = mergeApiDocKeys([
                interfaceSummary.solutionKeyPaths,
                goalCreateContract.solutionKeyPaths,
                cachedGoalContract?.solutionKeyPaths,
                hookHistoryContract?.solutionKeyPaths,
                cachedSceneContract?.solutionKeyPaths
            ], 1600);
            const campaignKeys = mergeApiDocKeys([
                interfaceSummary.campaignKeys,
                goalCreateContract.campaignKeys,
                cachedGoalContract?.campaignKeys,
                hookHistoryContract?.campaignKeys,
                cachedSceneContract?.campaignKeys
            ], 480);
            const campaignKeyPaths = mergeApiDocKeys([
                interfaceSummary.campaignKeyPaths,
                goalCreateContract.campaignKeyPaths,
                cachedGoalContract?.campaignKeyPaths,
                hookHistoryContract?.campaignKeyPaths,
                cachedSceneContract?.campaignKeyPaths
            ], 1400);
            const adgroupKeys = mergeApiDocKeys([
                interfaceSummary.adgroupKeys,
                goalCreateContract.adgroupKeys,
                cachedGoalContract?.adgroupKeys,
                hookHistoryContract?.adgroupKeys,
                cachedSceneContract?.adgroupKeys
            ], 480);
            const adgroupKeyPaths = mergeApiDocKeys([
                interfaceSummary.adgroupKeyPaths,
                goalCreateContract.adgroupKeyPaths,
                cachedGoalContract?.adgroupKeyPaths,
                hookHistoryContract?.adgroupKeyPaths,
                cachedSceneContract?.adgroupKeyPaths
            ], 1400);
            const warnings = [];
            if (!requestKeyPaths.length && !requestKeys.length) {
                warnings.push('æœªæ•è·åˆ°è¯·æ±‚ä½“å­—æ®µï¼Œè¯·å…ˆæ‰§è¡Œä¸€æ¬¡çœŸå®æ–°å»ºæäº¤å¹¶å¼€å¯ç½‘ç»œç›‘å¬');
            }
            if (!campaignKeyPaths.length && !campaignKeys.length) {
                warnings.push('æœªæ•è·åˆ° campaign å­—æ®µ');
            }
            if (!adgroupKeyPaths.length && !adgroupKeys.length) {
                warnings.push('æœªæ•è·åˆ° adgroup å­—æ®µ');
            }
            if (!endpoint || endpoint === SCENE_CREATE_ENDPOINT_FALLBACK) {
                warnings.push(`åˆ›å»ºæ¥å£ç«¯ç‚¹æœªé”å®šï¼Œå½“å‰å›é€€ä¸º ${SCENE_CREATE_ENDPOINT_FALLBACK}`);
            }
            return {
                sceneName: String(sceneName || '').trim(),
                goalLabel: normalizedGoalLabel || '',
                isDefaultGoal: !!goalSpec?.isDefault,
                method,
                endpoint,
                requestKeys,
                requestKeyPaths,
                solutionKeys,
                solutionKeyPaths,
                campaignKeys,
                campaignKeyPaths,
                adgroupKeys,
                adgroupKeyPaths,
                createInterfaceCount: goalCreateInterfaces.length,
                createInterfaces: goalCreateInterfaces.slice(0, 120),
                source: uniqueBy([
                    goalCreateInterfaces.length ? 'goal_load_contracts' : '',
                    Object.keys(goalCreateContract || {}).length ? 'goal_create_contract' : '',
                    cachedGoalContract ? 'cached_goal_contract' : '',
                    cachedSceneContract ? 'cached_scene_contract' : '',
                    hookHistoryContract ? 'hook_history_contract' : ''
                ].filter(Boolean), item => item),
                warnings
            };
        };
            const getSceneCachedGoalSpecs = (sceneName = '') => {
                const targetScene = String(sceneName || '').trim();
                if (!targetScene) return [];
                const sceneBizCode = resolveSceneBizCodeHint(targetScene) || SCENE_BIZCODE_HINT_FALLBACK[targetScene] || '';
                const cachedSceneSpec = getCachedSceneSpec(targetScene, sceneBizCode);
                if (isPlainObject(cachedSceneSpec) && Array.isArray(cachedSceneSpec.goals) && cachedSceneSpec.goals.length) {
                    return normalizeGoalSpecContracts(cachedSceneSpec.goals);
                }
                return buildFallbackGoalSpecList(targetScene);
            };
        const buildSceneCreateApiDoc = async (sceneName = '', options = {}) => {
            const targetScene = String(sceneName || '').trim();
            if (!targetScene) {
                return {
                    ok: false,
                    sceneName: '',
                    goals: [],
                    warnings: ['ç¼ºå°‘ sceneName']
                };
            }
            const warnings = [];
            let goalSpecs = getSceneCachedGoalSpecs(targetScene);
            let sceneSpecSource = goalSpecs.length ? 'scene_spec_cache' : 'none';
            if ((!goalSpecs.length || options.refresh === true) && options.extractOnMiss === true) {
                try {
                    const extracted = await extractSceneGoalSpecs(targetScene, {
                        ...options,
                        refresh: true
                    });
                    if (Array.isArray(extracted?.goals) && extracted.goals.length) {
                        goalSpecs = normalizeGoalSpecContracts(extracted.goals);
                        sceneSpecSource = 'extract_scene_goal_specs';
                    }
                    if (Array.isArray(extracted?.warnings) && extracted.warnings.length) {
                        warnings.push(...extracted.warnings);
                    }
                } catch (err) {
                    warnings.push(`æå–åœºæ™¯è¥é”€ç›®æ ‡å¤±è´¥ï¼š${err?.message || err}`);
                }
            }

            const cachedContracts = listCachedSceneCreateContracts(targetScene);
            const cachedSceneContract = cachedContracts.find(item => !item.goalLabel)?.contract || getCachedSceneCreateContract(targetScene, '');
            const activeCaptureSummary = options.includeActiveCaptures === false
                ? { contracts: [], snapshots: [] }
                : collectContractsFromActiveCaptures(targetScene);
            const hookHistorySummary = options.includeHookHistory === false
                ? { contracts: [], snapshots: [] }
                : collectContractsFromHookHistory(targetScene, {
                    limit: Math.max(200, Math.min(30000, toNumber(options.historyLimit, 8000))),
                    since: Math.max(0, toNumber(options.historySince, 0))
                });
            const networkContracts = mergeContractSummaries(
                []
                    .concat(Array.isArray(activeCaptureSummary.contracts) ? activeCaptureSummary.contracts : [])
                    .concat(Array.isArray(hookHistorySummary.contracts) ? hookHistorySummary.contracts : [])
            );
            const hookCreateInterfaces = summarizeCreateInterfacesFromContracts(
                networkContracts.filter(item => isGoalCreateSubmitPath(item?.path || ''))
            );
            const hookSummary = summarizeCreateInterfaceHints(hookCreateInterfaces);
            const hookHistoryContract = hookCreateInterfaces.length ? {
                method: hookSummary.method || 'POST',
                endpoint: normalizeGoalCreateEndpoint(hookSummary.path || ''),
                requestKeys: hookSummary.requestKeys || [],
                requestKeyPaths: hookSummary.requestKeyPaths || [],
                solutionKeys: hookSummary.solutionKeys || [],
                solutionKeyPaths: hookSummary.solutionKeyPaths || [],
                campaignKeys: hookSummary.campaignKeys || [],
                campaignKeyPaths: hookSummary.campaignKeyPaths || [],
                adgroupKeys: hookSummary.adgroupKeys || [],
                adgroupKeyPaths: hookSummary.adgroupKeyPaths || []
            } : null;
            if (!goalSpecs.length) {
                warnings.push(`åœºæ™¯ã€Œ${targetScene}ã€æœªå‘½ä¸­è¥é”€ç›®æ ‡ç¼“å­˜ï¼Œå½“å‰æŒ‰å·²ç¼“å­˜åˆ›å»ºåˆåŒå…œåº•`);
            }
            if (!networkContracts.length) {
                warnings.push(`åœºæ™¯ã€Œ${targetScene}ã€æœªå‘½ä¸­ç½‘ç»œåˆåŒï¼ˆactive capture + hook historyï¼‰`);
            }
            if (!cachedContracts.length) {
                warnings.push(`åœºæ™¯ã€Œ${targetScene}ã€æœªå‘½ä¸­åˆ›å»ºåˆåŒç¼“å­˜`);
            }
            if (hookCreateInterfaces.length) {
                rememberSceneCreateInterfaces(targetScene, '', hookCreateInterfaces, {
                    source: 'create_api_doc_hook_history'
                });
            }

            const goalLabelList = uniqueBy(
                []
                    .concat(goalSpecs.map(goal => normalizeGoalCandidateLabel(goal?.goalLabel || '')).filter(Boolean))
                    .concat(cachedContracts.map(item => normalizeGoalCandidateLabel(item?.goalLabel || '')).filter(Boolean)),
                item => item
            );
            if (!goalLabelList.length) {
                goalLabelList.push('');
            }
            const goals = goalLabelList.map(goalLabel => {
                const goalSpec = goalSpecs.find(item => normalizeGoalCandidateLabel(item?.goalLabel || '') === goalLabel) || null;
                const cachedGoalContract = getCachedSceneCreateContract(targetScene, goalLabel);
                return buildGoalCreateApiDocRow({
                    sceneName: targetScene,
                    goalLabel,
                    goalSpec,
                    cachedGoalContract,
                    cachedSceneContract,
                    hookHistoryContract
                });
            });
            const missingCritical = goals.flatMap(goal => {
                const reasons = [];
                if (!Array.isArray(goal?.requestKeyPaths) || !goal.requestKeyPaths.length) {
                    reasons.push('request_key_paths_missing');
                }
                if (!Array.isArray(goal?.campaignKeyPaths) || !goal.campaignKeyPaths.length) {
                    reasons.push('campaign_key_paths_missing');
                }
                if (!Array.isArray(goal?.adgroupKeyPaths) || !goal.adgroupKeyPaths.length) {
                    reasons.push('adgroup_key_paths_missing');
                }
                if (!reasons.length) return [];
                return [{
                    sceneName: targetScene,
                    goalLabel: goal.goalLabel || 'é»˜è®¤ç›®æ ‡',
                    reason: reasons.join(',')
                }];
            });
            const sceneResult = {
                ok: missingCritical.length === 0,
                sceneName: targetScene,
                goalCount: goals.length,
                goals,
                sceneCoverage: {
                    sceneSpecSource,
                    cachedGoalContractCount: cachedContracts.length,
                    activeCaptureContractCount: Array.isArray(activeCaptureSummary.contracts) ? activeCaptureSummary.contracts.length : 0,
                    hookHistoryContractCount: Array.isArray(hookHistorySummary.contracts) ? hookHistorySummary.contracts.length : 0,
                    totalNetworkContractCount: networkContracts.length,
                    hookHistorySnapshotCount: Array.isArray(hookHistorySummary.snapshots) ? hookHistorySummary.snapshots.length : 0,
                    requestFieldCount: goals.reduce((sum, goal) => sum + toNumber(goal?.requestKeys?.length, 0), 0),
                    requestFieldPathCount: goals.reduce((sum, goal) => sum + toNumber(goal?.requestKeyPaths?.length, 0), 0)
                },
                missingCritical,
                warnings: uniqueBy(warnings.concat(goals.flatMap(goal => goal.warnings || [])), item => normalizeText(item)).slice(0, 240)
            };
            return sceneResult;
        };
        const buildCreateApiDoc = async (options = {}) => {
            const scenes = Array.isArray(options.scenes) && options.scenes.length
                ? uniqueBy(options.scenes.map(item => String(item || '').trim()).filter(Boolean), item => item)
                : SCENE_NAME_LIST.slice();
            const list = [];
            for (let i = 0; i < scenes.length; i++) {
                const sceneName = scenes[i];
                if (typeof options.onProgress === 'function') {
                    try {
                        options.onProgress({
                            event: 'create_api_doc_scene_start',
                            sceneName,
                            index: i + 1,
                            total: scenes.length
                        });
                    } catch { }
                }
                const row = await buildSceneCreateApiDoc(sceneName, options);
                list.push(row);
                if (typeof options.onProgress === 'function') {
                    try {
                        options.onProgress({
                            event: 'create_api_doc_scene_done',
                            sceneName,
                            index: i + 1,
                            total: scenes.length,
                            ok: !!row?.ok,
                            goalCount: toNumber(row?.goalCount, 0),
                            missingCriticalCount: Array.isArray(row?.missingCritical) ? row.missingCritical.length : 0
                        });
                    } catch { }
                }
            }
            const allGoals = list.flatMap(item => Array.isArray(item?.goals) ? item.goals : []);
            const missingCritical = list.flatMap(item => Array.isArray(item?.missingCritical) ? item.missingCritical : []);
            const result = {
                ok: missingCritical.length === 0,
                source: 'network_listener_and_cache',
                generatedAt: new Date().toISOString(),
                scenes,
                count: list.length,
                successCount: list.filter(item => item?.ok).length,
                failCount: list.filter(item => !item?.ok).length,
                goalCount: allGoals.length,
                requestFieldCount: allGoals.reduce((sum, goal) => sum + toNumber(goal?.requestKeys?.length, 0), 0),
                requestFieldPathCount: allGoals.reduce((sum, goal) => sum + toNumber(goal?.requestKeyPaths?.length, 0), 0),
                missingCriticalCount: missingCritical.length,
                missingCritical,
                list
            };
            window.__AM_WXT_SCENE_CREATE_API_REPORT__ = result;
            return result;
        };
        const parseCreateEndpointFromMethodPath = (value = '') => {
            const text = String(value || '').trim();
            if (!text) return '';
            const match = text.match(/^[A-Z]+\s+(.+)$/);
            return normalizeCapturePath(match ? match[1] : text);
        };
        const buildTemplateTimestamp = (date = new Date()) => {
            const d = date instanceof Date ? date : new Date();
            const pad = (n) => String(n).padStart(2, '0');
            return `${d.getFullYear()}${pad(d.getMonth() + 1)}${pad(d.getDate())}${pad(d.getHours())}${pad(d.getMinutes())}${pad(d.getSeconds())}`;
        };
        const buildDefaultCommonByScene = (sceneName = '') => {
            if (sceneName === 'å…³é”®è¯æ¨å¹¿') {
                return {
                    bidMode: 'smart',
                    useWordPackage: DEFAULTS.useWordPackage,
                    keywordMode: 'mixed',
                    keywordDefaults: {
                        matchScope: 4,
                        bidPrice: 1,
                        onlineStatus: 1
                    }
                };
            }
            return {};
        };
        const buildDefaultPlanByScene = (sceneName = '', stamp = '', suffix = '') => {
            const baseName = `${sceneName || 'è®¡åˆ’'}_${stamp}${suffix}`;
            const plan = {
                planName: baseName
            };
            if (isSceneLikelyRequireItem(sceneName)) {
                plan.itemId = '';
            }
            if (sceneName === 'å…³é”®è¯æ¨å¹¿') {
                plan.keywords = [''];
            }
            return plan;
        };
        const normalizeSceneSettingTemplateKey = (text = '') => normalizeText(String(text || '').replace(/[ï¼š:]/g, '')).trim();
        const stringifySceneSettingTemplateValue = (value) => {
            if (value === undefined || value === null) return '';
            if (typeof value === 'string') {
                return normalizeSceneSettingValue(value);
            }
            if (typeof value === 'number' || typeof value === 'boolean') {
                return String(value);
            }
            try {
                return JSON.stringify(value);
            } catch {
                return '';
            }
        };
        const flattenObjectToSceneSettingKeyValues = (source = null, prefix = '', options = {}) => {
            const maxDepth = Math.max(1, Math.min(8, toNumber(options.maxDepth, 6)));
            const out = [];
            const walk = (node, basePath = '', depth = 0) => {
                if (depth > maxDepth) return;
                if (Array.isArray(node)) {
                    if (!basePath) return;
                    const text = stringifySceneSettingTemplateValue(node);
                    if (!text) return;
                    out.push({ key: basePath, value: text });
                    return;
                }
                if (!isPlainObject(node)) {
                    if (!basePath) return;
                    const text = stringifySceneSettingTemplateValue(node);
                    if (!text) return;
                    out.push({ key: basePath, value: text });
                    return;
                }
                const keys = Object.keys(node).slice(0, 280);
                keys.forEach(key => {
                    const normalizedKey = String(key || '').trim();
                    if (!normalizedKey) return;
                    const nextPath = basePath ? `${basePath}.${normalizedKey}` : normalizedKey;
                    const value = node[normalizedKey];
                    if (isPlainObject(value)) {
                        walk(value, nextPath, depth + 1);
                        return;
                    }
                    if (Array.isArray(value)) {
                        const text = stringifySceneSettingTemplateValue(value);
                        if (!text) return;
                        out.push({ key: nextPath, value: text });
                        return;
                    }
                    const text = stringifySceneSettingTemplateValue(value);
                    if (!text) return;
                    out.push({ key: nextPath, value: text });
                });
            };
            walk(source, String(prefix || '').trim(), 0);
            return uniqueBy(
                out.filter(item => normalizeSceneSettingTemplateKey(item?.key || '') && normalizeSceneSettingValue(item?.value || '')),
                item => `${normalizeSceneSettingTemplateKey(item.key)}::${normalizeSceneSettingValue(item.value)}`
            ).slice(0, 2000);
        };
        const appendGoalContractDefaultsToSceneSettings = (goal = null, applyDefault = () => { }, allowEmptyKeys = false) => {
            const createContract = isPlainObject(goal?.createContract) ? goal.createContract : {};
            const runtimeSnapshot = isPlainObject(goal?.runtimeSnapshot) ? goal.runtimeSnapshot : {};
            const campaignDefaults = isPlainObject(createContract?.defaultCampaign) ? createContract.defaultCampaign : {};
            const adgroupDefaults = isPlainObject(createContract?.defaultAdgroup) ? createContract.defaultAdgroup : {};

            // runtimeSnapshot å­˜åœ¨ä½† defaultCampaign ç¼ºå¤±æ—¶ï¼Œä»ç¡®ä¿å…³é”®å­—æ®µå¯é…ç½®ã€‚
            Object.keys(runtimeSnapshot || {}).forEach(key => {
                const normalizedKey = String(key || '').trim();
                if (!normalizedKey || campaignDefaults[normalizedKey] !== undefined) return;
                campaignDefaults[normalizedKey] = runtimeSnapshot[normalizedKey];
            });

            flattenObjectToSceneSettingKeyValues(campaignDefaults, 'campaign', { maxDepth: 6 })
                .forEach(entry => {
                    applyDefault(entry.key, entry.value);
                });
            flattenObjectToSceneSettingKeyValues(adgroupDefaults, 'adgroup', { maxDepth: 6 })
                .forEach(entry => {
                    applyDefault(entry.key, entry.value);
                });
            if (allowEmptyKeys) {
                const normalizePathKey = (path = '') => String(path || '')
                    .trim()
                    .replace(/^(campaign|adgroup)\./i, '')
                    .replace(/\[\]/g, '')
                    .replace(/\.+/g, '.')
                    .replace(/^\.+|\.+$/g, '');
                const appendPathList = (prefix = '', list = []) => {
                    (Array.isArray(list) ? list : [])
                        .map(item => normalizePathKey(item))
                        .filter(Boolean)
                        .slice(0, 1200)
                        .forEach(path => {
                            applyDefault(`${prefix}.${path}`, '', true);
                        });
                };
                appendPathList('campaign', createContract?.campaignKeyPaths || []);
                appendPathList('adgroup', createContract?.adgroupKeyPaths || []);
            }
        };
        const pickSceneSettingDefaultFromFieldRow = (row = {}) => {
            const defaultValue = normalizeSceneSettingValue(row?.defaultValue || '');
            if (defaultValue) return defaultValue;
            const options = Array.isArray(row?.options) ? row.options : [];
            const firstOption = options
                .map(item => normalizeSceneSettingValue(item))
                .find(Boolean);
            return firstOption || '';
        };
        const collectGoalFieldRowsForTemplate = (sceneName = '', goal = null, goalLabel = '') => {
            const targetScene = String(sceneName || '').trim();
            const normalizedGoalLabel = normalizeGoalLabel(goalLabel || goal?.goalLabel || '');
            const rowSeeds = [];
            if (Array.isArray(goal?.fieldRows) && goal.fieldRows.length) {
                rowSeeds.push(...goal.fieldRows);
            }
            if (Array.isArray(goal?.settingsRows) && goal.settingsRows.length) {
                rowSeeds.push(...goal.settingsRows);
            }
            if (isPlainObject(goal?.fieldMatrix)) {
                Object.keys(goal.fieldMatrix).forEach(label => {
                    const matrixRow = goal.fieldMatrix[label];
                    if (!matrixRow) return;
                    rowSeeds.push({
                        label,
                        options: Array.isArray(matrixRow?.options) ? matrixRow.options : [],
                        defaultValue: matrixRow?.defaultValue || ''
                    });
                });
            }
            if (!rowSeeds.length) {
                rowSeeds.push(...getSceneGoalFieldRowFallback(targetScene, normalizedGoalLabel));
            }
            return normalizeGoalFieldRows(rowSeeds);
        };
        const buildSceneSettingsTemplateByGoal = ({
            sceneName = '',
            goalLabel = '',
            goal = null,
            planTemplate = null,
            contractHints = {}
        } = {}) => {
            const targetScene = String(sceneName || '').trim();
            const normalizedGoal = normalizeGoalLabel(goalLabel || goal?.goalLabel || '');
            const output = {};
            const applyDefault = (key = '', value = '', allowEmpty = false) => {
                const normalizedKey = normalizeSceneSettingTemplateKey(key);
                const normalizedValue = normalizeSceneSettingValue(value);
                if (!normalizedKey) return;
                const currentValue = normalizeSceneSettingValue(output[normalizedKey]);
                if (currentValue) return;
                if (!normalizedValue && !allowEmpty) return;
                output[normalizedKey] = normalizedValue;
            };
            applyDefault('åœºæ™¯åç§°', targetScene);
            if (normalizedGoal) {
                applyDefault('è¥é”€ç›®æ ‡', normalizedGoal);
            }
            const fieldRows = collectGoalFieldRowsForTemplate(targetScene, goal, normalizedGoal);
            fieldRows.forEach(row => {
                const fieldLabel = normalizeSceneSettingTemplateKey(row?.label || row?.settingKey || '');
                if (!fieldLabel) return;
                applyDefault(fieldLabel, pickSceneSettingDefaultFromFieldRow(row));
            });
            const fallbackDefaults = isPlainObject(SCENE_SPEC_FIELD_FALLBACK[targetScene]) ? SCENE_SPEC_FIELD_FALLBACK[targetScene] : {};
            Object.keys(fallbackDefaults).forEach(key => {
                applyDefault(key, fallbackDefaults[key]);
            });
            appendGoalContractDefaultsToSceneSettings(goal, applyDefault, true);
            const normalizePath = (path = '') => String(path || '')
                .trim()
                .replace(/^(campaign|adgroup)\./i, '')
                .replace(/\[\]/g, '')
                .replace(/\.+/g, '.')
                .replace(/^\.+|\.+$/g, '');
            const appendHintPaths = (prefix = '', paths = []) => {
                (Array.isArray(paths) ? paths : [])
                    .map(item => normalizePath(item))
                    .filter(Boolean)
                    .slice(0, 1200)
                    .forEach(path => applyDefault(`${prefix}.${path}`, '', true));
            };
            appendHintPaths('campaign', contractHints?.campaignKeyPaths || []);
            appendHintPaths('adgroup', contractHints?.adgroupKeyPaths || []);
            const planName = normalizeSceneSettingValue(planTemplate?.planName || '');
            if (planName) {
                applyDefault('è®¡åˆ’åç§°', planName);
            }
            return output;
        };
        const normalizeTemplateSceneListInput = (source = null) => {
            if (Array.isArray(source)) return source;
            if (isPlainObject(source)) {
                if (Array.isArray(source.scenes)) return source.scenes;
                if (Array.isArray(source.list)) return source.list;
                if (Array.isArray(source.results)) return source.results;
            }
            const fromWindow = window.__AM_WXT_SCENE_CREATE_API_REPORT__;
            if (isPlainObject(fromWindow)) {
                if (Array.isArray(fromWindow.list)) return fromWindow.list;
                if (Array.isArray(fromWindow.scenes)) return fromWindow.scenes;
            }
            return [];
        };
        const inferCreateInterfacesFromSceneEntry = (entry = {}) => {
            if (Array.isArray(entry?.createInterfaces) && entry.createInterfaces.length) {
                return deepClone(entry.createInterfaces);
            }
            if (Array.isArray(entry?.createContracts) && entry.createContracts.length) {
                return summarizeCreateInterfacesFromContracts(entry.createContracts);
            }
            return [];
        };
        const buildSceneGoalRequestTemplates = async (source = null, options = {}) => {
            const sceneEntries = normalizeTemplateSceneListInput(source);
            const requestedScenes = Array.isArray(options?.scenes) && options.scenes.length
                ? uniqueBy(options.scenes.map(item => String(item || '').trim()).filter(Boolean), item => item)
                : [];
            const sceneNameList = requestedScenes.length
                ? requestedScenes
                : uniqueBy(sceneEntries.map(item => String(item?.sceneName || '').trim()).filter(Boolean), item => item);
            const fallbackScenes = sceneNameList.length ? sceneNameList : SCENE_NAME_LIST.slice();
            const stamp = buildTemplateTimestamp(new Date());
            const outList = [];

            for (let i = 0; i < fallbackScenes.length; i++) {
                const sceneName = fallbackScenes[i];
                const sceneEntry = sceneEntries.find(item => String(item?.sceneName || '').trim() === sceneName) || {};
                const createInterfaces = inferCreateInterfacesFromSceneEntry(sceneEntry);
                const createEndpoints = uniqueBy(
                    (Array.isArray(sceneEntry?.createEndpoints) ? sceneEntry.createEndpoints : []).map(item => String(item || '').trim()).filter(Boolean),
                    item => item
                );
                let goals = Array.isArray(sceneEntry?.goals) ? sceneEntry.goals : [];
                const warnings = [];
                if (!goals.length && options.resolveGoals !== false) {
                    try {
                        const sceneGoalResult = await extractSceneGoalSpecs(sceneName, {
                            scanMode: options.scanMode || 'visible',
                            unlockPolicy: options.unlockPolicy || 'safe_only',
                            refresh: !!options.refresh,
                            contractMode: 'network_only'
                        });
                        if (Array.isArray(sceneGoalResult?.goals) && sceneGoalResult.goals.length) {
                            goals = sceneGoalResult.goals;
                        }
                        if (Array.isArray(sceneGoalResult?.warnings) && sceneGoalResult.warnings.length) {
                            warnings.push(...sceneGoalResult.warnings);
                        }
                    } catch (err) {
                        warnings.push(`è¯»å–è¥é”€ç›®æ ‡å¤±è´¥ï¼š${err?.message || err}`);
                    }
                }
                const normalizedGoals = uniqueBy(
                    (Array.isArray(goals) ? goals : []).map(goal => ({
                        goalLabel: normalizeGoalLabel(goal?.goalLabel || ''),
                        isDefault: !!goal?.isDefault,
                        raw: isPlainObject(goal) ? deepClone(goal) : {}
                    })).filter(goal => goal.goalLabel),
                    goal => goal.goalLabel
                );
                if (!normalizedGoals.length) {
                    normalizedGoals.push({
                        goalLabel: '',
                        isDefault: true,
                        raw: {}
                    });
                } else if (!normalizedGoals.some(goal => goal.isDefault)) {
                    normalizedGoals[0].isDefault = true;
                }

                const preferredInterface = createInterfaces
                    .slice()
                    .sort((a, b) => toNumber(b?.count, 0) - toNumber(a?.count, 0))[0] || null;
                const submitEndpoint = normalizeCapturedCreateEndpoint(
                    preferredInterface?.path
                    || parseCreateEndpointFromMethodPath(createEndpoints[0] || '')
                    || ''
                );
                const contractHints = {
                    requestKeys: Array.isArray(preferredInterface?.requestKeys) ? preferredInterface.requestKeys.slice(0, 240) : [],
                    requestKeyPaths: Array.isArray(preferredInterface?.requestKeyPaths) ? preferredInterface.requestKeyPaths.slice(0, 1400) : [],
                    solutionKeys: Array.isArray(preferredInterface?.solutionKeys) ? preferredInterface.solutionKeys.slice(0, 240) : [],
                    solutionKeyPaths: Array.isArray(preferredInterface?.solutionKeyPaths) ? preferredInterface.solutionKeyPaths.slice(0, 1200) : [],
                    campaignKeys: Array.isArray(preferredInterface?.campaignKeys) ? preferredInterface.campaignKeys.slice(0, 240) : [],
                    campaignKeyPaths: Array.isArray(preferredInterface?.campaignKeyPaths) ? preferredInterface.campaignKeyPaths.slice(0, 1200) : [],
                    adgroupKeys: Array.isArray(preferredInterface?.adgroupKeys) ? preferredInterface.adgroupKeys.slice(0, 240) : [],
                    adgroupKeyPaths: Array.isArray(preferredInterface?.adgroupKeyPaths) ? preferredInterface.adgroupKeyPaths.slice(0, 1200) : []
                };

                normalizedGoals.forEach((goal, goalIdx) => {
                    const planTemplate = buildDefaultPlanByScene(sceneName, stamp, String(i * 20 + goalIdx + 1).padStart(2, '0'));
                    const requestTemplate = {
                        sceneName,
                        marketingGoal: goal.goalLabel || '',
                        common: buildDefaultCommonByScene(sceneName),
                        sceneSettings: buildSceneSettingsTemplateByGoal({
                            sceneName,
                            goalLabel: goal.goalLabel || '',
                            goal: goal?.raw || {},
                            planTemplate,
                            contractHints
                        }),
                        plans: [
                            planTemplate
                        ]
                    };
                    if (submitEndpoint) requestTemplate.submitEndpoint = submitEndpoint;
                    outList.push({
                        sceneName,
                        marketingGoal: goal.goalLabel || '',
                        isDefaultGoal: !!goal.isDefault,
                        submitEndpoint,
                        createInterfaces: createInterfaces.slice(0, 12),
                        createEndpoints: createEndpoints.slice(0, 12),
                        contractHints,
                        warnings: uniqueBy(warnings, item => item).slice(0, 40),
                        requestTemplate
                    });
                });
            }

            const templateMap = {};
            outList.forEach(item => {
                const sceneName = item.sceneName || '';
                const goalLabel = item.marketingGoal || 'é»˜è®¤ç›®æ ‡';
                if (!templateMap[sceneName]) templateMap[sceneName] = {};
                templateMap[sceneName][goalLabel] = deepClone(item.requestTemplate);
            });
            const result = {
                ok: true,
                source: 'capture_report_to_request_templates',
                generatedAt: new Date().toISOString(),
                sceneCount: uniqueBy(outList.map(item => item.sceneName).filter(Boolean), item => item).length,
                templateCount: outList.length,
                list: outList,
                map: templateMap
            };
            window.__AM_WXT_SCENE_GOAL_REQUEST_TEMPLATES__ = result;
            return result;
        };

        const toSafeItemRaw = (item = {}) => {
            const source = isPlainObject(item?.raw) ? item.raw : (isPlainObject(item) ? item : {});
            const materialId = String(source.materialId || source.itemId || item.materialId || item.itemId || '').trim();
            const itemId = String(source.itemId || source.materialId || item.itemId || item.materialId || '').trim();
            return {
                materialId: materialId || itemId,
                itemId: itemId || materialId,
                materialName: source.materialName || source.title || source.name || '',
                shopId: source.shopId || '',
                shopName: source.shopName || '',
                linkUrl: source.linkUrl || '',
                bidCount: source.bidCount || 0,
                categoryLevel1: source.categoryLevel1 || ''
            };
        };

        const normalizeItem = (item = {}) => {
            const materialId = String(item.materialId || item.itemId || '').trim();
            const itemId = String(item.itemId || item.materialId || '').trim();
            return {
                materialId: materialId || itemId,
                itemId: itemId || materialId,
                materialName: item.materialName || item.title || item.name || '',
                shopId: item.shopId || '',
                shopName: item.shopName || '',
                linkUrl: item.linkUrl || '',
                bidCount: item.bidCount || 0,
                categoryLevel1: item.categoryLevel1 || '',
                fromTab: item.fromTab || 'manual',
                raw: toSafeItemRaw(item)
            };
        };

        const parseItemIdsFromText = (text = '') => {
            const ids = [];
            const regex = /\d{6,}/g;
            let m;
            while ((m = regex.exec(text))) ids.push(m[0]);
            return uniqueBy(ids, id => id);
        };

        const parseQueryToItemIds = (query = '') => {
            if (!query) return [];
            const candidates = query.split(/[,ï¼Œ\s]+/).map(s => s.trim()).filter(Boolean);
            if (!candidates.length) return [];
            if (candidates.every(v => /^\d{6,}$/.test(v))) return uniqueBy(candidates, id => id);
            return [];
        };

        const searchItems = async (params = {}) => {
            const runtime = await getRuntimeDefaults(false);
            const bizCode = params.bizCode || runtime.bizCode || DEFAULTS.bizCode;
            const query = (params.query || '').trim();
            const queryItemIds = parseQueryToItemIds(query);
            const itemIdList = uniqueBy([...(params.itemIdList || []), ...queryItemIds].map(v => String(v).trim()).filter(Boolean), v => v);
            const hasTagId = Object.prototype.hasOwnProperty.call(params, 'tagId');
            const hasChannelKey = Object.prototype.hasOwnProperty.call(params, 'channelKey');
            const payload = {
                needQualification: true,
                materialType: 1,
                bizCode,
                promotionScene: params.promotionScene || runtime.promotionScene || DEFAULTS.promotionScene,
                itemSelectedMode: params.itemSelectedMode || runtime.itemSelectedMode || DEFAULTS.itemSelectedMode,
                subPromotionType: params.subPromotionType || DEFAULTS.subPromotionType,
                promotionType: params.promotionType || DEFAULTS.promotionType,
                offset: toNumber(params.offset, 0),
                pageSize: Math.max(1, Math.min(200, toNumber(params.pageSize, 40)))
            };
            if (hasTagId) {
                if (params.tagId !== undefined && params.tagId !== null && String(params.tagId).trim() !== '') {
                    payload.tagId = params.tagId;
                }
            } else {
                payload.tagId = '101111310';
            }
            if (hasChannelKey) {
                if (params.channelKey !== undefined && params.channelKey !== null && String(params.channelKey).trim() !== '') {
                    payload.channelKey = params.channelKey;
                }
            } else if (!query) {
                payload.channelKey = 'effect';
            }
            if (itemIdList.length) payload.itemIdList = itemIdList;
            if (query && !itemIdList.length) {
                payload.searchKeyword = query;
                payload.keyword = query;
                payload.itemTitle = query;
            }
            if (isPlainObject(params.extra)) Object.assign(payload, params.extra);

            const res = await requestOne(ENDPOINTS.materialFindPage, bizCode, payload, params.requestOptions || {});
            const list = Array.isArray(res?.data?.list) ? res.data.list.map(normalizeItem).filter(item => item.materialId) : [];
            return {
                ok: true,
                count: toNumber(res?.data?.count, list.length),
                list,
                raw: res
            };
        };

        const parseMatchScope = (value, fallback = DEFAULTS.matchScope) => {
            if (value === undefined || value === null || value === '') return fallback;
            if (value === 1 || value === '1' || value === 'exact' || value === 'ç²¾å‡†' || value === 'ç²¾ç¡®') return 1;
            if (value === 4 || value === '4' || value === 'broad' || value === 'å¹¿æ³›') return 4;
            return fallback;
        };

        const parseKeywordItem = (input, keywordDefaults = {}) => {
            const fallbackBid = toNumber(keywordDefaults.bidPrice, 1);
            const fallbackMatch = parseMatchScope(keywordDefaults.matchScope, DEFAULTS.matchScope);
            const fallbackStatus = toNumber(keywordDefaults.onlineStatus, DEFAULTS.keywordOnlineStatus);

            if (isPlainObject(input)) {
                const word = String(input.word || input.keyword || '').trim();
                if (!word) return null;
                return {
                    word,
                    bidPrice: toNumber(input.bidPrice, fallbackBid),
                    matchScope: parseMatchScope(input.matchScope, fallbackMatch),
                    onlineStatus: toNumber(input.onlineStatus, fallbackStatus)
                };
            }

            const raw = String(input || '').trim();
            if (!raw) return null;
            const parts = raw.split(/[,\tï¼Œ]/).map(s => s.trim()).filter(Boolean);
            const [word, bidPrice, matchScope] = parts;
            if (!word) return null;
            return {
                word,
                bidPrice: toNumber(bidPrice, fallbackBid),
                matchScope: parseMatchScope(matchScope, fallbackMatch),
                onlineStatus: fallbackStatus
            };
        };

        const parseKeywords = (keywordsInput, keywordDefaults = {}) => {
            if (!keywordsInput) return [];
            if (Array.isArray(keywordsInput)) {
                return uniqueBy(
                    keywordsInput.map(item => parseKeywordItem(item, keywordDefaults)).filter(Boolean),
                    item => item.word
                );
            }
            const text = String(keywordsInput);
            const lines = text.split(/\r?\n/).map(line => line.trim()).filter(Boolean);
            return uniqueBy(
                lines.map(line => parseKeywordItem(line, keywordDefaults)).filter(Boolean),
                item => item.word
            );
        };

        const fetchRecommendWordList = async ({ bizCode, materialId, defaults, source = 'auto', requestOptions }) => {
            const idValue = toIdValue(materialId);
            const body = {
                bizCode,
                itemSelectedMode: defaults.itemSelectedMode,
                bidTypeV2: defaults.bidTypeV2,
                bidTargetV2: defaults.bidTargetV2,
                promotionScene: defaults.promotionScene,
                materialId: idValue,
                materialIdList: [idValue]
            };
            const paths = source === 'kr'
                ? [ENDPOINTS.bidwordSuggestKr, ENDPOINTS.bidwordSuggestDefault]
                : source === 'default'
                    ? [ENDPOINTS.bidwordSuggestDefault]
                    : [ENDPOINTS.bidwordSuggestDefault, ENDPOINTS.bidwordSuggestKr];
            for (const path of paths) {
                try {
                    const res = await requestOne(path, bizCode, body, requestOptions || {});
                    const list = res?.data?.list?.[0]?.wordList;
                    if (Array.isArray(list) && list.length) return list;
                } catch (err) {
                    log.warn(`æ¨èè¯æ¥å£å¤±è´¥ ${path}:`, err?.message || err);
                }
            }
            return [];
        };

        const fetchRecommendWordPackageList = async ({ bizCode, materialId, defaults, requestOptions }) => {
            const idValue = toIdValue(materialId);
            const body = {
                bizCode,
                itemSelectedMode: defaults.itemSelectedMode,
                bidTypeV2: defaults.bidTypeV2,
                bidTargetV2: defaults.bidTargetV2,
                promotionScene: defaults.promotionScene,
                materialId: idValue,
                materialIdList: [idValue]
            };
            try {
                const res = await requestOne(ENDPOINTS.wordPackageSuggestDefault, bizCode, body, requestOptions || {});
                const list = res?.data?.list?.[0]?.wordPackageList;
                return Array.isArray(list) ? list : [];
            } catch (err) {
                log.warn('æ¨èè¯åŒ…æ¥å£å¤±è´¥:', err?.message || err);
                return [];
            }
        };

        const getCrowdMxId = (label = {}) => {
            const targetType = label?.targetType;
            const labelId = label?.labelId;
            const priceDimension = label?.priceDimension;
            const isMulti = !!label?.isMulti;
            if (priceDimension === 'OPTION' || (priceDimension === 'LABEL' && isMulti)) {
                const optionValues = (label?.optionList || [])
                    .map(option => String(option?.optionValue ?? '').trim())
                    .filter(Boolean)
                    .sort();
                return `${targetType}_${labelId}_${optionValues.join('_')}`;
            }
            return `${targetType}_${labelId}`;
        };

        const buildCrowdName = (label = {}) => {
            const labelName = String(label?.labelName || '').trim();
            const optionName = uniqueBy(
                (label?.optionList || []).map(option => String(option?.optionName || '').trim()).filter(Boolean),
                name => name
            ).join('ï¼Œ');
            return uniqueBy([labelName, optionName].filter(Boolean), name => name).join('ï¼š');
        };

        const labelListToCrowdList = (labelList = []) => {
            const out = [];
            (labelList || []).forEach((labelItem) => {
                if (!labelItem || typeof labelItem !== 'object') return;
                const priceDimension = labelItem.priceDimension;
                const priceMode = String(labelItem.priceMode);
                const optionList = Array.isArray(labelItem.optionList) ? labelItem.optionList : [];

                if (priceDimension === 'OPTION' || ((priceDimension === 'LABEL') && !!labelItem.isMulti)) {
                    optionList.forEach((option) => {
                        const label = deepClone(labelItem);
                        label.optionList = [deepClone(option)];
                        const crowd = {
                            crowd: {
                                targetType: labelItem.targetType,
                                label,
                                crowdName: buildCrowdName(label)
                            },
                            price: deepClone(option?.price || {}),
                            showTagList: label.showTagList || []
                        };
                        crowd.mx_crowdId = getCrowdMxId(label);
                        out.push(crowd);
                    });
                    return;
                }

                if (priceDimension === 'LABEL' || ['0', '1', '-1', '2', '3'].includes(priceMode)) {
                    const label = deepClone(labelItem);
                    const crowd = {
                        crowd: {
                            targetType: labelItem.targetType,
                            label,
                            crowdName: buildCrowdName(label)
                        },
                        price: deepClone(label?.price || {}),
                        showTagList: label.showTagList || []
                    };
                    crowd.mx_crowdId = getCrowdMxId(label);
                    out.push(crowd);
                }
            });
            return uniqueBy(out, item => item?.mx_crowdId || `${item?.crowd?.label?.labelId || ''}_${item?.crowd?.label?.optionList?.[0]?.optionValue || ''}`);
        };

        const fetchRecommendCrowdList = async ({ bizCode, defaults, labelIdList, materialIdList = [], requestOptions }) => {
            const ids = uniqueBy(
                (Array.isArray(labelIdList) ? labelIdList : DEFAULTS.recommendCrowdLabelIds)
                    .map(id => String(id || '').trim())
                    .filter(Boolean),
                id => id
            );
            if (!ids.length) return [];

            const labelResults = [];
            for (const labelId of ids) {
                try {
                    const res = await requestOne(ENDPOINTS.labelFindList, bizCode, {
                        bizCode,
                        promotionScene: defaults.promotionScene,
                        promotionType: defaults.promotionType || DEFAULTS.promotionType,
                        subPromotionType: defaults.subPromotionType || DEFAULTS.subPromotionType,
                        optimizeTarget: defaults.bidTargetV2 || DEFAULTS.bidTargetV2,
                        labelList: [{ labelId }],
                        materialIdList: (materialIdList || []).map(toIdValue).filter(Boolean)
                    }, requestOptions || {});
                    const list = Array.isArray(res?.data?.list) ? res.data.list : [];
                    if (list.length) labelResults.push(...list);
                } catch (err) {
                    log.warn(`æ¨èäººç¾¤æ¥å£å¤±è´¥ labelId=${labelId}:`, err?.message || err);
                }
            }
            return labelListToCrowdList(labelResults);
        };

        const applyKeywordDefaults = (word, keywordDefaults = {}) => {
            const fallbackBid = toNumber(keywordDefaults.bidPrice, 1);
            const fallbackMatch = parseMatchScope(keywordDefaults.matchScope, DEFAULTS.matchScope);
            const fallbackStatus = toNumber(keywordDefaults.onlineStatus, DEFAULTS.keywordOnlineStatus);
            return {
                word: String(word.word || word.keyword || '').trim(),
                bidPrice: toNumber(word.bidPrice, fallbackBid),
                matchScope: parseMatchScope(word.matchScope, fallbackMatch),
                onlineStatus: toNumber(word.onlineStatus, fallbackStatus)
            };
        };

        const WORD_PACKAGE_FIELD_RE = /(wordpackage|word_package|è¯åŒ…|krpackage|traffic.*package|package.*word|package)/i;
        const stripWordPackageArtifacts = (value) => {
            if (Array.isArray(value)) {
                return value
                    .map(item => stripWordPackageArtifacts(item))
                    .filter(item => item !== undefined && item !== null);
            }
            if (!isPlainObject(value)) return value;
            const out = {};
            Object.keys(value).forEach(key => {
                if (WORD_PACKAGE_FIELD_RE.test(key)) return;
                const nextValue = stripWordPackageArtifacts(value[key]);
                if (nextValue === undefined) return;
                out[key] = nextValue;
            });
            return out;
        };

        const KEYWORD_TRAFFIC_PACKAGE_FIELD_RE = /(golden|detent|trend|traffic|kr|card|flow|package|è¯åŒ…|å¡ä½|è¶‹åŠ¿|æµé‡é‡‘å¡)/i;
        const stripKeywordTrafficArtifacts = (value) => {
            if (Array.isArray(value)) {
                return value
                    .map(item => stripKeywordTrafficArtifacts(item))
                    .filter(item => item !== undefined && item !== null);
            }
            if (!isPlainObject(value)) return value;
            const out = {};
            Object.keys(value).forEach(key => {
                const lower = key.toLowerCase();
                if (key !== 'promotionScene'
                    && key !== 'subPromotionType'
                    && key !== 'promotionType'
                    && key !== 'itemSelectedMode'
                    && key !== 'campaignName'
                    && KEYWORD_TRAFFIC_PACKAGE_FIELD_RE.test(lower)) {
                    return;
                }
                const nextValue = stripKeywordTrafficArtifacts(value[key]);
                if (nextValue === undefined) return;
                out[key] = nextValue;
            });
            return out;
        };

        const KEYWORD_CUSTOM_CAMPAIGN_ALLOW_KEYS = new Set([
            'operation',
            'bizCode',
            'promotionScene',
            'subPromotionType',
            'promotionType',
            'itemSelectedMode',
            'bidTypeV2',
            'bidTargetV2',
            'campaignCycleBudgetInfo',
            'itemIdList',
            'deleteAdgroupList',
            'updatedRightInfoAdgroupList',
            'setSingleCostV2',
            'singleCostV2',
            'optimizeTarget',
            'dmcType',
            'campaignName',
            'campaignGroupId',
            'campaignGroupName',
            'supportCouponId',
            'creativeSetMode',
            'smartCreative',
            'campaignColdStartVO',
            'needTargetCrowd',
            'aiXiaowanCrowdListSwitch',
            'crowdList',
            'adzoneList',
            'launchAreaStrList',
            'launchPeriodList',
            'dayBudget',
            'dayAverageBudget',
            'totalBudget',
            'futureBudget'
        ]);
        const KEYWORD_WORD_PACKAGE_ERROR_RE = /æµé‡æ™ºé€‰è¯åŒ…æ ¡éªŒå¤±è´¥/;

        const normalizeBidMode = (value, fallback = 'smart') => {
            const raw = String(value || '').trim().toLowerCase();
            if (raw === 'smart' || raw === 'smart_bid') return 'smart';
            if (raw === 'manual' || raw === 'custom' || raw === 'custom_bid' || raw === 'manual_bid') return 'manual';
            if (fallback === '') return '';
            return fallback === 'manual' ? 'manual' : 'smart';
        };

        const normalizeFallbackPolicy = (value, fallback = 'confirm') => {
            const raw = String(value || '').trim().toLowerCase();
            if (raw === 'auto' || raw === 'none' || raw === 'confirm') return raw;
            return fallback === 'auto' || fallback === 'none' ? fallback : 'confirm';
        };
        const normalizeWizardFallbackPolicy = (value) => {
            const preferred = WIZARD_FORCE_API_ONLY_SCENE_CONFIG ? 'auto' : 'confirm';
            const normalized = normalizeFallbackPolicy(value || preferred, preferred);
            if (WIZARD_FORCE_API_ONLY_SCENE_CONFIG && normalized === 'confirm') return 'auto';
            return normalized;
        };

        const bidModeToBidType = (bidMode = 'smart') => normalizeBidMode(bidMode) === 'manual' ? 'custom_bid' : 'smart_bid';

        const isWordPackageValidationError = (errorText = '') => KEYWORD_WORD_PACKAGE_ERROR_RE.test(String(errorText || ''));

        const resolvePlanBidMode = ({ plan = {}, request = {}, runtime = {}, campaign = {} } = {}) => {
            const keywordGoal = normalizeGoalLabel(
                plan?.marketingGoal
                || plan?.__goalResolution?.resolvedMarketingGoal
                || request?.marketingGoal
                || request?.common?.marketingGoal
                || request?.__goalResolution?.resolvedMarketingGoal
                || ''
            );
            const keywordSceneHint = String(
                plan?.campaignOverride?.promotionScene
                || plan?.goalForcedCampaignOverride?.promotionScene
                || request?.sceneForcedCampaignOverride?.promotionScene
                || request?.goalForcedCampaignOverride?.promotionScene
                || request?.common?.campaignOverride?.promotionScene
                || request?.promotionScene
                || campaign?.promotionScene
                || runtime?.promotionScene
                || ''
            ).trim();
            const keywordItemModeHint = String(
                plan?.campaignOverride?.itemSelectedMode
                || plan?.goalForcedCampaignOverride?.itemSelectedMode
                || request?.sceneForcedCampaignOverride?.itemSelectedMode
                || request?.goalForcedCampaignOverride?.itemSelectedMode
                || request?.common?.campaignOverride?.itemSelectedMode
                || request?.itemSelectedMode
                || campaign?.itemSelectedMode
                || runtime?.itemSelectedMode
                || ''
            ).trim();
            const fromPlan = normalizeBidMode(plan?.bidMode || '', '');
            if (fromPlan) return fromPlan;
            const fromCommon = normalizeBidMode(request?.common?.bidMode || '', '');
            if (fromCommon) return fromCommon;
            const fromRequest = normalizeBidMode(request?.bidMode || '', '');
            if (fromRequest) return fromRequest;
            const fromPlanCampaign = normalizeBidMode(plan?.campaignOverride?.bidTypeV2 || '', '');
            if (fromPlanCampaign) return fromPlanCampaign;
            const fromPlanGoalCampaign = normalizeBidMode(plan?.goalForcedCampaignOverride?.bidTypeV2 || '', '');
            if (fromPlanGoalCampaign) return fromPlanGoalCampaign;
            const fromCommonCampaign = normalizeBidMode(request?.common?.campaignOverride?.bidTypeV2 || '', '');
            if (fromCommonCampaign) return fromCommonCampaign;
            const fromSceneForcedCampaign = normalizeBidMode(request?.sceneForcedCampaignOverride?.bidTypeV2 || '', '');
            if (fromSceneForcedCampaign) return fromSceneForcedCampaign;
            const fromGoalForcedCampaign = normalizeBidMode(request?.goalForcedCampaignOverride?.bidTypeV2 || '', '');
            if (fromGoalForcedCampaign) return fromGoalForcedCampaign;
            const fromRequestCampaign = normalizeBidMode(request?.bidTypeV2 || '', '');
            if (fromRequestCampaign) return fromRequestCampaign;
            const fromCampaign = normalizeBidMode(campaign?.bidTypeV2 || '', '');
            if (fromCampaign) return fromCampaign;
            const hintedBidType = normalizeBidMode(
                keywordGoal === 'è‡ªå®šä¹‰æ¨å¹¿'
                    ? 'custom_bid'
                    : (
                        keywordSceneHint === 'promotion_scene_search_user_define'
                            || keywordItemModeHint === 'user_define'
                            ? 'custom_bid'
                            : ''
                    ),
                ''
            );
            if (hintedBidType) return hintedBidType;
            return normalizeBidMode(runtime?.bidTypeV2 || DEFAULTS.bidTypeV2, 'smart');
        };

        const normalizeKeywordWordListForSubmit = (wordList = []) => {
            if (!Array.isArray(wordList)) return [];
            return uniqueBy(
                wordList
                    .map(item => applyKeywordDefaults(item || {}, {}))
                    .filter(item => item.word)
                    .map(item => ({
                        word: item.word,
                        bidPrice: item.bidPrice,
                        matchScope: item.matchScope,
                        onlineStatus: item.onlineStatus
                    })),
                item => item.word
            ).slice(0, 200);
        };

        const pruneKeywordCampaignForCustomScene = (campaign = {}, options = {}) => {
            const request = options?.request || {};
            const input = isPlainObject(campaign) ? campaign : {};
            const goalRuntime = isPlainObject(options?.goalRuntime) ? options.goalRuntime : {};
            const bidMode = normalizeBidMode(
                options?.bidMode
                    || request?.common?.bidMode
                    || request?.bidMode
                    || input?.bidTypeV2
                    || request?.common?.campaignOverride?.bidTypeV2
                    || request?.bidTypeV2
                    || DEFAULTS.bidTypeV2,
                'smart'
            );
            const isManual = bidMode === 'manual';
            const out = {};
            Object.keys(input).forEach(key => {
                if (!KEYWORD_CUSTOM_CAMPAIGN_ALLOW_KEYS.has(key)) return;
                out[key] = deepClone(input[key]);
            });
            const resolveCampaignField = (field = '', fallback = '') => {
                const candidates = [
                    input?.[field],
                    goalRuntime?.[field],
                    request?.sceneForcedCampaignOverride?.[field],
                    request?.goalForcedCampaignOverride?.[field],
                    request?.common?.campaignOverride?.[field],
                    request?.[field],
                    request?.common?.[field],
                    fallback
                ];
                for (let i = 0; i < candidates.length; i++) {
                    const value = candidates[i];
                    if (value === undefined || value === null || value === '') continue;
                    return deepClone(value);
                }
                return '';
            };
            out.bizCode = String(out.bizCode || '').trim() || DEFAULTS.bizCode;
            out.promotionScene = resolveCampaignField('promotionScene', DEFAULTS.promotionScene) || DEFAULTS.promotionScene;
            out.subPromotionType = out.subPromotionType || DEFAULTS.subPromotionType;
            out.promotionType = out.promotionType || DEFAULTS.promotionType;
            out.itemSelectedMode = resolveCampaignField('itemSelectedMode', DEFAULTS.itemSelectedMode) || DEFAULTS.itemSelectedMode;
            out.bidTypeV2 = bidModeToBidType(bidMode);
            if (isManual) {
                delete out.bidTargetV2;
                delete out.optimizeTarget;
                out.setSingleCostV2 = false;
                delete out.singleCostV2;
            } else {
                out.bidTargetV2 = out.bidTargetV2 || DEFAULTS.bidTargetV2;
                out.optimizeTarget = out.optimizeTarget || out.bidTargetV2 || DEFAULTS.bidTargetV2;
                out.setSingleCostV2 = !!out.setSingleCostV2;
                if (!out.setSingleCostV2) delete out.singleCostV2;
            }
            out.dmcType = out.dmcType || DEFAULTS.dmcType;
            out.campaignName = String(out.campaignName || `å…³é”®è¯æ¨å¹¿_${todayStamp()}`).trim();
            if (!isPlainObject(out.campaignCycleBudgetInfo)) {
                out.campaignCycleBudgetInfo = { currentCampaignActivityCycleBudgetStatus: '0' };
            } else if (!out.campaignCycleBudgetInfo.currentCampaignActivityCycleBudgetStatus) {
                out.campaignCycleBudgetInfo.currentCampaignActivityCycleBudgetStatus = '0';
            }
            if (!Array.isArray(out.itemIdList)) out.itemIdList = [];
            if (!Array.isArray(out.deleteAdgroupList)) out.deleteAdgroupList = [];
            if (!Array.isArray(out.updatedRightInfoAdgroupList)) out.updatedRightInfoAdgroupList = [];
            if (!Array.isArray(out.crowdList)) out.crowdList = [];
            if (!Array.isArray(out.adzoneList)) out.adzoneList = [];
            if (out.promotionScene === 'promotion_scene_search_user_define') {
                // è‡ªå®šä¹‰æ¨å¹¿æäº¤ adzone å¯¹è±¡æ—¶æœåŠ¡ç«¯å­˜åœ¨å¼‚å¸¸ï¼Œå½“å‰åœºæ™¯æ”¹ä¸ºç”±åç«¯ä½¿ç”¨é»˜è®¤èµ„æºä½ã€‚
                out.adzoneList = [];
            }
            if (!Array.isArray(out.launchAreaStrList) || !out.launchAreaStrList.length) out.launchAreaStrList = ['all'];
            if (!Array.isArray(out.launchPeriodList) || !out.launchPeriodList.length) out.launchPeriodList = buildDefaultLaunchPeriodList();
            return out;
        };

        const pruneKeywordAdgroupForCustomScene = (adgroup = {}, item = null, options = {}) => {
            const input = isPlainObject(adgroup) ? adgroup : {};
            const bidMode = normalizeBidMode(options?.bidMode || '', 'smart');
            const isManual = bidMode === 'manual';
            const out = {};
            out.rightList = Array.isArray(input.rightList) ? deepClone(input.rightList) : [];
            out.wordList = normalizeKeywordWordListForSubmit(input.wordList || []);
            if (!isManual && hasOwn(input, 'wordPackageList')) {
                out.wordPackageList = Array.isArray(input.wordPackageList)
                    ? deepClone(input.wordPackageList).slice(0, 100)
                    : [];
            }
            if (item && (item.materialId || item.itemId)) {
                out.material = pickMaterialFields(mergeDeep(input.material || {}, {
                    materialId: toIdValue(item.materialId || item.itemId),
                    materialName: item.materialName || '',
                    promotionType: DEFAULTS.promotionType,
                    subPromotionType: DEFAULTS.subPromotionType,
                    fromTab: item.fromTab || 'manual',
                    linkUrl: item.linkUrl || '',
                    goalLifeCycleList: item.goalLifeCycleList || null,
                    shopId: item.shopId || '',
                    shopName: item.shopName || '',
                    bidCount: item.bidCount || 0,
                    categoryLevel1: item.categoryLevel1 || ''
                }));
            } else if (isPlainObject(input.material)) {
                out.material = pickMaterialFields(input.material);
            }
            return out;
        };

        const deriveFallbackKeywordListFromItem = (item = {}, keywordDefaults = {}) => {
            const title = String(item?.materialName || '').trim();
            if (!title) return [];
            const seeds = [];
            const normalized = title.replace(/[ï¼Œã€‚ã€â€œâ€â€˜â€™!ï¼?ï¼Ÿ:ï¼š;ï¼›,.\-_/()ï¼ˆï¼‰ã€ã€‘\[\]\s]+/g, ' ').trim();
            if (normalized) {
                const parts = normalized.split(/\s+/).filter(Boolean);
                if (parts.length) seeds.push(parts[0]);
                if (parts.length > 1) seeds.push(parts.slice(0, 2).join(' '));
            }
            seeds.push(title.slice(0, 12));
            const words = uniqueBy(
                seeds
                    .map(text => String(text || '').trim())
                    .filter(text => text.length >= 2)
                    .map(text => applyKeywordDefaults({ word: text }, keywordDefaults)),
                item => item.word
            ).slice(0, 3);
            return words;
        };

        const buildKeywordBundle = async ({ plan, item, runtimeDefaults, request, requestOptions }) => {
            const commonKeywordDefaults = request?.common?.keywordDefaults || {};
            const planKeywordDefaults = plan?.keywordDefaults || {};
            const keywordDefaults = {
                bidPrice: toNumber(planKeywordDefaults.bidPrice, toNumber(commonKeywordDefaults.bidPrice, 1)),
                matchScope: parseMatchScope(planKeywordDefaults.matchScope, parseMatchScope(commonKeywordDefaults.matchScope, DEFAULTS.matchScope)),
                onlineStatus: toNumber(planKeywordDefaults.onlineStatus, toNumber(commonKeywordDefaults.onlineStatus, DEFAULTS.keywordOnlineStatus))
            };
            const sourceCfg = plan?.keywordSource || {};
            const mode = sourceCfg.mode || request?.common?.keywordMode || DEFAULTS.keywordMode;
            const recommendCount = Math.max(0, toNumber(sourceCfg.recommendCount, toNumber(request?.common?.recommendCount, DEFAULTS.recommendCount)));
            const recommendSource = sourceCfg.recommendSource || 'auto';
            const toBooleanOrEmpty = (value) => {
                if (value === true || value === false) return value;
                const text = String(value || '').trim().toLowerCase();
                if (!text) return '';
                if (text === 'true' || text === '1' || text === 'yes' || text === 'on') return true;
                if (text === 'false' || text === '0' || text === 'no' || text === 'off') return false;
                return '';
            };
            const resolveWordPackageSwitch = () => {
                const candidates = [
                    sourceCfg.useWordPackage,
                    plan?.useWordPackage,
                    request?.useWordPackage,
                    request?.common?.useWordPackage
                ];
                for (let i = 0; i < candidates.length; i++) {
                    const parsed = toBooleanOrEmpty(candidates[i]);
                    if (parsed === true || parsed === false) return parsed;
                }
                return DEFAULTS.useWordPackage !== false;
            };
            const useWordPackage = resolveWordPackageSwitch();
            const manualWords = parseKeywords(plan?.keywords || [], keywordDefaults).map(word => applyKeywordDefaults(word, keywordDefaults));

            let recommendedWords = [];
            let recommendedPackages = [];
            if (mode !== 'manual') {
                recommendedWords = await fetchRecommendWordList({
                    bizCode: runtimeDefaults.bizCode,
                    materialId: item.materialId,
                    defaults: runtimeDefaults,
                    source: recommendSource,
                    requestOptions
                });
                if (useWordPackage) {
                    recommendedPackages = await fetchRecommendWordPackageList({
                        bizCode: runtimeDefaults.bizCode,
                        materialId: item.materialId,
                        defaults: runtimeDefaults,
                        requestOptions
                    });
                }
            }

            const normalizedRecommend = recommendedWords
                .map(word => applyKeywordDefaults(word, keywordDefaults))
                .filter(word => word.word);

            let mergedWordList = [];
            if (mode === 'manual') {
                mergedWordList = manualWords;
            } else if (mode === 'recommend') {
                mergedWordList = normalizedRecommend.slice(0, recommendCount || normalizedRecommend.length);
            } else {
                const dedupMap = new Map();
                manualWords.forEach(word => dedupMap.set(word.word, word));
                normalizedRecommend.forEach(word => {
                    if (dedupMap.size >= Math.max(recommendCount, manualWords.length)) return;
                    if (!dedupMap.has(word.word)) dedupMap.set(word.word, word);
                });
                mergedWordList = Array.from(dedupMap.values());
                if (recommendCount > 0 && mergedWordList.length < recommendCount) {
                    normalizedRecommend.forEach(word => {
                        if (mergedWordList.length >= recommendCount) return;
                        if (!dedupMap.has(word.word)) {
                            dedupMap.set(word.word, word);
                            mergedWordList.push(word);
                        }
                    });
                }
            }
            mergedWordList = uniqueBy(mergedWordList, word => word.word).slice(0, 200);
            if (!mergedWordList.length) {
                mergedWordList = deriveFallbackKeywordListFromItem(item, keywordDefaults);
            }
            const wordPackageList = Array.isArray(recommendedPackages) ? recommendedPackages.slice(0, 100) : [];
            return {
                wordList: mergedWordList,
                wordPackageList,
                useWordPackage,
                mode,
                manualCount: manualWords.length,
                recommendCount: normalizedRecommend.length
            };
        };

        const extractPageAddedItemIds = () => {
            const addBtn = Array.from(document.querySelectorAll('button,div,a')).find(el =>
                /æ·»åŠ å•†å“\s*\d+\s*\/\s*\d+/.test((el.textContent || '').replace(/\s+/g, ' '))
            );
            const expectedCount = toNumber(((addBtn?.textContent || '').match(/(\d+)\s*\/\s*\d+/) || [])[1], 0);
            const root = addBtn?.closest('section,div')?.parentElement || document.body;

            const idsFromText = parseItemIdsFromText(root?.innerText || '');
            const idsFromHref = uniqueBy(
                Array.from(root?.querySelectorAll?.('a[href*="item.htm?id="]') || [])
                    .map(a => {
                        const match = (a.getAttribute('href') || '').match(/id=(\d{6,})/);
                        return match ? match[1] : '';
                    })
                    .filter(Boolean),
                id => id
            );
            const all = uniqueBy([...idsFromText, ...idsFromHref], id => id);
            return expectedCount > 0 ? all.slice(0, expectedCount) : all;
        };

        const fetchItemsByIds = async (itemIdList, runtime) => {
            if (!Array.isArray(itemIdList) || !itemIdList.length) return [];
            const res = await searchItems({
                bizCode: runtime.bizCode,
                promotionScene: runtime.promotionScene,
                itemIdList,
                pageSize: Math.max(40, itemIdList.length)
            });
            const map = new Map(res.list.map(item => [String(item.materialId), item]));
            return itemIdList.map(id => map.get(String(id))).filter(Boolean);
        };

        const readSessionDraft = () => {
            try {
                const raw = sessionStorage.getItem(SESSION_DRAFT_KEY);
                if (!raw) return null;
                const parsed = JSON.parse(raw);
                return isPlainObject(parsed) ? parsed : null;
            } catch {
                return null;
            }
        };

        const saveSessionDraft = (draft) => {
            try {
                sessionStorage.setItem(SESSION_DRAFT_KEY, JSON.stringify(draft || {}));
            } catch (err) {
                log.warn('ä¿å­˜å‘å¯¼è‰ç¨¿å¤±è´¥:', err?.message || err);
            }
        };

        const clearSessionDraft = () => {
            try {
                sessionStorage.removeItem(SESSION_DRAFT_KEY);
            } catch { }
            wizardState.draft = null;
            wizardState.addedItems = [];
            wizardState.crowdList = [];
            wizardState.debugVisible = false;
            wizardState.strategyList = getDefaultStrategyList();
            wizardState.editingStrategyId = '';
            wizardState.detailVisible = false;
        };

        const resolvePreferredItems = async (request, runtime) => {
            const draft = readSessionDraft();
            const draftItems = Array.isArray(draft?.addedItems)
                ? draft.addedItems.map(normalizeItem).filter(item => item.materialId)
                : [];
            if (draftItems.length) return draftItems.slice(0, WIZARD_MAX_ITEMS);

            const pageItemIds = extractPageAddedItemIds();
            if (pageItemIds.length) {
                const fromPage = await fetchItemsByIds(pageItemIds, runtime);
                if (fromPage.length) return fromPage.slice(0, WIZARD_MAX_ITEMS);
            }

            if (request?.itemSearch) {
                const searched = await searchItems(request.itemSearch);
                if (Array.isArray(searched?.list) && searched.list.length) {
                    return searched.list.slice(0, WIZARD_MAX_ITEMS);
                }
            }

            const targetScene = String(
                request?.sceneName
                || wizardState?.draft?.sceneName
                || inferCurrentSceneName()
                || ''
            ).trim();
            const targetGoal = normalizeGoalCandidateLabel(
                request?.marketingGoal
                || request?.common?.marketingGoal
                || ''
            );
            const isKeywordScene = targetScene === 'å…³é”®è¯æ¨å¹¿';
            const shouldInjectKeywordDefaultItem = isKeywordScene && (!targetGoal || targetGoal === 'è‡ªå®šä¹‰æ¨å¹¿');
            if (shouldInjectKeywordDefaultItem) {
                const defaultItems = await fetchItemsByIds([SCENE_SYNC_DEFAULT_ITEM_ID], runtime);
                if (defaultItems.length) return defaultItems.slice(0, WIZARD_MAX_ITEMS);
            }

            return [];
        };

        const isSceneLikelyRequireItem = (sceneName = '') => {
            const normalizedScene = String(sceneName || '').trim();
            if (!normalizedScene) return true;
            if (SCENE_REQUIRE_ITEM_FALLBACK[normalizedScene] !== undefined) {
                return !!SCENE_REQUIRE_ITEM_FALLBACK[normalizedScene];
            }
            return true;
        };

        const resolveSceneCapabilities = ({ sceneName = '', runtime = {}, request = {} }) => {
            const normalizedScene = String(sceneName || request?.sceneName || '').trim();
            const expectedSceneBizCode = normalizeSceneBizCode(
                resolveSceneBizCodeHint(normalizedScene)
                || SCENE_BIZCODE_HINT_FALLBACK[normalizedScene]
                || ''
            );
            const runtimeTemplateBizCode = normalizeSceneBizCode(
                runtime?.solutionTemplate?.bizCode
                || runtime?.solutionTemplate?.campaign?.bizCode
                || ''
            );
            const templateMatchedScene = !expectedSceneBizCode
                || !runtimeTemplateBizCode
                || runtimeTemplateBizCode === expectedSceneBizCode;
            const template = templateMatchedScene ? (runtime?.solutionTemplate || {}) : {};
            const templateCampaign = isPlainObject(template.campaign) ? template.campaign : {};
            const templateAdgroup = Array.isArray(template.adgroupList) && isPlainObject(template.adgroupList[0])
                ? template.adgroupList[0]
                : {};
            const capabilityFallback = {
                'è´§å“å…¨ç«™æ¨å¹¿': { hasMaterial: true, hasItemIdList: false, hasWordList: false, hasWordPackageList: false, hasRightList: false },
                'å…³é”®è¯æ¨å¹¿': { hasMaterial: true, hasItemIdList: true, hasWordList: true, hasWordPackageList: true, hasRightList: true },
                'äººç¾¤æ¨å¹¿': { hasMaterial: false, hasItemIdList: true, hasWordList: false, hasWordPackageList: false, hasRightList: true },
                'åº—é“ºç›´è¾¾': { hasMaterial: true, hasItemIdList: false, hasWordList: false, hasWordPackageList: true, hasRightList: false },
                'å†…å®¹è¥é”€': { hasMaterial: true, hasItemIdList: false, hasWordList: false, hasWordPackageList: false, hasRightList: false },
                'çº¿ç´¢æ¨å¹¿': { hasMaterial: false, hasItemIdList: true, hasWordList: true, hasWordPackageList: true, hasRightList: false }
            }[normalizedScene] || {};
            const hasTemplateCampaign = isPlainObject(templateCampaign) && Object.keys(templateCampaign).length > 0;
            const hasTemplateAdgroup = isPlainObject(templateAdgroup) && Object.keys(templateAdgroup).length > 0;
            const useFallbackCapability = !hasTemplateCampaign || !hasTemplateAdgroup || !templateMatchedScene;
            const hasMaterial = isPlainObject(templateAdgroup.material) && Object.keys(templateAdgroup.material).length > 0;
            const hasItemIdList = hasOwn(templateCampaign, 'itemIdList') || (!!capabilityFallback.hasItemIdList && useFallbackCapability);
            const hasWordList = hasOwn(templateAdgroup, 'wordList') || (!!capabilityFallback.hasWordList && useFallbackCapability);
            const hasWordPackageList = hasOwn(templateAdgroup, 'wordPackageList') || (!!capabilityFallback.hasWordPackageList && useFallbackCapability);
            const hasRightList = hasOwn(templateAdgroup, 'rightList') || (!!capabilityFallback.hasRightList && useFallbackCapability);

            const requireItemOverride = request?.requireItem;
            let requiresItem = false;
            if (requireItemOverride === true || requireItemOverride === false) {
                requiresItem = !!requireItemOverride;
            } else if (hasMaterial || hasItemIdList) {
                requiresItem = true;
            } else {
                requiresItem = isSceneLikelyRequireItem(normalizedScene);
            }

            const enableKeywordsOverride = request?.enableKeywords;
            let enableKeywords = false;
            if (enableKeywordsOverride === true || enableKeywordsOverride === false) {
                enableKeywords = !!enableKeywordsOverride;
            } else {
                // `wordPackageList` åœ¨éå…³é”®è¯åœºæ™¯å¯èƒ½ä»…æ˜¯æ¨¡æ¿æ®‹ç•™å­—æ®µï¼Œä¸èƒ½ç›´æ¥åˆ¤å®šä¸ºâ€œå¯ç”¨å…³é”®è¯â€ã€‚
                enableKeywords = /(å…³é”®è¯æ¨å¹¿|çº¿ç´¢æ¨å¹¿)/.test(normalizedScene) || hasWordList;
            }

            // å…³é”®è¯æ¨å¹¿å¿…é¡»æŒ‰â€œå•†å“ + å…³é”®è¯å•å…ƒâ€æäº¤ï¼Œä¸èƒ½ä¾èµ–æ¨¡æ¿æ˜¯å¦è¿”å›è¿™äº›å­—æ®µã€‚
            if (normalizedScene === 'å…³é”®è¯æ¨å¹¿') {
                requiresItem = true;
                enableKeywords = true;
            }

            return {
                sceneName: normalizedScene,
                expectedSceneBizCode,
                runtimeTemplateBizCode,
                templateMatchedScene,
                hasTemplateCampaign,
                hasTemplateAdgroup,
                requiresItem,
                enableKeywords,
                hasMaterial: SCENE_FORCE_ADGROUP_MATERIAL[normalizedScene]
                    ? true
                    : (normalizedScene === 'å…³é”®è¯æ¨å¹¿' ? true : (hasMaterial || (!!capabilityFallback.hasMaterial && useFallbackCapability))),
                hasItemIdList: normalizedScene === 'å…³é”®è¯æ¨å¹¿' ? true : hasItemIdList,
                hasWordList: normalizedScene === 'å…³é”®è¯æ¨å¹¿' ? true : hasWordList,
                hasWordPackageList: normalizedScene === 'å…³é”®è¯æ¨å¹¿' ? true : hasWordPackageList,
                hasRightList
            };
        };

        const resolvePlanNamePrefix = (request = {}) => {
            const fromRequest = String(request?.planNamePrefix || '').trim();
            if (fromRequest) return fromRequest;
            const sceneName = String(request?.sceneName || 'å…³é”®è¯æ¨å¹¿').trim() || 'å…³é”®è¯æ¨å¹¿';
            return buildSceneTimePrefix(sceneName);
        };

        const normalizePlans = (request, preferredItems, options = {}) => {
            const requiresItem = options.requiresItem !== false;
            const commonBidMode = normalizeBidMode(request?.common?.bidMode || request?.bidMode || '', 'smart');
            const plans = Array.isArray(request?.plans) ? request.plans.map(plan => ({ ...plan })) : [];
            if (!plans.length) {
                const prefix = resolvePlanNamePrefix(request);
                if (!preferredItems.length) {
                    if (requiresItem) return [];
                    const rawCount = request?.planCount ?? request?.count ?? 1;
                    const planCount = Math.max(1, Math.min(50, toNumber(rawCount, 1)));
                    return Array.from({ length: planCount }).map((_, idx) => ({
                        planName: `${prefix}_${String(idx + 1).padStart(2, '0')}`,
                        bidMode: commonBidMode,
                        keywords: request?.keywords || [],
                        keywordSource: request?.keywordSource || {}
                    }));
                }
                return preferredItems.map((item, idx) => ({
                    planName: `${prefix}_${String(idx + 1).padStart(2, '0')}`,
                    item,
                    bidMode: commonBidMode,
                    keywords: request?.keywords || [],
                    keywordSource: request?.keywordSource || {}
                }));
            }

            let fillCursor = 0;
            return plans.map((plan, idx) => {
                const normalized = { ...plan };
                if (!normalized.planName) {
                    const prefix = resolvePlanNamePrefix(request);
                    normalized.planName = `${prefix}_${String(idx + 1).padStart(2, '0')}`;
                }
                normalized.bidMode = normalizeBidMode(
                    normalized.bidMode
                        || normalized.campaignOverride?.bidTypeV2
                        || commonBidMode,
                    commonBidMode
                );
                if (normalized.item) {
                    normalized.item = normalizeItem(normalized.item);
                } else if (normalized.itemId) {
                    normalized.item = normalizeItem({
                        materialId: normalized.itemId,
                        itemId: normalized.itemId,
                        materialName: normalized.itemName || ''
                    });
                } else if (preferredItems[fillCursor]) {
                    normalized.item = normalizeItem(preferredItems[fillCursor]);
                    fillCursor++;
                }
                return normalized;
            }).filter(plan => {
                if (!requiresItem) return true;
                return !!plan.item?.materialId;
            });
        };

        const applyOverrides = (target, request, plan) => {
            const commonCampaignOverride = request?.common?.campaignOverride || {};
            const commonAdgroupOverride = request?.common?.adgroupOverride || {};
            const commonPassthrough = request?.common?.passthrough || {};
            const planCampaignOverride = plan?.campaignOverride || {};
            const planAdgroupOverride = plan?.adgroupOverride || {};
            const goalForcedCampaignOverride = request?.goalForcedCampaignOverride || {};
            const goalForcedAdgroupOverride = request?.goalForcedAdgroupOverride || {};
            const planGoalCampaignOverride = plan?.goalForcedCampaignOverride || {};
            const planGoalAdgroupOverride = plan?.goalForcedAdgroupOverride || {};
            const sceneForcedCampaignOverride = request?.sceneForcedCampaignOverride || {};
            const sceneForcedAdgroupOverride = request?.sceneForcedAdgroupOverride || {};
            const requestRawOverrides = isPlainObject(request?.rawOverrides) ? request.rawOverrides : {};
            const commonRawOverrides = isPlainObject(request?.common?.rawOverrides) ? request.common.rawOverrides : {};
            const planRawOverrides = isPlainObject(plan?.rawOverrides) ? plan.rawOverrides : {};

            const pickCampaignRaw = (raw) => {
                if (!isPlainObject(raw)) return {};
                if (isPlainObject(raw.campaign)) return raw.campaign;
                if (isPlainObject(raw.adgroup)) return {};
                return raw;
            };
            const pickAdgroupRaw = (raw) => {
                if (!isPlainObject(raw)) return {};
                if (isPlainObject(raw.adgroup)) return raw.adgroup;
                return {};
            };

            // åˆå¹¶é¡ºåºï¼šæ¨¡æ¿åŸºåº•(å·²åœ¨ buildSolutionFromPlan) -> GoalSpec é»˜è®¤ -> åœºæ™¯æ˜ å°„ -> common/plan override -> rawOverridesã€‚
            target.campaign = mergeDeep(
                target.campaign,
                goalForcedCampaignOverride,
                planGoalCampaignOverride,
                sceneForcedCampaignOverride,
                commonCampaignOverride,
                planCampaignOverride,
                commonPassthrough,
                pickCampaignRaw(requestRawOverrides),
                pickCampaignRaw(commonRawOverrides),
                pickCampaignRaw(planRawOverrides)
            );
            target.adgroup = mergeDeep(
                target.adgroup,
                goalForcedAdgroupOverride,
                planGoalAdgroupOverride,
                sceneForcedAdgroupOverride,
                commonAdgroupOverride,
                planAdgroupOverride,
                pickAdgroupRaw(requestRawOverrides),
                pickAdgroupRaw(commonRawOverrides),
                pickAdgroupRaw(planRawOverrides)
            );
        };

        const buildDefaultLaunchPeriodList = () => {
            const list = [];
            for (let day = 1; day <= 7; day++) {
                list.push({
                    dayOfWeek: String(day),
                    timeSpanList: [{ discount: 100, time: '00:00-24:00' }]
                });
            }
            return list;
        };

        const formatDateYmd = (date = new Date()) => {
            const d = date instanceof Date ? date : new Date();
            const pad = (n) => String(n).padStart(2, '0');
            return `${d.getFullYear()}-${pad(d.getMonth() + 1)}-${pad(d.getDate())}`;
        };

        const buildDefaultLaunchTime = ({ days = 7, forever = false } = {}) => {
            const safeDays = Math.max(1, toNumber(days, 7));
            const start = new Date();
            const startTime = formatDateYmd(start);
            if (forever) {
                return {
                    startTime,
                    launchForever: true
                };
            }
            const end = new Date(start.getTime() + (safeDays - 1) * 24 * 60 * 60 * 1000);
            return {
                startTime,
                endTime: formatDateYmd(end),
                launchForever: false
            };
        };

        const normalizeSceneSettingValue = (text = '') => {
            const value = String(text || '').trim();
            if (!value) return '';
            if (/^(è¯·é€‰æ‹©|é»˜è®¤|æ— |ä¸è®¾ç½®|æœªè®¾ç½®)$/i.test(value)) return '';
            return value;
        };

        const mapSceneBidTargetValue = (text = '') => {
            const value = normalizeSceneSettingValue(text);
            if (!value) return '';
            if (/^(conv|roi|click|fav_cart|market_penetration|similar_item|search_rank|display_shentou|display_roi|display_uv|display_cart|detent|word_penetration_rate|coll_cart|ad_strategy_buy|ad_strategy_retained_buy)$/i.test(value)) return value;
            if (/å¢åŠ å‡€æˆäº¤é‡‘é¢|å‡€æˆäº¤é‡‘é¢|ad_strategy[_\s-]*retained[_\s-]*buy/i.test(value)) return 'ad_strategy_retained_buy';
            if (/å¢åŠ æ€»æˆäº¤é‡‘é¢|æ€»æˆäº¤é‡‘é¢|ad_strategy[_\s-]*buy/i.test(value)) return 'ad_strategy_buy';
            if (/ç¨³å®šæ–°å®¢æŠ•äº§æ¯”|display[_\s-]*roi/i.test(value)) return 'display_roi';
            if (/æ‰©å¤§æ–°å®¢è§„æ¨¡|æ–°å®¢è§„æ¨¡|display[_\s-]*uv/i.test(value)) return 'display_uv';
            if (/æ–°å®¢æ”¶è—åŠ è´­|display[_\s-]*cart/i.test(value)) return 'display_cart';
            if (/æœç´¢å¡ä½|æŠ¢å .*å¡ä½|å¡ä½|æŠ¢ä½|æŠ¢é¦–|æŠ¢å‰|æŠ¢é¦–é¡µ/i.test(value)) return 'search_rank';
            if (/å¸‚åœºæ¸—é€|è¯å¸‚åœºæ¸—é€|penetration|word[_\s-]*penetration/i.test(value)) return 'word_penetration_rate';
            if (/ç›¸ä¼¼å“/.test(value)) return 'similar_item';
            if (/æ¸—é€|è¶‹åŠ¿|è¶‹åŠ¿æ˜æ˜Ÿ/.test(value)) return 'market_penetration';
            if (/æ‹‰æ–°|æ‹‰æ–°äººç¾¤|æ‹‰æ–°æ¸—é€|å¼•åŠ›é­”æ–¹|äººç¾¤æ¨å¹¿|display[_\s-]*shentou/i.test(value)) return 'display_shentou';
            if (/æµé‡é‡‘å¡/.test(value)) return 'click';
            if (/æŠ•äº§|ROI|æŠ•äº§æ¯”/i.test(value)) return 'roi';
            if (/ç‚¹å‡»/.test(value)) return 'click';
            if (/æ”¶è—|åŠ è´­/.test(value)) return 'fav_cart';
            if (/æ¸—é€/.test(value)) return 'market_penetration';
            if (/æˆäº¤|GMV|è§‚çœ‹.*æˆäº¤|å‡€æˆäº¤/i.test(value)) return 'conv';
            if (/è‡ªå®šä¹‰æ¨å¹¿|çº¿ç´¢|ç•™èµ„/.test(value)) return 'conv';
            return '';
        };

        const mapSiteMultiTargetOptimizeTargetValue = (text = '') => {
            const value = normalizeSceneSettingValue(text);
            if (!value) return '';
            if (/^\d{3,6}$/.test(value)) return value;
            if (/ä¼˜åŒ–åŠ è´­|æ”¶è—åŠ è´­|åŠ è´­/.test(value)) return '1034';
            if (/ä¼˜åŒ–ç›´æ¥æˆäº¤|å¢åŠ å‡€æˆäº¤é‡‘é¢|å‡€æˆäº¤é‡‘é¢|ç›´æ¥æˆäº¤/.test(value)) return '1230';
            if (/å¢åŠ æ€»æˆäº¤é‡‘é¢|æ€»æˆäº¤é‡‘é¢/.test(value)) return '1231';
            return '';
        };

        const buildQuickLiftHourSlotValue = (text = '') => {
            const fullHours = Array.from({ length: 24 }, (_, idx) => String(idx)).join(',');
            const value = normalizeSceneSettingValue(text);
            if (!value) return fullHours;
            if (/é•¿æœŸ|å…¨å¤©|24å°æ—¶|ä¸é™/.test(value)) return fullHours;

            const rangeMatch = value.match(/(\d{1,2})\s*(?:ç‚¹|æ—¶)?\s*(?:~|-|è‡³|åˆ°)\s*(\d{1,2})/);
            if (rangeMatch) {
                const start = Math.max(0, Math.min(23, toNumber(rangeMatch[1], 0)));
                const endRaw = toNumber(rangeMatch[2], 24);
                const end = Math.max(start + 1, Math.min(24, endRaw));
                const list = [];
                for (let i = start; i < end; i += 1) list.push(String(i));
                if (list.length) return list.join(',');
            }

            const hours = Array.from(
                new Set(
                    (value.match(/\d{1,2}/g) || [])
                        .map(item => toNumber(item, NaN))
                        .filter(num => Number.isFinite(num) && num >= 0 && num <= 23)
                        .map(num => String(num))
                )
            );
            if (hours.length) return hours.join(',');
            return fullHours;
        };

        const mapSceneLaunchAreaList = (text = '') => {
            const value = normalizeSceneSettingValue(text);
            if (!value || /(å…¨éƒ¨|å…¨å›½|ä¸é™|all)/i.test(value)) return ['all'];
            return value
                .split(/[,ï¼Œ\sã€]+/)
                .map(item => normalizeSceneSettingValue(item))
                .filter(Boolean)
                .slice(0, 80);
        };

        const resolveKeywordGoalRuntimeFallback = (goalText = '') => {
            const normalizedGoal = normalizeGoalCandidateLabel(goalText);
            if (!normalizedGoal) return {};
            const matched = KEYWORD_GOAL_RUNTIME_FALLBACK_MAP.find(item => item.pattern.test(normalizedGoal));
            if (!matched) return {};
            const out = {
                promotionScene: String(matched.promotionScene || '').trim(),
                itemSelectedMode: String(matched.itemSelectedMode || '').trim(),
                bidTargetV2: String(matched.bidTargetV2 || '').trim()
            };
            if (out.bidTargetV2) {
                out.optimizeTarget = out.bidTargetV2;
            }
            return out;
        };

        const mapSceneBudgetTypeValue = (text = '') => {
            const value = normalizeSceneSettingValue(text);
            if (!value) return '';
            if (/^(day_average|normal|total|day_freeze|unlimit)$/i.test(value)) return value;
            if (/ä¸é™é¢„ç®—/.test(value)) return 'unlimit';
            if (/æ—¥å‡é¢„ç®—/.test(value)) return 'day_average';
            if (/æ¯æ—¥é¢„ç®—/.test(value)) return 'normal';
            if (/æ€»é¢„ç®—/.test(value)) return 'total';
            if (/å†»ç»“|æœªæ¥/.test(value)) return 'day_freeze';
            return '';
        };

        const mapSceneBidTypeValue = (text = '', sceneName = '') => {
            const value = normalizeSceneSettingValue(text);
            if (!value) return '';
            if (/^(smart_bid|manual_bid|custom_bid|bcb|mcb|max_amount|cost_control|roi_control)$/i.test(value)) {
                return value.toLowerCase() === 'manual_bid' ? 'custom_bid' : value.toLowerCase();
            }
            const normalizedScene = String(sceneName || '').trim();
            if (/æ™ºèƒ½å‡ºä»·/.test(value)) return 'smart_bid';
            if (/æ‰‹åŠ¨å‡ºä»·|æ‰‹åŠ¨/.test(value)) return 'custom_bid';
            if (/æ§æŠ•äº§æ¯”/.test(value)) return 'roi_control';
            if (/æ§æˆæœ¬/.test(value)) {
                if (normalizedScene === 'å†…å®¹è¥é”€') return 'mcb';
                return 'cost_control';
            }
            if (/æœ€å¤§åŒ–æ‹¿é‡/.test(value)) {
                if (normalizedScene === 'å†…å®¹è¥é”€') return 'bcb';
                return 'max_amount';
            }
            return '';
        };

        const normalizeBidTypeForCampaignField = (bidType = '', targetKey = '', sceneName = '') => {
            const source = String(bidType || '').trim().toLowerCase();
            const key = String(targetKey || '').trim();
            const normalizedScene = String(sceneName || '').trim();
            if (!source || !key) return '';
            if (key === 'bidTypeV2') {
                if (normalizedScene === 'äººç¾¤æ¨å¹¿') {
                    if (/^(smart_bid|manual_bid|custom_bid|bcb|mcb|max_amount|cost_control|roi_control)$/i.test(source)) {
                        return 'custom_bid';
                    }
                }
                if (source === 'manual_bid') return 'custom_bid';
                if (source === 'smart_bid' || source === 'custom_bid') return source;
                return '';
            }
            if (key === 'bidType') {
                if (normalizedScene === 'äººç¾¤æ¨å¹¿') return '';
                if (source === 'manual_bid' || source === 'custom_bid') {
                    if (normalizedScene === 'å†…å®¹è¥é”€') return 'mcb';
                    if (normalizedScene === 'çº¿ç´¢æ¨å¹¿') return 'cost_control';
                    if (normalizedScene === 'è´§å“å…¨ç«™æ¨å¹¿') return 'roi_control';
                    return 'custom_bid';
                }
                if (source === 'smart_bid') {
                    if (normalizedScene === 'å†…å®¹è¥é”€') return 'bcb';
                    if (normalizedScene === 'çº¿ç´¢æ¨å¹¿') return 'max_amount';
                    if (normalizedScene === 'è´§å“å…¨ç«™æ¨å¹¿') return 'roi_control';
                    return 'max_amount';
                }
                if (/^(bcb|mcb|max_amount|cost_control|roi_control|custom_bid)$/i.test(source)) return source;
            }
            return '';
        };

        const mapSceneItemSelectedModeValue = (text = '') => {
            const value = normalizeSceneSettingValue(text);
            if (!value) return '';
            if (/^(user_define|shop|search_detent|trend)$/i.test(value)) return value;
            if (/è‡ªå®šä¹‰|æ‰‹åŠ¨|æŒ‡å®šå•†å“/.test(value)) return 'user_define';
            if (/æœç´¢å¡ä½/.test(value)) return 'search_detent';
            if (/è¶‹åŠ¿/.test(value)) return 'trend';
            if (/åº—é“º|å…¨åº—|è‡ªåŠ¨é€‰å“|æ¨èé€‰å“|è¡Œä¸šæ¨è/.test(value)) return 'shop';
            return '';
        };

        const mapSceneCreativeSetModeValue = (text = '') => {
            const value = normalizeSceneSettingValue(text);
            if (!value) return '';
            if (/^(minimalist|professional|smart)$/i.test(value)) return value;
            if (/æç®€|åŸºç¡€|é»˜è®¤/.test(value)) return 'minimalist';
            if (/ä¸“ä¸š|è¿›é˜¶/.test(value)) return 'professional';
            if (/æ™ºèƒ½|è‡ªåŠ¨/.test(value)) return 'smart';
            return '';
        };
        const mapScenePromotionModelValue = (text = '') => {
            const value = normalizeSceneSettingValue(text);
            if (!value) {
                return {
                    promotionModel: '',
                    promotionModelMarketing: ''
                };
            }
            if (/^(order|daily)$/i.test(value)) {
                return {
                    promotionModel: value.toLowerCase(),
                    promotionModelMarketing: /order/i.test(value) ? 'strategy' : ''
                };
            }
            if (/å¤šç›®æ ‡|å¤šç­–ç•¥|èµ·é‡|ç­–ç•¥/.test(value)) {
                return {
                    promotionModel: 'order',
                    promotionModelMarketing: 'strategy'
                };
            }
            if (/æ—¥å¸¸|å•ç›®æ ‡|åŸºç¡€|æ™®é€š/.test(value)) {
                return {
                    promotionModel: 'daily',
                    promotionModelMarketing: ''
                };
            }
            return {
                promotionModel: '',
                promotionModelMarketing: ''
            };
        };

        const mapScenePromotionStrategyValue = (sceneName = '', text = '', runtime = {}) => {
            const normalizedScene = String(sceneName || '').trim();
            const value = normalizeSceneSettingValue(text);
            if (!value) return '';
            if (normalizedScene !== 'äººç¾¤æ¨å¹¿') {
                return '';
            }
            if (/^(jingdian_laxin|jihui_laxin|zidingyi_laxin|leimu_laxin)$/i.test(value)) {
                return value;
            }
            if (/ç«åº—|ç»å…¸/.test(value)) return 'jingdian_laxin';
            if (/æœºä¼š/.test(value)) return 'jihui_laxin';
            if (/è·¨ç±»ç›®/.test(value)) return 'leimu_laxin';
            if (/è‡ªå®šä¹‰/.test(value)) return 'zidingyi_laxin';
            return normalizeSceneSettingValue(runtime?.storeData?.promotionStrategy || runtime?.solutionTemplate?.campaign?.promotionStrategy || '');
        };

        const mapSceneOrderChargeTypeValue = (text = '', runtime = {}) => {
            const value = normalizeSceneSettingValue(text);
            if (!value) return '';
            if (/^(click|cpc|conv|cpa|cps|show|cpm|balance_charge|pc_direct_charge|uni_budget_charge)$/i.test(value)) return value.toLowerCase();
            if (/ç‚¹å‡»|CPC/i.test(value)) return 'click';
            if (/æˆäº¤|è½¬åŒ–|CPA|CPS/i.test(value)) return 'conv';
            if (/å±•ç¤º|æ›å…‰|CPM/i.test(value)) return 'show';
            if (/é¢„ç®—é€š/.test(value)) return 'uni_budget_charge';
            if (/æ”¯ä»˜å®/.test(value)) return 'pc_direct_charge';
            if (/ä½™é¢/.test(value)) return 'balance_charge';
            return normalizeSceneSettingValue(runtime?.storeData?.orderChargeType || runtime?.solutionTemplate?.campaign?.orderChargeType || '');
        };

        const resolveSceneTargetCode = ({ sceneName = '', sourceKey = '', sourceValue = '', runtime = {} } = {}) => {
            const normalizedScene = String(sceneName || '').trim();
            const normalizedSourceKey = normalizeText(sourceKey).replace(/[ï¼š:]/g, '').trim();
            const value = normalizeSceneSettingValue(sourceValue);
            if (!value) return '';
            const fromExplicitTargetField = /(å‡ºä»·ç›®æ ‡|ä¼˜åŒ–ç›®æ ‡)/.test(normalizedSourceKey);
            const fromMarketingField = /è¥é”€ç›®æ ‡/.test(normalizedSourceKey);
            const runtimeTarget = normalizeSceneSettingValue(
                runtime?.storeData?.optimizeTarget
                || runtime?.storeData?.bidTargetV2
                || runtime?.solutionTemplate?.campaign?.optimizeTarget
                || runtime?.solutionTemplate?.campaign?.bidTargetV2
                || ''
            );

            if (normalizedScene !== 'å…³é”®è¯æ¨å¹¿' && fromMarketingField && !fromExplicitTargetField) {
                // éå…³é”®è¯åœºæ™¯çš„â€œè¥é”€ç›®æ ‡â€ä»…ç”¨äºç›®æ ‡åˆ†æµï¼Œä¸ç›´æ¥è¦†ç›–ç›®æ ‡ç å­—æ®µã€‚
                return '';
            }

            let code = mapSceneBidTargetValue(value);
            if (normalizedScene === 'äººç¾¤æ¨å¹¿') {
                if (!code || code === DEFAULTS.bidTargetV2 || code === 'market_penetration') {
                    code = runtimeTarget;
                }
                return code || runtimeTarget;
            }

            if (!code) return runtimeTarget;
            if (normalizedScene !== 'å…³é”®è¯æ¨å¹¿' && code === DEFAULTS.bidTargetV2 && runtimeTarget) {
                return runtimeTarget;
            }
            return code;
        };

        const parseNumberFromSceneValue = (text = '') => {
            const raw = String(text || '').replace(/,/g, '').trim();
            if (!raw) return NaN;
            const matched = raw.match(/-?\d+(?:\.\d+)?/);
            if (!matched || !matched[0]) return NaN;
            const value = Number(matched[0]);
            return Number.isFinite(value) ? value : NaN;
        };

        const normalizeSceneSettingEntries = (sceneSettings = {}) => {
            if (!isPlainObject(sceneSettings)) return [];
            return Object.keys(sceneSettings).map(key => ({
                key: String(key || '').trim(),
                value: normalizeSceneSettingValue(sceneSettings[key])
            })).filter(item => item.key && item.value);
        };

        const findSceneSettingEntry = (entries = [], patterns = []) => {
            if (!Array.isArray(entries) || !entries.length) return null;
            if (!Array.isArray(patterns) || !patterns.length) return null;
            for (const pattern of patterns) {
                const found = entries.find(item => pattern.test(item.key));
                if (found) return found;
            }
            return null;
        };

        const resolveSceneSettingOverrides = ({ sceneName = '', sceneSettings = {}, runtime = {} }) => {
            const entries = normalizeSceneSettingEntries(sceneSettings);
            const mapping = {
                sceneName: String(sceneName || '').trim(),
                applied: [],
                skipped: [],
                campaignOverride: {},
                adgroupOverride: {}
            };
            if (!entries.length) return mapping;

            const normalizedSceneName = String(sceneName || '').trim();
            const templateCampaign = runtime?.solutionTemplate?.campaign || {};
            const templateAdgroup = runtime?.solutionTemplate?.adgroupList?.[0] || {};
            const allowedCampaignKeys = new Set(Object.keys(templateCampaign || {}));
            [
                'campaignName',
                'dmcType',
                'bidType',
                'bidTargetV2',
                'optimizeTarget',
                'constraintType',
                'constraintValue',
                'smartCreative',
                'creativeSetMode',
                'itemSelectedMode',
                'promotionModel',
                'promotionModelMarketing',
                'multiTarget',
                'isMultiTarget',
                'quickLiftBudgetCommand',
                'isQuickLift',
                'dmcTypeElement',
                'launchPeriodList',
                'launchAreaStrList',
                'promotionStrategy',
                'needTargetCrowd',
                'aiXiaowanCrowdListSwitch',
                'user_level',
                'orderChargeType',
                'subOptimizeTarget',
                'dayBudget',
                'dayAverageBudget',
                'totalBudget',
                'futureBudget',
                'sourceChannel',
                'channelLocation',
                'selectedTargetBizCode',
                'dmpSolutionId',
                'activityId',
                'specialSourceForMainStep',
                'bpStrategyId',
                'bpStrategyType',
                'supportCouponId'
            ]
                .forEach(key => allowedCampaignKeys.add(key));
            allowedCampaignKeys.add('campaignColdStartVO');
            allowedCampaignKeys.add('crowdList');
            allowedCampaignKeys.add('adzoneList');
            if (SCENE_BIDTYPE_V2_ONLY.has(normalizedSceneName) || hasOwn(templateCampaign, 'bidTypeV2')) {
                allowedCampaignKeys.add('bidTypeV2');
            }
            const allowedAdgroupKeys = new Set(Object.keys(templateAdgroup || {}));
            ['rightList', 'smartCreative', 'material', 'wordList', 'wordPackageList']
                .forEach(key => allowedAdgroupKeys.add(key));

            const setValueByPath = (target, path, value) => {
                const normalizedPath = String(path || '').trim();
                if (!normalizedPath) return;
                const segments = normalizedPath.split('.').map(item => String(item || '').trim()).filter(Boolean);
                if (!segments.length) return;
                let cursor = target;
                for (let i = 0; i < segments.length - 1; i++) {
                    const segment = segments[i];
                    if (!isPlainObject(cursor[segment])) {
                        cursor[segment] = {};
                    }
                    cursor = cursor[segment];
                }
                cursor[segments[segments.length - 1]] = deepClone(value);
            };
            const canUseCampaignField = (key = '', sourceKey = '') => {
                const normalizedKey = String(key || '').trim();
                if (!normalizedKey) return false;
                if (allowedCampaignKeys.has(normalizedKey)) return true;
                const root = normalizedKey.split('.')[0];
                if (allowedCampaignKeys.has(root)) return true;
                if (/^campaign\./i.test(String(sourceKey || '').trim())) return true;
                return false;
            };
            const canUseAdgroupField = (key = '', sourceKey = '') => {
                const normalizedKey = String(key || '').trim();
                if (!normalizedKey) return false;
                if (allowedAdgroupKeys.has(normalizedKey)) return true;
                const root = normalizedKey.split('.')[0];
                if (allowedAdgroupKeys.has(root)) return true;
                if (/^adgroup\./i.test(String(sourceKey || '').trim())) return true;
                return false;
            };

            const applyCampaign = (key, value, sourceKey = '', sourceValue = '') => {
                if (value === undefined || value === null || value === '') return;
                if (!canUseCampaignField(key, sourceKey)) {
                    mapping.skipped.push({
                        sourceKey,
                        sourceValue,
                        targetKey: key,
                        reason: 'campaignå­—æ®µä¸åœ¨å½“å‰æ¨¡æ¿ä¸­'
                    });
                    return;
                }
                setValueByPath(mapping.campaignOverride, key, value);
                mapping.applied.push({
                    sourceKey,
                    sourceValue,
                    targetKey: key,
                    targetValue: deepClone(value)
                });
            };

            const applyAdgroup = (key, value, sourceKey = '', sourceValue = '') => {
                if (value === undefined || value === null || value === '') return;
                if (!canUseAdgroupField(key, sourceKey)) {
                    mapping.skipped.push({
                        sourceKey,
                        sourceValue,
                        targetKey: `adgroup.${key}`,
                        reason: 'adgroupå­—æ®µä¸åœ¨å½“å‰æ¨¡æ¿ä¸­'
                    });
                    return;
                }
                setValueByPath(mapping.adgroupOverride, key, value);
                mapping.applied.push({
                    sourceKey,
                    sourceValue,
                    targetKey: `adgroup.${key}`,
                    targetValue: deepClone(value)
                });
            };

            const parseDirectSettingValue = (key = '', rawValue = '') => {
                const value = normalizeSceneSettingValue(rawValue);
                if (!value) return '';
                if ((value.startsWith('{') && value.endsWith('}')) || (value.startsWith('[') && value.endsWith(']'))) {
                    try {
                        return JSON.parse(value);
                    } catch { }
                }
                if (/^(true|false)$/i.test(value)) return /^true$/i.test(value);
                if (/List$/i.test(key) && /[,ï¼Œ]/.test(value)) {
                    return value
                        .split(/[,ï¼Œ]/)
                        .map(item => normalizeSceneSettingValue(item))
                        .filter(Boolean);
                }
                const numeric = parseNumberFromSceneValue(value);
                if (Number.isFinite(numeric) && /(?:budget|cost|price|rate|switch|smartcreative|discount|singlecost|constraintvalue)$/i.test(key)) {
                    return numeric;
                }
                return value;
            };

            const targetPatterns = normalizedSceneName === 'å…³é”®è¯æ¨å¹¿'
                ? [/å‡ºä»·ç›®æ ‡/, /ä¼˜åŒ–ç›®æ ‡/, /è¥é”€ç›®æ ‡/]
                : [/å‡ºä»·ç›®æ ‡/, /ä¼˜åŒ–ç›®æ ‡/];
            const targetEntry = findSceneSettingEntry(entries, targetPatterns);
            const targetConstraintEntry = findSceneSettingEntry(entries, [
                /ç›®æ ‡æŠ•äº§æ¯”/,
                /å‡€ç›®æ ‡æŠ•äº§æ¯”/,
                /ROIç›®æ ‡å€¼/i,
                /å‡ºä»·ç›®æ ‡å€¼/,
                /çº¦æŸå€¼/,
                /ç›®æ ‡å€¼/
            ]);
            const keywordGoalEntry = normalizedSceneName === 'å…³é”®è¯æ¨å¹¿'
                ? findSceneSettingEntry(entries, [/è¥é”€ç›®æ ‡/, /é€‰æ‹©å¡ä½æ–¹æ¡ˆ/])
                : null;
            const keywordGoalRuntime = normalizedSceneName === 'å…³é”®è¯æ¨å¹¿'
                ? resolveKeywordGoalRuntimeFallback(keywordGoalEntry?.value || '')
                : {};
            const targetCode = resolveSceneTargetCode({
                sceneName: normalizedSceneName,
                sourceKey: targetEntry?.key || '',
                sourceValue: targetEntry?.value || '',
                runtime
            });
            if (normalizedSceneName === 'å…³é”®è¯æ¨å¹¿') {
                if (keywordGoalEntry && keywordGoalRuntime.promotionScene) {
                    applyCampaign('promotionScene', keywordGoalRuntime.promotionScene, keywordGoalEntry.key, keywordGoalEntry.value);
                }
                if (keywordGoalEntry && keywordGoalRuntime.itemSelectedMode) {
                    applyCampaign('itemSelectedMode', keywordGoalRuntime.itemSelectedMode, keywordGoalEntry.key, keywordGoalEntry.value);
                }
            }
            const supportsBidTargetFields = normalizedSceneName === 'å…³é”®è¯æ¨å¹¿'
                || normalizedSceneName === 'äººç¾¤æ¨å¹¿'
                || normalizedSceneName === 'è´§å“å…¨ç«™æ¨å¹¿'
                || hasOwn(templateCampaign, 'bidTargetV2')
                || hasOwn(templateCampaign, 'optimizeTarget');
            if (targetEntry && targetCode && supportsBidTargetFields) {
                applyCampaign('bidTargetV2', targetCode, targetEntry.key, targetEntry.value);
                applyCampaign('optimizeTarget', targetCode, targetEntry.key, targetEntry.value);
            } else if (targetEntry && targetCode && !supportsBidTargetFields) {
                mapping.skipped.push({
                    sourceKey: targetEntry.key,
                    sourceValue: targetEntry.value,
                    targetKey: 'bidTargetV2/optimizeTarget',
                    reason: 'å½“å‰åœºæ™¯æœªè¯†åˆ«åˆ°å¯ç”¨ç›®æ ‡å­—æ®µ'
                });
            }

            const budgetTypeEntry = findSceneSettingEntry(entries, [/é¢„ç®—ç±»å‹/]);
            const budgetTypeCode = mapSceneBudgetTypeValue(budgetTypeEntry?.value || '');
            if (budgetTypeEntry && budgetTypeCode) {
                applyCampaign('dmcType', budgetTypeCode, budgetTypeEntry.key, budgetTypeEntry.value);
            }

            const orderChargeTypeEntry = findSceneSettingEntry(entries, [/æ‰£è´¹æ–¹å¼/, /è®¡è´¹æ–¹å¼/, /æ”¶è´¹æ–¹å¼/, /æ”¯ä»˜æ–¹å¼/]);
            const orderChargeTypeCode = mapSceneOrderChargeTypeValue(orderChargeTypeEntry?.value || '', runtime);
            if (orderChargeTypeEntry && orderChargeTypeCode) {
                applyCampaign('orderChargeType', orderChargeTypeCode, orderChargeTypeEntry.key, orderChargeTypeEntry.value);
            }

            const bidTypeEntry = findSceneSettingEntry(entries, [/å‡ºä»·æ–¹å¼/]);
            const bidTypeCode = mapSceneBidTypeValue(bidTypeEntry?.value || '', normalizedSceneName);
            if (bidTypeEntry && bidTypeCode) {
                const targetKeys = [];
                if (SCENE_BIDTYPE_V2_ONLY.has(normalizedSceneName) || hasOwn(templateCampaign, 'bidTypeV2')) {
                    targetKeys.push('bidTypeV2');
                }
                if (
                    hasOwn(templateCampaign, 'bidType')
                    || ['è´§å“å…¨ç«™æ¨å¹¿', 'å†…å®¹è¥é”€', 'çº¿ç´¢æ¨å¹¿'].includes(normalizedSceneName)
                ) {
                    targetKeys.push('bidType');
                }
                uniqueBy(targetKeys, key => key).forEach(targetKey => {
                    const mappedCode = normalizeBidTypeForCampaignField(bidTypeCode, targetKey, normalizedSceneName);
                    if (!mappedCode) return;
                    applyCampaign(targetKey, mappedCode, bidTypeEntry.key, bidTypeEntry.value);
                });
            }
            if (bidTypeEntry && bidTypeCode && !hasOwn(mapping.campaignOverride, 'bidTypeV2') && !hasOwn(mapping.campaignOverride, 'bidType')) {
                mapping.skipped.push({
                    sourceKey: bidTypeEntry.key,
                    sourceValue: bidTypeEntry.value,
                    targetKey: 'bidTypeV2/bidType',
                    reason: 'å½“å‰åœºæ™¯æœªè¯†åˆ«åˆ°å¯ç”¨å‡ºä»·ç±»å‹å­—æ®µ'
                });
            }
            const targetConstraintValue = parseNumberFromSceneValue(targetConstraintEntry?.value || '');
            if (targetConstraintEntry && Number.isFinite(targetConstraintValue) && targetConstraintValue > 0) {
                applyCampaign('constraintValue', targetConstraintValue, targetConstraintEntry.key, targetConstraintEntry.value);
                const constraintTypeHint = [
                    normalizedSceneName,
                    targetEntry?.key || '',
                    targetEntry?.value || '',
                    bidTypeEntry?.value || '',
                    bidTypeCode || '',
                    targetConstraintEntry?.key || ''
                ].join(' ');
                let constraintTypeCode = '';
                if (/roi_control/i.test(String(bidTypeCode || ''))) {
                    constraintTypeCode = 'roi';
                } else if (/æ§æˆæœ¬|æˆæœ¬|cpa/i.test(constraintTypeHint)) {
                    constraintTypeCode = 'cost';
                } else if (/æŠ•äº§æ¯”|ROI/i.test(constraintTypeHint) || normalizedSceneName === 'è´§å“å…¨ç«™æ¨å¹¿') {
                    constraintTypeCode = 'roi';
                }
                if (constraintTypeCode) {
                    applyCampaign('constraintType', constraintTypeCode, targetConstraintEntry.key, targetConstraintEntry.value);
                }
            }

            const itemModeEntry = findSceneSettingEntry(entries, [/é€‰å“æ–¹å¼/, /é€‰æ‹©æ¨å¹¿å•†å“/]);
            const itemModeCode = mapSceneItemSelectedModeValue(itemModeEntry?.value || '');
            if (itemModeEntry && itemModeCode) {
                applyCampaign('itemSelectedMode', itemModeCode, itemModeEntry.key, itemModeEntry.value);
            }
            const promotionSceneEntry = findSceneSettingEntry(entries, [/è¥é”€åœºæ™¯/]);
            if (promotionSceneEntry) {
                const explicitCode = normalizeSceneSettingValue(promotionSceneEntry.value || '');
                const promotionSceneCode = /^promotion_scene_[a-z0-9_]+$/i.test(explicitCode)
                    ? explicitCode
                    : resolveSceneDefaultPromotionScene(
                        normalizedSceneName,
                        runtime?.storeData?.promotionScene || runtime?.promotionScene || DEFAULTS.promotionScene
                    );
                if (promotionSceneCode) {
                    applyCampaign('promotionScene', promotionSceneCode, promotionSceneEntry.key, promotionSceneEntry.value);
                }
            }
            const promotionModelEntry = findSceneSettingEntry(entries, [/æŠ•æ”¾è°ƒä¼˜/, /ä¼˜åŒ–æ¨¡å¼/, /å¤šç›®æ ‡ä¼˜åŒ–/]);
            const promotionModelValue = mapScenePromotionModelValue(promotionModelEntry?.value || '');
            if (promotionModelEntry && promotionModelValue.promotionModel) {
                applyCampaign('promotionModel', promotionModelValue.promotionModel, promotionModelEntry.key, promotionModelEntry.value);
                if (promotionModelValue.promotionModelMarketing) {
                    applyCampaign('promotionModelMarketing', promotionModelValue.promotionModelMarketing, promotionModelEntry.key, promotionModelEntry.value);
                }
            }
            const campaignGroupEntry = findSceneSettingEntry(entries, [/è®¡åˆ’ç»„/, /è®¾ç½®è®¡åˆ’ç»„/]);
            if (campaignGroupEntry) {
                const campaignGroupValue = normalizeSceneSettingValue(campaignGroupEntry.value || '');
                if (campaignGroupValue && !/^(ä¸è®¾ç½®è®¡åˆ’ç»„|ä¸è®¾ç½®|é»˜è®¤|æ— |none|null)$/i.test(campaignGroupValue)) {
                    if (/^\d{1,20}$/.test(campaignGroupValue)) {
                        applyCampaign('campaignGroupId', campaignGroupValue, campaignGroupEntry.key, campaignGroupEntry.value);
                    } else {
                        applyCampaign('campaignGroupName', campaignGroupValue, campaignGroupEntry.key, campaignGroupEntry.value);
                    }
                }
            }

            const budgetEntries = [
                { patterns: [/æ¯æ—¥é¢„ç®—(?!ç±»å‹)/], field: 'dayBudget' },
                { patterns: [/æ—¥å‡é¢„ç®—/], field: 'dayAverageBudget' },
                { patterns: [/æ€»é¢„ç®—/], field: 'totalBudget' },
                { patterns: [/å†»ç»“é¢„ç®—/, /æœªæ¥é¢„ç®—/], field: 'futureBudget' }
            ];
            budgetEntries.forEach(item => {
                const entry = findSceneSettingEntry(entries, item.patterns);
                const amount = parseNumberFromSceneValue(entry?.value || '');
                if (entry && Number.isFinite(amount) && amount > 0) {
                    applyCampaign(item.field, amount, entry.key, entry.value);
                }
            });
            const genericBudgetEntry = findSceneSettingEntry(entries, [/é¢„ç®—å€¼/]);
            const genericBudgetAmount = parseNumberFromSceneValue(genericBudgetEntry?.value || '');
            if (genericBudgetEntry && Number.isFinite(genericBudgetAmount) && genericBudgetAmount > 0) {
                const dmcHint = String(
                    mapping?.campaignOverride?.dmcType
                    || templateCampaign?.dmcType
                    || runtime?.dmcType
                    || DEFAULTS.dmcType
                    || 'day_average'
                ).trim();
                const budgetField = DMC_BUDGET_FIELD_MAP[dmcHint] || 'dayAverageBudget';
                applyCampaign(budgetField, genericBudgetAmount, genericBudgetEntry.key, genericBudgetEntry.value);
            }

            const singleCostEntry = findSceneSettingEntry(entries, [/å¹³å‡ç›´æ¥æˆäº¤æˆæœ¬/, /ç›´æ¥æˆäº¤æˆæœ¬/, /å•æ¬¡æˆäº¤æˆæœ¬/, /ç›®æ ‡æˆäº¤æˆæœ¬/]);
            if (singleCostEntry) {
                const singleCostAmount = parseNumberFromSceneValue(singleCostEntry.value || '');
                if (Number.isFinite(singleCostAmount) && singleCostAmount > 0) {
                    applyCampaign('setSingleCostV2', true, singleCostEntry.key, singleCostEntry.value);
                    applyCampaign('singleCostV2', singleCostAmount, singleCostEntry.key, singleCostEntry.value);
                } else if (/å…³|å…³é—­|ä¸å¯ç”¨/.test(singleCostEntry.value || '')) {
                    applyCampaign('setSingleCostV2', false, singleCostEntry.key, singleCostEntry.value);
                }
            }

            const smartCreativeEntry = findSceneSettingEntry(entries, [/åˆ›æ„ä¼˜é€‰/, /å°é¢æ™ºèƒ½åˆ›æ„/]);
            if (smartCreativeEntry) {
                if (/å…³/.test(smartCreativeEntry.value) && !/å¼€/.test(smartCreativeEntry.value)) {
                    applyCampaign('smartCreative', 0, smartCreativeEntry.key, smartCreativeEntry.value);
                } else if (/å¼€/.test(smartCreativeEntry.value)) {
                    applyCampaign('smartCreative', 1, smartCreativeEntry.key, smartCreativeEntry.value);
                }
            }

            const creativeModeEntry = findSceneSettingEntry(entries, [/åˆ›æ„è®¾ç½®/, /è®¾ç½®åˆ›æ„/, /åˆ›æ„æ¨¡å¼/]);
            const creativeModeCode = mapSceneCreativeSetModeValue(creativeModeEntry?.value || '');
            if (creativeModeEntry && creativeModeCode) {
                applyCampaign('creativeSetMode', creativeModeCode, creativeModeEntry.key, creativeModeEntry.value);
            }

            const coldStartEntry = findSceneSettingEntry(entries, [/å¼€å¯å†·å¯åŠ é€Ÿ/, /å†·å¯åŠ é€Ÿ/]);
            if (coldStartEntry) {
                const coldStartText = normalizeSceneSettingValue(coldStartEntry.value || '');
                if (coldStartText) {
                    const isColdStartOff = /(å…³|å…³é—­|ä¸å¯ç”¨|ç¦ç”¨|å¦|off|false|0)/i.test(coldStartText)
                        && !/(å¼€|å¼€å¯|å¯ç”¨|æ˜¯|on|true|1)/i.test(coldStartText);
                    applyCampaign(
                        'campaignColdStartVO.coldStartStatus',
                        isColdStartOff ? '0' : '1',
                        coldStartEntry.key,
                        coldStartEntry.value
                    );
                }
            }

            const launchTimeEntry = findSceneSettingEntry(entries, [/æŠ•æ”¾æ—¶é—´/, /æŠ•æ”¾æ—¥æœŸ/, /å‘å¸ƒæ—¥æœŸ/, /æ’æœŸ/]);
            if (launchTimeEntry && /(ä¸é™|é•¿æœŸ|å…¨å¤©|24å°æ—¶)/.test(launchTimeEntry.value)) {
                applyCampaign('launchPeriodList', buildDefaultLaunchPeriodList(), launchTimeEntry.key, launchTimeEntry.value);
            }

            const launchAreaEntry = findSceneSettingEntry(entries, [/æŠ•æ”¾åœ°åŸŸ/, /åœ°åŸŸè®¾ç½®/, /èµ·é‡æ—¶é—´åœ°åŸŸè®¾ç½®/, /æŠ•æ”¾æ—¶é—´åœ°åŸŸè®¾ç½®/]);
            if (launchAreaEntry) {
                const list = mapSceneLaunchAreaList(launchAreaEntry.value || '');
                if (list.length) {
                    applyCampaign('launchAreaStrList', list, launchAreaEntry.key, launchAreaEntry.value);
                }
            }

            if (normalizedSceneName === 'è´§å“å…¨ç«™æ¨å¹¿') {
                const multiTargetEnabled = promotionModelEntry
                    ? !/æ—¥å¸¸|å…³é—­|ä¸å¯ç”¨|å…³/.test(normalizeSceneSettingValue(promotionModelEntry.value || ''))
                    : false;
                if (promotionModelEntry) {
                    applyCampaign('multiTarget.multiTargetSwitch', multiTargetEnabled ? '1' : '0', promotionModelEntry.key, promotionModelEntry.value);
                }
                applyCampaign('isMultiTarget', multiTargetEnabled, promotionModelEntry?.key || 'æŠ•æ”¾è°ƒä¼˜', promotionModelEntry?.value || '');

                const siteOptimizeTargetEntry = findSceneSettingEntry(entries, [/ä¼˜åŒ–ç›®æ ‡/]);
                const siteOptimizeBudgetEntry = findSceneSettingEntry(entries, [/å¤šç›®æ ‡é¢„ç®—/]);
                if (multiTargetEnabled) {
                    const optimizeCode = mapSiteMultiTargetOptimizeTargetValue(siteOptimizeTargetEntry?.value || '');
                    const optimizeBudgetRaw = normalizeSceneSettingValue(siteOptimizeBudgetEntry?.value || '');
                    const optimizeBudgetNum = parseNumberFromSceneValue(optimizeBudgetRaw);
                    const configItem = {};
                    if (optimizeCode) configItem.optimizeTarget = optimizeCode;
                    if (Number.isFinite(optimizeBudgetNum) && optimizeBudgetNum > 0) {
                        configItem.multiTargetBudget = String(optimizeBudgetNum);
                    } else if (optimizeBudgetRaw) {
                        configItem.multiTargetBudget = optimizeBudgetRaw;
                    }
                    if (Object.keys(configItem).length) {
                        applyCampaign(
                            'multiTarget.multiTargetConfigList',
                            [configItem],
                            siteOptimizeTargetEntry?.key || siteOptimizeBudgetEntry?.key || 'ä¼˜åŒ–ç›®æ ‡',
                            siteOptimizeTargetEntry?.value || siteOptimizeBudgetEntry?.value || ''
                        );
                    }
                } else {
                    applyCampaign('multiTarget.multiTargetConfigList', [], promotionModelEntry?.key || 'æŠ•æ”¾è°ƒä¼˜', promotionModelEntry?.value || '');
                }

                const launchTimeValue = normalizeSceneSettingValue(launchTimeEntry?.value || '');
                const quickLiftEnabled = !!launchTimeValue && !/å›ºå®šæ—¶æ®µ|å…³é—­|ä¸å¯ç”¨|å…³/.test(launchTimeValue);
                if (launchTimeEntry) {
                    applyCampaign('quickLiftBudgetCommand.quickLiftSwitch', quickLiftEnabled ? 'true' : 'false', launchTimeEntry.key, launchTimeEntry.value);
                }

                const quickLiftBudgetEntry = findSceneSettingEntry(entries, [/ä¸€é”®èµ·é‡é¢„ç®—/]);
                const quickLiftBudgetRaw = normalizeSceneSettingValue(quickLiftBudgetEntry?.value || '');
                const quickLiftBudgetNum = parseNumberFromSceneValue(quickLiftBudgetRaw);
                if (quickLiftEnabled) {
                    if (Number.isFinite(quickLiftBudgetNum) && quickLiftBudgetNum > 0) {
                        applyCampaign('quickLiftBudgetCommand.quickLiftBudget', String(quickLiftBudgetNum), quickLiftBudgetEntry?.key || 'ä¸€é”®èµ·é‡é¢„ç®—', quickLiftBudgetRaw);
                    } else if (quickLiftBudgetRaw) {
                        applyCampaign('quickLiftBudgetCommand.quickLiftBudget', quickLiftBudgetRaw, quickLiftBudgetEntry?.key || 'ä¸€é”®èµ·é‡é¢„ç®—', quickLiftBudgetRaw);
                    }
                    applyCampaign(
                        'quickLiftBudgetCommand.quickLiftTimeSlot',
                        buildQuickLiftHourSlotValue(launchTimeValue),
                        launchTimeEntry?.key || 'æŠ•æ”¾æ—¶é—´',
                        launchTimeValue
                    );
                    const quickLiftAreaList = mapSceneLaunchAreaList(launchAreaEntry?.value || '');
                    if (quickLiftAreaList.length) {
                        applyCampaign(
                            'quickLiftBudgetCommand.quickLiftLaunchArea',
                            quickLiftAreaList,
                            launchAreaEntry?.key || 'æŠ•æ”¾åœ°åŸŸ',
                            launchAreaEntry?.value || ''
                        );
                    }
                    applyCampaign(
                        'dmcTypeElement',
                        'quickLiftBudgetCommand.quickLiftBudget',
                        quickLiftBudgetEntry?.key || launchTimeEntry?.key || 'ä¸€é”®èµ·é‡é¢„ç®—',
                        quickLiftBudgetRaw || launchTimeValue
                    );
                } else if (multiTargetEnabled) {
                    applyCampaign(
                        'dmcTypeElement',
                        'multiTarget.multiTargetConfigList',
                        siteOptimizeBudgetEntry?.key || siteOptimizeTargetEntry?.key || 'å¤šç›®æ ‡é¢„ç®—',
                        siteOptimizeBudgetEntry?.value || siteOptimizeTargetEntry?.value || ''
                    );
                }
            }

            const crowdEntry = findSceneSettingEntry(entries, [/è®¾ç½®æ‹‰æ–°äººç¾¤/, /äººç¾¤è®¾ç½®/, /ç§å­äººç¾¤/]);
            if (crowdEntry) {
                const crowdValue = normalizeSceneSettingValue(crowdEntry.value || '');
                const crowdOpenHint = /(å¼€|å¼€å¯|å¯ç”¨|æ˜¯|on|true|1)/i.test(crowdValue);
                const crowdCloseHint = /(å…³|å…³é—­|ä¸å¯ç”¨|ç¦ç”¨|å¦|off|false|0)/i.test(crowdValue);
                if (/(è®¾ç½®ä¼˜å…ˆæŠ•æ”¾å®¢æˆ·|ä¼˜å…ˆæŠ•æ”¾å®¢æˆ·|ä¼˜å…ˆ)/.test(crowdValue) || crowdOpenHint) {
                    applyCampaign('needTargetCrowd', '1', crowdEntry.key, crowdEntry.value);
                    applyCampaign('aiXiaowanCrowdListSwitch', '1', crowdEntry.key, crowdEntry.value);
                } else if (/(æ™ºèƒ½äººç¾¤|æ·»åŠ ç§å­äººç¾¤|ç§å­äººç¾¤|æ™ºèƒ½|ç§å­)/.test(crowdValue)) {
                    applyCampaign('needTargetCrowd', '1', crowdEntry.key, crowdEntry.value);
                    applyCampaign('aiXiaowanCrowdListSwitch', '0', crowdEntry.key, crowdEntry.value);
                } else if (crowdCloseHint || !crowdValue) {
                    applyCampaign('needTargetCrowd', '0', crowdEntry.key, crowdEntry.value);
                    applyCampaign('aiXiaowanCrowdListSwitch', '0', crowdEntry.key, crowdEntry.value);
                }
            }

            if (normalizedSceneName === 'äººç¾¤æ¨å¹¿') {
                const strategyEntry = findSceneSettingEntry(entries, [/é€‰æ‹©æ‹‰æ–°æ–¹æ¡ˆ/, /æŠ•æ”¾ç­–ç•¥/, /æ–¹æ¡ˆé€‰æ‹©/, /æ–¹æ¡ˆ/]);
                const strategyCode = mapScenePromotionStrategyValue(normalizedSceneName, strategyEntry?.value || '', runtime);
                if (strategyEntry && strategyCode) {
                    applyCampaign('promotionStrategy', strategyCode, strategyEntry.key, strategyEntry.value);
                }
            }

            entries.forEach(entry => {
                const rawKey = String(entry?.key || '').trim();
                if (!rawKey || /[\u4e00-\u9fa5]/.test(rawKey)) return;
                const directValue = parseDirectSettingValue(rawKey, entry?.value || '');
                if (directValue === '' || directValue === undefined || directValue === null) return;

                if (/^campaign\./i.test(rawKey)) {
                    const campaignKey = rawKey.replace(/^campaign\./i, '').trim();
                    if (campaignKey) applyCampaign(campaignKey, directValue, entry.key, entry.value);
                    return;
                }
                if (/^adgroup\./i.test(rawKey)) {
                    const adgroupKey = rawKey.replace(/^adgroup\./i, '').trim();
                    if (adgroupKey) applyAdgroup(adgroupKey, directValue, entry.key, entry.value);
                    return;
                }
                if (allowedCampaignKeys.has(rawKey)) {
                    applyCampaign(rawKey, directValue, entry.key, entry.value);
                    return;
                }
                if (allowedAdgroupKeys.has(rawKey)) {
                    applyAdgroup(rawKey, directValue, entry.key, entry.value);
                }
            });

            if (isPlainObject(runtime?.solutionTemplate?.adgroupList?.[0])) {
                const templateAdgroupRef = runtime.solutionTemplate.adgroupList[0];
                if (hasOwn(templateAdgroupRef, 'smartCreative')
                    && mapping.adgroupOverride.smartCreative === undefined
                    && mapping.campaignOverride.smartCreative !== undefined) {
                    applyAdgroup('smartCreative', mapping.campaignOverride.smartCreative, 'åˆ›æ„ä¼˜é€‰', String(mapping.campaignOverride.smartCreative));
                }
            }

            return mapping;
        };

        const buildFallbackSolutionTemplate = (runtime, sceneName = '') => {
            const normalizedSceneName = String(sceneName || '').trim();
            if (normalizedSceneName && normalizedSceneName !== 'å…³é”®è¯æ¨å¹¿') {
                const fallbackCampaign = {
                    operation: '',
                    bizCode: runtime.bizCode,
                    promotionScene: runtime.promotionScene || '',
                    subPromotionType: runtime.subPromotionType || DEFAULTS.subPromotionType,
                    promotionType: runtime.promotionType || DEFAULTS.promotionType,
                    dmcType: runtime.dmcType || DEFAULTS.dmcType,
                    campaignName: `${normalizedSceneName}_${todayStamp()}`,
                    campaignGroupId: '',
                    campaignGroupName: '',
                    itemIdList: [],
                    crowdList: [],
                    launchAreaStrList: ['all'],
                    launchPeriodList: buildDefaultLaunchPeriodList()
                };
                if (normalizedSceneName === 'äººç¾¤æ¨å¹¿') {
                    const crowdTarget = String(runtime.bidTargetV2 || runtime.optimizeTarget || SCENE_FALLBACK_BID_TARGET['äººç¾¤æ¨å¹¿'] || '').trim();
                    const crowdBidTypeV2 = normalizeBidTypeForCampaignField(
                        runtime?.storeData?.bidTypeV2 || runtime?.storeData?.bidType || runtime?.bidTypeV2 || '',
                        'bidTypeV2',
                        'äººç¾¤æ¨å¹¿'
                    ) || SCENE_BIDTYPE_V2_DEFAULT['äººç¾¤æ¨å¹¿'];
                    fallbackCampaign.itemSelectedMode = runtime.itemSelectedMode || DEFAULTS.itemSelectedMode;
                    if (crowdTarget) {
                        fallbackCampaign.bidTargetV2 = crowdTarget;
                        fallbackCampaign.optimizeTarget = crowdTarget;
                    }
                    fallbackCampaign.bidTypeV2 = crowdBidTypeV2;
                    fallbackCampaign.promotionStrategy = runtime.storeData?.promotionStrategy || 'jingdian_laxin';
                    fallbackCampaign.user_level = runtime.storeData?.user_level || 'm3';
                    fallbackCampaign.needTargetCrowd = runtime.storeData?.needTargetCrowd || '1';
                    fallbackCampaign.aiXiaowanCrowdListSwitch = runtime.storeData?.aiXiaowanCrowdListSwitch || '1';
                    fallbackCampaign.creativeSetMode = runtime.storeData?.creativeSetMode || 'professional';
                }
                return {
                    bizCode: runtime.bizCode,
                    campaign: fallbackCampaign,
                    adgroupList: [{
                        rightList: [],
                        smartCreative: 1
                    }]
                };
            }
            return {
                bizCode: runtime.bizCode,
                campaign: {
                    operation: '',
                    bizCode: runtime.bizCode,
                    promotionScene: runtime.promotionScene,
                    subPromotionType: runtime.subPromotionType,
                    promotionType: runtime.promotionType,
                    itemSelectedMode: runtime.itemSelectedMode,
                    bidTypeV2: runtime.bidTypeV2,
                    bidTargetV2: runtime.bidTargetV2,
                    campaignCycleBudgetInfo: { currentCampaignActivityCycleBudgetStatus: '0' },
                    subsidy: null,
                    itemIdList: [],
                    deleteAdgroupList: [],
                    updatedRightInfoAdgroupList: [],
                    campaignColdStartVO: { coldStartStatus: '0' },
                    subOptimizeTarget: 'retained_buy',
                    setSingleCostV2: false,
                    optimizeTarget: runtime.bidTargetV2 || 'conv',
                    dmcType: runtime.dmcType || DEFAULTS.dmcType,
                    campaignName: `å…³é”®è¯æ¨å¹¿_${todayStamp()}`,
                    campaignGroupId: '',
                    campaignGroupName: '',
                    supportCouponId: '',
                    creativeSetMode: 'minimalist',
                    smartCreative: 1,
                    crowdList: [],
                    adzoneList: [],
                    launchAreaStrList: ['all'],
                    launchPeriodList: buildDefaultLaunchPeriodList(),
                    sourceChannel: 'onebp',
                    channelLocation: '',
                    selectedTargetBizCode: '',
                    dmpSolutionId: '',
                    activityId: '',
                    specialSourceForMainStep: '',
                    bpStrategyId: '',
                    bpStrategyType: ''
                },
                adgroupList: [{
                    material: {
                        materialId: '',
                        materialName: '',
                        promotionType: runtime.promotionType,
                        subPromotionType: runtime.subPromotionType,
                        fromTab: 'manual',
                        linkUrl: '',
                        goalLifeCycleList: null,
                        shopId: '',
                        shopName: '',
                        bidCount: 0,
                        categoryLevel1: ''
                    },
                    rightList: [],
                    wordList: [],
                    wordPackageList: [],
                    smartCreative: 1
                }]
            };
        };

        const resolveBudgetForCampaign = (planBudget, runtime, campaign) => {
            const budget = isPlainObject(planBudget) ? planBudget : {};
            let dmcType = String(budget.dmcType || campaign?.dmcType || runtime.dmcType || DEFAULTS.dmcType || '').trim();
            if (!dmcType) dmcType = DEFAULTS.dmcType;

            let selectedField = '';
            let selectedValue = NaN;
            for (const key of BUDGET_FIELDS) {
                if (budget[key] === undefined || budget[key] === null || budget[key] === '') continue;
                selectedField = key;
                selectedValue = toNumber(budget[key], NaN);
                break;
            }
            if (!budget.dmcType && selectedField && BUDGET_FIELD_DMC_MAP[selectedField]) {
                dmcType = BUDGET_FIELD_DMC_MAP[selectedField];
            }

            if (!selectedField && planBudget !== undefined && planBudget !== null && planBudget !== '' && !isPlainObject(planBudget)) {
                selectedField = DMC_BUDGET_FIELD_MAP[dmcType] || 'dayAverageBudget';
                selectedValue = toNumber(planBudget, NaN);
            }

            if (!selectedField) {
                const mappedField = DMC_BUDGET_FIELD_MAP[dmcType] || 'dayAverageBudget';
                if (runtime[mappedField] !== undefined && runtime[mappedField] !== null && runtime[mappedField] !== '') {
                    selectedField = mappedField;
                    selectedValue = toNumber(runtime[mappedField], NaN);
                } else if (runtime.dayAverageBudget !== undefined && runtime.dayAverageBudget !== null && runtime.dayAverageBudget !== '') {
                    selectedField = mappedField;
                    selectedValue = toNumber(runtime.dayAverageBudget, NaN);
                } else if (campaign?.[mappedField] !== undefined && campaign?.[mappedField] !== null && campaign?.[mappedField] !== '') {
                    selectedField = mappedField;
                    selectedValue = toNumber(campaign[mappedField], NaN);
                }
            }

            return {
                dmcType,
                field: selectedField,
                value: selectedValue
            };
        };

        const buildSolutionFromPlan = async ({ plan, request, runtime, requestOptions }) => {
            const sceneCapabilities = resolveSceneCapabilities({
                sceneName: request?.sceneName || '',
                runtime,
                request
            });
            const goalResolution = isPlainObject(plan?.__goalResolution)
                ? plan.__goalResolution
                : (isPlainObject(request?.__goalResolution) ? request.__goalResolution : {});
            const resolvedMarketingGoal = normalizeGoalLabel(
                plan?.marketingGoal
                || goalResolution?.resolvedMarketingGoal
                || request?.marketingGoal
                || request?.common?.marketingGoal
                || ''
            );
            const submitEndpoint = normalizeGoalCreateEndpoint(
                plan?.submitEndpoint
                || request?.submitEndpoint
                || goalResolution?.endpoint
                || ENDPOINTS.solutionAddList
            );
            const isKeywordScene = sceneCapabilities.sceneName === 'å…³é”®è¯æ¨å¹¿';
            const planBidMode = isKeywordScene
                ? resolvePlanBidMode({ plan, request, runtime })
                : '';
            const isKeywordManualMode = isKeywordScene && planBidMode === 'manual';
            const keywordGoalRuntime = isKeywordScene
                ? resolveKeywordGoalRuntimeFallback(
                    resolvedMarketingGoal
                    || plan?.marketingGoal
                    || request?.marketingGoal
                    || request?.common?.marketingGoal
                    || ''
                )
                : {};
            const sceneBizCodeHint = normalizeSceneBizCode(
                sceneCapabilities.expectedSceneBizCode
                || resolveSceneBizCodeHint(sceneCapabilities.sceneName || request?.sceneName || '')
                || request?.bizCode
                || runtime?.bizCode
                || ''
            );
            const runtimeTemplateBizCode = normalizeSceneBizCode(
                runtime?.solutionTemplate?.bizCode
                || runtime?.solutionTemplate?.campaign?.bizCode
                || ''
            );
            const templateMatchesScene = !sceneBizCodeHint
                || !runtimeTemplateBizCode
                || runtimeTemplateBizCode === sceneBizCodeHint;
            const runtimeSceneName = sceneCapabilities.sceneName || request?.sceneName || '';
            const runtimeScenePromotionScene = isKeywordScene
                ? String(
                    runtime?.promotionScene
                    || request?.promotionScene
                    || keywordGoalRuntime?.promotionScene
                    || resolveSceneDefaultPromotionScene(runtimeSceneName, '')
                ).trim()
                : (
                    resolveSceneDefaultPromotionScene(runtimeSceneName, runtime?.promotionScene || '')
                    || runtime?.promotionScene
                    || ''
                );
            const runtimeForScene = mergeDeep({}, runtime, {
                bizCode: sceneBizCodeHint || runtime?.bizCode || DEFAULTS.bizCode,
                promotionScene: runtimeScenePromotionScene,
                solutionTemplate: templateMatchesScene ? runtime?.solutionTemplate : null
            });
            const template = runtimeForScene.solutionTemplate || buildFallbackSolutionTemplate(runtimeForScene, request?.sceneName || '');
            const item = plan?.item ? normalizeItem(plan.item) : null;
            const hasItem = !!(item?.materialId || item?.itemId);
            if (sceneCapabilities.requiresItem && !hasItem) {
                throw new Error(`åœºæ™¯ã€Œ${sceneCapabilities.sceneName || 'æœªå‘½å'}ã€è¦æ±‚å…ˆé€‰æ‹©å•†å“`);
            }

            const campaign = purgeCreateTransientFields(sanitizeCampaign(deepClone(template.campaign || {})));
            const baseAdgroup = (Array.isArray(template.adgroupList) && template.adgroupList[0]) ? template.adgroupList[0] : {};
            const adgroup = purgeCreateTransientFields(sanitizeAdgroup(deepClone(baseAdgroup)));

            campaign.bizCode = campaign.bizCode || runtimeForScene.bizCode || DEFAULTS.bizCode;
            campaign.subPromotionType = campaign.subPromotionType || runtimeForScene.subPromotionType || DEFAULTS.subPromotionType;
            campaign.promotionType = campaign.promotionType || runtimeForScene.promotionType || DEFAULTS.promotionType;
            campaign.bidTypeV2 = isKeywordScene
                ? bidModeToBidType(planBidMode)
                : (campaign.bidTypeV2 || runtimeForScene.bidTypeV2 || '');
            if (isKeywordScene) {
                campaign.promotionScene = String(
                    campaign.promotionScene
                    || runtimeForScene.promotionScene
                    || keywordGoalRuntime?.promotionScene
                    || DEFAULTS.promotionScene
                ).trim();
                campaign.itemSelectedMode = String(
                    campaign.itemSelectedMode
                    || runtimeForScene.itemSelectedMode
                    || keywordGoalRuntime?.itemSelectedMode
                    || DEFAULTS.itemSelectedMode
                ).trim();
                if (planBidMode === 'smart') {
                    campaign.bidTargetV2 = campaign.bidTargetV2 || runtimeForScene.bidTargetV2 || DEFAULTS.bidTargetV2;
                    campaign.optimizeTarget = campaign.optimizeTarget || campaign.bidTargetV2;
                } else {
                    delete campaign.bidTargetV2;
                    delete campaign.optimizeTarget;
                    campaign.setSingleCostV2 = false;
                    delete campaign.singleCostV2;
                }
            } else {
                const forcedScenePromotionScene = resolveSceneDefaultPromotionScene(
                    sceneCapabilities.sceneName || request?.sceneName || '',
                    runtimeForScene.promotionScene || ''
                );
                campaign.promotionScene = forcedScenePromotionScene || campaign.promotionScene || runtimeForScene.promotionScene || '';
                campaign.itemSelectedMode = campaign.itemSelectedMode || runtimeForScene.itemSelectedMode || '';
                campaign.bidTargetV2 = campaign.bidTargetV2 || runtimeForScene.bidTargetV2 || '';
                if (!campaign.bidTypeV2) delete campaign.bidTypeV2;
                if (!campaign.itemSelectedMode) delete campaign.itemSelectedMode;
                if (!campaign.promotionScene) delete campaign.promotionScene;
                if (!campaign.bidTargetV2) {
                    delete campaign.bidTargetV2;
                    delete campaign.optimizeTarget;
                } else if (!campaign.optimizeTarget) {
                    campaign.optimizeTarget = campaign.bidTargetV2;
                }
            }
            campaign.dmcType = campaign.dmcType || runtimeForScene.dmcType || DEFAULTS.dmcType;
            campaign.campaignName = plan.planName;
            if (hasItem && sceneCapabilities.hasItemIdList) {
                campaign.itemIdList = [toIdValue(item.materialId || item.itemId)];
            } else if (Array.isArray(campaign.itemIdList)) {
                campaign.itemIdList = [];
            } else if (!sceneCapabilities.hasItemIdList && hasOwn(campaign, 'itemIdList')) {
                delete campaign.itemIdList;
            }
            if (!isPlainObject(campaign.campaignCycleBudgetInfo)) {
                campaign.campaignCycleBudgetInfo = { currentCampaignActivityCycleBudgetStatus: '0' };
            } else if (!campaign.campaignCycleBudgetInfo.currentCampaignActivityCycleBudgetStatus) {
                campaign.campaignCycleBudgetInfo.currentCampaignActivityCycleBudgetStatus = '0';
            }

            const budgetConfig = resolveBudgetForCampaign(plan?.budget, runtimeForScene, campaign);
            campaign.dmcType = budgetConfig.dmcType || campaign.dmcType;
            if (budgetConfig.field && Number.isFinite(budgetConfig.value) && budgetConfig.value > 0) {
                BUDGET_FIELDS.forEach(field => {
                    if (field !== budgetConfig.field) delete campaign[field];
                });
                campaign[budgetConfig.field] = budgetConfig.value;
            }

            let keywordBundle = {
                wordList: [],
                wordPackageList: [],
                mode: 'none'
            };
            if (sceneCapabilities.enableKeywords) {
                if (!hasItem) {
                    throw new Error(`åœºæ™¯ã€Œ${sceneCapabilities.sceneName || 'æœªå‘½å'}ã€å¯ç”¨å…³é”®è¯æ—¶å¿…é¡»æä¾›å•†å“`);
                }
                keywordBundle = await buildKeywordBundle({
                    plan,
                    item,
                    runtimeDefaults: runtimeForScene,
                    request,
                    requestOptions
                });
                if (isKeywordManualMode) {
                    keywordBundle.useWordPackage = false;
                    keywordBundle.wordPackageList = [];
                }
            }

            if (sceneCapabilities.hasMaterial && hasItem) {
                const materialId = toIdValue(item.materialId || item.itemId);
                const fallbackMaterialName = `å•†å“${item.itemId || item.materialId || ''}`;
                const materialName = String(item.materialName || '').trim() || fallbackMaterialName;
                adgroup.material = pickMaterialFields(mergeDeep(adgroup.material || {}, {
                    materialId,
                    materialName,
                    promotionType: runtimeForScene.promotionType,
                    subPromotionType: runtimeForScene.subPromotionType,
                    fromTab: item.fromTab || adgroup.material?.fromTab || 'manual',
                    linkUrl: item.linkUrl || adgroup.material?.linkUrl || '',
                    shopId: item.shopId || adgroup.material?.shopId || '',
                    shopName: item.shopName || adgroup.material?.shopName || '',
                    bidCount: item.bidCount || adgroup.material?.bidCount || 0,
                    categoryLevel1: item.categoryLevel1 || adgroup.material?.categoryLevel1 || ''
                }));
            } else if (hasOwn(adgroup, 'material') && !sceneCapabilities.hasMaterial) {
                delete adgroup.material;
            }

            if (sceneCapabilities.hasWordList) {
                adgroup.wordList = keywordBundle.wordList;
            } else if (hasOwn(adgroup, 'wordList')) {
                delete adgroup.wordList;
            }

            if (sceneCapabilities.hasWordPackageList && keywordBundle.useWordPackage) {
                adgroup.wordPackageList = keywordBundle.wordPackageList;
            } else if (hasOwn(adgroup, 'wordPackageList')) {
                delete adgroup.wordPackageList;
            }

            if (sceneCapabilities.hasRightList && !Array.isArray(adgroup.rightList)) {
                adgroup.rightList = [];
            } else if (!sceneCapabilities.hasRightList && hasOwn(adgroup, 'rightList')) {
                delete adgroup.rightList;
            }

            if (!isKeywordScene
                && !hasOwn(baseAdgroup || {}, 'smartCreative')
                && hasOwn(adgroup, 'smartCreative')) {
                delete adgroup.smartCreative;
            }

            const merged = { campaign, adgroup };
            applyOverrides(merged, request, plan);
            if (sceneBizCodeHint) {
                merged.campaign.bizCode = sceneBizCodeHint;
            }
            if (hasItem && sceneCapabilities.hasItemIdList) {
                merged.campaign.itemIdList = [toIdValue(item.materialId || item.itemId)];
            } else if (!sceneCapabilities.hasItemIdList && hasOwn(merged.campaign, 'itemIdList')) {
                delete merged.campaign.itemIdList;
            }
            const hasExplicitCampaignField = (key = '') => {
                const sourceValues = [
                    request?.[key],
                    request?.common?.[key],
                    request?.common?.campaignOverride?.[key],
                    request?.goalForcedCampaignOverride?.[key],
                    request?.sceneForcedCampaignOverride?.[key],
                    request?.rawOverrides?.[key],
                    request?.rawOverrides?.campaign?.[key],
                    request?.common?.rawOverrides?.campaign?.[key],
                    plan?.[key],
                    plan?.campaignOverride?.[key],
                    plan?.goalForcedCampaignOverride?.[key],
                    plan?.rawOverrides?.[key],
                    plan?.rawOverrides?.campaign?.[key]
                ];
                return sourceValues.some(value => value !== undefined && value !== null && value !== '');
            };
            if (sceneCapabilities.enableKeywords && !keywordBundle.useWordPackage) {
                merged.campaign = stripWordPackageArtifacts(merged.campaign);
                merged.adgroup = stripWordPackageArtifacts(merged.adgroup);
                if (isKeywordScene) {
                    merged.campaign = stripKeywordTrafficArtifacts(merged.campaign);
                    merged.adgroup = stripKeywordTrafficArtifacts(merged.adgroup);
                }
            }
            if (isKeywordScene) {
                merged.campaign = pruneKeywordCampaignForCustomScene(merged.campaign, {
                    request,
                    bidMode: planBidMode,
                    goalRuntime: keywordGoalRuntime
                });
                merged.adgroup = pruneKeywordAdgroupForCustomScene(merged.adgroup, hasItem ? item : null, {
                    bidMode: planBidMode
                });
            } else {
                const expectedSceneBizCode = normalizeSceneBizCode(sceneCapabilities.expectedSceneBizCode || sceneBizCodeHint || request?.bizCode || '');
                const templateBizCode = normalizeSceneBizCode(runtimeForScene?.solutionTemplate?.bizCode || runtimeForScene?.solutionTemplate?.campaign?.bizCode || '');
                const hasRuntimeTemplateCampaign = isPlainObject(runtimeForScene?.solutionTemplate?.campaign)
                    && Object.keys(runtimeForScene.solutionTemplate.campaign).length > 0
                    && (!expectedSceneBizCode || (templateBizCode && templateBizCode === expectedSceneBizCode));
                const runtimeTemplateCampaign = hasRuntimeTemplateCampaign
                    ? (runtimeForScene.solutionTemplate.campaign || {})
                    : {};
                const explicitBidTypeV2 = hasExplicitCampaignField('bidTypeV2');
                const explicitBidType = hasExplicitCampaignField('bidType');
                const explicitOptimizeTarget = hasExplicitCampaignField('optimizeTarget');
                const scenePrefersBidTypeV2 = SCENE_BIDTYPE_V2_ONLY.has(sceneCapabilities.sceneName);
                const supportsTemplateBidTypeV2 = hasOwn(runtimeTemplateCampaign, 'bidTypeV2');
                const shouldKeepBidTypeV2 = scenePrefersBidTypeV2 || supportsTemplateBidTypeV2;
                if (!explicitBidTypeV2 && !shouldKeepBidTypeV2) {
                    delete merged.campaign.bidTypeV2;
                }
                if ((!explicitBidType && !hasRuntimeTemplateCampaign) || scenePrefersBidTypeV2) {
                    delete merged.campaign.bidType;
                }

                const supportsBidTargetFields = sceneCapabilities.sceneName === 'äººç¾¤æ¨å¹¿'
                    || sceneCapabilities.sceneName === 'è´§å“å…¨ç«™æ¨å¹¿'
                    || hasRuntimeTemplateCampaign && (
                        hasOwn(runtimeForScene.solutionTemplate.campaign || {}, 'bidTargetV2')
                        || hasOwn(runtimeForScene.solutionTemplate.campaign || {}, 'optimizeTarget')
                    );
                const fallbackBidTarget = SCENE_FALLBACK_BID_TARGET[sceneCapabilities.sceneName] || '';
                let bidTarget = String(merged.campaign.bidTargetV2 || '').trim();
                if ((!bidTarget || bidTarget === DEFAULTS.bidTargetV2) && fallbackBidTarget) {
                    bidTarget = fallbackBidTarget;
                }
                const keepOptimizeTarget = sceneCapabilities.sceneName === 'å†…å®¹è¥é”€'
                    || sceneCapabilities.sceneName === 'çº¿ç´¢æ¨å¹¿';
                if (!supportsBidTargetFields || !bidTarget) {
                    delete merged.campaign.bidTargetV2;
                    if (!keepOptimizeTarget) {
                        delete merged.campaign.optimizeTarget;
                    }
                } else {
                    merged.campaign.bidTargetV2 = bidTarget;
                    const optimizeTarget = String(merged.campaign.optimizeTarget || '').trim();
                    const shouldSyncOptimizeTarget = sceneCapabilities.sceneName === 'äººç¾¤æ¨å¹¿'
                        || !optimizeTarget
                        || optimizeTarget === DEFAULTS.bidTargetV2
                        || (!explicitOptimizeTarget && !hasRuntimeTemplateCampaign);
                    if (shouldSyncOptimizeTarget) {
                        merged.campaign.optimizeTarget = bidTarget;
                    }
                }

                if (sceneCapabilities.sceneName === 'äººç¾¤æ¨å¹¿') {
                    if (!merged.campaign.promotionScene || /promotion_scene_search_/i.test(String(merged.campaign.promotionScene || ''))) {
                        merged.campaign.promotionScene = resolveSceneDefaultPromotionScene('äººç¾¤æ¨å¹¿', runtimeForScene?.storeData?.promotionScene || 'promotion_scene_display_laxin');
                    }
                    const runtimeCrowdBidTypeV2 = normalizeBidTypeForCampaignField(
                        runtimeForScene?.storeData?.bidTypeV2 || runtimeForScene?.storeData?.bidType || runtimeForScene?.bidTypeV2 || '',
                        'bidTypeV2',
                        'äººç¾¤æ¨å¹¿'
                    );
                    const mergedCrowdBidTypeV2 = normalizeBidTypeForCampaignField(
                        merged.campaign.bidTypeV2 || merged.campaign.bidType || '',
                        'bidTypeV2',
                        'äººç¾¤æ¨å¹¿'
                    );
                    merged.campaign.bidTypeV2 = mergedCrowdBidTypeV2 || runtimeCrowdBidTypeV2 || SCENE_BIDTYPE_V2_DEFAULT['äººç¾¤æ¨å¹¿'];
                    delete merged.campaign.bidType;
                    if (!merged.campaign.itemSelectedMode) {
                        merged.campaign.itemSelectedMode = runtimeForScene.itemSelectedMode || DEFAULTS.itemSelectedMode;
                    }
                    if (!merged.campaign.promotionStrategy) {
                        merged.campaign.promotionStrategy = runtimeForScene?.storeData?.promotionStrategy || 'jingdian_laxin';
                    }
                    if (!merged.campaign.user_level) {
                        merged.campaign.user_level = runtimeForScene?.storeData?.user_level || 'm3';
                    }
                    if (merged.campaign.needTargetCrowd === undefined || merged.campaign.needTargetCrowd === null || merged.campaign.needTargetCrowd === '') {
                        merged.campaign.needTargetCrowd = runtimeForScene?.storeData?.needTargetCrowd || '1';
                    }
                    if (merged.campaign.aiXiaowanCrowdListSwitch === undefined || merged.campaign.aiXiaowanCrowdListSwitch === null || merged.campaign.aiXiaowanCrowdListSwitch === '') {
                        merged.campaign.aiXiaowanCrowdListSwitch = runtimeForScene?.storeData?.aiXiaowanCrowdListSwitch || '1';
                    }
                    if (!merged.campaign.creativeSetMode) {
                        merged.campaign.creativeSetMode = runtimeForScene?.storeData?.creativeSetMode || 'professional';
                    }
                }

                if (sceneCapabilities.sceneName === 'è´§å“å…¨ç«™æ¨å¹¿') {
                    merged.campaign.promotionScene = merged.campaign.promotionScene || runtimeForScene?.storeData?.promotionScene || 'promotion_scene_site';
                    merged.campaign.itemSelectedMode = merged.campaign.itemSelectedMode || runtimeForScene?.storeData?.itemSelectedMode || 'user_define';
                    merged.campaign.bidType = merged.campaign.bidType || runtimeForScene?.storeData?.bidType || 'roi_control';
                    merged.campaign.optimizeTarget = merged.campaign.optimizeTarget || runtimeForScene?.storeData?.optimizeTarget || 'ad_strategy_retained_buy';
                    const siteBidType = String(merged.campaign.bidType || '').trim().toLowerCase();
                    const needConstraintValue = siteBidType !== 'max_amount';
                    if (needConstraintValue) {
                        merged.campaign.constraintType = merged.campaign.constraintType || runtimeForScene?.storeData?.constraintType || 'roi';
                        if (merged.campaign.constraintValue === undefined || merged.campaign.constraintValue === null || merged.campaign.constraintValue === '') {
                            merged.campaign.constraintValue = toNumber(runtimeForScene?.storeData?.constraintValue, 5.0);
                        }
                    } else {
                        delete merged.campaign.constraintType;
                        delete merged.campaign.constraintValue;
                    }
                    if (!isPlainObject(merged.campaign.multiTarget)) {
                        merged.campaign.multiTarget = { multiTargetSwitch: '0' };
                    } else if (!merged.campaign.multiTarget.multiTargetSwitch) {
                        merged.campaign.multiTarget.multiTargetSwitch = '0';
                    }
                    const siteMultiTargetSwitch = String(merged.campaign.multiTarget?.multiTargetSwitch || '0').trim() === '1' ? '1' : '0';
                    merged.campaign.multiTarget.multiTargetSwitch = siteMultiTargetSwitch;
                    if (siteMultiTargetSwitch !== '1') {
                        delete merged.campaign.multiTarget.multiTargetConfigList;
                    } else if (!Array.isArray(merged.campaign.multiTarget.multiTargetConfigList)) {
                        merged.campaign.multiTarget.multiTargetConfigList = [];
                    }
                    merged.campaign.isMultiTarget = siteMultiTargetSwitch === '1';

                    const quickLiftCommand = isPlainObject(merged.campaign.quickLiftBudgetCommand)
                        ? merged.campaign.quickLiftBudgetCommand
                        : {};
                    const quickLiftSwitchRaw = String(quickLiftCommand.quickLiftSwitch || '').trim().toLowerCase();
                    const siteQuickLiftEnabled = quickLiftSwitchRaw === '1'
                        || quickLiftSwitchRaw === 'true'
                        || quickLiftSwitchRaw === 'yes'
                        || quickLiftSwitchRaw === 'on';
                    if (siteQuickLiftEnabled) {
                        quickLiftCommand.quickLiftSwitch = 'true';
                        if (!quickLiftCommand.quickLiftTimeSlot) {
                            quickLiftCommand.quickLiftTimeSlot = buildQuickLiftHourSlotValue('é•¿æœŸæŠ•æ”¾');
                        }
                        if (!Array.isArray(quickLiftCommand.quickLiftLaunchArea) || !quickLiftCommand.quickLiftLaunchArea.length) {
                            quickLiftCommand.quickLiftLaunchArea = ['all'];
                        }
                        merged.campaign.quickLiftBudgetCommand = quickLiftCommand;
                        merged.campaign.dmcTypeElement = 'quickLiftBudgetCommand.quickLiftBudget';
                    } else {
                        delete merged.campaign.quickLiftBudgetCommand;
                        delete merged.campaign.isQuickLift;
                        if (merged.campaign.isMultiTarget) {
                            merged.campaign.dmcTypeElement = 'multiTarget.multiTargetConfigList';
                        } else {
                            delete merged.campaign.dmcTypeElement;
                        }
                    }
                    delete merged.campaign.isQuickLift;
                    if (!hasOwn(merged.campaign, 'campaignId')) {
                        merged.campaign.campaignId = '';
                    }
                    if (!merged.campaign.sourceChannel) {
                        merged.campaign.sourceChannel = 'onebp';
                    }
                    const siteDmcType = String(merged.campaign.dmcType || '').trim().toLowerCase();
                    const siteBudgetValue = [
                        merged.campaign.dayBudget,
                        merged.campaign.dayAverageBudget,
                        runtimeForScene?.storeData?.dayBudget,
                        runtimeForScene?.storeData?.dayAverageBudget,
                        runtimeForScene?.dayBudget,
                        runtimeForScene?.dayAverageBudget
                    ]
                        .map(item => toNumber(item, NaN))
                        .find(item => Number.isFinite(item) && item > 0);
                    if (siteDmcType === 'unlimit') {
                        delete merged.campaign.dayBudget;
                        delete merged.campaign.dayAverageBudget;
                        delete merged.campaign.totalBudget;
                        delete merged.campaign.futureBudget;
                    } else {
                        merged.campaign.dmcType = 'normal';
                        if (Number.isFinite(siteBudgetValue) && siteBudgetValue > 0) {
                            merged.campaign.dayBudget = siteBudgetValue;
                        }
                        delete merged.campaign.dayAverageBudget;
                        delete merged.campaign.totalBudget;
                        delete merged.campaign.futureBudget;
                    }
                    delete merged.campaign.bidTargetV2;
                    delete merged.campaign.wordList;
                    delete merged.campaign.wordPackageList;
                    delete merged.campaign.promotionModel;
                    delete merged.campaign.promotionModelMarketing;
                    delete merged.campaign.orderChargeType;
                    delete merged.campaign.orderInfo;
                    const safeSiteCampaignName = String(merged.campaign.campaignName || '').trim();
                    if (!/^[A-Za-z0-9]{2,64}$/.test(safeSiteCampaignName)) {
                        merged.campaign.campaignName = `site${nowStampSeconds()}`;
                    }
                    const adgroupName = String(
                        merged.adgroup?.adgroupName
                        || merged.adgroup?.material?.materialName
                        || merged.campaign.campaignName
                        || plan.planName
                        || ''
                    ).trim();
                    if (adgroupName) {
                        merged.adgroup.adgroupName = /å•å…ƒ$/.test(adgroupName) ? adgroupName : `${adgroupName}_å•å…ƒ`;
                    }
                }
                if (sceneCapabilities.sceneName === 'åº—é“ºç›´è¾¾') {
                    delete merged.campaign.bidTypeV2;
                    delete merged.campaign.bidTargetV2;
                    delete merged.campaign.optimizeTarget;
                    if (!merged.campaign.promotionModel) {
                        merged.campaign.promotionModel = runtimeForScene?.storeData?.promotionModel || 'daily';
                    }
                }
                if (sceneCapabilities.sceneName === 'å†…å®¹è¥é”€') {
                    delete merged.campaign.bidTypeV2;
                    if (!merged.campaign.promotionScene) {
                        merged.campaign.promotionScene = resolveSceneDefaultPromotionScene('å†…å®¹è¥é”€', runtimeForScene?.storeData?.promotionScene || 'scene_live_room');
                    }
                    if (!merged.campaign.bidType) {
                        merged.campaign.bidType = runtimeForScene?.storeData?.bidType || 'bcb';
                    }
                    if (!merged.campaign.optimizeTarget) {
                        merged.campaign.optimizeTarget = runtimeForScene?.storeData?.optimizeTarget || 'ad_strategy_buy_net';
                    }
                    if (!merged.campaign.itemSelectedMode) {
                        merged.campaign.itemSelectedMode = runtimeForScene?.storeData?.itemSelectedMode || 'user_define';
                    }
                    if (!merged.campaign.promotionModel) {
                        merged.campaign.promotionModel = runtimeForScene?.storeData?.promotionModel || 'daily';
                    }
                    if (!Array.isArray(merged.campaign.launchPeriodList) || !merged.campaign.launchPeriodList.length) {
                        merged.campaign.launchPeriodList = buildDefaultLaunchPeriodList();
                    }
                    if (!Array.isArray(merged.campaign.launchAreaStrList) || !merged.campaign.launchAreaStrList.length) {
                        merged.campaign.launchAreaStrList = ['all'];
                    }
                    if (!isPlainObject(merged.campaign.launchTime)) {
                        merged.campaign.launchTime = buildDefaultLaunchTime({ forever: true });
                    }
                }
                if (sceneCapabilities.sceneName === 'çº¿ç´¢æ¨å¹¿') {
                    delete merged.campaign.bidTypeV2;
                    merged.campaign.dmcType = 'total';
                    if (!merged.campaign.promotionScene) {
                        merged.campaign.promotionScene = resolveSceneDefaultPromotionScene('çº¿ç´¢æ¨å¹¿', runtimeForScene?.storeData?.promotionScene || 'leads_collection');
                    }
                    if (!merged.campaign.bidType) {
                        merged.campaign.bidType = runtimeForScene?.storeData?.bidType || 'max_amount';
                    }
                    if (!merged.campaign.promotionModel) {
                        merged.campaign.promotionModel = runtimeForScene?.storeData?.promotionModel
                            || 'order';
                    }
                    if (!merged.campaign.promotionModelMarketing) {
                        merged.campaign.promotionModelMarketing = runtimeForScene?.storeData?.promotionModelMarketing
                            || 'strategy';
                    }
                    if (!merged.campaign.orderChargeType) {
                        merged.campaign.orderChargeType = runtimeForScene?.storeData?.orderChargeType
                            || 'balance_charge';
                    }
                    if (!merged.campaign.itemSelectedMode) {
                        merged.campaign.itemSelectedMode = runtimeForScene?.storeData?.itemSelectedMode
                            || 'user_define';
                    }
                    if (!merged.campaign.optimizeTarget) {
                        merged.campaign.optimizeTarget = runtimeForScene?.storeData?.optimizeTarget
                            || 'leads_cost';
                    }
                    if (!Array.isArray(merged.campaign.launchPeriodList) || !merged.campaign.launchPeriodList.length) {
                        merged.campaign.launchPeriodList = buildDefaultLaunchPeriodList();
                    }
                    if (!Array.isArray(merged.campaign.launchAreaStrList) || !merged.campaign.launchAreaStrList.length) {
                        merged.campaign.launchAreaStrList = ['all'];
                    }
                    if (!isPlainObject(merged.campaign.launchTime)) {
                        merged.campaign.launchTime = buildDefaultLaunchTime({ days: 7, forever: false });
                    }
                    if (merged.campaign.planId === undefined || merged.campaign.planId === null || merged.campaign.planId === '') {
                        merged.campaign.planId = runtimeForScene?.storeData?.planId || 308;
                    }
                    if (merged.campaign.planTemplateId === undefined || merged.campaign.planTemplateId === null || merged.campaign.planTemplateId === '') {
                        merged.campaign.planTemplateId = runtimeForScene?.storeData?.planTemplateId || merged.campaign.planId || 308;
                    }
                    if (merged.campaign.packageTemplateId === undefined || merged.campaign.packageTemplateId === null || merged.campaign.packageTemplateId === '') {
                        merged.campaign.packageTemplateId = runtimeForScene?.storeData?.packageTemplateId || 74;
                    }
                    const orderAmountBase = Math.max(1500, toNumber(
                        merged.campaign.orderAmount
                        || merged.campaign.totalBudget
                        || merged.campaign.dayBudget
                        || merged.campaign.dayAverageBudget
                        || 3000,
                        3000
                    ));
                    merged.campaign.orderAmount = orderAmountBase;
                    merged.campaign.totalBudget = Math.max(1500, toNumber(merged.campaign.totalBudget, orderAmountBase));
                    delete merged.campaign.dayBudget;
                    delete merged.campaign.dayAverageBudget;
                    delete merged.campaign.futureBudget;
                    if (!isPlainObject(merged.campaign.orderInfo)) {
                        merged.campaign.orderInfo = {};
                    }
                    merged.campaign.orderInfo.orderAmount = Math.max(1500, toNumber(merged.campaign.orderInfo.orderAmount, orderAmountBase));
                    merged.campaign.orderInfo.planId = merged.campaign.orderInfo.planId || merged.campaign.planId;
                    merged.campaign.orderInfo.planTemplateId = merged.campaign.orderInfo.planTemplateId || merged.campaign.planTemplateId;
                    merged.campaign.orderInfo.packageTemplateId = merged.campaign.orderInfo.packageTemplateId || merged.campaign.packageTemplateId;
                    merged.campaign.orderInfo.launchTimeType = merged.campaign.orderInfo.launchTimeType || 'adjustable';
                    merged.campaign.orderInfo.isCustom = merged.campaign.orderInfo.isCustom !== undefined
                        ? merged.campaign.orderInfo.isCustom
                        : true;
                    merged.campaign.orderInfo.name = merged.campaign.orderInfo.name || 'è‡ªå®šä¹‰æ–¹æ¡ˆåŒ…';
                    merged.campaign.orderInfo.planName = merged.campaign.orderInfo.planName || 'è‡ªå®šä¹‰æ–¹æ¡ˆåŒ…';
                    merged.campaign.orderInfo.minBudget = Math.max(1500, toNumber(merged.campaign.orderInfo.minBudget, 1500));
                    merged.campaign.orderInfo.maxBudget = Math.max(merged.campaign.orderInfo.minBudget, toNumber(merged.campaign.orderInfo.maxBudget, 1000000));
                    merged.campaign.orderInfo.predictCycle = Math.max(1, toNumber(merged.campaign.orderInfo.predictCycle, 7));
                    merged.campaign.orderInfo.dmcPeriod = Math.max(1, toNumber(merged.campaign.orderInfo.dmcPeriod, 7));
                    merged.campaign.orderInfo.supportRefund = merged.campaign.orderInfo.supportRefund !== undefined
                        ? merged.campaign.orderInfo.supportRefund
                        : true;
                    merged.campaign.orderInfo.supportRenewal = merged.campaign.orderInfo.supportRenewal !== undefined
                        ? merged.campaign.orderInfo.supportRenewal
                        : true;
                }

                // éå…³é”®è¯åœºæ™¯æŒ‰å½“å‰æ¨¡æ¿å‰”é™¤å¯é€‰å­—æ®µï¼Œé¿å…æŠŠä¸Šä¸€ä¸ªåœºæ™¯å­—æ®µä¸²åˆ°å½“å‰åœºæ™¯ã€‚
                if (hasRuntimeTemplateCampaign) {
                    const templateCampaign = runtimeForScene.solutionTemplate.campaign || {};
                    const optionalKeys = [
                        'bidTypeV2',
                        'adzoneList',
                        'launchAreaStrList',
                        'launchPeriodList',
                        'crowdList',
                        'itemIdList',
                        'promotionStrategy',
                        'needTargetCrowd',
                        'aiXiaowanCrowdListSwitch',
                        'creativeSetMode',
                        'user_level',
                        'orderChargeType'
                    ];
                    optionalKeys.forEach(key => {
                        if (hasOwn(templateCampaign, key)) return;
                        if (hasExplicitCampaignField(key)) return;
                        if (sceneCapabilities.sceneName === 'äººç¾¤æ¨å¹¿' && key === 'bidTypeV2') return;
                        if ((sceneCapabilities.sceneName === 'å†…å®¹è¥é”€' || sceneCapabilities.sceneName === 'çº¿ç´¢æ¨å¹¿')
                            && (key === 'launchPeriodList' || key === 'launchAreaStrList')) return;
                        delete merged.campaign[key];
                    });
                } else if (sceneCapabilities.sceneName !== 'äººç¾¤æ¨å¹¿') {
                    // æ— å¯ç”¨æ¨¡æ¿æ—¶ï¼Œä¿å®ˆç§»é™¤é«˜é¢‘æŠ¥é”™å­—æ®µã€‚
                    delete merged.campaign.bidTypeV2;
                    delete merged.campaign.adzoneList;
                    delete merged.campaign.crowdList;
                    if (sceneCapabilities.sceneName !== 'å†…å®¹è¥é”€' && sceneCapabilities.sceneName !== 'çº¿ç´¢æ¨å¹¿') {
                        delete merged.campaign.launchAreaStrList;
                        delete merged.campaign.launchPeriodList;
                    }
                }
            }

            return {
                solution: {
                    bizCode: runtimeForScene.bizCode,
                    campaign: merged.campaign,
                    adgroupList: [merged.adgroup]
                },
                meta: {
                    planName: plan.planName,
                    item: hasItem ? item : null,
                    marketingGoal: resolvedMarketingGoal,
                    goalFallbackUsed: !!goalResolution?.goalFallbackUsed,
                    goalWarnings: Array.isArray(goalResolution?.goalWarnings) ? goalResolution.goalWarnings.slice(0, 20) : [],
                    submitEndpoint,
                    keywordCount: keywordBundle.wordList.length,
                    wordPackageCount: keywordBundle.wordPackageList.length,
                    mode: keywordBundle.mode,
                    bidMode: isKeywordScene ? planBidMode : '',
                    bidTypeV2: merged?.campaign?.bidTypeV2 || merged?.campaign?.bidType || '',
                    bidTargetV2: merged?.campaign?.bidTargetV2 || '',
                    isKeywordScene,
                    fallbackTriggered: false
                }
            };
        };

        const emitProgress = (options, event, payload = {}) => {
            if (typeof options?.onProgress !== 'function') return;
            try {
                options.onProgress({ event, ...payload });
            } catch { }
        };

        const summarizeServerErrors = (res = {}) => {
            const detailList = Array.isArray(res?.data?.errorDetails) ? res.data.errorDetails : [];
            if (detailList.length) {
                return detailList
                    .map(detail => `${detail?.code || 'ERROR'}ï¼š${detail?.msg || 'æœªçŸ¥é”™è¯¯'}`)
                    .join('ï¼›');
            }
            return res?.info?.message || res?.message || '';
        };

        const parseAddListOutcome = (res, entries = []) => {
            const createdList = Array.isArray(res?.data?.list) ? res.data.list : [];
            const detailList = Array.isArray(res?.data?.errorDetails) ? res.data.errorDetails : [];
            const globalError = summarizeServerErrors(res);
            const successes = [];
            const failures = [];
            const failedEntries = [];

            entries.forEach((entry, idx) => {
                const created = createdList[idx] || {};
                const detail = detailList[idx] || (detailList.length === 1 ? detailList[0] : null);
                const campaignId = created?.campaignId || null;
                if (campaignId) {
                    successes.push({
                        planName: entry.meta.planName,
                        item: entry.meta.item,
                        campaignId,
                        adgroupIdList: created.adgroupIdList || [],
                        marketingGoal: entry?.meta?.marketingGoal || '',
                        submitEndpoint: entry?.meta?.submitEndpoint || '',
                        keywordCount: entry.meta.keywordCount,
                        wordPackageCount: entry.meta.wordPackageCount,
                        mode: entry.meta.mode,
                        bidMode: entry.meta.bidMode || ''
                    });
                    return;
                }

                const detailCode = detail?.code || '';
                const detailMsg = detail?.msg || '';
                const error = created?.errorMsg
                    || (detailCode || detailMsg ? `${detailCode || 'ERROR'}ï¼š${detailMsg || 'æœåŠ¡ç«¯è¿”å›å¤±è´¥'}` : '')
                    || globalError
                    || 'æœåŠ¡ç«¯æœªè¿”å› campaignId';
                failures.push({
                    planName: entry.meta.planName,
                    item: entry.meta.item,
                    error,
                    response: created,
                    code: detailCode || '',
                    detail: isPlainObject(detail?.result) ? deepClone(detail.result) : (detail?.result || null),
                    fullResponse: isPlainObject(res) ? deepClone(res) : null
                });
                failedEntries.push({
                    ...entry,
                    lastError: error,
                    meta: {
                        ...(entry.meta || {}),
                        lastError: error,
                        lastErrorCode: detailCode || '',
                        lastErrorDetail: isPlainObject(detail?.result) ? deepClone(detail.result) : (detail?.result || null),
                        lastErrorResponse: isPlainObject(res) ? deepClone(res) : null
                    }
                });
            });

            return { successes, failures, failedEntries };
        };

        const validate = (request, options = {}) => {
            const result = { ok: true, errors: [], warnings: [] };
            if (!isPlainObject(request)) {
                result.ok = false;
                result.errors.push('è¯·æ±‚ä½“å¿…é¡»æ˜¯å¯¹è±¡');
                return result;
            }
            const sceneName = String(request?.sceneName || '').trim();
            const requiresItem = (options?.requiresItem === true || options?.requiresItem === false)
                ? !!options.requiresItem
                : isSceneLikelyRequireItem(sceneName);
            if (request.plans !== undefined && !Array.isArray(request.plans)) {
                result.ok = false;
                result.errors.push('plans å¿…é¡»æ˜¯æ•°ç»„');
            }
            if (Array.isArray(request.plans) && request.plans.length > 0) {
                request.plans.forEach((plan, idx) => {
                    if (!plan || typeof plan !== 'object') {
                        result.ok = false;
                        result.errors.push(`plans[${idx}] éæ³•`);
                        return;
                    }
                    if (!plan.planName) {
                        result.warnings.push(`plans[${idx}] æœªæä¾› planNameï¼Œå°†è‡ªåŠ¨ç”Ÿæˆ`);
                    }
                    if (!plan.item && !plan.itemId) {
                        if (requiresItem) {
                            result.warnings.push(`plans[${idx}] æœªæä¾› itemï¼Œå°†å°è¯•ä»é¡µé¢å·²æ·»åŠ å•†å“è¡¥é½`);
                        }
                    }
                });
            } else {
                if (requiresItem) {
                    result.warnings.push('æœªæ˜¾å¼æä¾› plansï¼Œå°†å°è¯•è¯»å–å½“å‰å·²æ·»åŠ å•†å“è‡ªåŠ¨ç”Ÿæˆè®¡åˆ’');
                } else {
                    result.warnings.push('æœªæ˜¾å¼æä¾› plansï¼Œå°†æŒ‰åœºæ™¯è‡ªåŠ¨ç”Ÿæˆè®¡åˆ’ï¼ˆé»˜è®¤ 1 ä¸ªï¼Œå¯é€šè¿‡ planCount æŒ‡å®šï¼‰');
                }
            }
            return result;
        };

        const normalizeSceneSettingsObject = (sceneSettings = {}) => {
            if (!isPlainObject(sceneSettings)) return {};
            const out = {};
            Object.keys(sceneSettings).forEach(key => {
                const normalizedKey = normalizeText(key).replace(/[ï¼š:]/g, '').trim();
                if (!normalizedKey) return;
                out[normalizedKey] = normalizeSceneSettingValue(sceneSettings[key]);
            });
            return out;
        };

        const mergeSceneSettingsDefaults = ({
            sceneName = '',
            targetSettings = {},
            spec = null,
            runtime = {}
        }) => {
            const filledDefaults = [];
            const warnings = [];
            const merged = normalizeSceneSettingsObject(targetSettings);
            const applyDefault = (key, value, source) => {
                const normalizedKey = normalizeText(key).replace(/[ï¼š:]/g, '').trim();
                const normalizedValue = normalizeSceneSettingValue(value);
                if (!normalizedKey || !normalizedValue) return;
                if (/^è®¡åˆ’åç§°$|^è®¡åˆ’å$/.test(normalizedKey)) return;
                if (normalizeSceneSettingValue(merged[normalizedKey]) !== '') return;
                merged[normalizedKey] = normalizedValue;
                filledDefaults.push({
                    key: normalizedKey,
                    value: normalizedValue,
                    source
                });
            };

            const specFields = Array.isArray(spec?.fields) ? spec.fields : [];
            specFields.forEach(field => {
                const settingKey = normalizeText(field?.settingKey || field?.label || '').replace(/[ï¼š:]/g, '').trim();
                if (!settingKey) return;
                const defaultValue = normalizeSceneSettingValue(field?.defaultValue || '');
                if (defaultValue) applyDefault(settingKey, defaultValue, 'scene_spec');
            });

            const templateDefaults = deriveTemplateSceneSettings(runtime);
            Object.keys(templateDefaults).forEach(key => {
                applyDefault(key, templateDefaults[key], 'runtime_template');
            });

            const fallbackDefaults = isPlainObject(SCENE_SPEC_FIELD_FALLBACK[sceneName]) ? SCENE_SPEC_FIELD_FALLBACK[sceneName] : {};
            Object.keys(fallbackDefaults).forEach(key => {
                applyDefault(key, fallbackDefaults[key], 'scene_fallback');
            });

            const missingCritical = specFields
                .filter(field => field?.requiredGuess)
                .map(field => normalizeText(field?.settingKey || field?.label || '').replace(/[ï¼š:]/g, '').trim())
                .filter(Boolean)
                .filter(key => normalizeSceneSettingValue(merged[key]) === '');
            if (missingCritical.length) {
                warnings.push(`åœºæ™¯ã€Œ${sceneName || 'æœªå‘½å'}ã€ä»ç¼ºå°‘å…³é”®å­—æ®µï¼š${missingCritical.slice(0, 12).join('ï¼Œ')}`);
            }

            return {
                sceneSettings: merged,
                filledDefaults,
                warnings,
                missingCritical
            };
        };

        const validateSceneRequest = async (sceneName, request = {}, options = {}) => {
            const targetScene = String(sceneName || request?.sceneName || inferCurrentSceneName() || '').trim();
            if (!targetScene) {
                return {
                    ok: false,
                    sceneName: '',
                    normalizedRequest: mergeDeep({}, request),
                    resolvedMarketingGoal: '',
                    goalFallbackUsed: false,
                    goalWarnings: [],
                    filledDefaults: [],
                    warnings: ['ç¼ºå°‘ sceneNameï¼Œæ— æ³•åšåœºæ™¯çº§æ ¡éªŒ'],
                    missingCritical: ['sceneName']
                };
            }

            let runtime = null;
            try {
                runtime = await getRuntimeDefaults(!!options.forceRuntimeRefresh);
            } catch {
                runtime = {};
            }

            const sceneSpec = await getSceneSpec(targetScene, {
                scanMode: options.scanMode || 'visible',
                unlockPolicy: options.unlockPolicy || 'safe_only',
                goalScan: options.goalScan !== false,
                refresh: !!options.refresh
            });

            const normalizedRequest = mergeDeep({}, request, {
                sceneName: targetScene
            });
            const currentSettings = normalizeSceneSettingsObject(normalizedRequest.sceneSettings || {});
            const defaultsResult = mergeSceneSettingsDefaults({
                sceneName: targetScene,
                targetSettings: currentSettings,
                spec: sceneSpec,
                runtime
            });
            normalizedRequest.sceneSettings = defaultsResult.sceneSettings;

            const sceneBizCode = resolveSceneBizCodeHint(targetScene) || SCENE_BIZCODE_HINT_FALLBACK[targetScene] || '';
            if (!normalizedRequest.bizCode && sceneBizCode) {
                normalizedRequest.bizCode = sceneBizCode;
            }
            const scenePromotionScene = resolveSceneDefaultPromotionScene(targetScene, normalizedRequest.promotionScene || runtime?.promotionScene || '');
            if (!normalizedRequest.promotionScene && scenePromotionScene) {
                normalizedRequest.promotionScene = scenePromotionScene;
            }

            const goalResolution = resolveGoalContextForPlan({
                sceneName: targetScene,
                sceneSpec,
                runtime,
                marketingGoal: normalizedRequest.marketingGoal || normalizedRequest?.common?.marketingGoal || '',
                planName: '',
                planIndex: -1
            });
            if (!isPlainObject(normalizedRequest.common)) {
                normalizedRequest.common = {};
            }
            if (goalResolution.resolvedMarketingGoal) {
                normalizedRequest.marketingGoal = goalResolution.resolvedMarketingGoal;
                if (!normalizedRequest.common.marketingGoal) {
                    normalizedRequest.common.marketingGoal = goalResolution.resolvedMarketingGoal;
                }
            }
            if (goalResolution.endpoint) {
                normalizedRequest.submitEndpoint = normalizeGoalCreateEndpoint(
                    normalizedRequest.submitEndpoint || goalResolution.endpoint
                );
            }
            if (!isPlainObject(normalizedRequest.goalForcedCampaignOverride)) {
                normalizedRequest.goalForcedCampaignOverride = {};
            }
            if (!isPlainObject(normalizedRequest.goalForcedAdgroupOverride)) {
                normalizedRequest.goalForcedAdgroupOverride = {};
            }
            normalizedRequest.goalForcedCampaignOverride = mergeDeep(
                {},
                goalResolution.campaignOverride || {},
                normalizedRequest.goalForcedCampaignOverride || {}
            );
            if (sceneBizCode) {
                const forcedBizCode = normalizeSceneBizCode(normalizedRequest.goalForcedCampaignOverride?.bizCode || '');
                if (forcedBizCode && forcedBizCode !== sceneBizCode) {
                    normalizedRequest.goalForcedCampaignOverride.bizCode = sceneBizCode;
                }
            }
            normalizedRequest.goalForcedAdgroupOverride = mergeDeep(
                {},
                goalResolution.adgroupOverride || {},
                normalizedRequest.goalForcedAdgroupOverride || {}
            );

            const runtimePatch = goalResolution.runtimePatch || {};
            if (!normalizedRequest.bizCode && runtimePatch.bizCode) {
                normalizedRequest.bizCode = runtimePatch.bizCode;
            }
            if (!normalizedRequest.promotionScene && runtimePatch.promotionScene) {
                normalizedRequest.promotionScene = runtimePatch.promotionScene;
            }
            normalizedRequest.__sceneSpec = sceneSpec && sceneSpec.ok ? deepClone(sceneSpec) : null;
            normalizedRequest.__goalResolution = {
                resolvedMarketingGoal: goalResolution.resolvedMarketingGoal || '',
                goalFallbackUsed: !!goalResolution.goalFallbackUsed,
                goalWarnings: goalResolution.goalWarnings || [],
                availableGoals: goalResolution.availableGoalLabels || [],
                goalSpec: goalResolution.goalSpec ? deepClone(goalResolution.goalSpec) : null,
                endpoint: goalResolution.endpoint || '',
                contractHints: isPlainObject(goalResolution.contractHints) ? deepClone(goalResolution.contractHints) : {}
            };

            const passthroughWarnings = [];
            if (isPlainObject(normalizedRequest.rawOverrides)) {
                const knownCampaignKeys = new Set(Object.keys(runtime?.solutionTemplate?.campaign || {}));
                const rawCampaign = isPlainObject(normalizedRequest.rawOverrides.campaign)
                    ? normalizedRequest.rawOverrides.campaign
                    : normalizedRequest.rawOverrides;
                Object.keys(rawCampaign || {}).forEach(key => {
                    if (!knownCampaignKeys.size || knownCampaignKeys.has(key)) return;
                    passthroughWarnings.push(`rawOverrides.campaign.${key} éæ¨¡æ¿å­—æ®µï¼ŒæŒ‰é€ä¼ æäº¤`);
                });
            }

            return {
                ok: true,
                sceneName: targetScene,
                normalizedRequest,
                filledDefaults: defaultsResult.filledDefaults,
                resolvedMarketingGoal: goalResolution.resolvedMarketingGoal || '',
                goalFallbackUsed: !!goalResolution.goalFallbackUsed,
                goalWarnings: goalResolution.goalWarnings || [],
                warnings: defaultsResult.warnings.concat(goalResolution.goalWarnings || [], passthroughWarnings),
                missingCritical: defaultsResult.missingCritical,
                sceneSpecMeta: {
                    ok: !!sceneSpec?.ok,
                    sceneName: sceneSpec?.sceneName || targetScene,
                    fieldCount: sceneSpec?.coverage?.fieldCount || 0,
                    goalCount: sceneSpec?.coverage?.goalCount || sceneSpec?.goalCoverage?.goalCount || 0,
                    snapshotCount: sceneSpec?.coverage?.snapshotCount || 0,
                    scanMode: sceneSpec?.scanMode || options.scanMode || 'visible'
                },
                sceneSpec: sceneSpec?.ok ? deepClone(sceneSpec) : null
            };
        };

        const createPlansBatch = async (request = {}, options = {}) => {
            const validation = validate(request, {
                requiresItem: isSceneLikelyRequireItem(String(request?.sceneName || '').trim())
            });
            if (!validation.ok) {
                return { ok: false, partial: false, validation, successCount: 0, failCount: 0, successes: [], failures: [] };
            }

            const mergedRequest = mergeDeep({}, request);
            const fallbackPolicy = normalizeFallbackPolicy(
                options?.fallbackPolicy || mergedRequest?.fallbackPolicy || 'confirm',
                'confirm'
            );
            const conflictPolicy = String(
                options?.conflictPolicy
                || mergedRequest?.conflictPolicy
                || REPAIR_DEFAULTS.conflictPolicy
                || 'auto_stop_retry'
            ).trim() || 'auto_stop_retry';
            const stopScope = String(
                options?.stopScope
                || mergedRequest?.stopScope
                || REPAIR_DEFAULTS.stopScope
                || 'same_item_only'
            ).trim() || 'same_item_only';
            mergedRequest.fallbackPolicy = fallbackPolicy;
            if (!isPlainObject(mergedRequest.common)) {
                mergedRequest.common = {};
            }
            if (!isPlainObject(mergedRequest.sceneSettings)) {
                mergedRequest.sceneSettings = {};
            }
            const settingEntriesForGoal = normalizeSceneSettingEntries(mergedRequest.sceneSettings);
            const settingGoalEntry = findSceneSettingEntry(settingEntriesForGoal, [/è¥é”€ç›®æ ‡/, /ä¼˜åŒ–ç›®æ ‡/]);
            const settingGoalLabel = normalizeGoalLabel(settingGoalEntry?.value || '');
            if (settingGoalLabel) {
                if (!normalizeGoalLabel(mergedRequest.marketingGoal || '')) {
                    mergedRequest.marketingGoal = settingGoalLabel;
                }
                if (!normalizeGoalLabel(mergedRequest?.common?.marketingGoal || '')) {
                    mergedRequest.common.marketingGoal = settingGoalLabel;
                }
            }
            mergedRequest.common.bidMode = normalizeBidMode(
                mergedRequest?.common?.bidMode
                    || mergedRequest?.bidMode
                    || mergedRequest?.bidTypeV2
                    || DEFAULTS.bidTypeV2,
                'smart'
            );
            const requestedSceneName = String(mergedRequest.sceneName || '').trim();
            const expectedSceneBizCode = normalizeSceneBizCode(resolveSceneBizCodeHint(requestedSceneName));
            if (!mergedRequest.bizCode && expectedSceneBizCode) {
                mergedRequest.bizCode = expectedSceneBizCode;
            } else if (mergedRequest.bizCode) {
                mergedRequest.bizCode = normalizeSceneBizCode(mergedRequest.bizCode);
            }

            let runtime = await getRuntimeDefaults(!!options.forceRuntimeRefresh);
            const requireTemplateForScene = options.requireSceneTemplate === true
                && requestedSceneName
                && requestedSceneName !== 'å…³é”®è¯æ¨å¹¿';
            const isRuntimeTemplateReadyForScene = (runtimeRef = {}) => {
                if (!requireTemplateForScene) return true;
                const hasTemplateCampaign = isPlainObject(runtimeRef?.solutionTemplate?.campaign)
                    && Object.keys(runtimeRef.solutionTemplate.campaign).length > 0;
                if (!hasTemplateCampaign) return false;
                const templateBizCode = normalizeSceneBizCode(runtimeRef?.solutionTemplate?.bizCode || '');
                if (!expectedSceneBizCode || !templateBizCode) return true;
                return templateBizCode === expectedSceneBizCode;
            };
            const isSceneRuntimeReady = (runtimeRef = {}) => (
                isRuntimeBizCodeMatched(runtimeRef, expectedSceneBizCode, {
                    includeRoute: !requireTemplateForScene
                })
                && isRuntimeTemplateReadyForScene(runtimeRef)
            );
            const shouldSyncSceneRuntime = options.syncSceneRuntime === true;
            const strictSceneRuntimeMatch = options.strictSceneRuntimeMatch === true;
            if (shouldSyncSceneRuntime
                && requestedSceneName
                && expectedSceneBizCode
                && !isSceneRuntimeReady(runtime)) {
                emitProgress(options, 'scene_runtime_sync_start', {
                    sceneName: requestedSceneName,
                    currentBizCode: resolveRuntimeBizCode(runtime) || '',
                    expectedBizCode: expectedSceneBizCode
                });
                try {
                    const syncOptions = options.sceneSyncOptions || {};
                    const sceneSyncRetry = Math.max(3, toNumber(
                        syncOptions.retry,
                        toNumber(options.sceneSyncRetry, 8)
                    ));
                    const sceneSyncIntervalMs = Math.max(240, toNumber(
                        syncOptions.retryIntervalMs,
                        toNumber(options.sceneSyncIntervalMs, 420)
                    ));
                    await ensureSceneRoute(requestedSceneName, syncOptions);
                    await waitForDomStable(syncOptions);
                    let syncedRuntime = null;
                    for (let attempt = 0; attempt < sceneSyncRetry; attempt++) {
                        syncedRuntime = await getRuntimeDefaults(true);
                        if (!expectedSceneBizCode || isSceneRuntimeReady(syncedRuntime)) break;
                        await sleep(sceneSyncIntervalMs);
                    }
                    runtime = syncedRuntime || runtime;
                    const syncedBizCode = resolveRuntimeBizCode(runtime) || '';
                    emitProgress(options, 'scene_runtime_synced', {
                        sceneName: requestedSceneName,
                        currentBizCode: syncedBizCode,
                        expectedBizCode: expectedSceneBizCode,
                        matched: isSceneRuntimeReady(runtime),
                        templateReady: isRuntimeTemplateReadyForScene(runtime),
                        templateBizCode: normalizeSceneBizCode(runtime?.solutionTemplate?.bizCode || '')
                    });
                } catch (err) {
                    emitProgress(options, 'scene_runtime_sync_failed', {
                        sceneName: requestedSceneName,
                        currentBizCode: resolveRuntimeBizCode(runtime) || '',
                        expectedBizCode: expectedSceneBizCode,
                        error: err?.message || String(err)
                    });
                }
            }
            const sceneRuntimeMismatch = !!(
                requestedSceneName
                && expectedSceneBizCode
                && !isRuntimeBizCodeMatched(runtime, expectedSceneBizCode, {
                    includeRoute: !requireTemplateForScene
                })
            );
            if (sceneRuntimeMismatch && strictSceneRuntimeMatch) {
                const currentRuntimeBizCode = resolveRuntimeBizCode(runtime) || '';
                emitProgress(options, 'scene_runtime_sync_abort', {
                    sceneName: requestedSceneName,
                    currentBizCode: currentRuntimeBizCode,
                    expectedBizCode: expectedSceneBizCode
                });
                return {
                    ok: false,
                    partial: false,
                    validation,
                    successCount: 0,
                    failCount: 1,
                    successes: [],
                    failures: [{
                        error: `åœºæ™¯è¿è¡Œæ—¶åŒæ­¥å¤±è´¥ï¼šå½“å‰ ${currentRuntimeBizCode || 'unknown'}ï¼ŒæœŸæœ› ${expectedSceneBizCode}ï¼ˆ${requestedSceneName}ï¼‰`
                    }]
                };
            }
            if (sceneRuntimeMismatch && !strictSceneRuntimeMatch) {
                emitProgress(options, 'scene_runtime_sync_bypass', {
                    sceneName: requestedSceneName,
                    currentBizCode: resolveRuntimeBizCode(runtime) || '',
                    expectedBizCode: expectedSceneBizCode
                });
            }

            const runtimeTemplateBizCode = normalizeSceneBizCode(runtime?.solutionTemplate?.bizCode || '');
            if (requireTemplateForScene && !isRuntimeTemplateReadyForScene(runtime)) {
                const currentRuntimeBizCode = resolveRuntimeBizCode(runtime) || '';
                emitProgress(options, 'scene_runtime_sync_abort', {
                    sceneName: requestedSceneName,
                    currentBizCode: currentRuntimeBizCode,
                    expectedBizCode: expectedSceneBizCode,
                    error: `åœºæ™¯è¿è¡Œæ—¶æ¨¡æ¿æœªå°±ç»ªï¼šå½“å‰æ¨¡æ¿ ${runtimeTemplateBizCode || 'unknown'}ï¼ŒæœŸæœ› ${expectedSceneBizCode}`
                });
                return {
                    ok: false,
                    partial: false,
                    validation,
                    successCount: 0,
                    failCount: 1,
                    successes: [],
                    failures: [{
                        error: `åœºæ™¯è¿è¡Œæ—¶æ¨¡æ¿æœªå°±ç»ªï¼šå½“å‰æ¨¡æ¿ ${runtimeTemplateBizCode || 'unknown'}ï¼ŒæœŸæœ› ${expectedSceneBizCode}ï¼ˆ${requestedSceneName}ï¼‰`
                    }]
                };
            }

            const sceneNameHint = mergedRequest.sceneName || requestedSceneName || '';
            const useKeywordDefaults = sceneNameHint === 'å…³é”®è¯æ¨å¹¿';
            runtime.bizCode = normalizeSceneBizCode(mergedRequest.bizCode || runtime.bizCode || DEFAULTS.bizCode);
            runtime.promotionScene = mergedRequest.promotionScene || runtime.promotionScene || (useKeywordDefaults ? DEFAULTS.promotionScene : '');
            runtime.itemSelectedMode = mergedRequest.itemSelectedMode || runtime.itemSelectedMode || (useKeywordDefaults ? DEFAULTS.itemSelectedMode : '');
            runtime.bidTypeV2 = mergedRequest.bidTypeV2 || runtime.bidTypeV2 || (useKeywordDefaults ? DEFAULTS.bidTypeV2 : '');
            runtime.bidTargetV2 = mergedRequest.bidTargetV2 || runtime.bidTargetV2 || (useKeywordDefaults ? DEFAULTS.bidTargetV2 : '');
            if (!useKeywordDefaults) {
                if (!mergedRequest.bidTypeV2) runtime.bidTypeV2 = '';
                if (!mergedRequest.bidTargetV2) runtime.bidTargetV2 = '';
            }
            runtime.dmcType = mergedRequest.dmcType || runtime.dmcType || DEFAULTS.dmcType;
            if (!mergedRequest.sceneName) {
                const inferredSceneName = inferCurrentSceneName();
                if (SCENE_NAME_LIST.includes(inferredSceneName)) {
                    mergedRequest.sceneName = inferredSceneName;
                }
            }
            const sceneNameForRuntime = mergedRequest.sceneName || requestedSceneName || '';
            let sceneSpecForGoal = isPlainObject(mergedRequest.__sceneSpec) ? mergedRequest.__sceneSpec : null;
            if ((!sceneSpecForGoal || !Array.isArray(sceneSpecForGoal?.goals))
                && sceneNameForRuntime
                && options.applySceneSpec === true) {
                try {
                    sceneSpecForGoal = await getSceneSpec(sceneNameForRuntime, {
                        scanMode: options.goalScanMode || options.scanMode || 'visible',
                        unlockPolicy: options.goalUnlockPolicy || options.unlockPolicy || 'safe_only',
                        goalScan: options.goalScan !== false,
                        refresh: !!options.refreshSceneSpec
                    });
                } catch { }
            }

            const requestGoalContext = resolveGoalContextForPlan({
                sceneName: sceneNameForRuntime,
                sceneSpec: sceneSpecForGoal,
                runtime,
                marketingGoal: mergedRequest.marketingGoal || mergedRequest?.common?.marketingGoal || mergedRequest?.__goalResolution?.resolvedMarketingGoal || '',
                planName: '',
                planIndex: -1
            });
            if (requestGoalContext.goalWarnings.length) {
                emitProgress(options, 'goal_resolution_warning', {
                    sceneName: sceneNameForRuntime,
                    resolvedMarketingGoal: requestGoalContext.resolvedMarketingGoal || '',
                    goalFallbackUsed: !!requestGoalContext.goalFallbackUsed,
                    warnings: requestGoalContext.goalWarnings.slice(0, 20)
                });
            }
            mergedRequest.__goalResolution = {
                resolvedMarketingGoal: requestGoalContext.resolvedMarketingGoal || '',
                goalFallbackUsed: !!requestGoalContext.goalFallbackUsed,
                goalWarnings: requestGoalContext.goalWarnings || [],
                availableGoals: requestGoalContext.availableGoalLabels || [],
                goalSpec: requestGoalContext.goalSpec ? deepClone(requestGoalContext.goalSpec) : null,
                endpoint: requestGoalContext.endpoint || ''
            };
            if (requestGoalContext.resolvedMarketingGoal) {
                mergedRequest.marketingGoal = requestGoalContext.resolvedMarketingGoal;
                mergedRequest.common.marketingGoal = mergedRequest.common.marketingGoal || requestGoalContext.resolvedMarketingGoal;
            }
            mergedRequest.submitEndpoint = normalizeGoalCreateEndpoint(
                mergedRequest.submitEndpoint
                || requestGoalContext.endpoint
                || SCENE_CREATE_ENDPOINT_FALLBACK
            );
            mergedRequest.goalForcedCampaignOverride = mergeDeep(
                {},
                requestGoalContext.campaignOverride || {},
                mergedRequest.goalForcedCampaignOverride || {}
            );
            if (expectedSceneBizCode) {
                const forcedBizCode = normalizeSceneBizCode(mergedRequest.goalForcedCampaignOverride?.bizCode || '');
                if (forcedBizCode && forcedBizCode !== expectedSceneBizCode) {
                    mergedRequest.goalForcedCampaignOverride.bizCode = expectedSceneBizCode;
                }
            }
            const sceneKeepBidTypeV2 = SCENE_BIDTYPE_V2_ONLY.has(sceneNameForRuntime);
            if (!sceneKeepBidTypeV2) {
                delete mergedRequest.goalForcedCampaignOverride.bidTypeV2;
                delete mergedRequest.goalForcedCampaignOverride.bidTargetV2;
                delete mergedRequest.goalForcedCampaignOverride.optimizeTarget;
            }
            mergedRequest.goalForcedAdgroupOverride = mergeDeep(
                {},
                requestGoalContext.adgroupOverride || {},
                mergedRequest.goalForcedAdgroupOverride || {}
            );
            runtime = mergeRuntimeWithGoalPatch(runtime, requestGoalContext.runtimePatch || {});
            if (expectedSceneBizCode) {
                runtime.bizCode = expectedSceneBizCode;
            }
            if (!sceneKeepBidTypeV2) {
                if (!mergedRequest.bidTypeV2) runtime.bidTypeV2 = '';
                if (!mergedRequest.bidTargetV2) runtime.bidTargetV2 = '';
                if (!mergedRequest.optimizeTarget && !mergedRequest?.common?.campaignOverride?.optimizeTarget) {
                    runtime.optimizeTarget = '';
                }
            }

            const keywordGoalRuntimeAtRequest = sceneNameForRuntime === 'å…³é”®è¯æ¨å¹¿'
                ? resolveKeywordGoalRuntimeFallback(
                    mergedRequest.marketingGoal
                    || mergedRequest?.common?.marketingGoal
                    || settingGoalLabel
                    || ''
                )
                : {};
            const forcedPromotionScene = sceneNameForRuntime === 'å…³é”®è¯æ¨å¹¿'
                ? String(
                    mergedRequest?.goalForcedCampaignOverride?.promotionScene
                    || mergedRequest.promotionScene
                    || runtime.promotionScene
                    || keywordGoalRuntimeAtRequest?.promotionScene
                    || resolveSceneDefaultPromotionScene(sceneNameForRuntime, '')
                ).trim()
                : resolveSceneDefaultPromotionScene(sceneNameForRuntime, '');
            if (forcedPromotionScene) {
                mergedRequest.promotionScene = forcedPromotionScene;
                runtime.promotionScene = forcedPromotionScene;
            }
            if (sceneNameForRuntime === 'å…³é”®è¯æ¨å¹¿') {
                const forcedItemSelectedMode = String(
                    mergedRequest?.goalForcedCampaignOverride?.itemSelectedMode
                    || mergedRequest.itemSelectedMode
                    || runtime.itemSelectedMode
                    || keywordGoalRuntimeAtRequest?.itemSelectedMode
                    || DEFAULTS.itemSelectedMode
                ).trim();
                mergedRequest.itemSelectedMode = forcedItemSelectedMode || DEFAULTS.itemSelectedMode;
                runtime.itemSelectedMode = forcedItemSelectedMode || DEFAULTS.itemSelectedMode;
                mergedRequest.common.bidMode = normalizeBidMode(
                    mergedRequest?.common?.bidMode || mergedRequest?.bidMode || mergedRequest?.bidTypeV2 || DEFAULTS.bidTypeV2,
                    'smart'
                );
                runtime.bidTypeV2 = bidModeToBidType(mergedRequest.common.bidMode);
            }

            if (!isPlainObject(mergedRequest.sceneSettings)) {
                mergedRequest.sceneSettings = {};
            }
            const sceneConfigMapping = resolveSceneSettingOverrides({
                sceneName: sceneNameForRuntime,
                sceneSettings: mergedRequest.sceneSettings,
                runtime
            });
            mergedRequest.sceneForcedCampaignOverride = sceneConfigMapping.campaignOverride || {};
            mergedRequest.sceneForcedAdgroupOverride = sceneConfigMapping.adgroupOverride || {};

            const mappedCampaignOverride = mergeDeep(
                {},
                sceneConfigMapping.campaignOverride || {},
                mergedRequest?.common?.campaignOverride || {}
            );
            if (sceneNameForRuntime === 'å…³é”®è¯æ¨å¹¿') {
                const keywordGoalRuntime = resolveKeywordGoalRuntimeFallback(
                    mergedRequest.marketingGoal
                    || mergedRequest?.common?.marketingGoal
                    || settingGoalLabel
                    || ''
                );
                const keywordPromotionScene = String(
                    mappedCampaignOverride.promotionScene
                    || mergedRequest?.goalForcedCampaignOverride?.promotionScene
                    || mergedRequest.promotionScene
                    || runtime.promotionScene
                    || keywordGoalRuntime?.promotionScene
                    || resolveSceneDefaultPromotionScene(sceneNameForRuntime, '')
                ).trim();
                if (keywordPromotionScene) {
                    mergedRequest.promotionScene = keywordPromotionScene;
                    runtime.promotionScene = keywordPromotionScene;
                }
                const keywordItemSelectedMode = String(
                    mappedCampaignOverride.itemSelectedMode
                    || mergedRequest?.goalForcedCampaignOverride?.itemSelectedMode
                    || mergedRequest.itemSelectedMode
                    || runtime.itemSelectedMode
                    || keywordGoalRuntime?.itemSelectedMode
                    || DEFAULTS.itemSelectedMode
                ).trim();
                if (keywordItemSelectedMode) {
                    mergedRequest.itemSelectedMode = keywordItemSelectedMode;
                    runtime.itemSelectedMode = keywordItemSelectedMode;
                }
            }
            runtime.bidTypeV2 = mappedCampaignOverride.bidTypeV2
                || mergedRequest.bidTypeV2
                || runtime.bidTypeV2
                || SCENE_BIDTYPE_V2_DEFAULT[sceneNameForRuntime]
                || '';
            runtime.bidTargetV2 = mappedCampaignOverride.bidTargetV2
                || mappedCampaignOverride.optimizeTarget
                || mergedRequest.bidTargetV2
                || runtime.bidTargetV2
                || (sceneNameForRuntime === 'å…³é”®è¯æ¨å¹¿' ? DEFAULTS.bidTargetV2 : '');
            if (!sceneKeepBidTypeV2) {
                if (!mergedRequest.bidTypeV2 && !mappedCampaignOverride.bidTypeV2) {
                    runtime.bidTypeV2 = '';
                }
                if (!mergedRequest.bidTargetV2 && !mappedCampaignOverride.bidTargetV2 && !mappedCampaignOverride.optimizeTarget) {
                    runtime.bidTargetV2 = '';
                }
            }
            runtime.dmcType = mappedCampaignOverride.dmcType
                || mergedRequest.dmcType
                || runtime.dmcType
                || DEFAULTS.dmcType;

            const sceneCapabilities = resolveSceneCapabilities({
                sceneName: mergedRequest.sceneName || requestedSceneName,
                runtime,
                request: mergedRequest
            });
            const inputPlans = Array.isArray(mergedRequest.plans) ? mergedRequest.plans : [];
            const hasPlansWithoutItem = inputPlans.some(plan => isPlainObject(plan) && !plan.item && !plan.itemId);
            const shouldResolvePreferredItems = sceneCapabilities.requiresItem || !!mergedRequest.itemSearch || hasPlansWithoutItem;

            emitProgress(options, 'resolve_items_start', {
                sceneName: sceneCapabilities.sceneName,
                requiresItem: sceneCapabilities.requiresItem,
                resolvePreferredItems: shouldResolvePreferredItems
            });
            const preferredItems = shouldResolvePreferredItems
                ? await resolvePreferredItems(mergedRequest, runtime)
                : [];
            let plans = normalizePlans(mergedRequest, preferredItems, {
                requiresItem: sceneCapabilities.requiresItem
            });
            const planGoalWarnings = [];
            plans = plans.map((plan, idx) => {
                const goalContext = resolveGoalContextForPlan({
                    sceneName: sceneCapabilities.sceneName || sceneNameForRuntime,
                    sceneSpec: sceneSpecForGoal,
                    runtime,
                    marketingGoal: plan?.marketingGoal || mergedRequest.marketingGoal || mergedRequest?.common?.marketingGoal || '',
                    planName: plan?.planName || '',
                    planIndex: idx
                });
                if (goalContext.goalWarnings.length) {
                    planGoalWarnings.push(...goalContext.goalWarnings);
                }
                const planGoalCampaignOverride = mergeDeep(
                    {},
                    goalContext.campaignOverride || {},
                    plan?.goalForcedCampaignOverride || {}
                );
                if (expectedSceneBizCode) {
                    const forcedBizCode = normalizeSceneBizCode(planGoalCampaignOverride?.bizCode || '');
                    if (forcedBizCode && forcedBizCode !== expectedSceneBizCode) {
                        planGoalCampaignOverride.bizCode = expectedSceneBizCode;
                    }
                }
                if (!sceneKeepBidTypeV2) {
                    delete planGoalCampaignOverride.bidTypeV2;
                    delete planGoalCampaignOverride.bidTargetV2;
                    delete planGoalCampaignOverride.optimizeTarget;
                }
                return {
                    ...plan,
                    marketingGoal: goalContext.resolvedMarketingGoal || normalizeGoalLabel(plan?.marketingGoal || mergedRequest.marketingGoal || ''),
                    goalForcedCampaignOverride: planGoalCampaignOverride,
                    goalForcedAdgroupOverride: mergeDeep(
                        {},
                        goalContext.adgroupOverride || {},
                        plan?.goalForcedAdgroupOverride || {}
                    ),
                    submitEndpoint: normalizeGoalCreateEndpoint(
                        plan?.submitEndpoint
                        || goalContext.endpoint
                        || mergedRequest.submitEndpoint
                        || SCENE_CREATE_ENDPOINT_FALLBACK
                    ),
                    __goalResolution: {
                        resolvedMarketingGoal: goalContext.resolvedMarketingGoal || '',
                        goalFallbackUsed: !!goalContext.goalFallbackUsed,
                        goalWarnings: goalContext.goalWarnings || [],
                        availableGoals: goalContext.availableGoalLabels || [],
                        goalSpec: goalContext.goalSpec ? deepClone(goalContext.goalSpec) : null,
                        endpoint: goalContext.endpoint || ''
                    }
                };
            });
            if (planGoalWarnings.length) {
                emitProgress(options, 'goal_resolution_warning', {
                    sceneName: sceneCapabilities.sceneName || sceneNameForRuntime,
                    resolvedMarketingGoal: mergedRequest.marketingGoal || '',
                    goalFallbackUsed: false,
                    warnings: uniqueBy(planGoalWarnings, item => item).slice(0, 50)
                });
            }
            const forcedDmcType = mappedCampaignOverride.dmcType || '';
            if (forcedDmcType) {
                const targetBudgetField = DMC_BUDGET_FIELD_MAP[forcedDmcType] || 'dayAverageBudget';
                plans.forEach(plan => {
                    if (!isPlainObject(plan?.budget)) return;
                    let budgetValue = NaN;
                    BUDGET_FIELDS.forEach(field => {
                        if (Number.isFinite(budgetValue) && budgetValue > 0) return;
                        if (plan.budget[field] === undefined || plan.budget[field] === null || plan.budget[field] === '') return;
                        budgetValue = toNumber(plan.budget[field], NaN);
                    });
                    if (!Number.isFinite(budgetValue) || budgetValue <= 0) return;
                    plan.budget = { [targetBudgetField]: budgetValue };
                });
            }
            if (!plans.length) {
                return {
                    ok: false,
                    partial: false,
                    validation,
                    successCount: 0,
                    failCount: 1,
                    successes: [],
                    failures: [{
                        error: sceneCapabilities.requiresItem
                            ? 'æœªæ‰¾åˆ°å¯ç”¨å•†å“ï¼Œè¯·å…ˆæ·»åŠ å•†å“æˆ–æä¾› plans/itemSearch'
                            : 'æœªç”Ÿæˆå¯æäº¤è®¡åˆ’ï¼Œè¯·æ£€æŸ¥ plans æˆ– planCount å‚æ•°'
                    }]
                };
            }

            emitProgress(options, 'build_solution_start', { planCount: plans.length });
            const builtList = [];
            for (let i = 0; i < plans.length; i++) {
                const plan = plans[i];
                emitProgress(options, 'build_solution_item', { index: i + 1, total: plans.length, planName: plan.planName });
                const built = await buildSolutionFromPlan({
                    plan,
                    request: mergedRequest,
                    runtime,
                    requestOptions: options.requestOptions || {}
                });
                builtList.push(built);
            }
            if (builtList.length) {
                const sample = builtList[0]?.solution || {};
                const sampleMeta = builtList[0]?.meta || {};
                const sampleCampaign = isPlainObject(sample.campaign) ? sample.campaign : {};
                const sampleAdgroup = isPlainObject(sample.adgroupList?.[0]) ? sample.adgroupList[0] : {};
                emitProgress(options, 'submit_payload_snapshot', {
                    sceneName: mergedRequest.sceneName || '',
                    marketingGoal: sampleMeta?.marketingGoal || mergedRequest.marketingGoal || '',
                    promotionScene: sampleCampaign.promotionScene || runtime.promotionScene || '',
                    bidTypeV2: sampleCampaign.bidTypeV2 || '',
                    bidTargetV2: sampleCampaign.bidTargetV2 || '',
                    optimizeTarget: sampleCampaign.optimizeTarget || '',
                    bidMode: sampleMeta?.bidMode || '',
                    submitEndpoint: sampleMeta?.submitEndpoint || mergedRequest.submitEndpoint || SCENE_CREATE_ENDPOINT_FALLBACK,
                    materialId: sampleAdgroup?.material?.materialId || '',
                    wordListCount: Array.isArray(sampleAdgroup?.wordList) ? sampleAdgroup.wordList.length : 0,
                    wordPackageCount: Array.isArray(sampleAdgroup?.wordPackageList) ? sampleAdgroup.wordPackageList.length : 0,
                    fallbackTriggered: !!sampleMeta?.fallbackTriggered,
                    goalFallbackUsed: !!sampleMeta?.goalFallbackUsed,
                    campaignKeys: Object.keys(sampleCampaign).slice(0, 80),
                    adgroupKeys: Object.keys(sampleAdgroup).slice(0, 80)
                });
            }
            if (options.dryRunOnly === true) {
                const sampleEntry = builtList[0] || {};
                const sampleSolution = sampleEntry?.solution || {};
                const sampleCampaign = isPlainObject(sampleSolution.campaign) ? deepClone(sampleSolution.campaign) : {};
                const sampleAdgroup = isPlainObject(sampleSolution.adgroupList?.[0]) ? deepClone(sampleSolution.adgroupList[0]) : {};
                const sampleMeta = isPlainObject(sampleEntry?.meta) ? deepClone(sampleEntry.meta) : {};
                return {
                    ok: true,
                    partial: false,
                    dryRunOnly: true,
                    validation,
                    planCount: builtList.length,
                    successCount: 0,
                    failCount: 0,
                    successes: [],
                    failures: [],
                    submitEndpoint: normalizeGoalCreateEndpoint(
                        sampleMeta?.submitEndpoint
                        || mergedRequest.submitEndpoint
                        || SCENE_CREATE_ENDPOINT_FALLBACK
                    ),
                    submitPayloadSnapshot: {
                        sceneName: mergedRequest.sceneName || '',
                        marketingGoal: sampleMeta?.marketingGoal || mergedRequest.marketingGoal || '',
                        promotionScene: sampleCampaign.promotionScene || runtime.promotionScene || '',
                        bidTypeV2: sampleCampaign.bidTypeV2 || '',
                        bidTargetV2: sampleCampaign.bidTargetV2 || '',
                        optimizeTarget: sampleCampaign.optimizeTarget || '',
                        bidMode: sampleMeta?.bidMode || '',
                        submitEndpoint: normalizeGoalCreateEndpoint(
                            sampleMeta?.submitEndpoint
                            || mergedRequest.submitEndpoint
                            || SCENE_CREATE_ENDPOINT_FALLBACK
                        ),
                        materialId: sampleAdgroup?.material?.materialId || '',
                        wordListCount: Array.isArray(sampleAdgroup?.wordList) ? sampleAdgroup.wordList.length : 0,
                        wordPackageCount: Array.isArray(sampleAdgroup?.wordPackageList) ? sampleAdgroup.wordPackageList.length : 0,
                        fallbackTriggered: !!sampleMeta?.fallbackTriggered,
                        goalFallbackUsed: !!sampleMeta?.goalFallbackUsed,
                        campaignKeys: Object.keys(sampleCampaign).slice(0, 80),
                        adgroupKeys: Object.keys(sampleAdgroup).slice(0, 80)
                    },
                    sample: {
                        campaign: sampleCampaign,
                        adgroup: sampleAdgroup,
                        meta: sampleMeta
                    }
                };
            }

            const chunkSize = Math.max(1, toNumber(options.chunkSize, toNumber(mergedRequest.chunkSize, DEFAULTS.chunkSize)));
            const batchRetry = Math.max(0, toNumber(options.batchRetry, DEFAULTS.batchRetry));
            const resolveEntrySubmitEndpoint = (entry = {}) => normalizeGoalCreateEndpoint(
                entry?.meta?.submitEndpoint
                || mergedRequest.submitEndpoint
                || SCENE_CREATE_ENDPOINT_FALLBACK
            );
            const groupedBatches = (() => {
                const map = new Map();
                builtList.forEach(entry => {
                    const endpoint = resolveEntrySubmitEndpoint(entry);
                    if (!map.has(endpoint)) map.set(endpoint, []);
                    map.get(endpoint).push(entry);
                });
                const out = [];
                Array.from(map.keys()).forEach(endpoint => {
                    const list = map.get(endpoint) || [];
                    chunk(list, chunkSize).forEach(entries => {
                        out.push({ endpoint, entries });
                    });
                });
                return out;
            })();
            const successes = [];
            const failures = [];
            const rawResponses = [];
            const buildFailureFromEntry = (entry = {}, fallbackError = '') => ({
                planName: entry?.meta?.planName || '',
                item: entry?.meta?.item || null,
                marketingGoal: entry?.meta?.marketingGoal || '',
                submitEndpoint: entry?.meta?.submitEndpoint || '',
                error: String(entry?.lastError || entry?.meta?.lastError || fallbackError || 'æœåŠ¡ç«¯æœªè¿”å› campaignId')
            });

            for (let batchIndex = 0; batchIndex < groupedBatches.length; batchIndex++) {
                const batchPayload = groupedBatches[batchIndex] || {};
                const batchEndpoint = normalizeGoalCreateEndpoint(batchPayload.endpoint || SCENE_CREATE_ENDPOINT_FALLBACK);
                const batch = Array.isArray(batchPayload.entries) ? batchPayload.entries : [];
                emitProgress(options, 'submit_batch_start', {
                    batchIndex: batchIndex + 1,
                    batchTotal: groupedBatches.length,
                    size: batch.length,
                    endpoint: batchEndpoint
                });

                let remainingEntries = batch.slice();
                let batchError = null;
                for (let attempt = 1; attempt <= batchRetry + 1; attempt++) {
                    const solutionList = remainingEntries.map(entry => entry.solution);
                    try {
                        const res = await requestOne(batchEndpoint, runtime.bizCode, {
                            bizCode: runtime.bizCode,
                            solutionList
                        }, options.requestOptions || {});
                        rawResponses.push(res);
                        const outcome = parseAddListOutcome(res, remainingEntries);
                        if (outcome.successes.length) {
                            successes.push(...outcome.successes);
                        }
                        if (!outcome.failures.length) {
                            emitProgress(options, 'submit_batch_success', {
                                batchIndex: batchIndex + 1,
                                createdCount: outcome.successes.length,
                                failedCount: 0,
                                endpoint: batchEndpoint
                            });
                            remainingEntries = [];
                            break;
                        }

                        const errSummary = outcome.failures.map(item => `${item.planName}: ${item.error}`).join('ï¼›');
                        batchError = new Error(errSummary || 'æœåŠ¡ç«¯æœªè¿”å› campaignId');
                        emitProgress(options, 'submit_batch_success', {
                            batchIndex: batchIndex + 1,
                            createdCount: outcome.successes.length,
                            failedCount: outcome.failures.length,
                            endpoint: batchEndpoint,
                            error: batchError.message
                        });

                        if (!outcome.successes.length && attempt < batchRetry + 1) {
                            emitProgress(options, 'submit_batch_retry', {
                                batchIndex: batchIndex + 1,
                                attempt,
                                endpoint: batchEndpoint,
                                error: batchError.message
                            });
                            await sleep(1200);
                            continue;
                        }

                        remainingEntries = outcome.failedEntries;
                        break;
                    } catch (err) {
                        batchError = err;
                        emitProgress(options, 'submit_batch_retry', {
                            batchIndex: batchIndex + 1,
                            attempt,
                            endpoint: batchEndpoint,
                            error: err?.message || String(err)
                        });
                        if (attempt < batchRetry + 1) await sleep(1200);
                    }
                }

                if (!remainingEntries.length) continue;

                const singleRetryEntries = remainingEntries.slice();

                emitProgress(options, 'submit_batch_fallback_single', {
                    batchIndex: batchIndex + 1,
                    endpoint: batchEndpoint,
                    error: batchError?.message || String(batchError),
                    fallbackTriggered: false,
                    fallbackPolicy
                });
                for (const entry of singleRetryEntries) {
                    const entrySceneName = String(sceneCapabilities.sceneName || mergedRequest.sceneName || '').trim();
                    const entryItemId = toPositiveIdText(entry?.meta?.item?.materialId || entry?.meta?.item?.itemId || '');
                    const submitSingleEntry = async () => {
                        const singleEndpoint = resolveEntrySubmitEndpoint(entry);
                        const res = await requestOne(singleEndpoint, runtime.bizCode, {
                            bizCode: runtime.bizCode,
                            solutionList: [entry.solution]
                        }, options.requestOptions || {});
                        rawResponses.push(res);
                        return parseAddListOutcome(res, [entry]);
                    };
                    try {
                        let outcome = await submitSingleEntry();
                        if (outcome.successes.length) {
                            successes.push(...outcome.successes);
                        } else {
                            const primaryFailure = outcome.failures[0] || buildFailureFromEntry(entry, 'single_retry_failed');
                            const classification = classifyCreateFailure(primaryFailure?.error || '');
                            let conflictRetried = false;
                            if (classification === 'conflict' && conflictPolicy === 'auto_stop_retry' && entryItemId) {
                                const conflictText = String(primaryFailure?.error || '').trim();
                                const conflictSceneName = /(onebpsite|å…¨ç«™|site)/i.test(conflictText)
                                    ? 'è´§å“å…¨ç«™æ¨å¹¿'
                                    : (entrySceneName || mergedRequest.sceneName || '');
                                emitProgress(options, 'conflict_resolve_start', {
                                    sceneName: entrySceneName || conflictSceneName || '',
                                    conflictSceneName: conflictSceneName || '',
                                    planName: entry?.meta?.planName || '',
                                    itemId: entryItemId,
                                    error: conflictText
                                });
                                const resolved = await resolveCreateConflicts(primaryFailure, {
                                    sceneName: conflictSceneName || entrySceneName || mergedRequest.sceneName || '',
                                    entrySceneName: entrySceneName || mergedRequest.sceneName || '',
                                    itemId: entryItemId,
                                    bizCode: runtime.bizCode,
                                    requestOptions: options.requestOptions || {},
                                    conflictPolicy,
                                    stopScope,
                                    capture: options.captureConflictLifecycle !== false,
                                    conflictDeleteFallback: options.conflictDeleteFallback !== false,
                                    oneClickConflictResolve: options.oneClickConflictResolve !== false
                                });
                                emitProgress(options, 'conflict_resolve_done', {
                                    sceneName: entrySceneName || conflictSceneName || '',
                                    conflictSceneName: conflictSceneName || '',
                                    planName: entry?.meta?.planName || '',
                                    itemId: entryItemId,
                                    handled: !!resolved?.handled,
                                    resolved: !!resolved?.ok,
                                    stoppedCount: Array.isArray(resolved?.stoppedCampaignIds) ? resolved.stoppedCampaignIds.length : 0,
                                    unresolvedCount: Array.isArray(resolved?.unresolvedCampaignIds) ? resolved.unresolvedCampaignIds.length : 0,
                                    oneClickUsed: !!resolved?.oneClickResult,
                                    oneClickError: resolved?.oneClickResult?.error || '',
                                    error: resolved?.error || ''
                                });
                                if (resolved?.handled && resolved?.ok) {
                                    conflictRetried = true;
                                    outcome = await submitSingleEntry();
                                }
                            }
                            if (outcome.successes.length) {
                                successes.push(...outcome.successes);
                            } else {
                                const finalFailures = Array.isArray(outcome.failures) && outcome.failures.length
                                    ? outcome.failures
                                    : [buildFailureFromEntry(entry, conflictRetried ? 'conflict_resolve_retry_failed' : 'single_retry_failed')];
                                failures.push(...finalFailures);
                            }
                        }
                    } catch (err) {
                        failures.push({
                            planName: entry.meta.planName,
                            item: entry.meta.item,
                            marketingGoal: entry?.meta?.marketingGoal || '',
                            submitEndpoint: entry?.meta?.submitEndpoint || '',
                            error: err?.message || String(err)
                        });
                    }
                }
            }

            const result = {
                ok: failures.length === 0,
                partial: successes.length > 0 && failures.length > 0,
                validation,
                sceneConfigMapping: {
                    sceneName: sceneConfigMapping?.sceneName || mergedRequest.sceneName || '',
                    appliedCount: Array.isArray(sceneConfigMapping?.applied) ? sceneConfigMapping.applied.length : 0,
                    skippedCount: Array.isArray(sceneConfigMapping?.skipped) ? sceneConfigMapping.skipped.length : 0,
                    applied: Array.isArray(sceneConfigMapping?.applied) ? sceneConfigMapping.applied : [],
                    skipped: Array.isArray(sceneConfigMapping?.skipped) ? sceneConfigMapping.skipped : []
                },
                runtime: {
                    bizCode: runtime.bizCode,
                    promotionScene: runtime.promotionScene,
                    itemSelectedMode: runtime.itemSelectedMode,
                    bidTypeV2: runtime.bidTypeV2,
                    bidTargetV2: runtime.bidTargetV2,
                    dmcType: runtime.dmcType
                },
                marketingGoal: mergedRequest?.__goalResolution?.resolvedMarketingGoal || mergedRequest.marketingGoal || '',
                goalFallbackUsed: !!mergedRequest?.__goalResolution?.goalFallbackUsed,
                goalWarnings: Array.isArray(mergedRequest?.__goalResolution?.goalWarnings)
                    ? mergedRequest.__goalResolution.goalWarnings.slice(0, 50)
                    : [],
                submitEndpoint: mergedRequest.submitEndpoint || SCENE_CREATE_ENDPOINT_FALLBACK,
                fallbackPolicy,
                conflictPolicy,
                stopScope,
                successCount: successes.length,
                failCount: failures.length,
                successes,
                failures,
                rawResponses
            };
            emitProgress(options, 'done', result);
            return result;
        };

        const appendKeywords = async (request = {}, options = {}) => {
            const runtime = await getRuntimeDefaults(false);
            runtime.bizCode = request.bizCode || runtime.bizCode;
            runtime.promotionScene = request.promotionScene || runtime.promotionScene;
            runtime.itemSelectedMode = request.itemSelectedMode || runtime.itemSelectedMode;
            runtime.bidTypeV2 = request.bidTypeV2 || runtime.bidTypeV2;
            runtime.bidTargetV2 = request.bidTargetV2 || runtime.bidTargetV2;

            const entries = Array.isArray(request.entries) ? request.entries : [request];
            const results = [];
            for (const entry of entries) {
                const adgroupId = toIdValue(entry.adgroupId);
                if (!adgroupId) {
                    results.push({ ok: false, adgroupId: '', error: 'ç¼ºå°‘ adgroupId' });
                    continue;
                }
                const keywordDefaults = {
                    bidPrice: toNumber(entry?.keywordDefaults?.bidPrice, toNumber(request?.keywordDefaults?.bidPrice, 1)),
                    matchScope: parseMatchScope(entry?.keywordDefaults?.matchScope, parseMatchScope(request?.keywordDefaults?.matchScope, DEFAULTS.matchScope)),
                    onlineStatus: toNumber(entry?.keywordDefaults?.onlineStatus, toNumber(request?.keywordDefaults?.onlineStatus, DEFAULTS.keywordOnlineStatus))
                };
                const wordList = parseKeywords(entry.keywords || request.keywords || [], keywordDefaults)
                    .map(word => applyKeywordDefaults(word, keywordDefaults))
                    .slice(0, 200);
                if (!wordList.length) {
                    results.push({ ok: false, adgroupId, error: 'å…³é”®è¯ä¸ºç©º' });
                    continue;
                }

                try {
                    const res = await requestOne(ENDPOINTS.bidwordAdd, runtime.bizCode, {
                        bizCode: runtime.bizCode,
                        promotionScene: runtime.promotionScene,
                        itemSelectedMode: runtime.itemSelectedMode,
                        bidTypeV2: runtime.bidTypeV2,
                        bidTargetV2: runtime.bidTargetV2,
                        adgroupId,
                        wordList
                    }, options.requestOptions || {});
                    results.push({
                        ok: true,
                        adgroupId,
                        wordCount: wordList.length,
                        response: res
                    });
                } catch (err) {
                    results.push({
                        ok: false,
                        adgroupId,
                        wordCount: wordList.length,
                        error: err?.message || String(err)
                    });
                }
            }

            return {
                ok: results.every(item => item.ok),
                partial: results.some(item => item.ok) && results.some(item => !item.ok),
                results
            };
        };

        const suggestKeywords = async (request = {}, options = {}) => {
            const runtime = await getRuntimeDefaults(false);
            runtime.bizCode = request.bizCode || runtime.bizCode || DEFAULTS.bizCode;
            runtime.promotionScene = request.promotionScene || runtime.promotionScene || DEFAULTS.promotionScene;
            runtime.itemSelectedMode = request.itemSelectedMode || runtime.itemSelectedMode || DEFAULTS.itemSelectedMode;
            runtime.bidTypeV2 = request.bidTypeV2 || runtime.bidTypeV2 || DEFAULTS.bidTypeV2;
            runtime.bidTargetV2 = request.bidTargetV2 || runtime.bidTargetV2 || DEFAULTS.bidTargetV2;

            const materialId = request.materialId || request.itemId;
            if (!materialId) {
                return { ok: false, wordList: [], wordPackageList: [], error: 'ç¼ºå°‘ materialId/itemId' };
            }

            const keywordDefaults = {
                bidPrice: toNumber(request?.keywordDefaults?.bidPrice, 1),
                matchScope: parseMatchScope(request?.keywordDefaults?.matchScope, DEFAULTS.matchScope),
                onlineStatus: toNumber(request?.keywordDefaults?.onlineStatus, DEFAULTS.keywordOnlineStatus)
            };
            const source = request.source || 'auto';
            const limit = Math.max(1, Math.min(200, toNumber(request.limit, DEFAULTS.recommendCount)));
            const [wordList, wordPackageList] = await Promise.all([
                fetchRecommendWordList({
                    bizCode: runtime.bizCode,
                    materialId,
                    defaults: runtime,
                    source,
                    requestOptions: options.requestOptions || {}
                }),
                fetchRecommendWordPackageList({
                    bizCode: runtime.bizCode,
                    materialId,
                    defaults: runtime,
                    requestOptions: options.requestOptions || {}
                })
            ]);

            return {
                ok: true,
                wordList: (Array.isArray(wordList) ? wordList : [])
                    .map(word => applyKeywordDefaults(word, keywordDefaults))
                    .filter(word => word.word)
                    .slice(0, limit),
                wordPackageList: Array.isArray(wordPackageList) ? wordPackageList.slice(0, 100) : []
            };
        };

        const suggestCrowds = async (request = {}, options = {}) => {
            const runtime = await getRuntimeDefaults(false);
            runtime.bizCode = request.bizCode || runtime.bizCode || DEFAULTS.bizCode;
            runtime.promotionScene = request.promotionScene || runtime.promotionScene || DEFAULTS.promotionScene;
            runtime.bidTargetV2 = request.bidTargetV2 || runtime.bidTargetV2 || DEFAULTS.bidTargetV2;
            runtime.subPromotionType = request.subPromotionType || runtime.subPromotionType || DEFAULTS.subPromotionType;
            runtime.promotionType = request.promotionType || runtime.promotionType || DEFAULTS.promotionType;
            const crowdList = await fetchRecommendCrowdList({
                bizCode: runtime.bizCode,
                defaults: runtime,
                labelIdList: request.labelIdList || DEFAULTS.recommendCrowdLabelIds,
                materialIdList: Array.isArray(request.materialIdList) ? request.materialIdList : [],
                requestOptions: options.requestOptions || {}
            });
            return {
                ok: true,
                crowdList: crowdList.slice(0, Math.max(1, Math.min(100, toNumber(request.limit, 50))))
            };
        };

        const ensureWizardStyle = () => {
            if (document.getElementById('am-wxt-keyword-style')) return;
            const style = document.createElement('style');
            style.id = 'am-wxt-keyword-style';
            style.textContent = `
                #am-wxt-keyword-overlay {
                    position: fixed;
                    inset: 0;
                    background: rgba(15, 23, 42, 0.36);
                    backdrop-filter: blur(4px);
                    z-index: 1000006;
                    display: none;
                    align-items: center;
                    justify-content: center;
                }
                #am-wxt-keyword-overlay.open {
                    display: flex;
                }
                #am-wxt-keyword-modal {
                    width: min(1160px, 96vw);
                    max-height: 92vh;
                    background: #f7f8fc;
                    border: 1px solid rgba(69,84,229,0.2);
                    border-radius: 14px;
                    box-shadow: 0 16px 42px rgba(17,24,39,0.28);
                    display: flex;
                    flex-direction: column;
                    overflow: hidden;
                    font-family: PingFangSC-Regular,PingFang SC,"Microsoft Yahei","SimHei",sans-serif;
                    color: #1f2937;
                }
                #am-wxt-keyword-modal .am-wxt-header {
                    height: 48px;
                    padding: 0 16px;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    background: linear-gradient(135deg, #eef2ff, #f8f9ff);
                    border-bottom: 1px solid rgba(69,84,229,0.18);
                    font-weight: 600;
                }
                #am-wxt-keyword-modal .am-wxt-close {
                    border: 0;
                    background: transparent;
                    color: #4b5563;
                    cursor: pointer;
                    font-size: 16px;
                    padding: 4px 6px;
                }
                #am-wxt-keyword-modal .am-wxt-body {
                    padding: 12px 14px 14px;
                    overflow: auto;
                }
                #am-wxt-keyword-modal .am-wxt-split {
                    display: grid;
                    grid-template-columns: 1fr 1fr;
                    gap: 12px;
                }
                #am-wxt-keyword-modal .am-wxt-split.compact {
                    grid-template-columns: 1fr;
                }
                #am-wxt-keyword-modal .am-wxt-split.compact .am-wxt-panel:nth-child(1) {
                    display: none;
                }
                #am-wxt-keyword-modal .am-wxt-split.compact .am-wxt-panel:nth-child(2) {
                    display: flex;
                    min-height: 0;
                }
                #am-wxt-keyword-modal .am-wxt-split.compact #am-wxt-keyword-added-list {
                    flex: 0 0 auto;
                    height: 126px;
                    max-height: 126px;
                }
                #am-wxt-keyword-modal .am-wxt-panel {
                    border: 1px solid rgba(148,163,184,0.35);
                    border-radius: 10px;
                    background: #fff;
                    display: flex;
                    flex-direction: column;
                    min-height: 310px;
                    overflow: hidden;
                }
                #am-wxt-keyword-modal .am-wxt-panel-candidate {
                    min-height: 0;
                }
                #am-wxt-keyword-modal .am-wxt-toolbar {
                    padding: 10px;
                    border-bottom: 1px solid rgba(148,163,184,0.28);
                    display: flex;
                    gap: 8px;
                    align-items: center;
                    flex-wrap: wrap;
                }
                #am-wxt-keyword-modal .am-wxt-toolbar input,
                #am-wxt-keyword-modal .am-wxt-config input,
                #am-wxt-keyword-modal .am-wxt-config select,
                #am-wxt-keyword-modal .am-wxt-config textarea {
                    border: 1px solid rgba(148,163,184,0.5);
                    border-radius: 8px;
                    padding: 6px 8px;
                    font-size: 12px;
                    background: #fff;
                    color: #1f2937;
                    min-height: 30px;
                    box-sizing: border-box;
                }
                #am-wxt-keyword-modal .am-wxt-toolbar input {
                    flex: 1;
                    min-width: 180px;
                }
                #am-wxt-keyword-modal .am-wxt-btn {
                    border: 1px solid rgba(69,84,229,0.3);
                    border-radius: 8px;
                    padding: 6px 10px;
                    font-size: 12px;
                    line-height: 1;
                    background: #eef2ff;
                    color: #2e3ab8;
                    cursor: pointer;
                }
                #am-wxt-keyword-modal .am-wxt-btn.primary {
                    background: linear-gradient(135deg, #4554e5, #4f68ff);
                    color: #fff;
                    border-color: #4554e5;
                }
                #am-wxt-keyword-modal .am-wxt-btn.danger {
                    background: #fee2e2;
                    color: #b91c1c;
                    border-color: rgba(185, 28, 28, 0.32);
                }
                #am-wxt-keyword-modal .am-wxt-btn.am-wxt-right {
                    margin-left: auto;
                }
                #am-wxt-keyword-modal .am-wxt-list {
                    padding: 6px;
                    overflow: auto;
                    flex: 1;
                }
                #am-wxt-keyword-candidate-list {
                    flex: 0 0 auto;
                    height: 222px;
                    max-height: 222px;
                }
                #am-wxt-keyword-added-list {
                    flex: 0 0 auto;
                    height: 126px;
                    max-height: 126px;
                    transition: height .2s ease, max-height .2s ease;
                }
                #am-wxt-keyword-item-split.candidate-list-expanded #am-wxt-keyword-added-list {
                    height: 222px;
                    max-height: 222px;
                }
                #am-wxt-keyword-modal .am-wxt-toggle-candidate-list-btn.hidden {
                    display: none;
                }
                #am-wxt-keyword-modal .am-wxt-item {
                    border: 1px solid rgba(148,163,184,0.34);
                    border-radius: 8px;
                    padding: 8px;
                    margin-bottom: 6px;
                    display: flex;
                    justify-content: space-between;
                    gap: 8px;
                    align-items: center;
                }
                #am-wxt-keyword-modal .am-wxt-item .name {
                    font-size: 12px;
                    line-height: 1.35;
                    color: #111827;
                }
                #am-wxt-keyword-modal .am-wxt-item .meta {
                    font-size: 11px;
                    color: #64748b;
                    margin-top: 2px;
                }
                #am-wxt-keyword-modal .am-wxt-item .actions {
                    display: flex;
                    gap: 4px;
                    flex-shrink: 0;
                }
                #am-wxt-keyword-modal .am-wxt-strategy-board {
                    margin-top: 12px;
                    border: 1px solid rgba(148,163,184,0.35);
                    border-radius: 10px;
                    background: #fff;
                    padding: 10px;
                }
                #am-wxt-keyword-modal .am-wxt-strategy-head {
                    display: flex;
                    justify-content: flex-start;
                    align-items: center;
                    font-size: 13px;
                    color: #334155;
                    margin-bottom: 8px;
                }
                #am-wxt-keyword-modal .am-wxt-strategy-head-right {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }
                #am-wxt-keyword-modal .am-wxt-strategy-list {
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                }
                #am-wxt-keyword-modal .am-wxt-strategy-item {
                    border: 1px solid rgba(148,163,184,0.3);
                    border-radius: 10px;
                    padding: 10px;
                    background: #f8fafc;
                }
                #am-wxt-keyword-modal .am-wxt-strategy-main {
                    display: flex;
                    justify-content: space-between;
                    align-items: center;
                    gap: 8px;
                }
                #am-wxt-keyword-modal .am-wxt-strategy-left {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    font-size: 13px;
                    color: #111827;
                    font-weight: 600;
                }
                #am-wxt-keyword-modal .am-wxt-strategy-right {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    color: #374151;
                    font-size: 12px;
                }
                #am-wxt-keyword-modal .am-wxt-copy-btn {
                    display: inline-flex;
                    align-items: center;
                    gap: 6px;
                }
                #am-wxt-keyword-modal .am-wxt-copy-multi {
                    display: inline-flex;
                    align-items: center;
                    gap: 2px;
                    padding: 2px 6px;
                    border-radius: 10px;
                    border: 1px solid rgba(99,102,241,0.32);
                    background: rgba(255,255,255,0.88);
                    color: #3344c8;
                    font-size: 11px;
                    line-height: 1;
                    user-select: none;
                }
                #am-wxt-keyword-modal .am-wxt-copy-multi-icon {
                    font-weight: 700;
                    opacity: 0.9;
                }
                #am-wxt-keyword-modal .am-wxt-copy-multi-num {
                    min-width: 12px;
                    text-align: center;
                    font-weight: 600;
                }
                #am-wxt-keyword-modal .am-wxt-detail-title {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    margin-bottom: 6px;
                    font-size: 13px;
                    color: #334155;
                }
                #am-wxt-keyword-modal .am-wxt-detail-title-right {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                }
                #am-wxt-keyword-overlay #am-wxt-keyword-detail-backdrop {
                    position: fixed;
                    inset: 0;
                    background: rgba(15, 23, 42, 0.28);
                    z-index: 1000007;
                    display: none;
                }
                #am-wxt-keyword-overlay #am-wxt-keyword-detail-backdrop.open {
                    display: block;
                }
                #am-wxt-keyword-modal .am-wxt-config {
                    margin-top: 12px;
                    border: 1px solid rgba(148,163,184,0.35);
                    border-radius: 10px;
                    background: #fff;
                    padding: 10px;
                }
                #am-wxt-keyword-detail-config {
                    position: fixed;
                    left: 50%;
                    top: 50%;
                    transform: translate(-50%, -50%);
                    width: min(1240px, 94vw);
                    max-height: 90vh;
                    overflow: auto;
                    z-index: 1000008;
                    margin-top: 0;
                    box-shadow: 0 18px 48px rgba(17,24,39,0.26);
                }
                #am-wxt-keyword-modal .am-wxt-config.collapsed {
                    display: none;
                }
                #am-wxt-keyword-detail-config .am-wxt-detail-title {
                    position: sticky;
                    top: 0;
                    background: #fff;
                    z-index: 2;
                    margin: -10px -10px 10px;
                    padding: 10px;
                    border-bottom: 1px solid rgba(148,163,184,0.28);
                }
                #am-wxt-keyword-detail-config .am-wxt-detail-footer {
                    position: sticky;
                    bottom: 0;
                    background: #fff;
                    z-index: 2;
                    margin: 10px -10px -10px;
                    padding: 10px;
                    border-top: 1px solid rgba(148,163,184,0.28);
                    display: flex;
                    justify-content: flex-end;
                    align-items: center;
                }
                #am-wxt-keyword-modal .am-wxt-config-grid {
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                }
                #am-wxt-keyword-modal .am-wxt-setting-row {
                    display: grid;
                    grid-template-columns: 140px minmax(0, 1fr);
                    align-items: flex-start;
                    gap: 10px;
                    padding: 6px 0;
                    border-bottom: 1px dashed rgba(148,163,184,0.28);
                }
                #am-wxt-keyword-modal .am-wxt-setting-row:last-child {
                    border-bottom: 0;
                }
                #am-wxt-keyword-modal .am-wxt-setting-label {
                    font-size: 12px;
                    color: #334155;
                    line-height: 30px;
                    white-space: nowrap;
                }
                #am-wxt-keyword-modal .am-wxt-setting-control {
                    display: flex;
                    flex-direction: column;
                    gap: 6px;
                    min-width: 0;
                }
                #am-wxt-keyword-modal .am-wxt-setting-control.am-wxt-setting-control-pair {
                    flex-direction: row;
                    align-items: center;
                    gap: 10px;
                    flex-wrap: nowrap;
                }
                #am-wxt-keyword-modal .am-wxt-setting-control.am-wxt-setting-control-pair .am-wxt-option-line.segmented {
                    flex: 0 1 auto;
                    min-width: 0;
                }
                #am-wxt-keyword-modal .am-wxt-scene-inline-input {
                    display: inline-flex;
                    align-items: center;
                    justify-content: flex-start;
                    gap: 6px;
                    min-width: 178px;
                    flex: 0 0 auto;
                    margin-left: 8px;
                }
                #am-wxt-keyword-modal .am-wxt-scene-inline-input .am-wxt-inline-label {
                    font-size: 12px;
                    color: #475569;
                    line-height: 1.2;
                    white-space: nowrap;
                }
                #am-wxt-keyword-modal .am-wxt-scene-inline-input input {
                    width: 120px;
                }
                #am-wxt-keyword-modal .am-wxt-site-optimize-box {
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                    padding: 8px 10px;
                    border: 1px solid rgba(148,163,184,0.28);
                    border-radius: 12px;
                    background: #f8fafc;
                }
                #am-wxt-keyword-modal .am-wxt-site-optimize-item {
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                }
                #am-wxt-keyword-modal .am-wxt-site-optimize-main {
                    display: flex;
                    align-items: center;
                    gap: 10px;
                    flex-wrap: wrap;
                    min-width: 0;
                }
                #am-wxt-keyword-modal .am-wxt-site-optimize-title {
                    min-width: 68px;
                    font-size: 12px;
                    color: #334155;
                    font-weight: 600;
                    line-height: 1.4;
                }
                #am-wxt-keyword-modal .am-wxt-site-toggle {
                    display: inline-flex;
                    gap: 0;
                    border: 1px solid rgba(148,163,184,0.28);
                    border-radius: 12px;
                    overflow: hidden;
                    background: #fff;
                }
                #am-wxt-keyword-modal .am-wxt-site-toggle .am-wxt-option-chip {
                    border: none;
                    border-right: 1px solid rgba(148,163,184,0.2);
                    border-radius: 0;
                    padding: 8px 14px;
                    background: #fff;
                    color: #475569;
                }
                #am-wxt-keyword-modal .am-wxt-site-toggle .am-wxt-option-chip:last-child {
                    border-right: none;
                }
                #am-wxt-keyword-modal .am-wxt-site-toggle .am-wxt-option-chip.active {
                    background: rgba(79,104,255,0.1);
                    color: #5f76cc;
                    box-shadow: inset 0 0 0 1px rgba(63,94,251,0.62);
                    border-radius: 0;
                }
                #am-wxt-keyword-modal .am-wxt-site-toggle .am-wxt-option-chip:first-child.active {
                    border-top-left-radius: 11px;
                    border-bottom-left-radius: 11px;
                }
                #am-wxt-keyword-modal .am-wxt-site-toggle .am-wxt-option-chip:last-child.active {
                    border-top-right-radius: 11px;
                    border-bottom-right-radius: 11px;
                }
                #am-wxt-keyword-modal .am-wxt-site-toggle.am-wxt-site-toggle-wide {
                    flex-wrap: nowrap;
                    max-width: 100%;
                    overflow-x: auto;
                }
                #am-wxt-keyword-modal .am-wxt-site-switch {
                    position: relative;
                    display: inline-flex;
                    align-items: center;
                    justify-content: flex-start;
                    width: 36px;
                    min-width: 36px;
                    height: 18px;
                    border: none;
                    border-radius: 999px;
                    padding: 0 4px;
                    background: #4f68ff;
                    color: #fff;
                    cursor: pointer;
                    font-size: 10px;
                    line-height: 1;
                    font-weight: 700;
                    transition: background 0.2s ease;
                }
                #am-wxt-keyword-modal .am-wxt-site-switch.is-off {
                    justify-content: flex-end;
                    background: #cbd5e1;
                    color: #64748b;
                }
                #am-wxt-keyword-modal .am-wxt-site-switch .am-wxt-site-switch-handle {
                    position: absolute;
                    top: 2px;
                    left: 20px;
                    width: 14px;
                    height: 14px;
                    border-radius: 50%;
                    background: #fff;
                    box-shadow: 0 1px 2px rgba(15, 23, 42, 0.25);
                    transition: left 0.2s ease;
                }
                #am-wxt-keyword-modal .am-wxt-site-switch.is-off .am-wxt-site-switch-handle {
                    left: 2px;
                }
                #am-wxt-keyword-modal .am-wxt-site-switch .am-wxt-site-switch-state {
                    position: relative;
                    z-index: 1;
                    pointer-events: none;
                    user-select: none;
                }
                #am-wxt-keyword-modal .am-wxt-site-switch.is-on .am-wxt-site-switch-state {
                    padding-right: 10px;
                }
                #am-wxt-keyword-modal .am-wxt-site-switch.is-off .am-wxt-site-switch-state {
                    padding-left: 10px;
                }
                #am-wxt-keyword-modal .am-wxt-site-switch:focus-visible {
                    outline: 2px solid rgba(59, 130, 246, 0.65);
                    outline-offset: 2px;
                }
                #am-wxt-keyword-modal .am-wxt-site-optimize-inline-row {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    flex-wrap: wrap;
                }
                #am-wxt-keyword-modal .am-wxt-site-optimize-inline-label {
                    font-size: 12px;
                    color: #475569;
                    white-space: nowrap;
                }
                #am-wxt-keyword-modal .am-wxt-site-optimize-inline-input {
                    display: inline-flex;
                    align-items: center;
                    gap: 6px;
                    font-size: 12px;
                    color: #475569;
                }
                #am-wxt-keyword-modal .am-wxt-site-optimize-inline-input input {
                    width: 92px;
                }
                #am-wxt-keyword-modal .am-wxt-site-optimize-hint {
                    font-size: 12px;
                    color: #64748b;
                    line-height: 1.4;
                }
                #am-wxt-keyword-modal .am-wxt-site-optimize-link {
                    font-size: 12px;
                    color: #4f68ff;
                    line-height: 1.2;
                }
                #am-wxt-keyword-modal .am-wxt-site-optimize-config {
                    display: flex;
                    align-items: center;
                    flex-wrap: wrap;
                    gap: 8px;
                    padding-left: 78px;
                }
                #am-wxt-keyword-modal .am-wxt-site-optimize-config input {
                    width: 180px;
                }
                #am-wxt-keyword-modal .am-wxt-static-settings {
                    display: none;
                }
                #am-wxt-keyword-modal .am-wxt-setting-control-inline {
                    flex-direction: row;
                    align-items: center;
                    gap: 10px;
                    flex-wrap: wrap;
                }
                #am-wxt-keyword-modal .am-wxt-inline-check {
                    display: inline-flex;
                    align-items: center;
                    gap: 6px;
                    font-size: 12px;
                }
                #am-wxt-keyword-modal .am-wxt-option-line {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 8px;
                }
                #am-wxt-keyword-modal .am-wxt-option-line.segmented {
                    display: inline-flex;
                    width: fit-content;
                    max-width: 100%;
                    gap: 0;
                    flex-wrap: nowrap;
                    overflow-x: auto;
                    border: 1px solid rgba(148,163,184,0.28);
                    border-radius: 14px;
                    background: #fff;
                }
                #am-wxt-keyword-modal .am-wxt-option-chip {
                    border: 1px solid rgba(148,163,184,0.5);
                    border-radius: 9px;
                    padding: 5px 10px;
                    background: #fff;
                    color: #475569;
                    cursor: pointer;
                    font-size: 12px;
                    line-height: 1.2;
                }
                #am-wxt-keyword-modal .am-wxt-option-chip.active {
                    border-color: #4f68ff;
                    background: rgba(79,104,255,0.1);
                    color: #3344c8;
                    font-weight: 600;
                }
                #am-wxt-keyword-modal .am-wxt-option-chip:disabled {
                    cursor: not-allowed;
                    opacity: 0.48;
                }
                #am-wxt-keyword-modal .am-wxt-option-line.segmented .am-wxt-option-chip {
                    flex: 0 0 auto;
                    border: none;
                    border-right: 1px solid rgba(148,163,184,0.2);
                    border-radius: 0;
                    padding: 11px 16px;
                    background: #fff;
                    color: #64748b;
                    font-size: 13px;
                    line-height: 1.25;
                }
                #am-wxt-keyword-modal .am-wxt-option-line.segmented .am-wxt-option-chip:last-child {
                    border-right: none;
                }
                #am-wxt-keyword-modal .am-wxt-option-line.segmented .am-wxt-option-chip.active {
                    background: rgba(79,104,255,0.1);
                    color: #5f76cc;
                    font-weight: 600;
                    box-shadow: inset 0 0 0 1px rgba(63,94,251,0.62);
                    border-radius: 0;
                }
                #am-wxt-keyword-modal .am-wxt-option-line.segmented .am-wxt-option-chip:first-child.active {
                    border-top-left-radius: 13px;
                    border-bottom-left-radius: 13px;
                }
                #am-wxt-keyword-modal .am-wxt-option-line.segmented .am-wxt-option-chip:last-child.active {
                    border-top-right-radius: 13px;
                    border-bottom-right-radius: 13px;
                }
                #am-wxt-keyword-modal .am-wxt-option-chip .am-wxt-option-badge {
                    display: inline-flex;
                    align-items: center;
                    margin-left: 6px;
                    padding: 1px 7px;
                    border-radius: 10px;
                    background: #ffe4e8;
                    color: #ef4444;
                    font-size: 11px;
                    line-height: 1.25;
                    font-weight: 600;
                }
                #am-wxt-keyword-modal .am-wxt-hidden-control {
                    display: none !important;
                }
                #am-wxt-keyword-modal .am-wxt-scene-popup-control {
                    display: inline-flex;
                    align-items: center;
                    gap: 8px;
                    margin-left: 8px;
                }
                #am-wxt-keyword-modal .am-wxt-scene-popup-summary {
                    font-size: 12px;
                    color: #64748b;
                    white-space: nowrap;
                }
                #am-wxt-keyword-modal .am-wxt-scene-popup-summary[data-scene-popup-trigger-proxy] {
                    cursor: pointer;
                    user-select: none;
                }
                #am-wxt-keyword-modal .am-wxt-scene-popup-summary[data-scene-popup-trigger-proxy]:hover {
                    color: #475569;
                    text-decoration: underline;
                }
                #am-wxt-keyword-modal .am-wxt-scene-popup-summary[data-scene-popup-trigger-proxy]:focus-visible {
                    outline: 2px solid rgba(59,130,246,0.45);
                    outline-offset: 2px;
                    border-radius: 4px;
                }
                #am-wxt-scene-popup-mask {
                    position: fixed;
                    inset: 0;
                    z-index: 2147483500;
                    background: rgba(15, 23, 42, 0.52);
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    padding: 16px;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-popup-dialog {
                    width: min(720px, 96vw);
                    max-height: 86vh;
                    overflow: auto;
                    background: #fff;
                    border-radius: 12px;
                    border: 1px solid rgba(148,163,184,0.32);
                    box-shadow: 0 16px 48px rgba(15, 23, 42, 0.26);
                    padding: 12px;
                    display: flex;
                    flex-direction: column;
                    gap: 10px;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-popup-head {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    gap: 8px;
                    font-size: 14px;
                    color: #1f2937;
                    font-weight: 600;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-popup-body {
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-popup-foot {
                    display: flex;
                    justify-content: flex-end;
                    gap: 8px;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-popup-tips {
                    font-size: 12px;
                    color: #64748b;
                    line-height: 1.5;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-popup-label {
                    font-size: 12px;
                    color: #334155;
                    font-weight: 600;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-popup-actions {
                    display: flex;
                    flex-wrap: wrap;
                    gap: 8px;
                }
                #am-wxt-scene-popup-mask .am-wxt-btn {
                    border: 1px solid rgba(69,84,229,0.3);
                    border-radius: 8px;
                    padding: 6px 10px;
                    font-size: 12px;
                    line-height: 1;
                    background: #eef2ff;
                    color: #2e3ab8;
                    cursor: pointer;
                }
                #am-wxt-scene-popup-mask .am-wxt-btn.primary {
                    background: linear-gradient(135deg, #4554e5, #4f68ff);
                    color: #fff;
                    border-color: #4554e5;
                }
                #am-wxt-scene-popup-mask .am-wxt-btn.danger {
                    background: #fee2e2;
                    color: #b91c1c;
                    border-color: rgba(185, 28, 28, 0.32);
                }
                #am-wxt-scene-popup-mask .am-wxt-btn:disabled {
                    opacity: 0.5;
                    cursor: not-allowed;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-popup-textarea {
                    width: 100%;
                    min-height: 120px;
                    border: 1px solid rgba(148,163,184,0.42);
                    border-radius: 8px;
                    padding: 8px;
                    font-family: Menlo, Consolas, monospace;
                    font-size: 12px;
                    line-height: 1.45;
                    resize: vertical;
                    background: #f8fafc;
                    color: #1f2937;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-popup-dialog.am-wxt-scene-popup-dialog-advanced {
                    width: min(1120px, 96vw);
                    max-height: 90vh;
                    padding: 0;
                    gap: 0;
                    overflow: hidden;
                    border-radius: 16px;
                    border-color: rgba(148,163,184,0.26);
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-popup-dialog.am-wxt-scene-popup-dialog-advanced .am-wxt-scene-popup-head {
                    padding: 14px 18px;
                    border-bottom: 1px solid rgba(148,163,184,0.2);
                    background: #fff;
                    font-size: 16px;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-popup-dialog.am-wxt-scene-popup-dialog-advanced .am-wxt-scene-popup-head [data-scene-popup-close] {
                    min-width: 32px;
                    width: 32px;
                    height: 32px;
                    padding: 0;
                    border-radius: 16px;
                    font-size: 18px;
                    line-height: 1;
                    color: #64748b;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-popup-dialog.am-wxt-scene-popup-dialog-advanced .am-wxt-scene-popup-body {
                    padding: 0;
                    gap: 0;
                    min-height: min(640px, 72vh);
                    overflow: hidden;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-popup-dialog.am-wxt-scene-popup-dialog-advanced .am-wxt-scene-popup-foot {
                    padding: 12px 18px;
                    border-top: 1px solid rgba(148,163,184,0.2);
                    background: #fff;
                    justify-content: flex-start;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-layout {
                    height: 100%;
                    display: flex;
                    flex-direction: column;
                    background: #f8fafc;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-tabs {
                    display: inline-flex;
                    gap: 10px;
                    padding: 14px 18px 10px;
                    border-bottom: 1px solid rgba(148,163,184,0.2);
                    background: #fff;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-tab {
                    border: 1px solid rgba(148,163,184,0.4);
                    border-radius: 16px;
                    background: #fff;
                    color: #475569;
                    font-size: 13px;
                    line-height: 1.2;
                    padding: 6px 14px;
                    cursor: pointer;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-tab.active {
                    border-color: rgba(79,104,255,0.45);
                    background: rgba(79,104,255,0.11);
                    color: #3344c8;
                    font-weight: 600;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-main {
                    flex: 1;
                    min-height: 0;
                    display: grid;
                    grid-template-columns: minmax(0, 1fr) 230px;
                    gap: 0;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-content {
                    min-height: 0;
                    padding: 14px 18px 18px;
                    overflow: auto;
                    background: #fff;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-panel {
                    display: none;
                    flex-direction: column;
                    gap: 10px;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-panel.active {
                    display: flex;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-tip {
                    font-size: 12px;
                    color: #64748b;
                    line-height: 1.45;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-toolbar {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    flex-wrap: wrap;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-tip-inline {
                    font-size: 12px;
                    color: #64748b;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-adzone-table {
                    border: 1px solid rgba(148,163,184,0.32);
                    border-radius: 10px;
                    overflow: hidden;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-adzone-head,
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-adzone-row {
                    display: grid;
                    grid-template-columns: minmax(0, 1fr) 160px;
                    align-items: center;
                    gap: 10px;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-adzone-head {
                    background: #f8fafc;
                    color: #475569;
                    font-size: 12px;
                    font-weight: 600;
                    padding: 10px 12px;
                    border-bottom: 1px solid rgba(148,163,184,0.22);
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-adzone-list {
                    display: flex;
                    flex-direction: column;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-adzone-row {
                    padding: 10px 12px;
                    border-bottom: 1px solid rgba(148,163,184,0.18);
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-adzone-row:last-child {
                    border-bottom: none;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-adzone-name {
                    font-size: 13px;
                    color: #1f2937;
                    font-weight: 600;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-adzone-desc {
                    margin-top: 3px;
                    font-size: 12px;
                    color: #64748b;
                    line-height: 1.35;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-adzone-actions {
                    display: inline-flex;
                    justify-content: flex-end;
                    gap: 6px;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-area-presets {
                    display: flex;
                    align-items: center;
                    flex-wrap: wrap;
                    gap: 8px;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-area-label {
                    font-size: 12px;
                    color: #334155;
                    font-weight: 600;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-area-editor {
                    min-height: 280px;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-popup-time-grid {
                    border: 1px solid rgba(148,163,184,0.3);
                    border-radius: 10px;
                    overflow: hidden;
                    background: #fff;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-time-head {
                    display: grid;
                    grid-template-columns: 110px minmax(0, 1fr);
                    border-bottom: 1px solid rgba(148,163,184,0.2);
                    background: #f8fafc;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-time-days {
                    display: grid;
                    grid-template-columns: repeat(7, minmax(0, 1fr));
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-time-day {
                    font-size: 12px;
                    color: #475569;
                    padding: 10px 4px;
                    text-align: center;
                    border-left: 1px solid rgba(148,163,184,0.12);
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-time-body {
                    display: flex;
                    flex-direction: column;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-time-row {
                    display: grid;
                    grid-template-columns: 110px minmax(0, 1fr);
                    border-bottom: 1px solid rgba(148,163,184,0.12);
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-time-row:last-child {
                    border-bottom: none;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-time-label {
                    font-size: 12px;
                    color: #64748b;
                    padding: 8px 10px;
                    display: flex;
                    align-items: center;
                    background: #f8fafc;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-time-cells {
                    display: grid;
                    grid-template-columns: repeat(7, minmax(0, 1fr));
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-time-cell {
                    border: none;
                    border-left: 1px solid rgba(148,163,184,0.12);
                    border-radius: 0;
                    background: rgba(100,116,139,0.08);
                    min-height: 38px;
                    cursor: pointer;
                    padding: 0;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-time-cell.active {
                    background: rgba(79,104,255,0.23);
                    box-shadow: inset 0 0 0 1px rgba(79,104,255,0.45);
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-preview {
                    border-left: 1px solid rgba(148,163,184,0.18);
                    background: linear-gradient(180deg, #f8fafc 0%, #eef2ff 100%);
                    padding: 20px 14px;
                    display: flex;
                    flex-direction: column;
                    align-items: center;
                    justify-content: flex-start;
                    gap: 12px;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-preview-phone {
                    width: 150px;
                    height: 282px;
                    border-radius: 26px;
                    background: #e2e8f0;
                    padding: 10px 8px;
                    box-shadow: inset 0 0 0 1px rgba(100,116,139,0.25);
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-preview-screen {
                    width: 100%;
                    height: 100%;
                    border-radius: 18px;
                    background: linear-gradient(180deg, #fff 0%, #dbeafe 100%);
                    padding: 12px 8px;
                    display: flex;
                    flex-direction: column;
                    gap: 8px;
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-preview-card {
                    height: 58px;
                    border-radius: 10px;
                    background: linear-gradient(120deg, rgba(79,104,255,0.28), rgba(59,130,246,0.16));
                    border: 1px solid rgba(79,104,255,0.2);
                }
                #am-wxt-scene-popup-mask .am-wxt-scene-advanced-preview-desc {
                    font-size: 12px;
                    color: #64748b;
                    text-align: center;
                    line-height: 1.45;
                }
                @media (max-width: 980px) {
                    #am-wxt-scene-popup-mask .am-wxt-scene-popup-dialog.am-wxt-scene-popup-dialog-advanced {
                        width: min(96vw, 900px);
                    }
                    #am-wxt-scene-popup-mask .am-wxt-scene-advanced-main {
                        grid-template-columns: minmax(0, 1fr);
                    }
                    #am-wxt-scene-popup-mask .am-wxt-scene-advanced-preview {
                        display: none;
                    }
                }
                #am-wxt-keyword-modal .am-wxt-scene-dynamic {
                    margin-top: 8px;
                    border: none;
                    border-radius: 8px;
                    background: #f8fafc;
                    padding: 8px;
                }
                #am-wxt-keyword-modal .am-wxt-scene-dynamic .title {
                    font-size: 12px;
                    color: #334155;
                    font-weight: 600;
                    margin-bottom: 6px;
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    gap: 8px;
                }
                #am-wxt-keyword-modal .am-wxt-scene-dynamic .meta {
                    color: #64748b;
                    font-size: 11px;
                }
                #am-wxt-keyword-modal .am-wxt-scene-grid {
                    display: flex;
                    flex-direction: column;
                    gap: 0;
                }
                #am-wxt-keyword-modal .am-wxt-scene-setting-row {
                    display: grid;
                    grid-template-columns: 160px minmax(0, 1fr);
                    align-items: flex-start;
                    gap: 8px;
                    padding: 6px 0;
                    border-bottom: none;
                }
                #am-wxt-keyword-modal .am-wxt-scene-setting-row:last-child {
                    border-bottom: 0;
                }
                #am-wxt-keyword-modal .am-wxt-scene-setting-label {
                    font-size: 12px;
                    color: #334155;
                    line-height: 30px;
                }
                #am-wxt-keyword-modal .am-wxt-scene-empty {
                    color: #64748b;
                    font-size: 12px;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-panel {
                    border: 1px solid rgba(148,163,184,0.28);
                    border-radius: 10px;
                    background: #fff;
                    overflow: hidden;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-panel.is-collapsed .am-wxt-manual-keyword-layout,
                #am-wxt-keyword-modal .am-wxt-manual-keyword-panel.is-collapsed .am-wxt-manual-keyword-actions {
                    display: none;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-panel.is-collapsed .am-wxt-manual-keyword-toolbar {
                    border-bottom: 0;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-toolbar {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    gap: 8px;
                    padding: 8px 10px;
                    border-bottom: 1px solid rgba(148,163,184,0.2);
                    background: #f8fafc;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-toolbar-left {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    flex-wrap: wrap;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-match-menu {
                    position: relative;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-match-pop {
                    position: absolute;
                    top: calc(100% + 4px);
                    left: 0;
                    min-width: 136px;
                    z-index: 3;
                    padding: 6px;
                    border-radius: 8px;
                    border: 1px solid rgba(148,163,184,0.35);
                    background: #fff;
                    box-shadow: 0 8px 24px rgba(15,23,42,0.14);
                    display: none;
                    gap: 6px;
                    flex-direction: column;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-match-menu.open .am-wxt-manual-keyword-match-pop {
                    display: flex;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-toolbar .tips {
                    font-size: 12px;
                    color: #64748b;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-toolbar-right {
                    display: inline-flex;
                    align-items: center;
                    gap: 8px;
                    margin-left: auto;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-layout {
                    display: grid;
                    grid-template-columns: minmax(220px, 0.44fr) minmax(0, 1fr);
                    gap: 10px;
                    padding: 10px;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-left {
                    border: 1px solid rgba(148,163,184,0.22);
                    border-radius: 8px;
                    background: #fff;
                    overflow: hidden;
                    display: flex;
                    flex-direction: column;
                    min-height: 0;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-left-head,
                #am-wxt-keyword-modal .am-wxt-manual-keyword-left-item {
                    display: grid;
                    grid-template-columns: minmax(0, 1fr) 92px;
                    gap: 8px;
                    align-items: center;
                    padding: 10px 10px;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-left-head {
                    font-size: 12px;
                    font-weight: 600;
                    color: #334155;
                    border-bottom: 1px solid rgba(148,163,184,0.2);
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-left-list {
                    min-height: 0;
                    max-height: 360px;
                    overflow: auto;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-left-item {
                    border-top: 1px solid rgba(148,163,184,0.14);
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-left-item:first-child {
                    border-top: 0;
                }
                #am-wxt-keyword-modal .am-wxt-manual-left-check {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    min-width: 0;
                    color: #334155;
                }
                #am-wxt-keyword-modal .am-wxt-manual-left-check span {
                    min-width: 0;
                    line-height: 1.25;
                    word-break: break-word;
                }
                #am-wxt-keyword-modal .am-wxt-manual-left-title {
                    color: #334155;
                    font-size: 13px;
                    font-weight: 600;
                    line-height: 1.4;
                }
                #am-wxt-keyword-modal .am-wxt-manual-left-meta {
                    margin-top: 2px;
                    font-size: 12px;
                    color: #94a3b8;
                }
                #am-wxt-keyword-modal .am-wxt-manual-left-meta.status {
                    color: #10b981;
                    font-weight: 600;
                }
                #am-wxt-keyword-modal .am-wxt-manual-left-bid {
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    gap: 4px;
                    font-size: 13px;
                    color: #475569;
                    border: 1px solid rgba(148,163,184,0.24);
                    border-radius: 10px;
                    height: 36px;
                    background: #f8fafc;
                    width: 92px;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-right {
                    min-width: 0;
                    border: 1px solid rgba(148,163,184,0.22);
                    border-radius: 8px;
                    overflow: hidden;
                    background: #fff;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-head,
                #am-wxt-keyword-modal .am-wxt-manual-keyword-item {
                    display: grid;
                    grid-template-columns: minmax(220px, 1.9fr) 0.9fr 0.9fr 1fr minmax(160px, 1fr) minmax(130px, 0.95fr);
                    gap: 8px;
                    align-items: center;
                    padding: 8px 10px;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-head {
                    background: #f8fafc;
                    border-bottom: 1px solid rgba(148,163,184,0.22);
                    font-size: 12px;
                    font-weight: 600;
                    color: #334155;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-head .keyword-col,
                #am-wxt-keyword-modal .am-wxt-manual-keyword-item .keyword-col {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    min-width: 0;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-item .keyword-main {
                    display: flex;
                    flex-direction: column;
                    gap: 4px;
                    min-width: 0;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-item .keyword-text {
                    min-width: 0;
                    overflow: hidden;
                    text-overflow: ellipsis;
                    white-space: nowrap;
                    font-size: 13px;
                    color: #1f2937;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-item .keyword-submeta {
                    display: flex;
                    align-items: center;
                    gap: 8px;
                    min-width: 0;
                    color: #94a3b8;
                    font-size: 12px;
                    line-height: 1;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-item .keyword-submeta-text {
                    display: inline-flex;
                    align-items: center;
                    gap: 4px;
                    min-width: 0;
                    white-space: nowrap;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-item .keyword-relevance {
                    display: inline-flex;
                    align-items: center;
                    justify-content: center;
                    padding: 0 7px;
                    min-width: 22px;
                    height: 18px;
                    border-radius: 10px;
                    background: #e7efff;
                    color: #4f65ff;
                    font-size: 11px;
                    font-weight: 600;
                    line-height: 18px;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-item .keyword-relevance-mid {
                    background: #fef3c7;
                    color: #92400e;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-item .keyword-relevance-low {
                    background: #fee2e2;
                    color: #b91c1c;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-item {
                    border-top: 1px solid rgba(148,163,184,0.16);
                    font-size: 12px;
                    color: #475569;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-item:first-child {
                    border-top: 0;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-list {
                    max-height: 360px;
                    overflow: auto;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-item .metric-muted {
                    color: #94a3b8;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-item .bid-value {
                    color: #334155;
                    font-weight: 600;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-actions {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    gap: 8px;
                    padding: 8px 10px;
                    border-top: 1px solid rgba(148,163,184,0.22);
                    background: #f8fafc;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-actions .tips {
                    font-size: 11px;
                    color: #64748b;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-empty {
                    padding: 12px 10px;
                    font-size: 12px;
                    color: #94a3b8;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-item .am-wxt-bid-edit {
                    display: inline-flex;
                    align-items: center;
                    justify-content: space-between;
                    gap: 6px;
                    border: 1px solid rgba(148,163,184,0.3);
                    border-radius: 10px;
                    padding: 0 8px;
                    height: 36px;
                    background: #fff;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-item .am-wxt-bid-edit input {
                    width: 64px;
                    border: 0;
                    outline: none;
                    font-size: 13px;
                    color: #1f2937;
                    background: transparent;
                }
                #am-wxt-keyword-modal .am-wxt-manual-keyword-item .am-wxt-bid-edit span {
                    color: #64748b;
                    font-size: 12px;
                }
                #am-wxt-keyword-modal .am-wxt-config textarea {
                    width: 100%;
                    min-height: 76px;
                    margin-top: 0;
                    resize: vertical;
                }
                #am-wxt-keyword-modal .am-wxt-actions {
                    margin-top: 10px;
                    display: flex;
                    gap: 8px;
                    align-items: center;
                    flex-wrap: wrap;
                }
                #am-wxt-keyword-quick-log {
                    margin-top: 8px;
                    border: 1px solid rgba(148,163,184,0.35);
                    border-radius: 8px;
                    background: #fff;
                    min-height: 48px;
                    max-height: 96px;
                    overflow: auto;
                    padding: 6px 8px;
                    font-size: 12px;
                }
                #am-wxt-keyword-quick-log .line {
                    margin-bottom: 4px;
                    color: #334155;
                }
                #am-wxt-keyword-quick-log .line.error {
                    color: #b91c1c;
                }
                #am-wxt-keyword-quick-log .line.success {
                    color: #15803d;
                }
                #am-wxt-keyword-modal .am-wxt-crowd-box {
                    margin-top: 8px;
                    border: 1px dashed rgba(100,116,139,0.4);
                    border-radius: 8px;
                    padding: 8px;
                    background: #f8fafc;
                }
                #am-wxt-keyword-modal .am-wxt-crowd-title {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    font-size: 12px;
                    color: #334155;
                    margin-bottom: 6px;
                }
                #am-wxt-keyword-modal .am-wxt-crowd-list {
                    max-height: 104px;
                    overflow: auto;
                }
                #am-wxt-keyword-modal .am-wxt-crowd-item {
                    display: flex;
                    align-items: center;
                    justify-content: space-between;
                    gap: 8px;
                    font-size: 12px;
                    color: #334155;
                    padding: 4px 0;
                    border-bottom: 1px dashed rgba(148,163,184,0.3);
                }
                #am-wxt-keyword-modal .am-wxt-crowd-item:last-child {
                    border-bottom: 0;
                }
                #am-wxt-keyword-preview {
                    margin-top: 8px;
                    background: #0f172a;
                    color: #d1d5db;
                    border-radius: 8px;
                    padding: 10px;
                    min-height: 96px;
                    max-height: 180px;
                    overflow: auto;
                    font-family: Menlo, Consolas, monospace;
                    font-size: 11px;
                    white-space: pre-wrap;
                }
                #am-wxt-keyword-debug-wrap.collapsed {
                    display: none;
                }
                #am-wxt-keyword-modal .am-wxt-debug-toggle {
                    margin-top: 8px;
                    display: flex;
                    justify-content: flex-end;
                }
                #am-wxt-keyword-log {
                    margin-top: 8px;
                    border: 1px solid rgba(148,163,184,0.35);
                    border-radius: 8px;
                    background: #fff;
                    min-height: 90px;
                    max-height: 180px;
                    overflow: auto;
                    padding: 8px;
                    font-size: 12px;
                }
                #am-wxt-keyword-log .line {
                    margin-bottom: 4px;
                    color: #334155;
                }
                #am-wxt-keyword-log .line.error {
                    color: #b91c1c;
                }
                #am-wxt-keyword-log .line.success {
                    color: #15803d;
                }
                @media (max-width: 980px) {
                    #am-wxt-keyword-modal .am-wxt-split {
                        grid-template-columns: 1fr;
                    }
                    #am-wxt-keyword-modal .am-wxt-setting-row {
                        grid-template-columns: 1fr;
                        gap: 6px;
                    }
                    #am-wxt-keyword-modal .am-wxt-setting-label {
                        line-height: 1.3;
                    }
                    #am-wxt-keyword-modal .am-wxt-scene-setting-row {
                        grid-template-columns: 1fr;
                        gap: 6px;
                    }
                    #am-wxt-keyword-modal .am-wxt-scene-setting-label {
                        line-height: 1.3;
                    }
                    #am-wxt-keyword-modal .am-wxt-setting-control.am-wxt-setting-control-pair {
                        flex-wrap: wrap;
                        align-items: flex-start;
                    }
                    #am-wxt-keyword-modal .am-wxt-scene-inline-input {
                        justify-content: flex-start;
                        min-width: 0;
                        width: 100%;
                        margin-left: 0;
                    }
                    #am-wxt-keyword-modal .am-wxt-scene-inline-input input {
                        width: min(220px, 100%);
                        flex: 1 1 auto;
                    }
                    #am-wxt-keyword-modal .am-wxt-site-optimize-config {
                        padding-left: 0;
                    }
                    #am-wxt-keyword-modal .am-wxt-site-optimize-inline-row {
                        align-items: flex-start;
                    }
                    #am-wxt-keyword-modal .am-wxt-site-optimize-inline-input {
                        width: 100%;
                        justify-content: flex-start;
                    }
                    #am-wxt-keyword-modal .am-wxt-site-optimize-inline-input input {
                        width: min(220px, 100%);
                        flex: 1 1 auto;
                    }
                    #am-wxt-keyword-modal .am-wxt-site-optimize-config input {
                        width: min(220px, 100%);
                        flex: 1 1 auto;
                    }
                    #am-wxt-keyword-modal .am-wxt-manual-keyword-toolbar {
                        flex-direction: column;
                        align-items: flex-start;
                    }
                    #am-wxt-keyword-modal .am-wxt-manual-keyword-layout {
                        grid-template-columns: 1fr;
                    }
                    #am-wxt-keyword-modal .am-wxt-manual-keyword-head,
                    #am-wxt-keyword-modal .am-wxt-manual-keyword-item {
                        grid-template-columns: minmax(160px, 1.4fr) 1fr 1fr 1fr;
                    }
                    #am-wxt-keyword-modal .am-wxt-manual-keyword-head > :last-child,
                    #am-wxt-keyword-modal .am-wxt-manual-keyword-item > :last-child {
                        grid-column: 1 / -1;
                    }
                }
            `;
            document.head.appendChild(style);
        };

        const getDefaultStrategyList = () => ([
            { id: 'trend_star', name: 'å…³é”®è¯æ¨å¹¿-è¶‹åŠ¿æ˜æ˜Ÿ', marketingGoal: 'è¶‹åŠ¿æ˜æ˜Ÿ', enabled: true, dayAverageBudget: '100', bidMode: 'smart', useWordPackage: DEFAULTS.useWordPackage },
            { id: 'custom_define', name: 'å…³é”®è¯æ¨å¹¿-è‡ªå®šä¹‰æ¨å¹¿', marketingGoal: 'è‡ªå®šä¹‰æ¨å¹¿', enabled: true, dayAverageBudget: '100', bidMode: 'smart', useWordPackage: DEFAULTS.useWordPackage }
        ]);

        const wizardDefaultDraft = () => ({
            schemaVersion: SESSION_DRAFT_SCHEMA_VERSION,
            bizCode: DEFAULTS.bizCode,
            promotionScene: DEFAULTS.promotionScene,
            sceneName: 'å…³é”®è¯æ¨å¹¿',
            sceneSettingValues: {},
            sceneSettingTouched: {},
            planNamePrefix: buildSceneTimePrefix('å…³é”®è¯æ¨å¹¿'),
            dayAverageBudget: '',
            defaultBidPrice: '1',
            bidMode: 'smart',
            keywordMode: DEFAULTS.keywordMode,
            useWordPackage: DEFAULTS.useWordPackage,
            recommendCount: String(DEFAULTS.recommendCount),
            manualKeywords: '',
            manualKeywordPanelCollapsed: true,
            addedItems: [],
            crowdList: [],
            debugVisible: false,
            itemSplitExpanded: false,
            candidateListExpanded: false,
            fallbackPolicy: normalizeWizardFallbackPolicy('auto'),
            strategyList: getDefaultStrategyList(),
            editingStrategyId: '',
            detailVisible: false
        });

        const formatRepairStatusText = (state = {}) => {
            const scene = String(state.sceneName || '-').trim() || '-';
            const sceneText = state.sceneIndex && state.sceneTotal
                ? `${scene}(${state.sceneIndex}/${state.sceneTotal})`
                : scene;
            const caseIndex = Math.max(0, toNumber(state.caseIndex, 0));
            const caseTotal = Math.max(0, toNumber(state.caseTotal, 0));
            const passCases = Math.max(0, toNumber(state.passCases, 0));
            const repairedCases = Math.max(0, toNumber(state.repairedCases, 0));
            const failedCases = Math.max(0, toNumber(state.failedCases, 0));
            const deletedCount = Math.max(0, toNumber(state.deletedCount, 0));
            const stoppedCount = Math.max(0, toNumber(state.stoppedCount, 0));
            return `åœºæ™¯=${sceneText} ç”¨ä¾‹=${caseIndex}/${caseTotal} é€šè¿‡=${passCases} ä¿®å¤=${repairedCases} å¤±è´¥=${failedCases} åˆ é™¤=${deletedCount} åœæ­¢=${stoppedCount}`;
        };
        const normalizeRepairItemId = (value = '') => {
            const text = String(value || '').trim();
            return /^\d{4,}$/.test(text) ? text : '';
        };
        const setRepairStatusText = (text = '') => {
            if (wizardState?.els?.repairStatus instanceof HTMLElement) {
                wizardState.els.repairStatus.textContent = String(text || '').trim();
            }
        };
        const setRepairControlState = (running = false) => {
            const isRunning = !!running;
            if (wizardState?.els?.repairRunBtn instanceof HTMLButtonElement) {
                wizardState.els.repairRunBtn.disabled = isRunning;
            }
            if (wizardState?.els?.repairStopBtn instanceof HTMLButtonElement) {
                wizardState.els.repairStopBtn.disabled = !isRunning;
            }
            if (wizardState?.els?.repairItemIdInput instanceof HTMLInputElement) {
                wizardState.els.repairItemIdInput.disabled = isRunning;
            }
        };

        const mountWizard = () => {
            if (wizardState.mounted) return;
            ensureWizardStyle();

            const overlay = document.createElement('div');
            overlay.id = 'am-wxt-keyword-overlay';
            overlay.innerHTML = `
                <div id="am-wxt-keyword-detail-backdrop"></div>
                <div id="am-wxt-keyword-modal" role="dialog" aria-modal="true">
                    <div class="am-wxt-header">
                        <span>å…³é”®è¯æ¨å¹¿æ‰¹é‡å»ºè®¡åˆ’ API å‘å¯¼</span>
                        <button class="am-wxt-close" id="am-wxt-keyword-close" title="å…³é—­">âœ•</button>
                    </div>
                    <div class="am-wxt-body">
                        <div class="am-wxt-split" id="am-wxt-keyword-item-split">
                            <div class="am-wxt-panel am-wxt-panel-candidate">
                                <div class="am-wxt-toolbar">
                                    <input id="am-wxt-keyword-search-input" placeholder="è¾“å…¥å•†å“å…³é”®è¯æˆ–å•†å“IDï¼ˆé€—å·åˆ†éš”ï¼‰" />
                                    <button class="am-wxt-btn" id="am-wxt-keyword-search">æœç´¢</button>
                                    <button class="am-wxt-btn" id="am-wxt-keyword-hot">çƒ­é”€æœ€è¿‘</button>
                                    <button class="am-wxt-btn" id="am-wxt-keyword-all">å…¨éƒ¨å•†å“</button>
                                    <button class="am-wxt-btn" id="am-wxt-keyword-add-all">å…¨éƒ¨æ·»åŠ </button>
                                </div>
                                <div class="am-wxt-list" id="am-wxt-keyword-candidate-list"></div>
                            </div>
                            <div class="am-wxt-panel">
                                <div class="am-wxt-toolbar">
                                    <span>å·²æ·»åŠ å•†å“ <b id="am-wxt-keyword-added-count">0</b> / ${WIZARD_MAX_ITEMS}</span>
                                    <button class="am-wxt-btn" id="am-wxt-keyword-toggle-candidate">æ·»åŠ å•†å“</button>
                                    <button class="am-wxt-btn am-wxt-toggle-candidate-list-btn hidden" id="am-wxt-keyword-toggle-candidate-list">å±•å¼€æ›´å¤š</button>
                                    <button class="am-wxt-btn" id="am-wxt-keyword-clear-added">æ¸…ç©º</button>
                                </div>
                                <div class="am-wxt-list" id="am-wxt-keyword-added-list"></div>
                            </div>
                        </div>

                        <div class="am-wxt-strategy-board">
                            <div class="am-wxt-strategy-head">
                                <div class="am-wxt-strategy-head-right">
                                    <button class="am-wxt-btn" id="am-wxt-keyword-add-strategy">æ–°å»ºè®¡åˆ’</button>
                                    <span>å·²é€‰ <b id="am-wxt-keyword-strategy-count">0</b> ä¸ª</span>
                                </div>
                            </div>
                            <div class="am-wxt-strategy-list" id="am-wxt-keyword-strategy-list"></div>
                            <div class="am-wxt-actions">
                                <button class="am-wxt-btn primary" id="am-wxt-keyword-run-quick">ç«‹å³æŠ•æ”¾</button>
                                <button class="am-wxt-btn" id="am-wxt-keyword-preview-quick">ç”Ÿæˆå…¶ä»–ç­–ç•¥</button>
                            </div>
                            <div id="am-wxt-keyword-quick-log"></div>
                        </div>

                        <div class="am-wxt-config collapsed" id="am-wxt-keyword-detail-config">
                            <div class="am-wxt-detail-title">
                                <span id="am-wxt-keyword-detail-title">åŒæ­¥è®¡åˆ’</span>
                                <div class="am-wxt-detail-title-right">
                                    <button class="am-wxt-close" id="am-wxt-keyword-detail-close" title="å…³é—­">âœ•</button>
                                </div>
                            </div>
                            <div id="am-wxt-keyword-static-settings" class="am-wxt-static-settings">
                                <div class="am-wxt-config-grid">
                                    <div class="am-wxt-setting-row">
                                        <div class="am-wxt-setting-label">åœºæ™¯é€‰æ‹©</div>
                                        <div class="am-wxt-setting-control">
                                            <div class="am-wxt-option-line" data-bind-select="am-wxt-keyword-scene-select"></div>
                                            <select id="am-wxt-keyword-scene-select" class="am-wxt-hidden-control">
                                                <option value="è´§å“å…¨ç«™æ¨å¹¿">è´§å“å…¨ç«™æ¨å¹¿</option>
                                                <option value="å…³é”®è¯æ¨å¹¿">å…³é”®è¯æ¨å¹¿</option>
                                                <option value="äººç¾¤æ¨å¹¿">äººç¾¤æ¨å¹¿</option>
                                                <option value="åº—é“ºç›´è¾¾">åº—é“ºç›´è¾¾</option>
                                                <option value="å†…å®¹è¥é”€">å†…å®¹è¥é”€</option>
                                                <option value="çº¿ç´¢æ¨å¹¿">çº¿ç´¢æ¨å¹¿</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="am-wxt-setting-row">
                                        <div class="am-wxt-setting-label">å‡ºä»·æ–¹å¼</div>
                                        <div class="am-wxt-setting-control">
                                            <div class="am-wxt-option-line" data-bind-select="am-wxt-keyword-bid-mode"></div>
                                            <select id="am-wxt-keyword-bid-mode" class="am-wxt-hidden-control">
                                                <option value="smart">æ™ºèƒ½å‡ºä»·</option>
                                                <option value="manual">æ‰‹åŠ¨å‡ºä»·</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="am-wxt-setting-row" id="am-wxt-keyword-bid-target-row">
                                        <div class="am-wxt-setting-label">å‡ºä»·ç›®æ ‡</div>
                                        <div class="am-wxt-setting-control">
                                            <div class="am-wxt-option-line" data-bind-select="am-wxt-keyword-bid-target"></div>
                                            <select id="am-wxt-keyword-bid-target" class="am-wxt-hidden-control">
                                                <option value="conv">è·å–æˆäº¤é‡</option>
                                                <option value="similar_item">ç›¸ä¼¼å“è·ŸæŠ•</option>
                                                <option value="search_rank">æŠ¢å æœç´¢å¡ä½</option>
                                                <option value="market_penetration">æå‡å¸‚åœºæ¸—é€</option>
                                                <option value="fav_cart">å¢åŠ æ”¶è—åŠ è´­é‡</option>
                                                <option value="click">å¢åŠ ç‚¹å‡»é‡</option>
                                                <option value="roi">ç¨³å®šæŠ•äº§æ¯”</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="am-wxt-setting-row">
                                        <div class="am-wxt-setting-label">é¢„ç®—ç±»å‹</div>
                                        <div class="am-wxt-setting-control">
                                            <div class="am-wxt-option-line" data-bind-select="am-wxt-keyword-budget-type"></div>
                                            <select id="am-wxt-keyword-budget-type" class="am-wxt-hidden-control">
                                                <option value="day_average">æ¯æ—¥é¢„ç®—</option>
                                                <option value="day_budget">æ—¥å‡é¢„ç®—</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="am-wxt-setting-row">
                                        <div class="am-wxt-setting-label">å…³é”®è¯æ¨¡å¼</div>
                                        <div class="am-wxt-setting-control">
                                            <div class="am-wxt-option-line" data-bind-select="am-wxt-keyword-mode"></div>
                                            <select id="am-wxt-keyword-mode" class="am-wxt-hidden-control">
                                                <option value="mixed">æ··åˆï¼ˆæ‰‹åŠ¨ä¼˜å…ˆ + æ¨èè¡¥é½ï¼‰</option>
                                                <option value="manual">ä»…æ‰‹åŠ¨</option>
                                                <option value="recommend">ä»…æ¨è</option>
                                            </select>
                                        </div>
                                    </div>
                                    <div class="am-wxt-setting-row">
                                        <div class="am-wxt-setting-label">è®¡åˆ’åå‰ç¼€</div>
                                        <div class="am-wxt-setting-control">
                                            <input id="am-wxt-keyword-prefix" placeholder="ä¾‹å¦‚ï¼šå…³é”®è¯æ¨å¹¿_å®¶ç”µ" />
                                        </div>
                                    </div>
                                    <div class="am-wxt-setting-row">
                                        <div class="am-wxt-setting-label">æ—¥å‡é¢„ç®—</div>
                                        <div class="am-wxt-setting-control">
                                            <input id="am-wxt-keyword-budget" placeholder="ç•™ç©ºåˆ™ç”¨é¡µé¢é»˜è®¤" />
                                        </div>
                                    </div>
                                    <div class="am-wxt-setting-row">
                                        <div class="am-wxt-setting-label">é»˜è®¤å…³é”®è¯å‡ºä»·</div>
                                        <div class="am-wxt-setting-control">
                                            <input id="am-wxt-keyword-bid" placeholder="é»˜è®¤ 1.00" />
                                        </div>
                                    </div>
                                    <div class="am-wxt-setting-row">
                                        <div class="am-wxt-setting-label">æ¨èè¯ç›®æ ‡æ•°</div>
                                        <div class="am-wxt-setting-control">
                                            <input id="am-wxt-keyword-recommend-count" placeholder="é»˜è®¤ 20" />
                                        </div>
                                    </div>
                                </div>
                                <div class="am-wxt-setting-row">
                                    <div class="am-wxt-setting-label">å¹³å‡ç›´æ¥æˆäº¤æˆæœ¬</div>
                                    <div class="am-wxt-setting-control am-wxt-setting-control-inline">
                                        <label class="am-wxt-inline-check">
                                            <input type="checkbox" id="am-wxt-keyword-single-cost-enable" />
                                            <span>å¯ç”¨ï¼ˆéå¿…è¦ï¼‰</span>
                                        </label>
                                        <input id="am-wxt-keyword-single-cost" placeholder="æˆæœ¬ä¸Šé™" style="width:140px;" />
                                    </div>
                                </div>
                                <div class="am-wxt-setting-row">
                                    <div class="am-wxt-setting-label">æ‰‹åŠ¨å…³é”®è¯</div>
                                    <div class="am-wxt-setting-control">
                                        <textarea id="am-wxt-keyword-manual" placeholder="æ‰‹åŠ¨å…³é”®è¯ï¼Œæ¯è¡Œä¸€ä¸ªï¼Œæ”¯æŒï¼šå…³é”®è¯,å‡ºä»·,åŒ¹é…æ–¹å¼ï¼ˆå¹¿æ³›/ç²¾å‡†ï¼‰"></textarea>
                                    </div>
                                </div>
                            </div>
                            <div id="am-wxt-keyword-scene-dynamic" class="am-wxt-scene-dynamic"></div>
                            <div class="am-wxt-actions">
                                <button class="am-wxt-btn" id="am-wxt-keyword-load-recommend">åŠ è½½æ¨èå…³é”®è¯</button>
                                <button class="am-wxt-btn" id="am-wxt-keyword-load-crowd">åŠ è½½æ¨èäººç¾¤</button>
                                <button class="am-wxt-btn" id="am-wxt-keyword-preview-btn">é¢„è§ˆè¯·æ±‚</button>
                                <button class="am-wxt-btn primary" id="am-wxt-keyword-run-btn">æ‰¹é‡åˆ›å»º</button>
                                <button class="am-wxt-btn" data-am-wxt-debug-toggle="1">æ‰“å¼€æ—¥å¿—</button>
                                <button class="am-wxt-btn" id="am-wxt-keyword-clear-draft">æ¸…ç©ºä¼šè¯è‰ç¨¿</button>
                            </div>
                            <div class="am-wxt-crowd-box">
                                <div class="am-wxt-crowd-title">
                                    <span>è®¡åˆ’äººç¾¤ <b id="am-wxt-keyword-crowd-count">0</b></span>
                                    <button class="am-wxt-btn" id="am-wxt-keyword-clear-crowd">æ¸…ç©ºäººç¾¤</button>
                                </div>
                                <div class="am-wxt-crowd-list" id="am-wxt-keyword-crowd-list"></div>
                            </div>
                            <div id="am-wxt-keyword-debug-wrap" class="collapsed">
                                <pre id="am-wxt-keyword-preview"></pre>
                                <div id="am-wxt-keyword-log"></div>
                            </div>
                            <div class="am-wxt-detail-footer">
                                <button class="am-wxt-btn primary" id="am-wxt-keyword-back-simple">ä¿å­˜å¹¶å…³é—­</button>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(overlay);

            wizardState.els = {
                overlay,
                closeBtn: overlay.querySelector('#am-wxt-keyword-close'),
                detailBackdrop: overlay.querySelector('#am-wxt-keyword-detail-backdrop'),
                searchInput: overlay.querySelector('#am-wxt-keyword-search-input'),
                searchBtn: overlay.querySelector('#am-wxt-keyword-search'),
                hotBtn: overlay.querySelector('#am-wxt-keyword-hot'),
                allBtn: overlay.querySelector('#am-wxt-keyword-all'),
                addAllBtn: overlay.querySelector('#am-wxt-keyword-add-all'),
                itemSplit: overlay.querySelector('#am-wxt-keyword-item-split'),
                candidateList: overlay.querySelector('#am-wxt-keyword-candidate-list'),
                addedList: overlay.querySelector('#am-wxt-keyword-added-list'),
                addedCount: overlay.querySelector('#am-wxt-keyword-added-count'),
                toggleCandidateBtn: overlay.querySelector('#am-wxt-keyword-toggle-candidate'),
                toggleCandidateListBtn: overlay.querySelector('#am-wxt-keyword-toggle-candidate-list'),
                clearAddedBtn: overlay.querySelector('#am-wxt-keyword-clear-added'),
                strategyList: overlay.querySelector('#am-wxt-keyword-strategy-list'),
                strategyCount: overlay.querySelector('#am-wxt-keyword-strategy-count'),
                addStrategyBtn: overlay.querySelector('#am-wxt-keyword-add-strategy'),
                runQuickBtn: overlay.querySelector('#am-wxt-keyword-run-quick'),
                previewQuickBtn: overlay.querySelector('#am-wxt-keyword-preview-quick'),
                quickLog: overlay.querySelector('#am-wxt-keyword-quick-log'),
                detailConfig: overlay.querySelector('#am-wxt-keyword-detail-config'),
                detailTitle: overlay.querySelector('#am-wxt-keyword-detail-title'),
                detailCloseBtn: overlay.querySelector('#am-wxt-keyword-detail-close'),
                backSimpleBtn: overlay.querySelector('#am-wxt-keyword-back-simple'),
                sceneSelect: overlay.querySelector('#am-wxt-keyword-scene-select'),
                bidModeSelect: overlay.querySelector('#am-wxt-keyword-bid-mode'),
                sceneDynamic: overlay.querySelector('#am-wxt-keyword-scene-dynamic'),
                bidTargetRow: overlay.querySelector('#am-wxt-keyword-bid-target-row'),
                bidTargetSelect: overlay.querySelector('#am-wxt-keyword-bid-target'),
                budgetTypeSelect: overlay.querySelector('#am-wxt-keyword-budget-type'),
                prefixInput: overlay.querySelector('#am-wxt-keyword-prefix'),
                budgetInput: overlay.querySelector('#am-wxt-keyword-budget'),
                bidInput: overlay.querySelector('#am-wxt-keyword-bid'),
                singleCostEnableInput: overlay.querySelector('#am-wxt-keyword-single-cost-enable'),
                singleCostInput: overlay.querySelector('#am-wxt-keyword-single-cost'),
                modeSelect: overlay.querySelector('#am-wxt-keyword-mode'),
                recommendCountInput: overlay.querySelector('#am-wxt-keyword-recommend-count'),
                manualInput: overlay.querySelector('#am-wxt-keyword-manual'),
                loadRecommendBtn: overlay.querySelector('#am-wxt-keyword-load-recommend'),
                loadCrowdBtn: overlay.querySelector('#am-wxt-keyword-load-crowd'),
                previewBtn: overlay.querySelector('#am-wxt-keyword-preview-btn'),
                runBtn: overlay.querySelector('#am-wxt-keyword-run-btn'),
                toggleDebugBtns: Array.from(overlay.querySelectorAll('[data-am-wxt-debug-toggle]')),
                clearDraftBtn: overlay.querySelector('#am-wxt-keyword-clear-draft'),
                crowdCount: overlay.querySelector('#am-wxt-keyword-crowd-count'),
                crowdList: overlay.querySelector('#am-wxt-keyword-crowd-list'),
                clearCrowdBtn: overlay.querySelector('#am-wxt-keyword-clear-crowd'),
                debugWrap: overlay.querySelector('#am-wxt-keyword-debug-wrap'),
                preview: overlay.querySelector('#am-wxt-keyword-preview'),
                log: overlay.querySelector('#am-wxt-keyword-log')
            };

            const ensureQuickLogContainer = () => {
                if (wizardState?.els?.quickLog instanceof HTMLElement) return wizardState.els.quickLog;
                const strategyBoard = wizardState?.els?.overlay?.querySelector('.am-wxt-strategy-board');
                if (!strategyBoard) return null;
                let quickLog = strategyBoard.querySelector('#am-wxt-keyword-quick-log');
                if (!quickLog) {
                    quickLog = document.createElement('div');
                    quickLog.id = 'am-wxt-keyword-quick-log';
                    strategyBoard.appendChild(quickLog);
                }
                if (wizardState?.els) wizardState.els.quickLog = quickLog;
                return quickLog;
            };

            const appendWizardLog = (text, type = 'info') => {
                const timestampText = `[${new Date().toLocaleTimeString('zh-CN', { hour12: false })}] ${text}`;
                const appendLine = (container, maxLines = 120) => {
                    if (!container) return;
                    const line = document.createElement('div');
                    line.className = `line ${type}`;
                    line.textContent = timestampText;
                    container.appendChild(line);
                    while (container.children.length > maxLines) {
                        container.removeChild(container.firstChild);
                    }
                    container.scrollTop = container.scrollHeight;
                };

                appendLine(ensureQuickLogContainer(), 40);
                appendLine(wizardState.els.log, 160);
            };

            const formatKeywordLine = (word) => {
                const bid = toNumber(word?.bidPrice, 1);
                const matchText = parseMatchScope(word?.matchScope, DEFAULTS.matchScope) === 1 ? 'ç²¾å‡†' : 'å¹¿æ³›';
                return `${String(word?.word || '').trim()},${bid.toFixed(2)},${matchText}`;
            };
            const keywordMetricKey = (value = '') => String(value || '').trim().toLowerCase();
            const formatRatePercent = (value) => {
                const num = Number(value);
                if (!Number.isFinite(num)) return '-';
                return `${(num * 100).toFixed(2)}%`;
            };
            const formatMetricBid = (value) => {
                const num = Number(value);
                if (!Number.isFinite(num)) return '-';
                return String(num.toFixed(4)).replace(/(?:\.0+|(\.\d+?)0+)$/, '$1');
            };
            const resolveKeywordRelevanceMeta = (value) => {
                const num = toNumber(value, 3);
                if (num <= 1) return { text: 'ä½', className: 'keyword-relevance keyword-relevance-low' };
                if (num === 2) return { text: 'ä¸­', className: 'keyword-relevance keyword-relevance-mid' };
                return { text: 'å¥½', className: 'keyword-relevance' };
            };
            const buildKeywordMetricEntry = (rawWord = {}) => {
                if (!isPlainObject(rawWord)) return null;
                const word = String(rawWord.word || rawWord.keyword || '').trim();
                if (!word) return null;
                const relevanceMeta = resolveKeywordRelevanceMeta(rawWord.relevanceType);
                const searchIndex = Number(rawWord.searchIndex);
                const marketAverageBid = Number(rawWord.marketAverageBid);
                const reasonTagList = Array.isArray(rawWord.reasonTagList)
                    ? rawWord.reasonTagList.map(item => String(item?.name || '').trim()).filter(Boolean)
                    : [];
                const predictClick = Number(rawWord.predictClick);
                return {
                    word,
                    searchIndexText: Number.isFinite(searchIndex) ? String(Math.max(0, Math.round(searchIndex))) : '-',
                    marketClickRateText: formatRatePercent(rawWord.marketClickRate),
                    marketClickConversionRateText: formatRatePercent(rawWord.marketClickConversionRate),
                    marketAverageBidText: formatMetricBid(marketAverageBid),
                    relevanceText: relevanceMeta.text,
                    relevanceClassName: relevanceMeta.className,
                    reasonTagList,
                    predictClickText: Number.isFinite(predictClick) ? String(Math.max(0, predictClick).toFixed(2)) : '-'
                };
            };
            const mergeKeywordMetricMap = (wordList = []) => {
                if (!Array.isArray(wordList) || !wordList.length) return;
                const nextMap = { ...(isPlainObject(wizardState.keywordMetricMap) ? wizardState.keywordMetricMap : {}) };
                wordList.forEach(rawWord => {
                    const metricEntry = buildKeywordMetricEntry(rawWord);
                    if (!metricEntry) return;
                    const key = keywordMetricKey(metricEntry.word);
                    if (!key) return;
                    nextMap[key] = metricEntry;
                });
                wizardState.keywordMetricMap = nextMap;
            };
            const getKeywordMetricByWord = (word = '') => {
                const key = keywordMetricKey(word);
                if (!key) return null;
                return isPlainObject(wizardState.keywordMetricMap) ? wizardState.keywordMetricMap[key] || null : null;
            };

            const getCrowdDisplayName = (crowdItem = {}) => {
                const label = crowdItem?.crowd?.label || {};
                const crowdName = String(crowdItem?.crowd?.crowdName || '').trim();
                if (crowdName) return crowdName;
                const labelName = String(label?.labelName || '').trim();
                const optionNames = uniqueBy(
                    (label?.optionList || []).map(option => String(option?.optionName || '').trim()).filter(Boolean),
                    name => name
                ).join('ï¼Œ');
                return uniqueBy([labelName, optionNames].filter(Boolean), name => name).join('ï¼š') || 'æœªå‘½åäººç¾¤';
            };

            const setDebugVisible = (visible) => {
                wizardState.debugVisible = !!visible;
                if (wizardState.els.debugWrap) {
                    wizardState.els.debugWrap.classList.toggle('collapsed', !wizardState.debugVisible);
                }
                (Array.isArray(wizardState.els.toggleDebugBtns) ? wizardState.els.toggleDebugBtns : [])
                    .forEach(btn => {
                        if (!(btn instanceof HTMLButtonElement)) return;
                        btn.textContent = wizardState.debugVisible ? 'éšè—æ—¥å¿—' : 'æ‰“å¼€æ—¥å¿—';
                    });
            };
            const refreshItemSplitButtons = () => {
                const splitExpanded = wizardState.itemSplitExpanded === true;
                const listExpanded = wizardState.candidateListExpanded === true;
                if (wizardState.els.toggleCandidateBtn instanceof HTMLButtonElement) {
                    wizardState.els.toggleCandidateBtn.textContent = splitExpanded ? 'æ”¶èµ·å•†å“åº“' : 'æ·»åŠ å•†å“';
                }
                if (wizardState.els.toggleCandidateListBtn instanceof HTMLButtonElement) {
                    wizardState.els.toggleCandidateListBtn.classList.remove('hidden');
                    wizardState.els.toggleCandidateListBtn.textContent = listExpanded ? 'æ”¶èµ·å·²é€‰' : 'å±•å¼€å·²é€‰';
                }
            };
            const setCandidateListExpanded = (expanded) => {
                const nextExpanded = expanded === true;
                wizardState.candidateListExpanded = nextExpanded;
                wizardState.draft = wizardState.draft || wizardDefaultDraft();
                wizardState.draft.candidateListExpanded = nextExpanded;
                if (wizardState.els.itemSplit) {
                    wizardState.els.itemSplit.classList.toggle(
                        'candidate-list-expanded',
                        nextExpanded
                    );
                }
                refreshItemSplitButtons();
            };
            const setItemSplitExpanded = (expanded) => {
                const nextExpanded = expanded === true;
                wizardState.itemSplitExpanded = nextExpanded;
                wizardState.draft = wizardState.draft || wizardDefaultDraft();
                wizardState.draft.itemSplitExpanded = nextExpanded;
                if (wizardState.els.itemSplit) {
                    wizardState.els.itemSplit.classList.toggle('compact', !nextExpanded);
                    wizardState.els.itemSplit.classList.toggle(
                        'candidate-list-expanded',
                        wizardState.candidateListExpanded === true
                    );
                }
                refreshItemSplitButtons();
            };

            const renderSelectOptionLine = (selectEl) => {
                if (!(selectEl instanceof HTMLSelectElement)) return;
                const line = wizardState?.els?.detailConfig?.querySelector(`[data-bind-select="${selectEl.id}"]`);
                if (!(line instanceof HTMLElement)) return;
                const currentValue = String(selectEl.value || '');
                const options = Array.from(selectEl.options || []);
                line.innerHTML = '';
                options.forEach((option) => {
                    const value = String(option?.value || '');
                    const text = String(option?.textContent || option?.label || value);
                    const chip = document.createElement('button');
                    chip.type = 'button';
                    chip.className = `am-wxt-option-chip${value === currentValue ? ' active' : ''}`;
                    chip.textContent = text;
                    chip.disabled = !!selectEl.disabled;
                    chip.onclick = () => {
                        if (selectEl.disabled) return;
                        if (selectEl.value !== value) {
                            selectEl.value = value;
                            selectEl.dispatchEvent(new Event('input', { bubbles: true }));
                        }
                        selectEl.dispatchEvent(new Event('change', { bubbles: true }));
                        renderSelectOptionLine(selectEl);
                    };
                    line.appendChild(chip);
                });
            };

            const renderStaticOptionLines = () => {
                renderSelectOptionLine(wizardState?.els?.sceneSelect);
                renderSelectOptionLine(wizardState?.els?.bidModeSelect);
                renderSelectOptionLine(wizardState?.els?.bidTargetSelect);
                renderSelectOptionLine(wizardState?.els?.budgetTypeSelect);
                renderSelectOptionLine(wizardState?.els?.modeSelect);
            };

            const BID_TARGET_OPTIONS = [
                { value: 'conv', label: 'è·å–æˆäº¤é‡' },
                { value: 'ad_strategy_buy', label: 'å¢åŠ æ€»æˆäº¤é‡‘é¢' },
                { value: 'ad_strategy_retained_buy', label: 'å¢åŠ å‡€æˆäº¤é‡‘é¢' },
                { value: 'similar_item', label: 'ç›¸ä¼¼å“è·ŸæŠ•' },
                { value: 'search_rank', label: 'æŠ¢å æœç´¢å¡ä½' },
                { value: 'market_penetration', label: 'æå‡å¸‚åœºæ¸—é€' },
                { value: 'fav_cart', label: 'å¢åŠ æ”¶è—åŠ è´­é‡' },
                { value: 'click', label: 'å¢åŠ ç‚¹å‡»é‡' },
                { value: 'roi', label: 'ç¨³å®šæŠ•äº§æ¯”' }
            ];
            const SCENE_OPTIONS = SCENE_NAME_LIST.slice();
            const escapeRegExp = (text = '') => String(text || '').replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            const isAutoGeneratedPlanPrefix = (prefix = '') => {
                const value = String(prefix || '').trim();
                if (!value) return true;
                if (
                    /^[^_\s]+_\d{8}$/.test(value)
                    || /^[^_\s]+_\d{14}$/.test(value)
                    || /^[^_\s]+_\d{8}_\d{6}$/.test(value)
                    || /^[^_\s]+_\d{14}_\d+$/.test(value)
                    || /^[^_\s]+_\d{8}_\d{6}_\d+$/.test(value)
                ) return true;
                return SCENE_OPTIONS.some(scene => {
                    const escaped = escapeRegExp(scene);
                    return new RegExp(`^${escaped}_\\d{8}$`).test(value)
                        || new RegExp(`^${escaped}_\\d{14}$`).test(value)
                        || new RegExp(`^${escaped}_\\d{8}_\\d{6}$`).test(value)
                        || new RegExp(`^${escaped}_\\d{14}_\\d+$`).test(value)
                        || new RegExp(`^${escaped}_\\d{8}_\\d{6}_\\d+$`).test(value);
                });
            };
            const buildDefaultPlanPrefixByScene = (sceneName = '') => buildSceneTimePrefix(sceneName || wizardState?.draft?.sceneName || 'å…³é”®è¯æ¨å¹¿');
            const stripAutoPlanSerialSuffix = (rawValue = '') => {
                const value = String(rawValue || '').trim();
                if (!value) return '';
                if (/^[^_\s]+_\d{14}_\d+$/.test(value) || /^[^_\s]+_\d{8}_\d{6}_\d+$/.test(value)) {
                    return value.replace(/_\d+$/, '');
                }
                return value;
            };
            const getCurrentEditorSceneName = () => {
                const selected = String(wizardState?.els?.sceneSelect?.value || wizardState?.draft?.sceneName || 'å…³é”®è¯æ¨å¹¿').trim();
                return SCENE_OPTIONS.includes(selected) ? selected : 'å…³é”®è¯æ¨å¹¿';
            };
            const createStrategyCloneId = (seed = 'strategy') => `${String(seed || 'strategy').replace(/[^\w]/g, '_')}_${Date.now()}_${Math.random().toString(36).slice(2, 7)}`;
            const createStrategyCloneName = (baseName = '') => {
                const sourceName = String(baseName || '').trim() || 'è®¡åˆ’';
                const usedNameSet = new Set((wizardState.strategyList || []).map(item => String(item?.name || '').trim()).filter(Boolean));
                let candidate = `${sourceName}_å¤åˆ¶`;
                let cursor = 2;
                while (usedNameSet.has(candidate) && cursor < 99) {
                    candidate = `${sourceName}_å¤åˆ¶${cursor}`;
                    cursor += 1;
                }
                return candidate;
            };
            const createNewStrategyName = (sceneName = '') => {
                const base = `${String(sceneName || 'å…³é”®è¯æ¨å¹¿').trim() || 'å…³é”®è¯æ¨å¹¿'}-æ–°å»ºè®¡åˆ’`;
                const usedNameSet = new Set((wizardState.strategyList || []).map(item => String(item?.name || '').trim()).filter(Boolean));
                if (!usedNameSet.has(base)) return base;
                let cursor = 2;
                let candidate = `${base}${cursor}`;
                while (usedNameSet.has(candidate) && cursor < 999) {
                    cursor += 1;
                    candidate = `${base}${cursor}`;
                }
                return candidate;
            };
            const ensureUniqueStrategyPlanName = (basePlanName = '', ignoreStrategyId = '') => {
                const seed = String(basePlanName || '').trim();
                if (!seed) return buildDefaultPlanPrefixByScene(getCurrentEditorSceneName());
                const usedPlanNames = new Set(
                    (wizardState.strategyList || [])
                        .filter(item => String(item?.id || '') !== String(ignoreStrategyId || ''))
                        .map(item => String(item?.planName || '').trim())
                        .filter(Boolean)
                );
                if (!usedPlanNames.has(seed)) return seed;
                let cursor = 2;
                let candidate = `${seed}_${cursor}`;
                while (usedPlanNames.has(candidate) && cursor < 99) {
                    cursor += 1;
                    candidate = `${seed}_${cursor}`;
                }
                return candidate;
            };
            const buildCopiedStrategyPlanName = (sourcePlanName = '', sceneName = '', copyIndex = 0) => {
                const raw = String(sourcePlanName || '').trim();
                const fallback = buildDefaultPlanPrefixByScene(sceneName || getCurrentEditorSceneName());
                const baseSeed = raw || fallback;
                const base = /(?:_\d{8}|\d{14}|_\d{8}_\d{6})$/.test(baseSeed)
                    ? baseSeed
                    : baseSeed.replace(/_\d+$/, '');
                const suffix = Math.max(1, toNumber(copyIndex, 1));
                const next = `${base}_${suffix}`;
                return ensureUniqueStrategyPlanName(next);
            };
            const normalizeKeywordBidTargetOptionValue = (bidTarget = '') => {
                const value = String(bidTarget || '').trim();
                if (!value) return '';
                if (value === 'coll_cart') return 'fav_cart';
                if (value === 'word_penetration_rate') return 'market_penetration';
                return value;
            };
            const getStrategyTargetLabel = (strategy = {}) => {
                const bidTargetValue = normalizeKeywordBidTargetOptionValue(
                    String(strategy?.bidTargetV2 || DEFAULTS.bidTargetV2).trim() || DEFAULTS.bidTargetV2
                ) || DEFAULTS.bidTargetV2;
                return BID_TARGET_OPTIONS.find(item => item.value === bidTargetValue)?.label || 'è·å–æˆäº¤é‡';
            };
            const resolveKeywordCustomBidTargetAlias = (bidTarget = '', marketingGoal = '') => {
                const value = String(bidTarget || '').trim();
                if (!value) return '';
                const goal = normalizeGoalLabel(marketingGoal);
                if (goal !== 'è‡ªå®šä¹‰æ¨å¹¿') return value;
                if (value === 'fav_cart') return 'coll_cart';
                if (value === 'market_penetration') return 'word_penetration_rate';
                return value;
            };
            const detectKeywordGoalFromText = (text = '') => {
                const value = normalizeGoalLabel(text);
                if (!value) return '';
                if (/æœç´¢å¡ä½|å¡ä½/.test(value)) return 'æœç´¢å¡ä½';
                if (/è¶‹åŠ¿æ˜æ˜Ÿ|è¶‹åŠ¿/.test(value)) return 'è¶‹åŠ¿æ˜æ˜Ÿ';
                if (/æµé‡é‡‘å¡|é‡‘å¡/.test(value)) return 'æµé‡é‡‘å¡';
                if (/è‡ªå®šä¹‰æ¨å¹¿|è‡ªå®šä¹‰/.test(value)) return 'è‡ªå®šä¹‰æ¨å¹¿';
                return '';
            };
            const detectKeywordGoalFromBidTarget = (bidTarget = '') => {
                const value = String(bidTarget || '').trim();
                if (!value) return '';
                if (value === 'search_rank') return 'æœç´¢å¡ä½';
                if (value === 'market_penetration' || value === 'word_penetration_rate') return 'è¶‹åŠ¿æ˜æ˜Ÿ';
                if (value === 'click') return 'æµé‡é‡‘å¡';
                return 'è‡ªå®šä¹‰æ¨å¹¿';
            };
            const resolveKeywordGoalFromSceneSettings = (sceneSettings = {}) => {
                const settings = isPlainObject(sceneSettings) ? sceneSettings : {};
                return normalizeGoalLabel(
                    settings.è¥é”€ç›®æ ‡
                    || settings.é€‰æ‹©å¡ä½æ–¹æ¡ˆ
                    || settings.ä¼˜åŒ–ç›®æ ‡
                    || ''
                );
            };
            const resolveGenericGoalFromSceneSettings = (sceneSettings = {}) => {
                const settings = isPlainObject(sceneSettings) ? sceneSettings : {};
                return normalizeGoalLabel(
                    settings.è¥é”€ç›®æ ‡
                    || settings.é€‰æ‹©å¡ä½æ–¹æ¡ˆ
                    || settings.é€‰æ‹©æ‹‰æ–°æ–¹æ¡ˆ
                    || settings.é€‰æ‹©æ–¹æ¡ˆ
                    || settings.é€‰æ‹©ä¼˜åŒ–æ–¹å‘
                    || settings.é€‰æ‹©è§£å†³æ–¹æ¡ˆ
                    || settings.æŠ•æ”¾ç­–ç•¥
                    || settings.æ¨å¹¿æ¨¡å¼
                    || settings.é€‰æ‹©æ–¹å¼
                    || settings.ä¼˜åŒ–ç›®æ ‡
                    || ''
                );
            };
            const resolveStrategyMarketingGoal = (strategy = {}, sceneSettings = {}, sceneName = '') => {
                const currentScene = SCENE_OPTIONS.includes(String(sceneName || '').trim())
                    ? String(sceneName || '').trim()
                    : getCurrentEditorSceneName();
                if (currentScene !== 'å…³é”®è¯æ¨å¹¿') {
                    const sceneGoalOptions = getSceneMarketingGoalFallbackList(currentScene);
                    const pickGoalByScene = (text = '') => {
                        const normalized = normalizeGoalLabel(text);
                        if (!normalized) return '';
                        if (!sceneGoalOptions.length) return normalized;
                        const exact = sceneGoalOptions.find(goal => normalizeGoalLabel(goal) === normalized);
                        if (exact) return exact;
                        const included = sceneGoalOptions.find(goal => normalized.includes(goal) || goal.includes(normalized));
                        if (included) return included;
                        return '';
                    };
                    const fromStrategy = pickGoalByScene(strategy?.marketingGoal || '');
                    if (fromStrategy) return fromStrategy;
                    const fromName = pickGoalByScene(strategy?.name || '');
                    if (fromName) return fromName;
                    const fromPlanName = pickGoalByScene(strategy?.planName || '');
                    if (fromPlanName) return fromPlanName;
                    const fromScene = pickGoalByScene(resolveGenericGoalFromSceneSettings(sceneSettings));
                    if (fromScene) return fromScene;
                    return sceneGoalOptions[0] || '';
                }
                const fromScene = detectKeywordGoalFromText(resolveKeywordGoalFromSceneSettings(sceneSettings));
                if (fromScene) return fromScene;
                const fromStrategy = detectKeywordGoalFromText(strategy?.marketingGoal || '');
                if (fromStrategy) return fromStrategy;
                const fromBidTarget = detectKeywordGoalFromBidTarget(strategy?.bidTargetV2 || '');
                if (fromBidTarget) return fromBidTarget;
                const fromName = detectKeywordGoalFromText(strategy?.name || '');
                if (fromName) return fromName;
                const fromPlanName = detectKeywordGoalFromText(strategy?.planName || '');
                if (fromPlanName) return fromPlanName;
                return getSceneMarketingGoalFallbackList(currentScene)[0] || 'è¶‹åŠ¿æ˜æ˜Ÿ';
            };
            const getStrategyMainLabel = (strategy = {}) => {
                const explicitPlanName = String(strategy?.planName || '').trim();
                if (explicitPlanName) return explicitPlanName;
                const getStrategyAutoPlanPrefix = (targetStrategy = {}) => {
                    const strategyScene = SCENE_OPTIONS.includes(String(targetStrategy?.sceneName || '').trim())
                        ? String(targetStrategy.sceneName).trim()
                        : getCurrentEditorSceneName();
                    const existingPrefix = String(targetStrategy?.autoPlanPrefix || '').trim();
                    if (existingPrefix) return existingPrefix;
                    const draftScene = String(wizardState?.draft?.sceneName || '').trim();
                    const draftPrefix = String(wizardState?.draft?.planNamePrefix || '').trim();
                    const fallbackPrefix = draftPrefix && draftScene === strategyScene
                        ? draftPrefix
                        : buildSceneTimePrefix(strategyScene);
                    if (isPlainObject(targetStrategy)) {
                        targetStrategy.autoPlanPrefix = fallbackPrefix;
                    }
                    return fallbackPrefix;
                };
                const scenePrefix = getStrategyAutoPlanPrefix(strategy);
                const strategyList = Array.isArray(wizardState?.strategyList) ? wizardState.strategyList : [];
                const strategyIndex = strategyList.findIndex(item => String(item?.id || '') === String(strategy?.id || ''));
                if (strategyIndex >= 0) {
                    return `${scenePrefix}_${String(strategyIndex + 1).padStart(2, '0')}`;
                }
                return scenePrefix;
            };
            const updateBidModeControls = (modeValue = 'smart') => {
                const bidMode = normalizeBidMode(modeValue, 'smart');
                const isManual = bidMode === 'manual';
                if (wizardState.els.bidModeSelect) {
                    wizardState.els.bidModeSelect.value = bidMode;
                }
                if (wizardState.els.bidTargetRow instanceof HTMLElement) {
                    wizardState.els.bidTargetRow.style.display = isManual ? 'none' : '';
                }
                if (wizardState.els.bidTargetSelect) {
                    wizardState.els.bidTargetSelect.disabled = isManual;
                    wizardState.els.bidTargetSelect.title = isManual ? 'æ‰‹åŠ¨å‡ºä»·æ¨¡å¼ä¸‹ä¸å¯ç”¨å‡ºä»·ç›®æ ‡' : '';
                }
                if (wizardState.els.singleCostEnableInput) {
                    if (isManual) wizardState.els.singleCostEnableInput.checked = false;
                    wizardState.els.singleCostEnableInput.disabled = isManual;
                }
                if (wizardState.els.singleCostInput) {
                    wizardState.els.singleCostInput.disabled = isManual || !wizardState.els.singleCostEnableInput?.checked;
                }
                renderStaticOptionLines();
            };
            const SCENE_REQUIREMENT_FALLBACK = {
                'è´§å“å…¨ç«™æ¨å¹¿': ['é€‰æ‹©æ¨å¹¿å•†å“', 'æ·»åŠ å•†å“', 'è®¾ç½®å•†å“æ¨å¹¿æ–¹æ¡ˆ', 'è®¾ç½®é¢„ç®—', 'é¢„ç®—ç±»å‹', 'è®¾ç½®åŸºç¡€ä¿¡æ¯', 'è®¡åˆ’åç§°', 'é«˜çº§è®¾ç½®'],
                'å…³é”®è¯æ¨å¹¿': ['è¥é”€ç›®æ ‡', 'é€‰æ‹©å¡ä½æ–¹æ¡ˆ', 'æ ¸å¿ƒè¯è®¾ç½®', 'æ·»åŠ å•†å“', 'å¡ä½æ–¹å¼', 'è®¾ç½®é¢„ç®—', 'é¢„ç®—ç±»å‹', 'è®¾ç½®åŸºç¡€ä¿¡æ¯', 'è®¡åˆ’åç§°', 'é«˜çº§è®¾ç½®'],
                'äººç¾¤æ¨å¹¿': ['è¥é”€ç›®æ ‡', 'é€‰æ‹©æ‹‰æ–°æ–¹æ¡ˆ', 'é€‰æ‹©æ¨å¹¿å•†å“', 'æ·»åŠ å•†å“', 'è®¾ç½®æ‹‰æ–°äººç¾¤', 'é€‰æ‹©æ–¹å¼', 'è®¾ç½®é¢„ç®—åŠæ’æœŸ', 'é¢„ç®—ç±»å‹', 'è®¾ç½®åŸºç¡€ä¿¡æ¯', 'è®¡åˆ’åç§°', 'é«˜çº§è®¾ç½®'],
                'åº—é“ºç›´è¾¾': ['è®¾ç½®åˆ›æ„', 'è®¾ç½®æ¨å¹¿æ–¹æ¡ˆ', 'è®¾ç½®è¯åŒ…', 'è®¾ç½®é¢„ç®—åŠæ’æœŸ', 'é¢„ç®—ç±»å‹', 'æ¯æ—¥é¢„ç®—', 'è®¾ç½®åŸºç¡€ä¿¡æ¯', 'è®¡åˆ’åç§°', 'é«˜çº§è®¾ç½®'],
                'å†…å®¹è¥é”€': ['é€‰æ‹©ä¼˜åŒ–æ–¹å‘', 'é€‰æ‹©æ–¹æ¡ˆ', 'ä¼˜åŒ–ç›®æ ‡', 'é€‰æ‹©æ¨å¹¿ä¸»ä½“', 'è®¾ç½®é¢„ç®—åŠæ’æœŸ', 'æŠ•æ”¾æ—¥æœŸ', 'å‡ºä»·æ–¹å¼', 'è®¾ç½®äººç¾¤', 'è®¾ç½®åŸºç¡€ä¿¡æ¯', 'è®¾ç½®åˆ›æ„', 'è®¡åˆ’åç§°', 'é«˜çº§è®¾ç½®'],
                'çº¿ç´¢æ¨å¹¿': ['è¥é”€ç›®æ ‡', 'é€‰æ‹©è§£å†³æ–¹æ¡ˆ', 'æŠ•æ”¾ç­–ç•¥', 'ä¼˜åŒ–ç›®æ ‡', 'é€‰æ‹©æ¨å¹¿å•†å“', 'æ·»åŠ å•†å“', 'æ ¸å¿ƒè¯è®¾ç½®', 'ç§å­äººç¾¤', 'å¥—é¤åŒ…', 'æŠ•æ”¾æ—¥æœŸ', 'è®¾ç½®é¢„ç®—åŠæ’æœŸ', 'è®¾ç½®åŸºç¡€ä¿¡æ¯', 'è®¡åˆ’åç§°', 'é«˜çº§è®¾ç½®']
            };
            const SCENE_FIELD_OPTION_FALLBACK = [
                { pattern: /(è¥é”€ç›®æ ‡|é€‰æ‹©å¡ä½æ–¹æ¡ˆ|é€‰æ‹©æ‹‰æ–°æ–¹æ¡ˆ|é€‰æ‹©æ–¹æ¡ˆ|é€‰æ‹©ä¼˜åŒ–æ–¹å‘|é€‰æ‹©è§£å†³æ–¹æ¡ˆ|æŠ•æ”¾ç­–ç•¥|æ¨å¹¿æ¨¡å¼)/, options: [] },
                { pattern: /(è¥é”€åœºæ™¯)/, options: ['å…¨åŸŸæŠ•æ”¾ Â· ROIç¡®å®šäº¤ä»˜'] },
                { pattern: /(é¢„ç®—ç±»å‹)/, options: ['ä¸é™é¢„ç®—', 'æ¯æ—¥é¢„ç®—', 'æ—¥å‡é¢„ç®—', 'æ€»é¢„ç®—'] },
                { pattern: /(å‡ºä»·æ–¹å¼)/, options: ['æ™ºèƒ½å‡ºä»·', 'æ‰‹åŠ¨å‡ºä»·', 'æœ€å¤§åŒ–æ‹¿é‡', 'æ§æˆæœ¬', 'æ§æŠ•äº§æ¯”æŠ•æ”¾', 'æ§æŠ•äº§æ¯”'] },
                { pattern: /(å‡ºä»·ç›®æ ‡|ä¼˜åŒ–ç›®æ ‡)/, options: ['å¢åŠ æ€»æˆäº¤é‡‘é¢', 'å¢åŠ å‡€æˆäº¤é‡‘é¢', 'è·å–æˆäº¤é‡', 'ç¨³å®šæŠ•äº§æ¯”', 'å¢åŠ ç‚¹å‡»é‡', 'å¢åŠ æ”¶è—åŠ è´­é‡', 'æå‡å¸‚åœºæ¸—é€', 'ä¼˜åŒ–ç•™èµ„è·å®¢æˆæœ¬', 'æ‹‰æ–°æ¸—é€', 'æ‰©å¤§æ–°å®¢è§„æ¨¡', 'ç¨³å®šæ–°å®¢æŠ•äº§æ¯”', 'æ–°å®¢æ”¶è—åŠ è´­', 'å¢åŠ æˆäº¤é‡‘é¢', 'å¢åŠ è§‚çœ‹æ¬¡æ•°', 'å¢åŠ è§‚çœ‹æ—¶é•¿'] },
                { pattern: /(å…³é”®è¯è®¾ç½®|æ ¸å¿ƒè¯è®¾ç½®|è®¾ç½®è¯åŒ…)/, options: ['æ·»åŠ å…³é”®è¯', 'ç³»ç»Ÿæ¨èè¯', 'æ‰‹åŠ¨è‡ªé€‰è¯'] },
                { pattern: /(åŒ¹é…æ–¹å¼)/, options: ['å¹¿æ³›', 'ä¸­å¿ƒè¯', 'ç²¾å‡†'] },
                { pattern: /(æµé‡æ™ºé€‰)/, options: ['å¼€å¯', 'å…³é—­'] },
                { pattern: /(å†·å¯åŠ é€Ÿ)/, options: ['å¼€å¯', 'å…³é—­'] },
                { pattern: /(äººç¾¤è®¾ç½®|ç§å­äººç¾¤|è®¾ç½®æ‹‰æ–°äººç¾¤|è®¾ç½®äººç¾¤)/, options: ['æ™ºèƒ½äººç¾¤', 'æ·»åŠ ç§å­äººç¾¤', 'è®¾ç½®ä¼˜å…ˆæŠ•æ”¾å®¢æˆ·', 'å…³é—­'] },
                { pattern: /(é€‰å“æ–¹å¼|é€‰æ‹©æ¨å¹¿å•†å“)/, options: ['è‡ªå®šä¹‰é€‰å“', 'è¡Œä¸šæ¨èé€‰å“'] },
                { pattern: /(æŠ•æ”¾è°ƒä¼˜|ä¼˜åŒ–æ¨¡å¼)/, options: ['å¤šç›®æ ‡ä¼˜åŒ–', 'æ—¥å¸¸ä¼˜åŒ–'] },
                { pattern: /(æŠ•æ”¾åœ°åŸŸ|åœ°åŸŸè®¾ç½®)/, options: ['å…¨éƒ¨åœ°åŸŸ'] },
                { pattern: /(æŠ•æ”¾æ—¶é—´|æŠ•æ”¾æ—¥æœŸ|å‘å¸ƒæ—¥æœŸ|æ’æœŸ)/, options: ['é•¿æœŸæŠ•æ”¾', 'ä¸é™æ—¶æ®µ', 'å›ºå®šæ—¶æ®µ'] },
                { pattern: /(è®¡åˆ’ç»„|è®¾ç½®è®¡åˆ’ç»„)/, options: ['ä¸è®¾ç½®è®¡åˆ’ç»„'] }
            ];
            const SCENE_FALLBACK_OPTION_MAP = {
                'è´§å“å…¨ç«™æ¨å¹¿': {
                    è¥é”€ç›®æ ‡: ['è´§å“å…¨ç«™æ¨å¹¿'],
                    è¥é”€åœºæ™¯: ['å…¨åŸŸæŠ•æ”¾ Â· ROIç¡®å®šäº¤ä»˜'],
                    é€‰å“æ–¹å¼: ['è‡ªå®šä¹‰é€‰å“', 'è¡Œä¸šæ¨èé€‰å“'],
                    å‡ºä»·æ–¹å¼: ['æ§æŠ•äº§æ¯”æŠ•æ”¾', 'æœ€å¤§åŒ–æ‹¿é‡'],
                    å‡ºä»·ç›®æ ‡: ['å¢åŠ æ€»æˆäº¤é‡‘é¢', 'å¢åŠ å‡€æˆäº¤é‡‘é¢'],
                    ç›®æ ‡æŠ•äº§æ¯”: ['5'],
                    é¢„ç®—ç±»å‹: ['ä¸é™é¢„ç®—', 'æ¯æ—¥é¢„ç®—', 'æ—¥å‡é¢„ç®—'],
                    æŠ•æ”¾è°ƒä¼˜: ['å¤šç›®æ ‡ä¼˜åŒ–', 'æ—¥å¸¸ä¼˜åŒ–'],
                    å‘å¸ƒæ—¥æœŸ: ['é•¿æœŸæŠ•æ”¾', 'ç«‹å³æŠ•æ”¾'],
                    æŠ•æ”¾æ—¶é—´: ['é•¿æœŸæŠ•æ”¾', 'ä¸é™æ—¶æ®µ', 'å›ºå®šæ—¶æ®µ'],
                    æŠ•æ”¾åœ°åŸŸ: ['å…¨éƒ¨åœ°åŸŸ'],
                    è®¾ç½®è®¡åˆ’ç»„: ['ä¸è®¾ç½®è®¡åˆ’ç»„'],
                    è®¡åˆ’ç»„: ['ä¸è®¾ç½®è®¡åˆ’ç»„']
                },
                'å…³é”®è¯æ¨å¹¿': {
                    è¥é”€ç›®æ ‡: ['æœç´¢å¡ä½', 'è¶‹åŠ¿æ˜æ˜Ÿ', 'æµé‡é‡‘å¡', 'è‡ªå®šä¹‰æ¨å¹¿'],
                    é€‰æ‹©å¡ä½æ–¹æ¡ˆ: ['æœç´¢å¡ä½', 'è¶‹åŠ¿æ˜æ˜Ÿ', 'æµé‡é‡‘å¡', 'è‡ªå®šä¹‰æ¨å¹¿'],
                    å¡ä½æ–¹å¼: ['æŠ¢é¦–æ¡', 'æŠ¢å‰ä¸‰', 'æŠ¢é¦–é¡µ'],
                    åŒ¹é…æ–¹å¼: ['å¹¿æ³›', 'ä¸­å¿ƒè¯', 'ç²¾å‡†'],
                    æµé‡æ™ºé€‰: ['å¼€å¯', 'å…³é—­'],
                    å¼€å¯å†·å¯åŠ é€Ÿ: ['å¼€å¯', 'å…³é—­'],
                    å†·å¯åŠ é€Ÿ: ['å¼€å¯', 'å…³é—­'],
                    äººç¾¤è®¾ç½®: ['æ™ºèƒ½äººç¾¤', 'æ·»åŠ ç§å­äººç¾¤', 'è®¾ç½®ä¼˜å…ˆæŠ•æ”¾å®¢æˆ·', 'å…³é—­'],
                    æ·»åŠ å•†å“: ['å…¨éƒ¨å•†å“', 'æœºä¼šå“æ¨è', 'è‡ªå®šä¹‰é€‰å“'],
                    å‡ºä»·æ–¹å¼: ['æ™ºèƒ½å‡ºä»·', 'æ‰‹åŠ¨å‡ºä»·'],
                    å‡ºä»·ç›®æ ‡: ['è·å–æˆäº¤é‡', 'ç›¸ä¼¼å“è·ŸæŠ•', 'æŠ¢å æœç´¢å¡ä½', 'æå‡å¸‚åœºæ¸—é€', 'å¢åŠ æ”¶è—åŠ è´­é‡', 'å¢åŠ ç‚¹å‡»é‡', 'ç¨³å®šæŠ•äº§æ¯”'],
                    ä¼˜åŒ–ç›®æ ‡: ['è·å–æˆäº¤é‡', 'ç›¸ä¼¼å“è·ŸæŠ•', 'æŠ¢å æœç´¢å¡ä½', 'æå‡å¸‚åœºæ¸—é€', 'å¢åŠ æ”¶è—åŠ è´­é‡', 'å¢åŠ ç‚¹å‡»é‡', 'ç¨³å®šæŠ•äº§æ¯”'],
                    é¢„ç®—ç±»å‹: ['æ¯æ—¥é¢„ç®—', 'æ—¥å‡é¢„ç®—']
                },
                'äººç¾¤æ¨å¹¿': {
                    è¥é”€ç›®æ ‡: ['é«˜æ•ˆæ‹‰æ–°', 'ç«åº—æ‹‰æ–°', 'å€ŸåŠ¿è½¬åŒ–', 'æœºä¼šäººç¾¤æ‹‰æ–°', 'è·¨ç±»ç›®æ‹‰æ–°'],
                    é€‰æ‹©æ‹‰æ–°æ–¹æ¡ˆ: ['é«˜æ•ˆæ‹‰æ–°', 'ç«åº—æ‹‰æ–°', 'å€ŸåŠ¿è½¬åŒ–', 'æœºä¼šäººç¾¤æ‹‰æ–°', 'è·¨ç±»ç›®æ‹‰æ–°'],
                    æŠ•æ”¾ç­–ç•¥: ['é«˜æ•ˆæ‹‰æ–°', 'ç«åº—æ‹‰æ–°', 'å€ŸåŠ¿è½¬åŒ–', 'æœºä¼šäººç¾¤æ‹‰æ–°', 'è·¨ç±»ç›®æ‹‰æ–°'],
                    å‡ºä»·æ–¹å¼: ['æ‰‹åŠ¨å‡ºä»·'],
                    å‡ºä»·ç›®æ ‡: ['æ‹‰æ–°æ¸—é€', 'æ‰©å¤§æ–°å®¢è§„æ¨¡', 'ç¨³å®šæ–°å®¢æŠ•äº§æ¯”', 'æ–°å®¢æ”¶è—åŠ è´­'],
                    ä¼˜åŒ–ç›®æ ‡: ['æ‹‰æ–°æ¸—é€', 'æ‰©å¤§æ–°å®¢è§„æ¨¡', 'ç¨³å®šæ–°å®¢æŠ•äº§æ¯”', 'æ–°å®¢æ”¶è—åŠ è´­'],
                    é¢„ç®—ç±»å‹: ['æ¯æ—¥é¢„ç®—', 'æ—¥å‡é¢„ç®—']
                },
                'åº—é“ºç›´è¾¾': {
                    æ¨å¹¿æ¨¡å¼: ['æŒç»­æ¨å¹¿'],
                    å‡ºä»·æ–¹å¼: ['æ™ºèƒ½å‡ºä»·', 'æ‰‹åŠ¨å‡ºä»·'],
                    å‡ºä»·ç›®æ ‡: ['è·å–æˆäº¤é‡', 'ç¨³å®šæŠ•äº§æ¯”', 'å¢åŠ ç‚¹å‡»é‡'],
                    é¢„ç®—ç±»å‹: ['æ¯æ—¥é¢„ç®—', 'æ—¥å‡é¢„ç®—']
                },
                'å†…å®¹è¥é”€': {
                    è¥é”€ç›®æ ‡: ['ç›´æ’­é—´æˆé•¿', 'å•†å“æ‰“çˆ†', 'æ‹‰æ–°å¢ç²‰'],
                    é€‰æ‹©ä¼˜åŒ–æ–¹å‘: ['ç›´æ’­é—´æˆé•¿', 'å•†å“æ‰“çˆ†', 'æ‹‰æ–°å¢ç²‰'],
                    é€‰æ‹©æ–¹æ¡ˆ: ['ç›´æ’­é—´æˆé•¿', 'å•†å“æ‰“çˆ†', 'æ‹‰æ–°å¢ç²‰'],
                    å‡ºä»·æ–¹å¼: ['æœ€å¤§åŒ–æ‹¿é‡', 'æ§æˆæœ¬'],
                    ä¼˜åŒ–ç›®æ ‡: ['å¢åŠ å‡€æˆäº¤é‡‘é¢', 'å¢åŠ æˆäº¤é‡‘é¢', 'å¢åŠ è§‚çœ‹æ¬¡æ•°', 'å¢åŠ è§‚çœ‹æ—¶é•¿'],
                    é¢„ç®—ç±»å‹: ['æ¯æ—¥é¢„ç®—', 'æ—¥å‡é¢„ç®—']
                },
                'çº¿ç´¢æ¨å¹¿': {
                    è¥é”€ç›®æ ‡: ['æ”¶é›†é”€å”®çº¿ç´¢', 'è¡Œä¸šè§£å†³æ–¹æ¡ˆ'],
                    é€‰æ‹©è§£å†³æ–¹æ¡ˆ: ['è¡Œä¸šè§£å†³æ–¹æ¡ˆ', 'è‡ªå®šä¹‰æ–¹æ¡ˆ'],
                    è§£å†³æ–¹æ¡ˆ: ['è¡Œä¸šè§£å†³æ–¹æ¡ˆ', 'è‡ªå®šä¹‰æ–¹æ¡ˆ'],
                    æŠ•æ”¾ç­–ç•¥: ['è¡Œä¸šè§£å†³æ–¹æ¡ˆ', 'è‡ªå®šä¹‰æ–¹æ¡ˆ'],
                    å‡ºä»·æ–¹å¼: ['æœ€å¤§åŒ–æ‹¿é‡', 'æ§æˆæœ¬'],
                    ä¼˜åŒ–ç›®æ ‡: ['ä¼˜åŒ–ç•™èµ„è·å®¢æˆæœ¬', 'è·å–æˆäº¤é‡'],
                    é¢„ç®—ç±»å‹: ['æ¯æ—¥é¢„ç®—', 'æ—¥å‡é¢„ç®—']
                }
            };
            const SCENE_STRICT_OPTION_TYPE_SET = new Set(['goal', 'bidType', 'bidTarget', 'budgetType', 'itemMode', 'keyword', 'crowd', 'schedule']);

            const normalizeSceneFieldKey = (label = '') => {
                const raw = String(label || '').trim();
                if (!raw) return 'field';
                // Keep explicit API paths for direct field passthrough.
                if (/^(campaign|adgroup)\./i.test(raw)) return raw.replace(/\s+/g, '');
                const normalized = raw
                    .replace(/[^\u4e00-\u9fa5A-Za-z0-9]+/g, '_')
                    .replace(/^_+|_+$/g, '');
                return normalized || 'field';
            };

            const ensureSceneSettingBucket = (sceneName) => {
                wizardState.draft = wizardState.draft || wizardDefaultDraft();
                if (!isPlainObject(wizardState.draft.sceneSettingValues)) {
                    wizardState.draft.sceneSettingValues = {};
                }
                if (!isPlainObject(wizardState.draft.sceneSettingValues[sceneName])) {
                    wizardState.draft.sceneSettingValues[sceneName] = {};
                }
                return wizardState.draft.sceneSettingValues[sceneName];
            };

            const ensureSceneTouchedBucket = (sceneName) => {
                wizardState.draft = wizardState.draft || wizardDefaultDraft();
                if (!isPlainObject(wizardState.draft.sceneSettingTouched)) {
                    wizardState.draft.sceneSettingTouched = {};
                }
                if (!isPlainObject(wizardState.draft.sceneSettingTouched[sceneName])) {
                    wizardState.draft.sceneSettingTouched[sceneName] = {};
                }
                return wizardState.draft.sceneSettingTouched[sceneName];
            };
            const normalizeSceneSettingBucketValues = (rawValues = {}) => {
                if (!isPlainObject(rawValues)) return {};
                const out = {};
                Object.keys(rawValues).forEach(rawKey => {
                    const key = normalizeSceneFieldKey(rawKey);
                    if (!key) return;
                    const value = normalizeSceneSettingValue(rawValues[rawKey]);
                    if (!value) return;
                    out[key] = value;
                });
                return out;
            };
            const normalizeSceneSettingTouchedValues = (rawTouched = {}) => {
                if (!isPlainObject(rawTouched)) return {};
                const out = {};
                Object.keys(rawTouched).forEach(rawKey => {
                    const key = normalizeSceneFieldKey(rawKey);
                    if (!key) return;
                    if (rawTouched[rawKey] === true) out[key] = true;
                });
                return out;
            };

            const normalizeSceneLabelToken = (text = '') => normalizeText(String(text || '').replace(/[ï¼š:]/g, ''));
            const SCENE_CONNECTED_SETTING_LABEL_RE = /^(è¥é”€ç›®æ ‡|è¥é”€åœºæ™¯|é€‰æ‹©å¡ä½æ–¹æ¡ˆ|é€‰æ‹©æ‹‰æ–°æ–¹æ¡ˆ|é€‰æ‹©æ–¹æ¡ˆ|é€‰æ‹©ä¼˜åŒ–æ–¹å‘|é€‰æ‹©è§£å†³æ–¹æ¡ˆ|æŠ•æ”¾ç­–ç•¥|æŠ•æ”¾è°ƒä¼˜|ä¼˜åŒ–æ¨¡å¼|æ¨å¹¿æ¨¡å¼|å¡ä½æ–¹å¼|é€‰æ‹©æ–¹å¼|å‡ºä»·æ–¹å¼|å‡ºä»·ç›®æ ‡|ç›®æ ‡æŠ•äº§æ¯”|å‡€ç›®æ ‡æŠ•äº§æ¯”|ROIç›®æ ‡å€¼|å‡ºä»·ç›®æ ‡å€¼|çº¦æŸå€¼|ä¼˜åŒ–ç›®æ ‡|å¤šç›®æ ‡é¢„ç®—|ä¸€é”®èµ·é‡é¢„ç®—|ä¸“å±æƒç›Š|é¢„ç®—ç±»å‹|æ¯æ—¥é¢„ç®—|æ—¥å‡é¢„ç®—|æ€»é¢„ç®—|å†»ç»“é¢„ç®—|æœªæ¥é¢„ç®—|é¢„ç®—å€¼|å¹³å‡ç›´æ¥æˆäº¤æˆæœ¬|æ‰£è´¹æ–¹å¼|è®¡è´¹æ–¹å¼|æ”¶è´¹æ–¹å¼|æ”¯ä»˜æ–¹å¼|åˆ›æ„è®¾ç½®|è®¾ç½®åˆ›æ„|åˆ›æ„æ¨¡å¼|åˆ›æ„ä¼˜é€‰|å°é¢æ™ºèƒ½åˆ›æ„|æŠ•æ”¾æ—¶é—´|æŠ•æ”¾æ—¥æœŸ|å‘å¸ƒæ—¥æœŸ|æ’æœŸ|æŠ•æ”¾åœ°åŸŸ|åœ°åŸŸè®¾ç½®|èµ·é‡æ—¶é—´åœ°åŸŸè®¾ç½®|è®¡åˆ’ç»„|è®¾ç½®è®¡åˆ’ç»„|é€‰å“æ–¹å¼|é€‰æ‹©æ¨å¹¿å•†å“|äººç¾¤è®¾ç½®|è®¾ç½®æ‹‰æ–°äººç¾¤|è®¾ç½®äººç¾¤|ç§å­äººç¾¤|æ–¹æ¡ˆé€‰æ‹©)$/;
            const SCENE_RENDER_FIELD_ALIAS_RULES = [
                { pattern: /^(å…³é”®è¯è®¾ç½®|æ ¸å¿ƒè¯è®¾ç½®)$/, label: 'æ ¸å¿ƒè¯è®¾ç½®' },
                { pattern: /^(å¼€å¯å†·å¯åŠ é€Ÿ|å†·å¯åŠ é€Ÿ)$/, label: 'å†·å¯åŠ é€Ÿ' },
                { pattern: /^(è®¾ç½®åˆ›æ„|åˆ›æ„è®¾ç½®|åˆ›æ„æ¨¡å¼)$/, label: 'åˆ›æ„è®¾ç½®' },
                { pattern: /^(è®¾ç½®æ‹‰æ–°äººç¾¤|è®¾ç½®äººç¾¤|äººç¾¤è®¾ç½®|ç§å­äººç¾¤)$/, label: 'äººç¾¤è®¾ç½®' },
                { pattern: /^(å‡€ç›®æ ‡æŠ•äº§æ¯”|ç›®æ ‡æŠ•äº§æ¯”|ROIç›®æ ‡å€¼|å‡ºä»·ç›®æ ‡å€¼|çº¦æŸå€¼)$/, label: 'ç›®æ ‡æŠ•äº§æ¯”' },
                { pattern: /^(æŠ•æ”¾æ—¥æœŸ|æŠ•æ”¾æ—¶é—´|æ’æœŸ)$/, label: 'æŠ•æ”¾æ—¶é—´' },
                { pattern: /^(å‘å¸ƒæ—¥æœŸ|å‘å¸ƒæ—¶é—´)$/, label: 'æŠ•æ”¾æ—¶é—´' },
                { pattern: /^(é€‰æ‹©æ¨å¹¿å•†å“|é€‰å“æ–¹å¼)$/, label: 'é€‰å“æ–¹å¼' },
                { pattern: /^(æ–¹æ¡ˆé€‰æ‹©|é€‰æ‹©æ–¹æ¡ˆ)$/, label: 'é€‰æ‹©æ–¹æ¡ˆ' },
                { pattern: /^(è®¾ç½®è®¡åˆ’ç»„|è®¡åˆ’ç»„è®¾ç½®)$/, label: 'è®¡åˆ’ç»„' }
            ];
            const normalizeSceneRenderFieldLabel = (fieldLabel = '') => {
                const raw = normalizeText(fieldLabel).replace(/[ï¼š:]/g, '').trim();
                if (!raw) return '';
                if (/^(campaign\.|adgroup\.)/i.test(raw)) return raw;
                const token = normalizeSceneLabelToken(raw);
                for (const rule of SCENE_RENDER_FIELD_ALIAS_RULES) {
                    if (rule.pattern.test(token)) {
                        return rule.label;
                    }
                }
                return raw;
            };
            const normalizeSceneRenderFieldToken = (fieldLabel = '') => normalizeSceneLabelToken(normalizeSceneRenderFieldLabel(fieldLabel));
            const isSceneFieldConnectedToPayload = (fieldLabel = '') => {
                const normalizedLabel = normalizeSceneRenderFieldLabel(fieldLabel);
                if (!normalizedLabel) return false;
                if (/^(campaign\.|adgroup\.)/i.test(normalizedLabel)) return true;
                const token = normalizeSceneLabelToken(normalizedLabel);
                return !!token && SCENE_CONNECTED_SETTING_LABEL_RE.test(token);
            };
            const dedupeSceneFieldLabelsForRender = (labels = []) => {
                const out = [];
                const seen = new Set();
                (Array.isArray(labels) ? labels : []).forEach(label => {
                    const normalizedLabel = normalizeSceneRenderFieldLabel(label);
                    const token = normalizeSceneLabelToken(normalizedLabel);
                    if (!token || seen.has(token)) return;
                    seen.add(token);
                    out.push(normalizedLabel);
                });
                return out;
            };
            const shouldRenderDynamicSceneField = (fieldLabel = '', sceneName = '') => {
                const normalizedLabel = normalizeSceneRenderFieldLabel(fieldLabel);
                const token = normalizeSceneLabelToken(normalizedLabel);
                if (!token) return false;
                const isApiPathField = /^(campaign\.|adgroup\.)/i.test(token);
                if (isApiPathField) return false;
                if (token.length > 24) return false;
                if (!isLikelyFieldLabel(token)) return false;
                if (SCENE_SECTION_ONLY_LABEL_RE.test(token)) return false;
                if (SCENE_LABEL_NOISE_RE.test(token) || token.includes('Â·')) return false;
                if (SCENE_DYNAMIC_FIELD_BLOCK_RE.test(token)) return false;
                if (!isSceneFieldConnectedToPayload(normalizedLabel)) return false;
                const strictAllow = SCENE_FIELD_LABEL_RE.test(token);
                if (!strictAllow) return false;
                const normalizedSceneName = String(sceneName || wizardState?.draft?.sceneName || '').trim();
                const isKeywordScene = normalizedSceneName === 'å…³é”®è¯æ¨å¹¿';
                const duplicatedRules = [
                    /åœºæ™¯(åç§°|é€‰æ‹©)?/,
                    /è¥é”€åœºæ™¯/,
                    /å‡ºä»·æ–¹å¼/,
                    /å‡ºä»·ç›®æ ‡/,
                    /ä¼˜åŒ–ç›®æ ‡/,
                    /é¢„ç®—ç±»å‹/,
                    /æ¯æ—¥é¢„ç®—/,
                    /æ—¥å‡é¢„ç®—/,
                    /æ€»é¢„ç®—/,
                    /è®¡åˆ’(åç§°|å)/,
                    /é€‰æ‹©æ¨å¹¿å•†å“/,
                    /é€‰å“æ–¹å¼/,
                    /æ·»åŠ å•†å“/,
                    /é€‰æ‹©å¡ä½æ–¹æ¡ˆ/
                ];
                if (isKeywordScene) {
                    duplicatedRules.push(
                        /å…³é”®è¯æ¨¡å¼/,
                        /å…³é”®è¯è®¾ç½®/,
                        /æ ¸å¿ƒè¯è®¾ç½®/,
                        /å¹³å‡ç›´æ¥æˆäº¤æˆæœ¬/
                    );
                }
                return !duplicatedRules.some(rule => rule.test(token));
            };
            const isSceneLabelMatch = (left = '', right = '') => {
                const a = normalizeSceneLabelToken(left);
                const b = normalizeSceneLabelToken(right);
                if (!a || !b) return false;
                return a === b || a.includes(b) || b.includes(a);
            };

            const toShortSceneValue = (text = '') => {
                const normalized = normalizeSceneSettingValue(text);
                if (!normalized) return '';
                if (normalized.length > 24) return '';
                return normalized;
            };

            const pickSceneValueFromOptions = (candidate = '', options = []) => {
                const text = normalizeSceneSettingValue(candidate);
                if (!text || !Array.isArray(options) || !options.length) return '';
                const exact = options.find(opt => opt === text);
                if (exact) return exact;
                const included = options.find(opt => text.includes(opt) || opt.includes(text));
                if (included) return included;
                return '';
            };

            const isSceneOptionMatch = (left = '', right = '') => {
                const a = normalizeSceneOptionText(left);
                const b = normalizeSceneOptionText(right);
                if (!a || !b) return false;
                return a === b || a.includes(b) || b.includes(a);
            };

            const resolveSceneFieldOptionType = (fieldLabel = '') => {
                const token = normalizeSceneLabelToken(fieldLabel);
                if (!token) return '';
                if (/(è¥é”€ç›®æ ‡|é€‰æ‹©å¡ä½æ–¹æ¡ˆ|é€‰æ‹©æ‹‰æ–°æ–¹æ¡ˆ|é€‰æ‹©æ–¹æ¡ˆ|é€‰æ‹©ä¼˜åŒ–æ–¹å‘|é€‰æ‹©è§£å†³æ–¹æ¡ˆ|æŠ•æ”¾ç­–ç•¥|æ¨å¹¿æ¨¡å¼|å¡ä½æ–¹å¼|é€‰æ‹©æ–¹å¼)/.test(token)) return 'goal';
                if (/(å‡ºä»·æ–¹å¼)/.test(token)) return 'bidType';
                if (/(å‡ºä»·ç›®æ ‡|ä¼˜åŒ–ç›®æ ‡)/.test(token)) return 'bidTarget';
                if (/(é¢„ç®—ç±»å‹)/.test(token)) return 'budgetType';
                if (/(é€‰å“æ–¹å¼|é€‰æ‹©æ¨å¹¿å•†å“|æ·»åŠ å•†å“)/.test(token)) return 'itemMode';
                if (/(å…³é”®è¯è®¾ç½®|æ ¸å¿ƒè¯è®¾ç½®|è®¾ç½®è¯åŒ…|åŒ¹é…æ–¹å¼)/.test(token)) return 'keyword';
                if (/(äººç¾¤è®¾ç½®|ç§å­äººç¾¤|è®¾ç½®æ‹‰æ–°äººç¾¤|è®¾ç½®äººç¾¤)/.test(token)) return 'crowd';
                if (/(æŠ•æ”¾è°ƒä¼˜|ä¼˜åŒ–æ¨¡å¼)/.test(token)) return 'strategy';
                if (/(æŠ•æ”¾æ—¶é—´|æŠ•æ”¾æ—¥æœŸ|å‘å¸ƒæ—¥æœŸ|æ’æœŸ|æŠ•æ”¾åœ°åŸŸ|åœ°åŸŸè®¾ç½®|æµé‡æ™ºé€‰|å†·å¯åŠ é€Ÿ)/.test(token)) return 'schedule';
                return '';
            };

            const resolveSceneFallbackOptionSeed = (sceneName = '', fieldLabel = '') => {
                const normalizedSceneName = String(sceneName || '').trim();
                const normalizedLabel = normalizeSceneLabelToken(fieldLabel);
                const sceneOptionMap = isPlainObject(SCENE_FALLBACK_OPTION_MAP[normalizedSceneName])
                    ? SCENE_FALLBACK_OPTION_MAP[normalizedSceneName]
                    : {};
                const options = [];
                let matchedSceneOptionRule = false;
                Object.keys(sceneOptionMap).forEach(ruleLabel => {
                    const normalizedRuleLabel = normalizeSceneLabelToken(ruleLabel);
                    if (!normalizedRuleLabel || !normalizedLabel) return;
                    if (!isSceneLabelMatch(normalizedRuleLabel, normalizedLabel)) return;
                    options.push(...(sceneOptionMap[ruleLabel] || []));
                    matchedSceneOptionRule = true;
                });
                if (!options.length) {
                    SCENE_FIELD_OPTION_FALLBACK.forEach(rule => {
                        if (rule.pattern.test(normalizedLabel)) options.push(...rule.options);
                    });
                }
                const isGoalSelectorLabel = /è¥é”€ç›®æ ‡/.test(normalizedLabel)
                    || (!/é€‰æ‹©è§£å†³æ–¹æ¡ˆ/.test(normalizedLabel) && /^(é€‰æ‹©å¡ä½æ–¹æ¡ˆ|é€‰æ‹©æ‹‰æ–°æ–¹æ¡ˆ|é€‰æ‹©ä¼˜åŒ–æ–¹å‘|é€‰æ‹©æ–¹å¼|æ¨å¹¿æ¨¡å¼|é€‰æ‹©æ–¹æ¡ˆ)$/.test(normalizedLabel));
                if (resolveSceneFieldOptionType(normalizedLabel) === 'goal' && (isGoalSelectorLabel || !matchedSceneOptionRule)) {
                    options.push(...getSceneMarketingGoalFallbackList(normalizedSceneName));
                }
                return uniqueBy(
                    options
                        .map(item => normalizeSceneOptionText(item))
                        .filter(item => isLikelySceneOptionValue(item))
                        .filter(item => !SCENE_DYNAMIC_FIELD_BLOCK_RE.test(item)),
                    item => item
                ).slice(0, 24);
            };

            const filterSceneOptionsByType = ({ sceneName = '', fieldLabel = '', options = [], fallbackOptions = [] }) => {
                const optionType = resolveSceneFieldOptionType(fieldLabel);
                const normalizedOptions = uniqueBy(
                    (Array.isArray(options) ? options : [])
                        .map(item => normalizeSceneOptionText(item))
                        .filter(item => isLikelySceneOptionValue(item))
                        .filter(item => !SCENE_DYNAMIC_FIELD_BLOCK_RE.test(item)),
                    item => item
                );
                const normalizedFallback = uniqueBy(
                    (Array.isArray(fallbackOptions) ? fallbackOptions : [])
                        .map(item => normalizeSceneOptionText(item))
                        .filter(item => isLikelySceneOptionValue(item))
                        .filter(item => !SCENE_DYNAMIC_FIELD_BLOCK_RE.test(item)),
                    item => item
                );
                if (!SCENE_STRICT_OPTION_TYPE_SET.has(optionType)) {
                    return uniqueBy(normalizedOptions.concat(normalizedFallback), item => item).slice(0, 24);
                }
                if (!normalizedFallback.length) {
                    return normalizedOptions.slice(0, 24);
                }
                const matched = normalizedOptions.filter(item => normalizedFallback.some(seed => isSceneOptionMatch(item, seed)));
                const merged = matched.length
                    ? uniqueBy(matched.concat(normalizedFallback), item => item)
                    : normalizedFallback.slice();
                if (optionType === 'goal' && /è¥é”€ç›®æ ‡/.test(normalizeSceneLabelToken(fieldLabel))) {
                    const sceneGoals = getSceneMarketingGoalFallbackList(sceneName);
                    if (sceneGoals.length) {
                        const goalMatched = merged.filter(item => sceneGoals.some(goal => isSceneOptionMatch(item, goal)));
                        if (goalMatched.length) return uniqueBy(goalMatched.concat(sceneGoals), item => item).slice(0, 24);
                        return uniqueBy(sceneGoals.concat(merged), item => item).slice(0, 24);
                    }
                }
                return merged.slice(0, 24);
            };

            const toOptionGroupMap = (entry = {}) => {
                const map = {};
                (entry.sections || []).forEach(section => {
                    const title = String(section?.title || '').trim();
                    const options = Array.isArray(section?.options)
                        ? section.options.map(item => normalizeSceneOptionText(item)).filter(item => isLikelySceneOptionValue(item))
                        : [];
                    if (!title || options.length < 2) return;
                    map[title] = uniqueBy((map[title] || []).concat(options), item => item).slice(0, 12);
                });
                (entry.optionGroups || []).forEach(group => {
                    const title = String(group?.label || '').trim();
                    const options = Array.isArray(group?.options)
                        ? group.options.map(item => normalizeSceneOptionText(item)).filter(item => isLikelySceneOptionValue(item))
                        : [];
                    if (!title || options.length < 2) return;
                    map[title] = uniqueBy((map[title] || []).concat(options), item => item).slice(0, 12);
                });
                (entry.radios || []).forEach(radio => {
                    const title = String(radio?.label || '').trim();
                    const text = normalizeSceneOptionText(radio?.text || '');
                    if (!isLikelySceneOptionValue(text)) return;
                    if (!title || !text) return;
                    map[title] = uniqueBy((map[title] || []).concat([text]), item => item).slice(0, 12);
                });
                return map;
            };

            const buildProfileFromSceneSpec = (sceneName = '', spec = null) => {
                const fieldList = Array.isArray(spec?.fields) ? spec.fields : [];
                const requiredFields = [];
                const optionGroups = {};
                const fieldDefaults = {};
                const fieldMeta = {};
                fieldList.forEach(field => {
                    const label = normalizeText(field?.settingKey || field?.label || '').replace(/[ï¼š:]/g, '').trim();
                    if (!label || !isLikelyFieldLabel(label)) return;
                    requiredFields.push(label);
                    const key = normalizeSceneFieldKey(label);
                    const rawOptions = uniqueBy(
                        (Array.isArray(field?.options) ? field.options : [])
                            .map(item => normalizeSceneOptionText(item))
                            .filter(item => isLikelySceneOptionValue(item)),
                        item => item
                    ).slice(0, 36);
                    const options = filterSceneOptionsByType({
                        sceneName,
                        fieldLabel: label,
                        options: rawOptions,
                        fallbackOptions: resolveSceneFallbackOptionSeed(sceneName, label)
                    });
                    if (options.length) optionGroups[label] = options;
                    const defaultValue = normalizeSceneSettingValue(field?.defaultValue || '');
                    if (defaultValue) fieldDefaults[key] = defaultValue;
                    fieldMeta[key] = {
                        key,
                        label,
                        options,
                        defaultValue,
                        requiredGuess: !!field?.requiredGuess,
                        criticalGuess: !!field?.criticalGuess,
                        triggerPath: normalizeText(field?.triggerPath || ''),
                        dependsOn: Array.isArray(field?.dependsOn)
                            ? uniqueBy(field.dependsOn.map(item => normalizeText(item)).filter(Boolean), item => item).slice(0, 10)
                            : []
                    };
                });
                const dedupRequiredFields = uniqueBy(requiredFields, item => item);
                return {
                    sceneName,
                    requiredFields: dedupRequiredFields,
                    optionGroups,
                    fieldDefaults,
                    fieldMeta,
                    source: 'scene_spec',
                    coverage: deepClone(spec?.coverage || {})
                };
            };
            const normalizeContractPathKeyForSceneField = (rawPath = '') => {
                let path = String(rawPath || '').trim();
                if (!path) return '';
                path = path.replace(/^(campaign|adgroup)\./i, '');
                if (path.includes('[]')) {
                    path = path.split('[]')[0];
                }
                path = path.replace(/\.+/g, '.').replace(/^\.+|\.+$/g, '');
                return path;
            };
            const inferApiFieldOptionsFromDefault = (fieldPath = '', defaultValue = '') => {
                const options = [];
                const valueText = normalizeSceneSettingValue(defaultValue);
                if (/^(true|false)$/i.test(valueText)) {
                    options.push('true', 'false');
                }
                if (/^(0|1)$/.test(valueText) || /(switch|status|smartcreative)$/i.test(fieldPath)) {
                    options.push('1', '0');
                }
                return uniqueBy(
                    options.map(item => normalizeSceneSettingValue(item)).filter(Boolean),
                    item => item
                ).slice(0, 8);
            };
            const buildProfileFromApiContracts = (sceneName = '') => {
                const requiredFields = [];
                const optionGroups = {};
                const fieldDefaults = {};
                const fieldMeta = {};
                const pushField = (fieldLabel = '', defaultValue = '', options = [], source = 'api_contract') => {
                    const label = normalizeText(fieldLabel).replace(/[ï¼š:]/g, '').trim();
                    if (!label) return;
                    const key = normalizeSceneFieldKey(label);
                    const normalizedDefault = normalizeSceneSettingValue(defaultValue);
                    const normalizedOptions = uniqueBy(
                        (Array.isArray(options) ? options : [])
                            .map(item => normalizeSceneSettingValue(item))
                            .filter(Boolean),
                        item => item
                    ).slice(0, 16);
                    requiredFields.push(label);
                    if (normalizedDefault) fieldDefaults[key] = normalizedDefault;
                    if (normalizedOptions.length >= 2) optionGroups[label] = normalizedOptions;
                    fieldMeta[key] = {
                        key,
                        label,
                        options: normalizedOptions,
                        defaultValue: normalizedDefault,
                        requiredGuess: true,
                        criticalGuess: false,
                        triggerPath: '',
                        dependsOn: [],
                        source: [source]
                    };
                };

                const goalSpecs = getSceneCachedGoalSpecs(sceneName);
                const sceneContracts = listCachedSceneCreateContracts(sceneName)
                    .map(item => (isPlainObject(item?.contract) ? item.contract : null))
                    .filter(Boolean);
                const allContracts = [];
                goalSpecs.forEach(goal => {
                    if (isPlainObject(goal?.createContract)) {
                        allContracts.push(goal.createContract);
                    }
                });
                allContracts.push(...sceneContracts);

                const ensureByPath = (prefix = '', path = '', defaultValue = '', source = 'api_contract') => {
                    const normalizedPath = normalizeContractPathKeyForSceneField(path);
                    if (!normalizedPath) return;
                    const fieldLabel = `${prefix}.${normalizedPath}`;
                    const optionSeed = inferApiFieldOptionsFromDefault(fieldLabel, defaultValue);
                    pushField(fieldLabel, defaultValue, optionSeed, source);
                };

                allContracts.forEach(contract => {
                    const defaultCampaign = isPlainObject(contract?.defaultCampaign) ? contract.defaultCampaign : {};
                    const defaultAdgroup = isPlainObject(contract?.defaultAdgroup) ? contract.defaultAdgroup : {};
                    const campaignPairs = flattenObjectToSceneSettingKeyValues(defaultCampaign, '', { maxDepth: 6 });
                    const adgroupPairs = flattenObjectToSceneSettingKeyValues(defaultAdgroup, '', { maxDepth: 6 });
                    campaignPairs.forEach(pair => {
                        ensureByPath('campaign', pair.key, pair.value, 'api_contract.default_campaign');
                    });
                    adgroupPairs.forEach(pair => {
                        ensureByPath('adgroup', pair.key, pair.value, 'api_contract.default_adgroup');
                    });
                    (Array.isArray(contract?.campaignKeyPaths) ? contract.campaignKeyPaths : [])
                        .map(item => normalizeContractPathKeyForSceneField(item))
                        .filter(Boolean)
                        .slice(0, 800)
                        .forEach(path => ensureByPath('campaign', path, '', 'api_contract.campaign_key_path'));
                    (Array.isArray(contract?.adgroupKeyPaths) ? contract.adgroupKeyPaths : [])
                        .map(item => normalizeContractPathKeyForSceneField(item))
                        .filter(Boolean)
                        .slice(0, 800)
                        .forEach(path => ensureByPath('adgroup', path, '', 'api_contract.adgroup_key_path'));
                });

                return {
                    sceneName,
                    requiredFields: uniqueBy(requiredFields, item => item).slice(0, 1200),
                    optionGroups,
                    fieldDefaults,
                    fieldMeta,
                    source: 'api_contract'
                };
            };

            const buildSceneProfiles = () => {
                const profiles = {};
                SCENE_OPTIONS.forEach(sceneName => {
                    profiles[sceneName] = {
                        sceneName,
                        requiredFields: (SCENE_REQUIREMENT_FALLBACK[sceneName] || []).slice(),
                        optionGroups: {},
                        fieldDefaults: {},
                        fieldMeta: {},
                        source: 'fallback'
                    };
                });

                SCENE_OPTIONS.forEach(sceneName => {
                    const sceneBizCode = resolveSceneBizCodeHint(sceneName) || SCENE_BIZCODE_HINT_FALLBACK[sceneName] || '';
                    const cachedSpec = getCachedSceneSpec(sceneName, sceneBizCode);
                    if (!cachedSpec?.ok || !Array.isArray(cachedSpec?.fields)) return;
                    const specProfile = buildProfileFromSceneSpec(sceneName, cachedSpec);
                    if (!specProfile.requiredFields.length) return;
                    profiles[sceneName] = {
                        ...profiles[sceneName],
                        ...specProfile,
                        requiredFields: uniqueBy(
                            (specProfile.requiredFields || []).concat(profiles[sceneName]?.requiredFields || []),
                            item => item
                        ).slice(0, 1200),
                        optionGroups: mergeDeep({}, profiles[sceneName]?.optionGroups || {}, specProfile.optionGroups || {}),
                        fieldDefaults: mergeDeep({}, profiles[sceneName]?.fieldDefaults || {}, specProfile.fieldDefaults || {}),
                        fieldMeta: mergeDeep({}, profiles[sceneName]?.fieldMeta || {}, specProfile.fieldMeta || {}),
                        source: 'scene_spec'
                    };
                });

                SCENE_OPTIONS.forEach(sceneName => {
                    const apiProfile = buildProfileFromApiContracts(sceneName);
                    if (!apiProfile.requiredFields.length) return;
                    profiles[sceneName] = {
                        ...profiles[sceneName],
                        requiredFields: uniqueBy(
                            (profiles[sceneName]?.requiredFields || []).concat(apiProfile.requiredFields || []),
                            item => item
                        ).slice(0, 1200),
                        optionGroups: mergeDeep({}, profiles[sceneName]?.optionGroups || {}, apiProfile.optionGroups || {}),
                        fieldDefaults: mergeDeep({}, profiles[sceneName]?.fieldDefaults || {}, apiProfile.fieldDefaults || {}),
                        fieldMeta: mergeDeep({}, profiles[sceneName]?.fieldMeta || {}, apiProfile.fieldMeta || {}),
                        source: profiles[sceneName]?.source === 'scene_spec' ? 'scene_spec+api_contract' : 'api_contract'
                    };
                });

                const scan = window.__AM_WXT_LAST_SCENE_SCAN__;
                if (!scan || !Array.isArray(scan.list)) return profiles;

                scan.list.forEach(entry => {
                    if (!entry?.ok) return;
                    const sceneName = String(entry.sceneName || '').trim();
                    if (!SCENE_OPTIONS.includes(sceneName)) return;
                    const profile = profiles[sceneName] || {
                        sceneName,
                        requiredFields: [],
                        optionGroups: {},
                        fieldDefaults: {},
                        fieldMeta: {},
                        source: 'scan'
                    };
                    const dynamicFields = uniqueBy([
                        ...(profile.requiredFields || []),
                        ...(entry.labels || []).filter(text => isLikelyFieldLabel(text)).slice(0, 20),
                        ...(entry.sectionTitles || []).filter(text => isLikelyFieldLabel(text)).slice(0, 10)
                    ], item => item).slice(0, 1200);
                    profile.requiredFields = dynamicFields;
                    profile.optionGroups = mergeDeep(profile.optionGroups || {}, toOptionGroupMap(entry));
                    if (String(profile.source || '').includes('api_contract')) {
                        profile.source = `${profile.source}+scan`;
                    } else {
                        profile.source = profile.source === 'scene_spec' ? 'scene_spec' : 'scan';
                    }
                    profiles[sceneName] = profile;
                });
                return profiles;
            };

            const getSceneProfile = (sceneName) => {
                if (!isPlainObject(wizardState.sceneProfiles) || !Object.keys(wizardState.sceneProfiles).length) {
                    wizardState.sceneProfiles = buildSceneProfiles();
                }
                return wizardState.sceneProfiles?.[sceneName] || {
                    sceneName,
                    requiredFields: (SCENE_REQUIREMENT_FALLBACK[sceneName] || []).slice(),
                    optionGroups: {},
                    fieldDefaults: {},
                    fieldMeta: {},
                    source: 'fallback'
                };
            };

            const refreshSceneProfileFromSpec = async (sceneName = '', options = {}) => {
                const targetSceneName = String(sceneName || '').trim();
                if (!targetSceneName || !SCENE_OPTIONS.includes(targetSceneName)) return null;
                const requestId = toNumber(wizardState.sceneProfileRequestId, 0) + 1;
                wizardState.sceneProfileRequestId = requestId;
                const scanMode = options.scanMode || 'full_top_down';
                const unlockPolicy = options.unlockPolicy || 'safe_only';
                const refresh = !!options.refresh;
                const silent = options.silent !== false;
                try {
                    const spec = await getSceneSpec(targetSceneName, {
                        scanMode,
                        unlockPolicy,
                        goalScan: options.goalScan !== false,
                        refresh
                    });
                    if (requestId !== wizardState.sceneProfileRequestId) return spec;
                    if (!spec?.ok || !Array.isArray(spec?.fields) || !spec.fields.length) {
                        if (!silent) {
                            appendWizardLog(`åœºæ™¯è®¾ç½®åŒæ­¥å¤±è´¥ï¼š${targetSceneName} æœªè·å–åˆ°æœ‰æ•ˆå­—æ®µ`, 'error');
                        }
                        return spec;
                    }
                    wizardState.sceneProfiles = buildSceneProfiles();
                    const currentScene = String(wizardState.els.sceneSelect?.value || wizardState.draft?.sceneName || '').trim();
                    if (currentScene === targetSceneName) {
                        renderSceneDynamicConfig();
                        syncDraftFromUI();
                        if (typeof wizardState.buildRequest === 'function') {
                            wizardState.renderPreview(wizardState.buildRequest());
                        }
                    }
                    if (!silent) {
                        appendWizardLog(`åœºæ™¯è®¾ç½®å·²å¯¹é½ï¼š${targetSceneName}ï¼ˆå­—æ®µ ${spec.fields.length}ï¼Œç›®æ ‡ ${(spec.goals || []).length}ï¼‰`, 'success');
                    }
                    return spec;
                } catch (err) {
                    if (!silent) {
                        appendWizardLog(`åœºæ™¯è®¾ç½®åŒæ­¥å¼‚å¸¸ï¼š${err?.message || err}`, 'error');
                    }
                    return null;
                }
            };

            const resolveSceneFieldOptions = (profile, fieldLabel) => {
                const sceneName = String(profile?.sceneName || wizardState?.els?.sceneSelect?.value || wizardState?.draft?.sceneName || '').trim();
                const normalizedKey = normalizeSceneFieldKey(fieldLabel);
                const token = normalizeSceneLabelToken(fieldLabel);
                const metaOptions = Array.isArray(profile?.fieldMeta?.[normalizedKey]?.options)
                    ? profile.fieldMeta[normalizedKey].options
                    : [];
                const options = [];
                if (metaOptions.length) options.push(...metaOptions);
                const groups = isPlainObject(profile?.optionGroups) ? profile.optionGroups : {};
                Object.keys(groups).forEach(groupLabel => {
                    if (!groupLabel) return;
                    if (!isSceneLabelMatch(fieldLabel, groupLabel)) return;
                    options.push(...(groups[groupLabel] || []));
                });
                const componentRows = Array.isArray(componentConfigCache?.data?.summary?.fieldRows)
                    ? componentConfigCache.data.summary.fieldRows
                    : [];
                componentRows.forEach(row => {
                    if (!isSceneLabelMatch(fieldLabel, row?.label || '')) return;
                    options.push(...(Array.isArray(row?.options) ? row.options : []));
                });
                if (/^(campaign\.|adgroup\.)/i.test(token)) {
                    return uniqueBy(
                        options.map(item => normalizeSceneSettingValue(item)).filter(Boolean),
                        item => item
                    ).slice(0, 24);
                }
                const fallbackOptions = resolveSceneFallbackOptionSeed(sceneName, fieldLabel);
                const filteredOptions = filterSceneOptionsByType({
                    sceneName,
                    fieldLabel,
                    options,
                    fallbackOptions
                });
                if (filteredOptions.length) return filteredOptions.slice(0, 24);
                return fallbackOptions.slice(0, 24);
            };

            const resolveSceneFieldHeuristicDefault = (fieldLabel = '', options = []) => {
                const normalizedLabel = normalizeSceneLabelToken(fieldLabel);
                const optionList = Array.isArray(options) ? options : [];
                const currentSceneName = String(wizardState?.els?.sceneSelect?.value || wizardState?.draft?.sceneName || 'å…³é”®è¯æ¨å¹¿').trim() || 'å…³é”®è¯æ¨å¹¿';
                const fallbackOptions = resolveSceneFallbackOptionSeed(currentSceneName, normalizedLabel);
                const sceneDefaults = isPlainObject(SCENE_SPEC_FIELD_FALLBACK[currentSceneName]) ? SCENE_SPEC_FIELD_FALLBACK[currentSceneName] : {};
                const hasVisibleNativeHint = (pattern) => {
                    try {
                        const re = pattern instanceof RegExp ? pattern : new RegExp(String(pattern || ''), 'i');
                        if (!re) return false;
                        const nodes = document.querySelectorAll('div,span,label,button,strong,p,li,a');
                        for (let i = 0; i < nodes.length; i++) {
                            const el = nodes[i];
                            if (!(el instanceof Element)) continue;
                            if (!isElementVisible(el)) continue;
                            const text = normalizeText(getOwnText(el) || el.textContent || '');
                            if (!text) continue;
                            if (re.test(text)) return true;
                        }
                    } catch { }
                    return false;
                };
                const pickByText = (candidate = '', fallbackRaw = false) => {
                    const mapped = pickSceneValueFromOptions(candidate, optionList);
                    if (mapped) return mapped;
                    if (!fallbackRaw) return '';
                    return toShortSceneValue(candidate);
                };
                const extractSceneConstraintValue = () => {
                    const hasConstraintContext = (text = '') => /æŠ•äº§æ¯”|ROI|å‡ºä»·ç›®æ ‡|å‡€ç›®æ ‡|çº¦æŸ|ç›®æ ‡å€¼/i.test(normalizeText(text));
                    const normalizeNumericText = (raw = '') => {
                        const num = parseNumberFromSceneValue(raw);
                        if (!Number.isFinite(num) || num <= 0) return '';
                        if (num > 9999) return '';
                        return toShortSceneValue(String(num));
                    };
                    const tryContainerValue = (el) => {
                        if (!(el instanceof Element)) return '';
                        const container = el.closest('label,li,div,section') || el;
                        const containerText = normalizeText(container?.textContent || '');
                        if (!hasConstraintContext(containerText)) return '';
                        const textValue = normalizeNumericText(container?.textContent || '');
                        if (textValue) return textValue;
                        const siblingInput = container?.querySelector?.('input:not([type="radio"]):not([type="checkbox"])');
                        const inputValue = normalizeNumericText(siblingInput?.value || '');
                        if (inputValue) return inputValue;
                        return '';
                    };
                    try {
                        const checkedRadios = Array.from(document.querySelectorAll('input[type="radio"]:checked,[role="radio"][aria-checked="true"]'));
                        for (const radio of checkedRadios) {
                            if (!(radio instanceof Element) || !isElementVisible(radio)) continue;
                            const fromContainer = tryContainerValue(radio);
                            if (fromContainer) return fromContainer;
                        }
                        const focusHints = Array.from(document.querySelectorAll('div,span,label,strong,p,li'))
                            .filter(el => el instanceof Element && isElementVisible(el))
                            .map(el => normalizeText(el.textContent || ''))
                            .filter(Boolean)
                            .filter(text => /æŠ•äº§æ¯”|ROI|å‡ºä»·ç›®æ ‡|å‡€ç›®æ ‡/.test(text));
                        for (const text of focusHints) {
                            const fromHint = normalizeNumericText(text);
                            if (fromHint) return fromHint;
                        }
                    } catch { }
                    return '';
                };
                if (!normalizedLabel) return '';

                if (currentSceneName === 'è´§å“å…¨ç«™æ¨å¹¿') {
                    if (/è¥é”€åœºæ™¯/.test(normalizedLabel)) {
                        if (hasVisibleNativeHint(/å…¨åŸŸæŠ•æ”¾\s*[Â·.]?\s*ROIç¡®å®šäº¤ä»˜/i)) {
                            return pickByText('å…¨åŸŸæŠ•æ”¾ Â· ROIç¡®å®šäº¤ä»˜', true)
                                || pickByText('å…¨åŸŸæŠ•æ”¾ROIç¡®å®šäº¤ä»˜', true);
                        }
                    }
                    if (/é¢„ç®—ç±»å‹/.test(normalizedLabel)) {
                        if (hasVisibleNativeHint(/ä¸é™é¢„ç®—/)) {
                            return pickByText('ä¸é™é¢„ç®—', true);
                        }
                    }
                    if (/å‡ºä»·æ–¹å¼/.test(normalizedLabel)) {
                        if (hasVisibleNativeHint(/æ§æŠ•äº§æ¯”æŠ•æ”¾|æ§æŠ•äº§æ¯”/)) {
                            return pickByText('æ§æŠ•äº§æ¯”æŠ•æ”¾', true)
                                || pickByText('æ§æŠ•äº§æ¯”', true);
                        }
                        if (hasVisibleNativeHint(/æœ€å¤§åŒ–æ‹¿é‡/)) {
                            return pickByText('æœ€å¤§åŒ–æ‹¿é‡', true);
                        }
                        if (hasVisibleNativeHint(/æ§æˆæœ¬æŠ•æ”¾|æ§æˆæœ¬/)) {
                            return pickByText('æ§æˆæœ¬', true);
                        }
                    }
                    if (/(å‡ºä»·ç›®æ ‡|ä¼˜åŒ–ç›®æ ‡)/.test(normalizedLabel)) {
                        if (hasVisibleNativeHint(/å¢åŠ å‡€æˆäº¤é‡‘é¢|å‡€æˆäº¤é‡‘é¢/)) {
                            return pickByText('å¢åŠ å‡€æˆäº¤é‡‘é¢', true);
                        }
                        if (hasVisibleNativeHint(/å¢åŠ æ€»æˆäº¤é‡‘é¢|æ€»æˆäº¤é‡‘é¢/)) {
                            return pickByText('å¢åŠ æ€»æˆäº¤é‡‘é¢', true);
                        }
                        if (hasVisibleNativeHint(/å‡€ç›®æ ‡æŠ•äº§æ¯”|ç›®æ ‡æŠ•äº§æ¯”|ROI/i)) {
                            return pickByText('å‡€ç›®æ ‡æŠ•äº§æ¯”', true)
                                || pickByText('ç¨³å®šæŠ•äº§æ¯”', true);
                        }
                    }
                    if (/(ç›®æ ‡æŠ•äº§æ¯”|ROIç›®æ ‡å€¼|å‡ºä»·ç›®æ ‡å€¼|çº¦æŸå€¼|ç›®æ ‡å€¼)/.test(normalizedLabel)) {
                        const fromConstraint = extractSceneConstraintValue();
                        if (fromConstraint) return fromConstraint;
                        const runtimeConstraintValue = parseNumberFromSceneValue(
                            runtimeCache?.value?.storeData?.constraintValue
                            || runtimeCache?.value?.solutionTemplate?.campaign?.constraintValue
                            || ''
                        );
                        if (Number.isFinite(runtimeConstraintValue) && runtimeConstraintValue > 0) {
                            return toShortSceneValue(String(runtimeConstraintValue));
                        }
                        const fromDefaults = parseNumberFromSceneValue(
                            sceneDefaults[normalizedLabel]
                            || sceneDefaults.ç›®æ ‡æŠ•äº§æ¯”
                            || sceneDefaults.å‡€ç›®æ ‡æŠ•äº§æ¯”
                            || ''
                        );
                        if (Number.isFinite(fromDefaults) && fromDefaults > 0) {
                            return toShortSceneValue(String(fromDefaults));
                        }
                    }
                    if (/(æŠ•æ”¾è°ƒä¼˜|ä¼˜åŒ–æ¨¡å¼)/.test(normalizedLabel)) {
                        if (hasVisibleNativeHint(/å¤šç›®æ ‡ä¼˜åŒ–|å¤šç›®æ ‡/)) {
                            return pickByText('å¤šç›®æ ‡ä¼˜åŒ–', true);
                        }
                        if (hasVisibleNativeHint(/æ—¥å¸¸ä¼˜åŒ–/)) {
                            return pickByText('æ—¥å¸¸ä¼˜åŒ–', true);
                        }
                    }
                    if (/(æŠ•æ”¾æ—¶é—´|æŠ•æ”¾æ—¥æœŸ|å‘å¸ƒæ—¥æœŸ|æ’æœŸ)/.test(normalizedLabel)) {
                        if (hasVisibleNativeHint(/é•¿æœŸæŠ•æ”¾|ä¸é™æ—¶æ®µ|å…¨å¤©|24å°æ—¶/)) {
                            return pickByText('é•¿æœŸæŠ•æ”¾', true) || pickByText('ä¸é™æ—¶æ®µ', true);
                        }
                    }
                    if (/(æŠ•æ”¾åœ°åŸŸ|åœ°åŸŸè®¾ç½®)/.test(normalizedLabel)) {
                        if (hasVisibleNativeHint(/å…¨éƒ¨åœ°åŸŸ|å…¨å›½|ä¸é™åœ°åŸŸ|å…¨éƒ¨åœ°åŒº/)) {
                            return pickByText('å…¨éƒ¨åœ°åŸŸ', true);
                        }
                    }
                    if (/(è®¡åˆ’ç»„|è®¾ç½®è®¡åˆ’ç»„)/.test(normalizedLabel)) {
                        if (hasVisibleNativeHint(/è®¾ç½®è®¡åˆ’ç»„|è®¡åˆ’ç»„/)) {
                            return pickByText('ä¸è®¾ç½®è®¡åˆ’ç»„', true);
                        }
                    }
                }

                if (/é¢„ç®—ç±»å‹/.test(normalizedLabel)) {
                    const budgetType = String(wizardState?.els?.budgetTypeSelect?.value || wizardState?.draft?.strategyList?.[0]?.budgetType || 'day_average').trim();
                    const preferred = budgetType === 'day_budget' ? 'æ—¥å‡é¢„ç®—' : 'æ¯æ—¥é¢„ç®—';
                    return pickByText(preferred, true)
                        || pickByText(sceneDefaults.é¢„ç®—ç±»å‹ || '', true)
                        || pickByText(fallbackOptions[0] || '', true)
                        || pickByText('æ¯æ—¥é¢„ç®—', true)
                        || pickByText('æ—¥å‡é¢„ç®—', true);
                }

                if (/(è¥é”€ç›®æ ‡|é€‰æ‹©å¡ä½æ–¹æ¡ˆ|é€‰æ‹©æ‹‰æ–°æ–¹æ¡ˆ|é€‰æ‹©æ–¹æ¡ˆ|é€‰æ‹©ä¼˜åŒ–æ–¹å‘|é€‰æ‹©è§£å†³æ–¹æ¡ˆ|æŠ•æ”¾ç­–ç•¥|æ¨å¹¿æ¨¡å¼|å¡ä½æ–¹å¼|é€‰æ‹©æ–¹å¼)/.test(normalizedLabel)) {
                    const defaultGoal = normalizeSceneSettingValue(
                        sceneDefaults[normalizedLabel]
                        || sceneDefaults.è¥é”€ç›®æ ‡
                        || sceneDefaults.ä¼˜åŒ–ç›®æ ‡
                        || ''
                    );
                    const fallbackGoal = getSceneMarketingGoalFallbackList(currentSceneName)[0] || '';
                    return pickByText(defaultGoal, true)
                        || pickByText(fallbackOptions[0] || '', true)
                        || pickByText(fallbackGoal, true);
                }

                if (/(å‡ºä»·æ–¹å¼)/.test(normalizedLabel)) {
                    if (currentSceneName === 'å…³é”®è¯æ¨å¹¿') {
                        const bidMode = normalizeBidMode(wizardState?.els?.bidModeSelect?.value || wizardState?.draft?.bidMode || 'smart', 'smart');
                        const preferred = bidMode === 'manual' ? 'æ‰‹åŠ¨å‡ºä»·' : 'æ™ºèƒ½å‡ºä»·';
                        return pickByText(preferred, true)
                            || pickByText('æ™ºèƒ½å‡ºä»·', true)
                            || pickByText('æ‰‹åŠ¨å‡ºä»·', true);
                    }
                    return pickByText(sceneDefaults[normalizedLabel] || '', true)
                        || pickByText(sceneDefaults.å‡ºä»·æ–¹å¼ || '', true)
                        || pickByText(fallbackOptions[0] || '', true);
                }

                if (/(å‡ºä»·ç›®æ ‡|ä¼˜åŒ–ç›®æ ‡)/.test(normalizedLabel)) {
                    const bidTargetValue = String(wizardState?.els?.bidTargetSelect?.value || DEFAULTS.bidTargetV2).trim() || DEFAULTS.bidTargetV2;
                    const bidTargetLabel = BID_TARGET_OPTIONS.find(item => item.value === bidTargetValue)?.label || 'è·å–æˆäº¤é‡';
                    return pickByText(bidTargetLabel, true)
                        || pickByText(sceneDefaults[normalizedLabel] || '', true)
                        || pickByText(sceneDefaults.å‡ºä»·ç›®æ ‡ || '', true)
                        || pickByText(sceneDefaults.ä¼˜åŒ–ç›®æ ‡ || '', true)
                        || pickByText(fallbackOptions[0] || '', true)
                        || pickByText('è·å–æˆäº¤é‡', true)
                        || pickByText('å¢åŠ æˆäº¤é‡‘é¢', true)
                        || pickByText('ä¼˜åŒ–ç•™èµ„è·å®¢æˆæœ¬', true);
                }

                if (/(è®¡åˆ’åç§°|è®¡åˆ’å)/.test(normalizedLabel)) {
                    const planName = String(wizardState?.els?.prefixInput?.value || wizardState?.draft?.planNamePrefix || buildSceneTimePrefix(currentSceneName)).trim();
                    return toShortSceneValue(planName);
                }

                if (/(æ¯æ—¥é¢„ç®—|æ—¥å‡é¢„ç®—)/.test(normalizedLabel)) {
                    const budgetValue = String(wizardState?.els?.budgetInput?.value || wizardState?.draft?.dayAverageBudget || '100').trim();
                    return toShortSceneValue(budgetValue);
                }

                if (/(å…³é”®è¯è®¾ç½®|æ ¸å¿ƒè¯è®¾ç½®)/.test(normalizedLabel)) {
                    return pickByText('æ·»åŠ å…³é”®è¯', true)
                        || pickByText('ç³»ç»Ÿæ¨èè¯', true)
                        || pickByText('æ‰‹åŠ¨è‡ªé€‰è¯', true);
                }
                if (/(åŒ¹é…æ–¹å¼)/.test(normalizedLabel)) {
                    return pickByText(sceneDefaults[normalizedLabel] || '', true)
                        || pickByText(sceneDefaults.åŒ¹é…æ–¹å¼ || '', true)
                        || pickByText('å¹¿æ³›', true)
                        || pickByText('ä¸­å¿ƒè¯', true)
                        || pickByText('ç²¾å‡†', true);
                }
                if (/(æµé‡æ™ºé€‰)/.test(normalizedLabel)) {
                    return pickByText(sceneDefaults[normalizedLabel] || '', true)
                        || pickByText(sceneDefaults.æµé‡æ™ºé€‰ || '', true)
                        || pickByText('å¼€å¯', true)
                        || pickByText('å…³é—­', true);
                }
                if (/(å†·å¯åŠ é€Ÿ)/.test(normalizedLabel)) {
                    return pickByText(sceneDefaults[normalizedLabel] || '', true)
                        || pickByText(sceneDefaults.å¼€å¯å†·å¯åŠ é€Ÿ || '', true)
                        || pickByText('å¼€å¯', true)
                        || pickByText('å…³é—­', true);
                }

                if (/(äººç¾¤è®¾ç½®|ç§å­äººç¾¤)/.test(normalizedLabel)) {
                    return pickByText('æ™ºèƒ½äººç¾¤', true)
                        || pickByText('è®¾ç½®ä¼˜å…ˆæŠ•æ”¾å®¢æˆ·', true)
                        || pickByText('æ·»åŠ ç§å­äººç¾¤', true);
                }

                if (/(é€‰æ‹©æ¨å¹¿å•†å“|é€‰å“æ–¹å¼|æ·»åŠ å•†å“)/.test(normalizedLabel)) {
                    return pickByText(sceneDefaults[normalizedLabel] || '', true)
                        || pickByText(sceneDefaults.æ·»åŠ å•†å“ || '', true)
                        || pickByText('å…¨éƒ¨å•†å“', true)
                        || pickByText('æœºä¼šå“æ¨è', true)
                        || pickByText('è‡ªå®šä¹‰é€‰å“', true)
                        || pickByText('è¡Œä¸šæ¨èé€‰å“', true);
                }

                if (/(æŠ•æ”¾æ—¥æœŸ|æŠ•æ”¾æ—¶é—´|æ’æœŸ)/.test(normalizedLabel)) {
                    return pickByText('é•¿æœŸæŠ•æ”¾', true) || pickByText('ä¸é™æ—¶æ®µ', true);
                }

                return '';
            };

            const resolveSceneFieldDefaultValue = ({ fieldLabel = '', options = [], schema = null }) => {
                const optionList = Array.isArray(options) ? options : [];
                const strictField = SCENE_STRICT_OPTION_TYPE_SET.has(resolveSceneFieldOptionType(fieldLabel));
                const pickFromCandidate = (candidate = '', fallbackRaw = false) => {
                    const mapped = pickSceneValueFromOptions(candidate, optionList);
                    if (mapped) return mapped;
                    if (!fallbackRaw || (strictField && optionList.length > 0)) return '';
                    return toShortSceneValue(candidate);
                };

                if (isPlainObject(schema)) {
                    const matchedSelects = (Array.isArray(schema.selects) ? schema.selects : [])
                        .filter(item => isSceneLabelMatch(item?.label, fieldLabel));
                    for (const selectItem of matchedSelects) {
                        const selectedOption = (selectItem.options || []).find(opt => opt?.selected) || null;
                        const fromSelectedLabel = pickFromCandidate(selectedOption?.label || '', true);
                        if (fromSelectedLabel) return fromSelectedLabel;
                        const fromSelectedValue = pickFromCandidate(selectedOption?.value || '', true);
                        if (fromSelectedValue) return fromSelectedValue;
                        const fromSelectValue = pickFromCandidate(selectItem.value || '', true);
                        if (fromSelectValue) return fromSelectValue;
                    }

                    const matchedRadios = (Array.isArray(schema.radios) ? schema.radios : [])
                        .filter(item => item?.checked && isSceneLabelMatch(item?.label, fieldLabel));
                    for (const radioItem of matchedRadios) {
                        const fromRadio = pickFromCandidate(radioItem.text || '', false);
                        if (fromRadio) return fromRadio;
                        const firstToken = String(radioItem.text || '').split(/[ï¼Œã€‚,.ï¼›;ï¼š:\s]/)[0] || '';
                        const fromToken = pickFromCandidate(firstToken, true);
                        if (fromToken) return fromToken;
                    }

                    const matchedInputs = (Array.isArray(schema.inputs) ? schema.inputs : [])
                        .filter(item => isSceneLabelMatch(item?.label, fieldLabel));
                    for (const inputItem of matchedInputs) {
                        const fromInput = toShortSceneValue(inputItem.value || '');
                        if (fromInput) return fromInput;
                    }

                    const matchedGroups = (Array.isArray(schema.optionGroups) ? schema.optionGroups : [])
                        .filter(item => isSceneLabelMatch(item?.label, fieldLabel));
                    for (const groupItem of matchedGroups) {
                        const firstOption = String((groupItem.options || [])[0] || '').trim();
                        const fromGroup = pickFromCandidate(firstOption, true);
                        if (fromGroup) return fromGroup;
                    }
                }

                const heuristicDefault = normalizeSceneSettingValue(resolveSceneFieldHeuristicDefault(fieldLabel, optionList));
                if (heuristicDefault) return heuristicDefault;
                if (optionList.length) return optionList[0];
                return '';
            };

            const autoFillSceneDefaults = ({ sceneName = '', profile = {}, fields = [], bucket = {} }) => {
                const targetSceneName = String(sceneName || '').trim();
                if (!targetSceneName || !Array.isArray(fields) || !fields.length) return 0;
                const missingFields = fields.filter(fieldLabel => {
                    const key = normalizeSceneFieldKey(fieldLabel);
                    if (!key) return false;
                    if (normalizeSceneSettingValue(bucket[key]) !== '') return false;
                    return true;
                });
                if (!missingFields.length) return 0;

                let schema = null;
                try {
                    schema = scanCurrentSceneSettings(targetSceneName);
                } catch {
                    schema = null;
                }

                let fillCount = 0;
                missingFields.forEach(fieldLabel => {
                    const key = normalizeSceneFieldKey(fieldLabel);
                    const options = resolveSceneFieldOptions(profile, fieldLabel);
                    const scannedValue = normalizeSceneSettingValue(resolveSceneFieldDefaultValue({
                        fieldLabel,
                        options,
                        schema
                    }));
                    if (scannedValue) {
                        bucket[key] = scannedValue;
                        fillCount += 1;
                        return;
                    }
                    const profileDefaultValue = normalizeSceneSettingValue(
                        profile?.fieldMeta?.[key]?.defaultValue
                        || profile?.fieldDefaults?.[key]
                        || ''
                    );
                    if (profileDefaultValue) {
                        bucket[key] = profileDefaultValue;
                        fillCount += 1;
                        return;
                    }
                    const fallbackDefaultValue = normalizeSceneSettingValue(
                        SCENE_SPEC_FIELD_FALLBACK?.[targetSceneName]?.[normalizeSceneRenderFieldLabel(fieldLabel) || fieldLabel]
                        || ''
                    );
                    if (fallbackDefaultValue) {
                        bucket[key] = fallbackDefaultValue;
                        fillCount += 1;
                        return;
                    }
                    if (options.length) {
                        bucket[key] = options[0];
                        fillCount += 1;
                    }
                });
                return fillCount;
            };

            const syncSceneSettingValuesFromUI = () => {
                const sceneName = String(wizardState.els.sceneSelect?.value || wizardState.draft?.sceneName || 'å…³é”®è¯æ¨å¹¿').trim();
                if (!sceneName) return;
                const bucket = ensureSceneSettingBucket(sceneName);
                const controls = wizardState.els.sceneDynamic?.querySelectorAll('[data-scene-field]') || [];
                controls.forEach(control => {
                    const key = String(control.getAttribute('data-scene-field') || '').trim();
                    if (!key) return;
                    bucket[key] = normalizeSceneSettingValue(control.value);
                });
            };

            const buildSceneSettingsPayload = (sceneName = '') => {
                const targetSceneName = String(sceneName || wizardState?.draft?.sceneName || 'å…³é”®è¯æ¨å¹¿').trim() || 'å…³é”®è¯æ¨å¹¿';
                const profile = getSceneProfile(targetSceneName);
                const bucket = ensureSceneSettingBucket(targetSceneName);
                const touchedBucket = ensureSceneTouchedBucket(targetSceneName);
                const labelMap = {};
                if (isPlainObject(profile?.fieldMeta)) {
                    Object.keys(profile.fieldMeta).forEach(key => {
                        const meta = profile.fieldMeta[key];
                        const label = normalizeSceneRenderFieldLabel(meta?.label || key);
                        const normalizedKey = normalizeSceneFieldKey(label);
                        if (!label || !normalizedKey) return;
                        if (!labelMap[normalizedKey]) labelMap[normalizedKey] = label;
                    });
                }
                (profile?.requiredFields || []).forEach(fieldLabel => {
                    if (!shouldRenderDynamicSceneField(fieldLabel, targetSceneName)) return;
                    const label = normalizeSceneRenderFieldLabel(fieldLabel);
                    const key = normalizeSceneFieldKey(label);
                    if (!label || !key || labelMap[key]) return;
                    labelMap[key] = label;
                });
                const skippedDynamicKeySet = new Set(
                    (profile?.requiredFields || [])
                        .filter(fieldLabel => !shouldRenderDynamicSceneField(fieldLabel, targetSceneName))
                        .map(fieldLabel => normalizeSceneFieldKey(normalizeSceneRenderFieldLabel(fieldLabel)))
                        .filter(Boolean)
                );
                const preserveDynamicKeySet = new Set(
                    ['æŠ•æ”¾è°ƒä¼˜', 'ä¼˜åŒ–ç›®æ ‡', 'å¤šç›®æ ‡é¢„ç®—', 'ä¸€é”®èµ·é‡é¢„ç®—', 'ä¸“å±æƒç›Š', 'å‘å¸ƒæ—¥æœŸ', 'æŠ•æ”¾æ—¶é—´', 'æŠ•æ”¾åœ°åŸŸ', 'è®¡åˆ’ç»„', 'ç›®æ ‡æŠ•äº§æ¯”']
                        .map(label => normalizeSceneFieldKey(label))
                        .filter(Boolean)
                );
                const hiddenSceneSettingKeySet = new Set(
                    [
                        normalizeSceneFieldKey('campaign.bidTargetV2'),
                        normalizeSceneFieldKey('campaign.optimizeTarget')
                    ].filter(Boolean)
                );

                const sceneSettings = {};
                Object.keys(bucket || {}).forEach(rawKey => {
                    const key = normalizeText(rawKey).replace(/[ï¼š:]/g, '').trim();
                    if (hiddenSceneSettingKeySet.has(key)) return;
                    if (skippedDynamicKeySet.has(key) && !preserveDynamicKeySet.has(key)) return;
                    const value = normalizeSceneSettingValue(bucket[rawKey]);
                    if (!key || !value) return;
                    const mappedLabel = labelMap[key] || normalizeSceneRenderFieldLabel(key) || key;
                    if (!isSceneFieldConnectedToPayload(mappedLabel)) return;
                    sceneSettings[mappedLabel] = value;
                });

                const currentBidMode = normalizeBidMode(
                    wizardState?.els?.bidModeSelect?.value || wizardState?.draft?.bidMode || 'smart',
                    'smart'
                );
                const bidMode = currentBidMode;
                const bidTypeLabel = bidMode === 'manual' ? 'æ‰‹åŠ¨å‡ºä»·' : 'æ™ºèƒ½å‡ºä»·';
                const budgetTypeValue = String(wizardState?.els?.budgetTypeSelect?.value || wizardState?.draft?.strategyList?.[0]?.budgetType || 'day_average').trim();
                const budgetTypeLabel = budgetTypeValue === 'day_budget' ? 'æ—¥å‡é¢„ç®—' : 'æ¯æ—¥é¢„ç®—';
                const scenePrefix = String(wizardState?.draft?.planNamePrefix || buildSceneTimePrefix(targetSceneName)).trim();
                const budgetValue = normalizeSceneSettingValue(wizardState?.els?.budgetInput?.value || wizardState?.draft?.dayAverageBudget || '');
                const bidTargetValue = String(wizardState?.els?.bidTargetSelect?.value || DEFAULTS.bidTargetV2).trim() || DEFAULTS.bidTargetV2;
                const bidTargetLabel = BID_TARGET_OPTIONS.find(item => item.value === bidTargetValue)?.label || '';
                const keywordModeValue = String(wizardState?.els?.modeSelect?.value || DEFAULTS.keywordMode).trim();
                const keywordModeLabelMap = {
                    mixed: 'æ··åˆï¼ˆæ‰‹åŠ¨ä¼˜å…ˆ + æ¨èè¡¥é½ï¼‰',
                    manual: 'ä»…æ‰‹åŠ¨',
                    recommend: 'ä»…æ¨è'
                };
                const keywordModeLabel = keywordModeLabelMap[keywordModeValue] || keywordModeValue;
                const sceneFieldTokens = uniqueBy(
                    Object.values(labelMap || {})
                        .concat(profile?.requiredFields || [])
                        .map(item => normalizeSceneLabelToken(item))
                        .filter(Boolean),
                    item => item
                );
                const sceneFieldText = sceneFieldTokens.join(' ');
                const hasProfileField = (pattern) => pattern.test(sceneFieldText);
                const allowAutoBidType = targetSceneName === 'å…³é”®è¯æ¨å¹¿' || hasProfileField(/å‡ºä»·æ–¹å¼/);
                const allowAutoBidTarget = targetSceneName === 'å…³é”®è¯æ¨å¹¿' || hasProfileField(/å‡ºä»·ç›®æ ‡|ä¼˜åŒ–ç›®æ ‡/);
                const allowAutoBudgetType = targetSceneName === 'å…³é”®è¯æ¨å¹¿' || hasProfileField(/é¢„ç®—ç±»å‹/);
                const allowAutoBudgetAmount = hasProfileField(/é¢„ç®—|æ—¥å‡é¢„ç®—|æ¯æ—¥é¢„ç®—|æ€»é¢„ç®—/) || targetSceneName === 'å…³é”®è¯æ¨å¹¿';

                sceneSettings.åœºæ™¯åç§° = sceneSettings.åœºæ™¯åç§° || targetSceneName;
                if (allowAutoBidType) {
                    if (targetSceneName === 'å…³é”®è¯æ¨å¹¿') {
                        sceneSettings.å‡ºä»·æ–¹å¼ = bidTypeLabel;
                    } else if (!sceneSettings.å‡ºä»·æ–¹å¼) {
                        sceneSettings.å‡ºä»·æ–¹å¼ = bidTypeLabel;
                    }
                }
                if (allowAutoBudgetType && !sceneSettings.é¢„ç®—ç±»å‹) {
                    sceneSettings.é¢„ç®—ç±»å‹ = budgetTypeLabel;
                }
                if (!sceneSettings.è®¡åˆ’åç§°) {
                    if (scenePrefix) sceneSettings.è®¡åˆ’åç§° = scenePrefix;
                }
                if (allowAutoBudgetAmount && budgetValue) {
                    if (budgetTypeValue === 'day_budget' && !sceneSettings.æ—¥å‡é¢„ç®—) {
                        sceneSettings.æ—¥å‡é¢„ç®— = budgetValue;
                    }
                    if (budgetTypeValue !== 'day_budget' && !sceneSettings.æ¯æ—¥é¢„ç®—) {
                        sceneSettings.æ¯æ—¥é¢„ç®— = budgetValue;
                    }
                }
                if (allowAutoBidTarget && bidTargetLabel) {
                    if (targetSceneName === 'å…³é”®è¯æ¨å¹¿') {
                        if (currentBidMode === 'manual') {
                            delete sceneSettings.å‡ºä»·ç›®æ ‡;
                            delete sceneSettings.ä¼˜åŒ–ç›®æ ‡;
                        } else {
                            sceneSettings.å‡ºä»·ç›®æ ‡ = bidTargetLabel;
                        }
                    } else if (!sceneSettings.å‡ºä»·ç›®æ ‡) {
                        sceneSettings.å‡ºä»·ç›®æ ‡ = bidTargetLabel;
                    }
                }
                if (targetSceneName === 'å…³é”®è¯æ¨å¹¿') {
                    const keywordGoalFromScene = resolveKeywordGoalFromSceneSettings(sceneSettings);
                    const inferredKeywordGoal = (() => {
                        if (keywordGoalFromScene) return keywordGoalFromScene;
                        const bidModeValue = normalizeBidMode(wizardState?.draft?.bidMode || 'smart', 'smart');
                        if (bidModeValue === 'manual') return 'è‡ªå®šä¹‰æ¨å¹¿';
                        return detectKeywordGoalFromBidTarget(bidTargetValue) || 'è¶‹åŠ¿æ˜æ˜Ÿ';
                    })();
                    if (!keywordGoalFromScene) {
                        sceneSettings.è¥é”€ç›®æ ‡ = inferredKeywordGoal;
                        if (sceneSettings.é€‰æ‹©å¡ä½æ–¹æ¡ˆ || hasProfileField(/é€‰æ‹©å¡ä½æ–¹æ¡ˆ/)) {
                            sceneSettings.é€‰æ‹©å¡ä½æ–¹æ¡ˆ = inferredKeywordGoal;
                        }
                    }
                    if (keywordModeLabel && !sceneSettings.å…³é”®è¯æ¨¡å¼) {
                        sceneSettings.å…³é”®è¯æ¨¡å¼ = keywordModeLabel;
                    }
                    const recommendCountValue = normalizeSceneSettingValue(wizardState?.els?.recommendCountInput?.value || '');
                    if (recommendCountValue && !sceneSettings.æ¨èè¯ç›®æ ‡æ•°) {
                        sceneSettings.æ¨èè¯ç›®æ ‡æ•° = recommendCountValue;
                    }
                    const defaultBidValue = normalizeSceneSettingValue(wizardState?.els?.bidInput?.value || '');
                    if (defaultBidValue && !sceneSettings.é»˜è®¤å…³é”®è¯å‡ºä»·) {
                        sceneSettings.é»˜è®¤å…³é”®è¯å‡ºä»· = defaultBidValue;
                    }
                    const singleCostEnabled = !!wizardState?.els?.singleCostEnableInput?.checked;
                    const singleCostValue = normalizeSceneSettingValue(wizardState?.els?.singleCostInput?.value || '');
                    if (singleCostEnabled && singleCostValue && !sceneSettings.å¹³å‡ç›´æ¥æˆäº¤æˆæœ¬) {
                        sceneSettings.å¹³å‡ç›´æ¥æˆäº¤æˆæœ¬ = singleCostValue;
                    }
                }
                if (targetSceneName === 'è´§å“å…¨ç«™æ¨å¹¿') {
                    delete sceneSettings.è¥é”€åœºæ™¯;
                    const siteBidType = normalizeSceneSettingValue(sceneSettings.å‡ºä»·æ–¹å¼ || '');
                    if (/æœ€å¤§åŒ–æ‹¿é‡/.test(siteBidType)) {
                        delete sceneSettings.ç›®æ ‡æŠ•äº§æ¯”;
                        delete sceneSettings.å‡€ç›®æ ‡æŠ•äº§æ¯”;
                        delete sceneSettings.ROIç›®æ ‡å€¼;
                        delete sceneSettings.å‡ºä»·ç›®æ ‡å€¼;
                        delete sceneSettings.çº¦æŸå€¼;
                        if (!sceneSettings.é¢„ç®—ç±»å‹ || /ä¸é™é¢„ç®—/.test(sceneSettings.é¢„ç®—ç±»å‹)) {
                            sceneSettings.é¢„ç®—ç±»å‹ = 'æ¯æ—¥é¢„ç®—';
                        }
                    }
                }

                return sceneSettings;
            };

            const renderSceneDynamicConfig = () => {
                if (!wizardState.els.sceneDynamic) return;
                const sceneName = String(wizardState.els.sceneSelect?.value || wizardState.draft?.sceneName || 'å…³é”®è¯æ¨å¹¿').trim();
                const profile = getSceneProfile(sceneName);
                const metaFieldLabels = isPlainObject(profile?.fieldMeta)
                    ? Object.keys(profile.fieldMeta)
                        .map(key => normalizeText(profile.fieldMeta[key]?.label || '').replace(/[ï¼š:]/g, '').trim())
                        .filter(Boolean)
                    : [];
                const GOAL_SELECTOR_LABEL_RE = /^(è¥é”€ç›®æ ‡|é€‰æ‹©å¡ä½æ–¹æ¡ˆ|é€‰æ‹©æ‹‰æ–°æ–¹æ¡ˆ|é€‰æ‹©æ–¹æ¡ˆ|é€‰æ‹©ä¼˜åŒ–æ–¹å‘|é€‰æ‹©è§£å†³æ–¹æ¡ˆ|æŠ•æ”¾ç­–ç•¥|æ¨å¹¿æ¨¡å¼|é€‰æ‹©æ–¹å¼|å¡ä½æ–¹å¼)$/;
                const isGoalSelectorField = (label = '') => GOAL_SELECTOR_LABEL_RE.test(normalizeSceneLabelToken(label));
                const collectGoalFieldLabels = (goal = null) => {
                    const labels = [];
                    if (Array.isArray(goal?.fieldRows)) {
                        goal.fieldRows.forEach(row => {
                            const text = normalizeText(row?.label || row?.settingKey || '').replace(/[ï¼š:]/g, '').trim();
                            if (text) labels.push(text);
                        });
                    }
                    if (isPlainObject(goal?.fieldMatrix)) {
                        Object.keys(goal.fieldMatrix).forEach(label => {
                            const text = normalizeText(label).replace(/[ï¼š:]/g, '').trim();
                            if (text) labels.push(text);
                        });
                    }
                    return uniqueBy(labels, item => normalizeSceneLabelToken(item));
                };
                const baseSceneFields = dedupeSceneFieldLabelsForRender(
                    (profile.requiredFields || [])
                        .concat(metaFieldLabels)
                        .filter(Boolean)
                        .filter(item => shouldRenderDynamicSceneField(item, sceneName))
                ).slice(0, 320);
                const bucket = ensureSceneSettingBucket(sceneName);
                const touchedBucket = ensureSceneTouchedBucket(sceneName);
                const goalFieldKey = normalizeSceneFieldKey('è¥é”€ç›®æ ‡');
                const goalAliasKeys = [
                    normalizeSceneFieldKey('é€‰æ‹©å¡ä½æ–¹æ¡ˆ'),
                    normalizeSceneFieldKey('é€‰æ‹©æ‹‰æ–°æ–¹æ¡ˆ'),
                    normalizeSceneFieldKey('é€‰æ‹©æ–¹æ¡ˆ'),
                    normalizeSceneFieldKey('é€‰æ‹©ä¼˜åŒ–æ–¹å‘'),
                    normalizeSceneFieldKey('é€‰æ‹©è§£å†³æ–¹æ¡ˆ'),
                    normalizeSceneFieldKey('æŠ•æ”¾ç­–ç•¥'),
                    normalizeSceneFieldKey('æ¨å¹¿æ¨¡å¼'),
                    normalizeSceneFieldKey('é€‰æ‹©æ–¹å¼'),
                    normalizeSceneFieldKey('å¡ä½æ–¹å¼')
                ].filter(Boolean);
                const goalOptions = uniqueBy(
                    resolveSceneFieldOptions(profile, 'è¥é”€ç›®æ ‡')
                        .concat(getSceneMarketingGoalFallbackList(sceneName))
                        .map(item => normalizeGoalCandidateLabel(item))
                        .filter(Boolean),
                    item => item
                ).slice(0, 24);
                const goalFromBucket = normalizeGoalCandidateLabel(
                    bucket[goalFieldKey]
                    || goalAliasKeys.map(key => bucket[key]).find(Boolean)
                    || ''
                );
                const goalFallback = normalizeGoalCandidateLabel(
                    SCENE_SPEC_FIELD_FALLBACK?.[sceneName]?.è¥é”€ç›®æ ‡
                    || ''
                );
                const activeMarketingGoal = goalFromBucket || goalOptions[0] || goalFallback || '';
                if (activeMarketingGoal) {
                    bucket[goalFieldKey] = activeMarketingGoal;
                }
                const keywordGoalRuntime = sceneName === 'å…³é”®è¯æ¨å¹¿'
                    ? resolveKeywordGoalRuntimeFallback(activeMarketingGoal)
                    : {};
                const syncGoalRuntimeBucket = (label = '', nextValue = '') => {
                    const key = normalizeSceneFieldKey(label);
                    const value = String(nextValue || '').trim();
                    if (!key || !value) return;
                    if (touchedBucket[key]) return;
                    bucket[key] = value;
                };
                if (sceneName === 'å…³é”®è¯æ¨å¹¿' && activeMarketingGoal) {
                    syncGoalRuntimeBucket('campaign.promotionScene', keywordGoalRuntime.promotionScene || '');
                    syncGoalRuntimeBucket('campaign.itemSelectedMode', keywordGoalRuntime.itemSelectedMode || '');
                }
                const sceneGoalSpecs = getSceneCachedGoalSpecs(sceneName);
                const fallbackGoalRows = getSceneGoalFieldRowFallback(sceneName, activeMarketingGoal);
                const fallbackGoalFieldLabels = dedupeSceneFieldLabelsForRender(
                    fallbackGoalRows
                        .map(row => normalizeText(row?.label || '').replace(/[ï¼š:]/g, '').trim())
                        .filter(Boolean)
                );
                fallbackGoalRows.forEach(row => {
                    const key = normalizeSceneFieldKey(normalizeSceneRenderFieldLabel(row?.label || ''));
                    if (!key || touchedBucket[key]) return;
                    if (normalizeSceneSettingValue(bucket[key]) !== '') return;
                    const defaultValue = normalizeSceneSettingValue(row?.defaultValue || '');
                    if (!defaultValue) return;
                    bucket[key] = defaultValue;
                });
                const allGoalFieldLabels = dedupeSceneFieldLabelsForRender(
                    sceneGoalSpecs.flatMap(goal => collectGoalFieldLabels(goal)).concat(fallbackGoalFieldLabels)
                );
                const matchedGoalSpec = sceneGoalSpecs.find(goal => (
                    normalizeGoalCandidateLabel(goal?.goalLabel || '') === activeMarketingGoal
                )) || sceneGoalSpecs.find(goal => goal?.isDefault) || sceneGoalSpecs[0] || null;
                const activeGoalFieldLabels = dedupeSceneFieldLabelsForRender(
                    collectGoalFieldLabels(matchedGoalSpec).concat(fallbackGoalFieldLabels)
                );
                const extraSceneFields = sceneName === 'è´§å“å…¨ç«™æ¨å¹¿'
                    ? ['ç›®æ ‡æŠ•äº§æ¯”', 'å‘å¸ƒæ—¥æœŸ', 'è®¡åˆ’ç»„']
                    : [];
                const allSceneFields = dedupeSceneFieldLabelsForRender(
                    baseSceneFields.concat(
                        activeGoalFieldLabels.filter(label => {
                            if (!label || isGoalSelectorField(label)) return false;
                            const token = normalizeSceneLabelToken(label);
                            if (!token || SCENE_SECTION_ONLY_LABEL_RE.test(token)) return false;
                            if (SCENE_LABEL_NOISE_RE.test(token)) return false;
                            return true;
                        }),
                        extraSceneFields
                    )
                ).slice(0, 360);
                const isLabelInGoalFieldSet = (label = '', set = []) => (
                    Array.isArray(set) && set.some(item => isSceneLabelMatch(label, item))
                );
                const staticFieldTokenSet = new Set(
                    [
                        'è¥é”€ç›®æ ‡',
                        'è¥é”€åœºæ™¯',
                        'åœºæ™¯åç§°',
                        'è®¡åˆ’åç§°',
                        'è®¡åˆ’å',
                        'é¢„ç®—å€¼',
                        'æ¯æ—¥é¢„ç®—',
                        'æ—¥å‡é¢„ç®—',
                        'æ€»é¢„ç®—'
                    ].map(item => normalizeSceneRenderFieldToken(item)).filter(Boolean)
                );
                if (sceneName === 'å…³é”®è¯æ¨å¹¿') {
                    [
                        'å‡ºä»·æ–¹å¼',
                        'å‡ºä»·ç›®æ ‡',
                        'é¢„ç®—ç±»å‹',
                        'å…³é”®è¯æ¨¡å¼',
                        'é»˜è®¤å…³é”®è¯å‡ºä»·',
                        'æ¨èè¯ç›®æ ‡æ•°',
                        'å¹³å‡ç›´æ¥æˆäº¤æˆæœ¬',
                        'æ‰‹åŠ¨å…³é”®è¯',
                        'é€‰å“æ–¹å¼',
                        'é€‰æ‹©æ¨å¹¿å•†å“',
                        'å†·å¯åŠ é€Ÿ',
                        'å¼€å¯å†·å¯åŠ é€Ÿ',
                        'æµé‡æ™ºé€‰',
                        'äººç¾¤è®¾ç½®',
                        'åˆ›æ„è®¾ç½®',
                        'æŠ•æ”¾æ—¶é—´',
                        'æŠ•æ”¾åœ°åŸŸ'
                    ].forEach(item => staticFieldTokenSet.add(normalizeSceneRenderFieldToken(item)));
                }
                if (sceneName === 'è´§å“å…¨ç«™æ¨å¹¿') {
                    [
                        'å‡ºä»·æ–¹å¼',
                        'å‡ºä»·ç›®æ ‡',
                        'é¢„ç®—ç±»å‹',
                        'ä¸“å±æƒç›Š',
                        'æŠ•æ”¾è°ƒä¼˜',
                        'ä¼˜åŒ–ç›®æ ‡',
                        'å¤šç›®æ ‡é¢„ç®—',
                        'ä¸€é”®èµ·é‡é¢„ç®—',
                        'æŠ•æ”¾æ—¶é—´',
                        'æŠ•æ”¾åœ°åŸŸ',
                        'åœ°åŸŸè®¾ç½®',
                        'èµ·é‡æ—¶é—´åœ°åŸŸè®¾ç½®'
                    ]
                        .forEach(item => staticFieldTokenSet.add(normalizeSceneRenderFieldToken(item)));
                }
                const liveBidTypeValue = normalizeSceneSettingValue(
                    wizardState.els.sceneDynamic?.querySelector('input[data-scene-field="å‡ºä»·æ–¹å¼"]')?.value || ''
                );
                const fullSiteBidType = normalizeSceneSettingValue(
                    bucket[normalizeSceneFieldKey('å‡ºä»·æ–¹å¼')]
                    || liveBidTypeValue
                    || SCENE_SPEC_FIELD_FALLBACK?.['è´§å“å…¨ç«™æ¨å¹¿']?.å‡ºä»·æ–¹å¼
                    || ''
                );
                const isFullSiteMaxAmount = sceneName === 'è´§å“å…¨ç«™æ¨å¹¿' && /æœ€å¤§åŒ–æ‹¿é‡/.test(fullSiteBidType);
                const hiddenKeywordFieldTokenSet = new Set(
                    [
                        'campaign.promotionScene',
                        'campaign.itemSelectedMode'
                    ].map(item => normalizeSceneRenderFieldToken(item)).filter(Boolean)
                );
                let fields = allSceneFields.filter((fieldLabel) => {
                    if (isGoalSelectorField(fieldLabel)) return false;
                    if (!isSceneFieldConnectedToPayload(fieldLabel)) return false;
                    const fieldToken = normalizeSceneRenderFieldToken(fieldLabel);
                    if (sceneName === 'å…³é”®è¯æ¨å¹¿' && hiddenKeywordFieldTokenSet.has(fieldToken)) return false;
                    if (isFullSiteMaxAmount && /^(ç›®æ ‡æŠ•äº§æ¯”|ROIç›®æ ‡å€¼|å‡ºä»·ç›®æ ‡å€¼|çº¦æŸå€¼)$/.test(fieldToken)) return false;
                    if (staticFieldTokenSet.has(fieldToken)) return false;
                    if (
                        sceneName === 'è´§å“å…¨ç«™æ¨å¹¿'
                        && /^(ç›®æ ‡æŠ•äº§æ¯”|å‘å¸ƒæ—¥æœŸ|è®¡åˆ’ç»„)$/.test(fieldToken)
                    ) {
                        return true;
                    }
                    if (!allGoalFieldLabels.length || !activeGoalFieldLabels.length) return true;
                    if (!isLabelInGoalFieldSet(fieldLabel, allGoalFieldLabels)) return true;
                    return isLabelInGoalFieldSet(fieldLabel, activeGoalFieldLabels);
                });
                if (sceneName === 'è´§å“å…¨ç«™æ¨å¹¿') {
                    const moveFieldAfter = (list = [], targetLabel = '', anchorLabel = '') => {
                        const targetToken = normalizeSceneRenderFieldToken(targetLabel);
                        const anchorToken = normalizeSceneRenderFieldToken(anchorLabel);
                        if (!targetToken || !anchorToken || targetToken === anchorToken) return list;
                        const targetIndex = list.findIndex(item => normalizeSceneRenderFieldToken(item) === targetToken);
                        const anchorIndex = list.findIndex(item => normalizeSceneRenderFieldToken(item) === anchorToken);
                        if (targetIndex < 0 || anchorIndex < 0) return list;
                        const next = list.slice();
                        const [targetField] = next.splice(targetIndex, 1);
                        const currentAnchorIndex = next.findIndex(item => normalizeSceneRenderFieldToken(item) === anchorToken);
                        const insertIndex = currentAnchorIndex >= 0 ? currentAnchorIndex + 1 : next.length;
                        next.splice(insertIndex, 0, targetField);
                        return next;
                    };
                    fields = moveFieldAfter(fields, 'ç›®æ ‡æŠ•äº§æ¯”', 'å‡ºä»·ç›®æ ‡');
                }
                const autoFilledCount = autoFillSceneDefaults({
                    sceneName,
                    profile,
                    fields,
                    bucket
                });
                if (autoFilledCount > 0) {
                    saveSessionDraft(wizardState.draft);
                    appendWizardLog(`åœºæ™¯é»˜è®¤è®¾ç½®å·²åŠ è½½ ${autoFilledCount} é¡¹ï¼ˆ${sceneName}ï¼‰`, 'success');
                }
                const filledCount = Object.keys(bucket || {})
                    .filter(key => normalizeSceneSettingValue(bucket[key]) !== '')
                    .length;

                const buildProxySelectRow = (label, targetId, selectEl, rowOptions = {}) => {
                    if (!(selectEl instanceof HTMLSelectElement)) return '';
                    const segmented = rowOptions.segmented !== false;
                    const resolveBadgeText = typeof rowOptions.resolveBadgeText === 'function'
                        ? rowOptions.resolveBadgeText
                        : (() => '');
                    const inlineControlHtml = String(rowOptions.inlineControlHtml || '').trim();
                    const selectedValue = String(selectEl.value || '');
                    const optionHtml = Array.from(selectEl.options || []).map(option => {
                        const value = String(option?.value || '');
                        const text = String(option?.textContent || option?.label || value);
                        const badgeText = String(resolveBadgeText({ value, text, label }) || '').trim();
                        const textHtml = Utils.escapeHtml(text);
                        const badgeHtml = badgeText ? `<span class="am-wxt-option-badge">${Utils.escapeHtml(badgeText)}</span>` : '';
                        return `
                            <button
                                type="button"
                                class="am-wxt-option-chip ${value === selectedValue ? 'active' : ''}"
                                data-proxy-select-target="${Utils.escapeHtml(targetId)}"
                                data-proxy-select-value="${Utils.escapeHtml(value)}"
                                ${selectEl.disabled ? 'disabled' : ''}
                            >${textHtml}${badgeHtml}</button>
                        `;
                    }).join('');
                    const controlClass = `am-wxt-setting-control${inlineControlHtml ? ' am-wxt-setting-control-pair' : ''}`;
                    return `
                        <div class="am-wxt-scene-setting-row">
                            <div class="am-wxt-scene-setting-label">${Utils.escapeHtml(label)}</div>
                            <div class="${controlClass}">
                                <div class="am-wxt-option-line${segmented ? ' segmented' : ''}">${optionHtml}</div>
                                ${inlineControlHtml}
                            </div>
                        </div>
                    `;
                };

                const buildGoalSelectorRow = (goalLabel, options = [], selectedValue = '', rowOptions = {}) => {
                    const key = normalizeSceneFieldKey(goalLabel || 'è¥é”€ç›®æ ‡');
                    const segmented = rowOptions.segmented !== false;
                    const optionList = uniqueBy(
                        (Array.isArray(options) ? options : [])
                            .concat([selectedValue])
                            .map(item => normalizeGoalCandidateLabel(item))
                            .filter(Boolean),
                        item => item
                    ).slice(0, 24);
                    if (!optionList.length) return '';
                    const safeValue = optionList.includes(selectedValue) ? selectedValue : optionList[0];
                    const optionHtml = optionList.map(opt => `
                        <button
                            type="button"
                            class="am-wxt-option-chip ${opt === safeValue ? 'active' : ''}"
                            data-scene-option="1"
                            data-scene-option-value="${Utils.escapeHtml(opt)}"
                        >${Utils.escapeHtml(opt)}</button>
                    `).join('');
                    return `
                        <div class="am-wxt-scene-setting-row">
                            <div class="am-wxt-scene-setting-label">${Utils.escapeHtml(goalLabel || 'è¥é”€ç›®æ ‡')}</div>
                            <div class="am-wxt-setting-control">
                                <div class="am-wxt-option-line${segmented ? ' segmented' : ''}">${optionHtml}</div>
                                <input class="am-wxt-hidden-control" data-scene-field="${Utils.escapeHtml(key)}" value="${Utils.escapeHtml(safeValue)}" />
                            </div>
                        </div>
                    `;
                };

                const buildSceneOptionRow = (label, fieldKey, options = [], selectedValue = '', rowOptions = {}) => {
                    const segmented = rowOptions.segmented !== false;
                    const inlineControlHtml = String(rowOptions.inlineControlHtml || '').trim();
                    const optionList = uniqueBy(
                        (Array.isArray(options) ? options : [])
                            .concat([selectedValue])
                            .map(item => normalizeSceneSettingValue(item))
                            .filter(Boolean),
                        item => item
                    ).slice(0, 24);
                    if (!optionList.length) return '';
                    const safeValue = optionList.find(opt => isSceneOptionMatch(opt, selectedValue)) || optionList[0];
                    const optionHtml = optionList.map(opt => `
                        <button
                            type="button"
                            class="am-wxt-option-chip ${isSceneOptionMatch(opt, safeValue) ? 'active' : ''}"
                            data-scene-option="1"
                            data-scene-option-value="${Utils.escapeHtml(opt)}"
                        >${Utils.escapeHtml(opt)}</button>
                    `).join('');
                    const controlClass = `am-wxt-setting-control${inlineControlHtml ? ' am-wxt-setting-control-pair' : ''}`;
                    return `
                        <div class="am-wxt-scene-setting-row">
                            <div class="am-wxt-scene-setting-label">${Utils.escapeHtml(label)}</div>
                            <div class="${controlClass}">
                                <div class="am-wxt-option-line${segmented ? ' segmented' : ''}">${optionHtml}</div>
                                <input class="am-wxt-hidden-control" data-scene-field="${Utils.escapeHtml(fieldKey)}" value="${Utils.escapeHtml(safeValue)}" />
                                ${inlineControlHtml}
                            </div>
                        </div>
                    `;
                };

                const buildSceneSwitchControl = (fieldKey, currentValue, onValue, offValue, switchOptions = {}) => {
                    const normalizedValue = normalizeSceneSettingValue(currentValue || '');
                    const normalizedOn = normalizeSceneSettingValue(onValue || 'å¼€');
                    const normalizedOff = normalizeSceneSettingValue(offValue || 'å…³');
                    const onLabel = normalizeSceneSettingValue(switchOptions.onLabel || 'å¼€') || 'å¼€';
                    const offLabel = normalizeSceneSettingValue(switchOptions.offLabel || 'å…³') || 'å…³';
                    const isOn = isSceneOptionMatch(normalizedValue, normalizedOn);
                    const stateText = isOn ? onLabel : offLabel;
                    return `
                        <button
                            type="button"
                            class="am-wxt-site-switch ${isOn ? 'is-on' : 'is-off'}"
                            data-scene-switch-target="${Utils.escapeHtml(fieldKey)}"
                            data-scene-switch-on="${Utils.escapeHtml(normalizedOn)}"
                            data-scene-switch-off="${Utils.escapeHtml(normalizedOff)}"
                            data-scene-switch-on-label="${Utils.escapeHtml(onLabel)}"
                            data-scene-switch-off-label="${Utils.escapeHtml(offLabel)}"
                            aria-pressed="${isOn ? 'true' : 'false'}"
                        >
                            <span class="am-wxt-site-switch-handle"></span>
                            <span class="am-wxt-site-switch-state">${Utils.escapeHtml(stateText)}</span>
                        </button>
                    `;
                };

                const buildProxyInputRow = (label, targetId, value, placeholder = '') => `
                    <div class="am-wxt-scene-setting-row">
                        <div class="am-wxt-scene-setting-label">${Utils.escapeHtml(label)}</div>
                        <div class="am-wxt-setting-control">
                            <input
                                data-proxy-input-target="${Utils.escapeHtml(targetId)}"
                                value="${Utils.escapeHtml(value || '')}"
                                placeholder="${Utils.escapeHtml(placeholder || '')}"
                            />
                        </div>
                    </div>
                `;

                const buildInlineProxyInputControl = (label, targetId, value, placeholder = '') => `
                    <div class="am-wxt-scene-inline-input">
                        <span class="am-wxt-inline-label">${Utils.escapeHtml(label)}</span>
                        <input
                            data-proxy-input-target="${Utils.escapeHtml(targetId)}"
                            value="${Utils.escapeHtml(value || '')}"
                            placeholder="${Utils.escapeHtml(placeholder || '')}"
                        />
                    </div>
                `;

                const buildInlineSceneInputControl = (label, fieldKey, value, placeholder = '') => `
                    <div class="am-wxt-scene-inline-input">
                        <span class="am-wxt-inline-label">${Utils.escapeHtml(label)}</span>
                        <input
                            data-scene-field="${Utils.escapeHtml(fieldKey)}"
                            value="${Utils.escapeHtml(value || '')}"
                            placeholder="${Utils.escapeHtml(placeholder || '')}"
                        />
                    </div>
                `;

                const parseScenePopupJsonArray = (rawValue = '', fallback = []) => {
                    const parsed = tryParseMaybeJSON(rawValue);
                    if (!Array.isArray(parsed)) return Array.isArray(fallback) ? fallback : [];
                    return parsed.filter(item => item !== null && item !== undefined);
                };

                const describeLaunchPeriodSummary = (rawValue = '') => {
                    const list = parseScenePopupJsonArray(rawValue, []);
                    if (!list.length) return 'ä½¿ç”¨é»˜è®¤å…¨æ—¶æ®µ';
                    const allDay = list.every(item => {
                        const timeSpanList = Array.isArray(item?.timeSpanList) ? item.timeSpanList : [];
                        return timeSpanList.length === 1 && String(timeSpanList[0]?.time || '') === '00:00-24:00';
                    });
                    if (allDay) return 'å…¨æ—¶æ®µ 00:00-24:00';
                    return `å·²é…ç½® ${list.length} ç»„æ—¶æ®µ`;
                };

                const describeLaunchAreaSummary = (rawValue = '') => {
                    const list = parseScenePopupJsonArray(rawValue, ['all'])
                        .map(item => String(item || '').trim())
                        .filter(Boolean);
                    if (!list.length || (list.length === 1 && list[0] === 'all')) return 'å…¨éƒ¨åœ°åŸŸ';
                    return `å·²é…ç½® ${list.length} ä¸ªåœ°åŸŸ`;
                };

                const isAdzoneStatusEnabled = (item = {}) => {
                    if (!isPlainObject(item)) return false;
                    const statusCandidate = [
                        item.status,
                        item.enabled,
                        item.state,
                        item.switch
                    ].find(value => value !== undefined && value !== null && String(value).trim() !== '');
                    if (statusCandidate === undefined) return true;
                    if (typeof statusCandidate === 'boolean') return statusCandidate;
                    const text = String(statusCandidate).trim().toLowerCase();
                    if (!text) return true;
                    if (['0', 'false', 'off', 'close', 'closed', 'å…³', 'å…³é—­', 'å¦', 'no'].includes(text)) return false;
                    return true;
                };

                const setAdzoneStatus = (item = {}, enabled = true) => {
                    const source = isPlainObject(item) ? deepClone(item) : {};
                    const boolEnabled = !!enabled;
                    if (hasOwn(source, 'status') || (!hasOwn(source, 'enabled') && !hasOwn(source, 'state') && !hasOwn(source, 'switch'))) {
                        source.status = boolEnabled ? '1' : '0';
                        return source;
                    }
                    if (hasOwn(source, 'enabled')) {
                        source.enabled = boolEnabled;
                    } else if (hasOwn(source, 'state')) {
                        source.state = boolEnabled ? 1 : 0;
                    } else if (hasOwn(source, 'switch')) {
                        source.switch = boolEnabled ? '1' : '0';
                    } else {
                        source.status = boolEnabled ? '1' : '0';
                    }
                    return source;
                };

                const describeAdzoneSummary = (rawValue = '') => {
                    const list = parseScenePopupJsonArray(rawValue, [])
                        .filter(item => isPlainObject(item));
                    if (!list.length) return 'æ²¿ç”¨é»˜è®¤èµ„æºä½';
                    const enabledCount = list.filter(item => isAdzoneStatusEnabled(item)).length;
                    return `å·²å¼€å¯ ${enabledCount}/${list.length} ä¸ªèµ„æºä½`;
                };

                const describeCrowdSummary = (campaignRaw = '', adgroupRaw = '') => {
                    const campaignList = parseScenePopupJsonArray(campaignRaw, []);
                    const adgroupList = parseScenePopupJsonArray(adgroupRaw, []);
                    if (!campaignList.length && !adgroupList.length) return 'æœªé…ç½®äººç¾¤æ˜ç»†';
                    return `å®¢æˆ· ${campaignList.length} / ç§å­ ${adgroupList.length}`;
                };

                const buildScenePopupControl = (popup = {}) => {
                    const trigger = String(popup?.trigger || '').trim();
                    if (!trigger) return '';
                    const title = String(popup?.title || '').trim();
                    const buttonLabel = String(popup?.buttonLabel || 'é…ç½®').trim() || 'é…ç½®';
                    const summary = String(popup?.summary || '').trim();
                    const hiddenFields = Array.isArray(popup?.hiddenFields) ? popup.hiddenFields : [];
                    const hiddenHtml = hiddenFields
                        .map(field => {
                            const fieldKey = String(field?.fieldKey || '').trim();
                            if (!fieldKey) return '';
                            const fieldValue = String(field?.value || '').trim();
                            return `
                                <input
                                    class="am-wxt-hidden-control"
                                    data-scene-field="${Utils.escapeHtml(fieldKey)}"
                                    data-scene-popup-field="${Utils.escapeHtml(trigger)}"
                                    value="${Utils.escapeHtml(fieldValue)}"
                                />
                            `;
                        })
                        .join('');
                    return `
                        <div class="am-wxt-scene-popup-control">
                            <button
                                type="button"
                                class="am-wxt-btn"
                                data-scene-popup-trigger="${Utils.escapeHtml(trigger)}"
                                data-scene-popup-title="${Utils.escapeHtml(title)}"
                            >${Utils.escapeHtml(buttonLabel)}</button>
                            <span
                                class="am-wxt-scene-popup-summary"
                                data-scene-popup-summary="${Utils.escapeHtml(trigger)}"
                                data-scene-popup-trigger-proxy="${Utils.escapeHtml(trigger)}"
                                role="button"
                                tabindex="0"
                                aria-label="${Utils.escapeHtml(`ç‚¹å‡»${buttonLabel}`)}"
                            >${Utils.escapeHtml(summary || 'æœªé…ç½®')}</span>
                            ${hiddenHtml}
                        </div>
                    `;
                };

                const buildProxyTextareaRow = (label, targetId, value, placeholder = '') => `
                    <div class="am-wxt-scene-setting-row">
                        <div class="am-wxt-scene-setting-label">${Utils.escapeHtml(label)}</div>
                        <div class="am-wxt-setting-control">
                            <textarea
                                data-proxy-input-target="${Utils.escapeHtml(targetId)}"
                                placeholder="${Utils.escapeHtml(placeholder || '')}"
                            >${Utils.escapeHtml(value || '')}</textarea>
                        </div>
                    </div>
                `;
                const buildManualKeywordDesignerRow = (label = 'æ‰‹åŠ¨å…³é”®è¯') => {
                    const fallbackBid = toNumber(wizardState.els.bidInput?.value, 1);
                    const keywordDefaults = {
                        bidPrice: Number.isFinite(fallbackBid) ? fallbackBid : 1,
                        matchScope: DEFAULTS.matchScope,
                        onlineStatus: DEFAULTS.keywordOnlineStatus
                    };
                    const rawManualText = String(wizardState.els.manualInput?.value || '').trim();
                    const keywordList = parseKeywords(rawManualText, keywordDefaults).slice(0, 200);
                    const normalizedManualText = keywordList.map(item => formatKeywordLine(item)).join('\n');
                    const flowFieldKey = normalizeSceneFieldKey('æµé‡æ™ºé€‰');
                    const editingStrategy = typeof getStrategyById === 'function'
                        ? getStrategyById(wizardState.editingStrategyId)
                        : null;
                    const flowEnabled = editingStrategy
                        ? editingStrategy.useWordPackage !== false
                        : wizardState?.draft?.useWordPackage !== false;
                    const manualKeywordPanelCollapsed = wizardState.manualKeywordPanelCollapsed !== false;
                    const flowStatusText = flowEnabled ? 'ç”Ÿæ•ˆä¸­' : 'å·²å…³é—­';
                    const flowSwitchText = flowEnabled ? 'å¼€' : 'å…³';
                    const flowSwitchClassName = flowEnabled ? 'is-on' : 'is-off';
                    const formatBidDisplay = (value) => {
                        const num = toNumber(value, Number.isFinite(fallbackBid) ? fallbackBid : 1);
                        if (!Number.isFinite(num)) return '1';
                        return String(Math.max(0, num).toFixed(4)).replace(/(?:\.0+|(\.\d+?)0+)$/, '$1');
                    };
                    const keywordComboMap = new Map();
                    keywordList.forEach(item => {
                        const metricEntry = getKeywordMetricByWord(item.word) || {};
                        const reasonTag = Array.isArray(metricEntry.reasonTagList) && metricEntry.reasonTagList.length
                            ? String(metricEntry.reasonTagList[0] || '').trim()
                            : '';
                        if (!reasonTag) return;
                        const comboKey = reasonTag;
                        if (!keywordComboMap.has(comboKey)) {
                            keywordComboMap.set(comboKey, {
                                name: reasonTag,
                                wordCount: 0,
                                bidTotal: 0,
                                predictClickTotal: 0
                            });
                        }
                        const target = keywordComboMap.get(comboKey);
                        target.wordCount += 1;
                        target.bidTotal += toNumber(metricEntry.marketAverageBidText, 0);
                        target.predictClickTotal += toNumber(metricEntry.predictClickText, 0);
                    });
                    const keywordComboList = Array.from(keywordComboMap.values())
                        .map(item => ({
                            ...item,
                            avgBidText: item.wordCount > 0
                                ? String((item.bidTotal / item.wordCount).toFixed(2)).replace(/(?:\.0+|(\.\d+?)0+)$/, '$1')
                                : '1',
                            displayText: item.predictClickTotal > 0
                                ? `é¢„ä¼°å±•ç°ï¼š${Math.max(1, Math.round(item.predictClickTotal * 100))}`
                                : `é¢„ä¼°å±•ç°ï¼š${Math.max(1, item.wordCount * 80)}`
                        }))
                        .sort((a, b) => b.wordCount - a.wordCount)
                        .slice(0, 8);
                    const comboRows = keywordComboList.map(item => `
                        <div class="am-wxt-manual-keyword-left-item">
                            <label class="am-wxt-manual-left-check">
                                <input type="checkbox" data-manual-package-enable="1" checked />
                                <span>
                                    <span class="am-wxt-manual-left-title">#${Utils.escapeHtml(item.name)}#</span>
                                    <span class="am-wxt-manual-left-meta">${Utils.escapeHtml(item.displayText)}</span>
                                </span>
                            </label>
                            <span class="am-wxt-manual-left-bid">${Utils.escapeHtml(item.avgBidText)} å…ƒ</span>
                        </div>
                    `).join('');
                    const keywordRows = keywordList.map((item, idx) => {
                        const matchScope = parseMatchScope(item.matchScope, DEFAULTS.matchScope);
                        const isExact = matchScope === 1;
                        const bidText = formatBidDisplay(item.bidPrice);
                        const metricEntry = getKeywordMetricByWord(item.word) || {};
                        const searchIndexText = String(metricEntry.searchIndexText || '-');
                        const clickRateText = String(metricEntry.marketClickRateText || '-');
                        const conversionRateText = String(metricEntry.marketClickConversionRateText || '-');
                        const marketAverageBidText = String(metricEntry.marketAverageBidText || bidText || '-');
                        const relevanceText = String(metricEntry.relevanceText || 'å¥½');
                        const relevanceClassName = String(metricEntry.relevanceClassName || 'keyword-relevance');
                        return `
                            <div
                                class="am-wxt-manual-keyword-item"
                                data-manual-keyword-row="1"
                                data-manual-keyword-word="${Utils.escapeHtml(item.word)}"
                                data-manual-keyword-bid="${Utils.escapeHtml(bidText)}"
                                data-manual-keyword-match="${isExact ? '1' : '4'}"
                            >
                                <label class="keyword-col">
                                    <input type="checkbox" data-manual-keyword-enable="1" checked />
                                    <span class="keyword-main">
                                        <span class="keyword-text">${Utils.escapeHtml(item.word)}</span>
                                        <span class="keyword-submeta">
                                            <span class="keyword-submeta-text">æœç´¢æŒ‡æ•°ï¼š${Utils.escapeHtml(searchIndexText)}</span>
                                            <span class="keyword-submeta-text">ç›¸å…³æ€§ï¼š<span class="${Utils.escapeHtml(relevanceClassName)}">${Utils.escapeHtml(relevanceText)}</span></span>
                                        </span>
                                    </span>
                                </label>
                                <span class="${clickRateText === '-' ? 'metric-muted' : ''}">${Utils.escapeHtml(clickRateText)}</span>
                                <span class="${conversionRateText === '-' ? 'metric-muted' : ''}">${Utils.escapeHtml(conversionRateText)}</span>
                                <span class="bid-value">${Utils.escapeHtml(marketAverageBidText)}</span>
                                <div class="am-wxt-option-line segmented">
                                    <button type="button" class="am-wxt-option-chip ${isExact ? '' : 'active'}" data-manual-keyword-match="4">å¹¿æ³›</button>
                                    <button type="button" class="am-wxt-option-chip ${isExact ? 'active' : ''}" data-manual-keyword-match="1">ç²¾å‡†</button>
                                </div>
                                <label class="am-wxt-bid-edit">
                                    <input type="text" data-manual-keyword-bid-input="1" value="${Utils.escapeHtml(bidText)}" />
                                    <span>å…ƒ</span>
                                </label>
                            </div>
                        `;
                    }).join('');
                    return `
                        <div class="am-wxt-scene-setting-row">
                            <div class="am-wxt-scene-setting-label">${Utils.escapeHtml(label)}</div>
                            <div class="am-wxt-setting-control">
                                <input class="am-wxt-hidden-control" data-scene-field="${Utils.escapeHtml(flowFieldKey)}" data-manual-keyword-flow-hidden="1" value="${flowEnabled ? 'å¼€å¯' : 'å…³é—­'}" />
                                <textarea class="am-wxt-hidden-control" data-proxy-input-target="am-wxt-keyword-manual" data-manual-keyword-hidden="1">${Utils.escapeHtml(normalizedManualText || rawManualText)}</textarea>
                                <div
                                    class="am-wxt-manual-keyword-panel ${manualKeywordPanelCollapsed ? 'is-collapsed' : ''}"
                                    data-manual-keyword-panel="1"
                                    data-manual-keyword-combo-count="${keywordComboList.length}"
                                    data-manual-keyword-count="${keywordList.length}"
                                    data-manual-keyword-collapsed="${manualKeywordPanelCollapsed ? '1' : '0'}"
                                >
                                    <div class="am-wxt-manual-keyword-toolbar">
                                        <div class="am-wxt-manual-keyword-toolbar-left">
                                            <button class="am-wxt-btn primary" type="button" data-manual-keyword-add="1">+æ›´å¤šå…³é”®è¯</button>
                                            <button class="am-wxt-btn" type="button" data-manual-keyword-batch-bid="1">æ‰¹é‡ä¿®æ”¹å‡ºä»·</button>
                                            <div class="am-wxt-manual-keyword-match-menu" data-manual-keyword-match-menu="1">
                                                <button class="am-wxt-btn" type="button" data-manual-keyword-menu-toggle="1">ä¿®æ”¹åŒ¹é…æ–¹æ¡ˆ â–¾</button>
                                                <div class="am-wxt-manual-keyword-match-pop">
                                                    <button class="am-wxt-btn" type="button" data-manual-keyword-batch-match="4">æ‰¹é‡è®¾ä¸ºå¹¿æ³›</button>
                                                    <button class="am-wxt-btn" type="button" data-manual-keyword-batch-match="1">æ‰¹é‡è®¾ä¸ºç²¾å‡†</button>
                                                </div>
                                            </div>
                                        </div>
                                        <div class="am-wxt-manual-keyword-toolbar-right">
                                            <span class="tips">å·²è®¾ç½®ï¼š${flowEnabled ? 'å¼€å¯' : 'å…³é—­'}æµé‡æ™ºé€‰ï¼Œå…³é”®è¯ç»„åˆ ${keywordComboList.length} ä¸ªã€è‡ªé€‰è¯ ${keywordList.length} ä¸ª</span>
                                            <button
                                                class="am-wxt-btn"
                                                type="button"
                                                data-manual-keyword-collapse-toggle="1"
                                                aria-expanded="${manualKeywordPanelCollapsed ? 'false' : 'true'}"
                                            >${manualKeywordPanelCollapsed ? 'å±•å¼€' : 'æ”¶èµ·'}</button>
                                        </div>
                                    </div>
                                    <div class="am-wxt-manual-keyword-layout">
                                        <div class="am-wxt-manual-keyword-left">
                                            <div class="am-wxt-manual-keyword-left-head">
                                                <label class="am-wxt-manual-left-check">
                                                    <input type="checkbox" data-manual-package-check-all="1" ${keywordComboList.length ? 'checked' : ''} />
                                                    <span>è¯åŒ… (${keywordComboList.length}/100)<br />/é¢„ä¼°å±•ç°é‡</span>
                                                </label>
                                                <span>åŸºç¡€å‡ºä»·</span>
                                            </div>
                                            <div class="am-wxt-manual-keyword-left-list">
                                                <div class="am-wxt-manual-keyword-left-item">
                                                    <label class="am-wxt-manual-left-check">
                                                        <input type="checkbox" data-manual-package-enable="1" ${flowEnabled ? 'checked' : ''} />
                                                        <span>
                                                            <span class="am-wxt-manual-left-title">æµé‡æ™ºé€‰</span>
                                                            <span class="am-wxt-manual-left-meta status">${flowStatusText}</span>
                                                        </span>
                                                    </label>
                                                    <button
                                                        type="button"
                                                        class="am-wxt-site-switch ${flowSwitchClassName}"
                                                        data-manual-keyword-flow-toggle="1"
                                                        aria-pressed="${flowEnabled ? 'true' : 'false'}"
                                                    >
                                                        <span class="am-wxt-site-switch-handle"></span>
                                                        <span class="am-wxt-site-switch-state">${flowSwitchText}</span>
                                                    </button>
                                                </div>
                                                ${comboRows || '<div class="am-wxt-manual-keyword-empty">æš‚æ— å…³é”®è¯ç»„åˆ</div>'}
                                            </div>
                                        </div>
                                        <div class="am-wxt-manual-keyword-right">
                                            <div class="am-wxt-manual-keyword-head">
                                                <label class="keyword-col">
                                                    <input type="checkbox" data-manual-keyword-check-all="1" ${keywordList.length ? 'checked' : ''} />
                                                    <span>å…³é”®è¯ (${keywordList.length}/200)</span>
                                                </label>
                                                <span>å¸‚åœºç‚¹å‡»ç‡</span>
                                                <span>å¸‚åœºè½¬åŒ–ç‡</span>
                                                <span>å¸‚åœºå¹³å‡å‡ºä»·</span>
                                                <span>åŒ¹é…æ–¹æ¡ˆ</span>
                                                <span>åŸºç¡€å‡ºä»·</span>
                                            </div>
                                            <div class="am-wxt-manual-keyword-list">
                                                ${keywordRows || '<div class="am-wxt-manual-keyword-empty">æš‚æ— æ‰‹åŠ¨å…³é”®è¯ï¼Œç‚¹å‡»â€œ+æ›´å¤šå…³é”®è¯â€å½•å…¥</div>'}
                                            </div>
                                        </div>
                                    </div>
                                    <div class="am-wxt-manual-keyword-actions">
                                        <span class="tips">æ”¯æŒæ‰¹é‡æ”¹ä»·ã€æ‰¹é‡ä¿®æ”¹åŒ¹é…æ–¹æ¡ˆ</span>
                                        <div>
                                            <button class="am-wxt-btn" type="button" data-manual-keyword-clear="1">æ¸…ç©º</button>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    `;
                };

                const sceneFieldText = uniqueBy((profile.requiredFields || []).concat(metaFieldLabels), item => normalizeSceneLabelToken(item)).join(' ');
                const hasSceneField = (pattern) => pattern.test(sceneFieldText);
                const isKeywordScene = sceneName === 'å…³é”®è¯æ¨å¹¿';
                const shouldShowBudgetInput = isKeywordScene || hasSceneField(/é¢„ç®—|æ—¥å‡é¢„ç®—|æ¯æ—¥é¢„ç®—|æ€»é¢„ç®—/);
                const budgetTypeFieldToken = normalizeSceneRenderFieldToken('é¢„ç®—ç±»å‹');
                const hasDynamicBudgetTypeField = fields.some(
                    fieldLabel => normalizeSceneRenderFieldToken(fieldLabel) === budgetTypeFieldToken
                );
                const shouldInlineBudgetWithBudgetType = shouldShowBudgetInput && (isKeywordScene || sceneName === 'è´§å“å…¨ç«™æ¨å¹¿' || hasDynamicBudgetTypeField);
                const shouldRenderStandaloneBudgetRow = shouldShowBudgetInput && !shouldInlineBudgetWithBudgetType;
                const bidConstraintFieldLabel = (() => {
                    if (sceneName !== 'è´§å“å…¨ç«™æ¨å¹¿' || isFullSiteMaxAmount) return '';
                    const preferredLabels = ['ç›®æ ‡æŠ•äº§æ¯”', 'å‡€ç›®æ ‡æŠ•äº§æ¯”', 'ROIç›®æ ‡å€¼', 'å‡ºä»·ç›®æ ‡å€¼', 'çº¦æŸå€¼'];
                    for (const preferredLabel of preferredLabels) {
                        const token = normalizeSceneRenderFieldToken(preferredLabel);
                        const hit = fields.find(fieldLabel => normalizeSceneRenderFieldToken(fieldLabel) === token);
                        if (hit) return hit;
                    }
                    return 'ç›®æ ‡æŠ•äº§æ¯”';
                })();
                const bidConstraintFieldKey = bidConstraintFieldLabel ? normalizeSceneFieldKey(bidConstraintFieldLabel) : '';
                const bidConstraintFieldToken = bidConstraintFieldLabel ? normalizeSceneRenderFieldToken(bidConstraintFieldLabel) : '';
                if (sceneName === 'è´§å“å…¨ç«™æ¨å¹¿' && Object.prototype.hasOwnProperty.call(bucket, 'field')) {
                    delete bucket.field;
                }
                if (sceneName === 'è´§å“å…¨ç«™æ¨å¹¿' && bidConstraintFieldKey && normalizeSceneSettingValue(bucket[bidConstraintFieldKey]) === '') {
                    const fallbackBidConstraintValue = normalizeSceneSettingValue(
                        SCENE_SPEC_FIELD_FALLBACK?.['è´§å“å…¨ç«™æ¨å¹¿']?.ç›®æ ‡æŠ•äº§æ¯”
                        || SCENE_SPEC_FIELD_FALLBACK?.['è´§å“å…¨ç«™æ¨å¹¿']?.å‡€ç›®æ ‡æŠ•äº§æ¯”
                        || ''
                    );
                    if (fallbackBidConstraintValue) {
                        bucket[bidConstraintFieldKey] = fallbackBidConstraintValue;
                    }
                }
                if (sceneName === 'è´§å“å…¨ç«™æ¨å¹¿' && bidConstraintFieldKey) {
                    const currentBidConstraintValue = normalizeSceneSettingValue(bucket[bidConstraintFieldKey]);
                    if (/(å¢åŠ æ€»æˆäº¤é‡‘é¢|å¢åŠ å‡€æˆäº¤é‡‘é¢|è·å–æˆäº¤é‡|ç¨³å®šæŠ•äº§æ¯”|å¢åŠ ç‚¹å‡»é‡|å¢åŠ æ”¶è—åŠ è´­é‡)/.test(currentBidConstraintValue)) {
                        const fallbackBidConstraintValue = normalizeSceneSettingValue(
                            SCENE_SPEC_FIELD_FALLBACK?.['è´§å“å…¨ç«™æ¨å¹¿']?.ç›®æ ‡æŠ•äº§æ¯”
                            || SCENE_SPEC_FIELD_FALLBACK?.['è´§å“å…¨ç«™æ¨å¹¿']?.å‡€ç›®æ ‡æŠ•äº§æ¯”
                            || '5'
                        );
                        bucket[bidConstraintFieldKey] = fallbackBidConstraintValue;
                    }
                }
                const staticRows = [];
                staticRows.push(buildProxySelectRow('åœºæ™¯é€‰æ‹©', 'am-wxt-keyword-scene-select', wizardState.els.sceneSelect, { segmented: true }));
                staticRows.push(buildGoalSelectorRow('è¥é”€ç›®æ ‡', goalOptions, activeMarketingGoal, { segmented: true }));
                staticRows.push(buildProxyInputRow('è®¡åˆ’åç§°', 'am-wxt-keyword-prefix', wizardState.els.prefixInput?.value || '', 'ä¾‹å¦‚ï¼šåœºæ™¯_æ—¶é—´'));
                if (isKeywordScene) {
                    const keywordBidMode = normalizeBidMode(
                        wizardState?.els?.bidModeSelect?.value || wizardState?.draft?.bidMode || 'smart',
                        'smart'
                    );
                    staticRows.push(buildProxySelectRow('å‡ºä»·æ–¹å¼', 'am-wxt-keyword-bid-mode', wizardState.els.bidModeSelect, { segmented: true }));
                    if (keywordBidMode !== 'manual') {
                        staticRows.push(buildProxySelectRow('å‡ºä»·ç›®æ ‡', 'am-wxt-keyword-bid-target', wizardState.els.bidTargetSelect, {
                            segmented: true,
                            resolveBadgeText: ({ value, text }) => (value === 'conv' || /è·å–æˆäº¤é‡/.test(text)) ? 'å‡çº§å‡€æˆäº¤' : ''
                        }));
                    }
                    staticRows.push(buildProxySelectRow('é¢„ç®—ç±»å‹', 'am-wxt-keyword-budget-type', wizardState.els.budgetTypeSelect, {
                        segmented: true,
                        inlineControlHtml: shouldInlineBudgetWithBudgetType
                            ? buildInlineProxyInputControl(
                                'é¢„ç®—å€¼',
                                'am-wxt-keyword-budget',
                                wizardState.els.budgetInput?.value || '',
                                'è¯·è¾“å…¥é¢„ç®—'
                            )
                            : ''
                    }));
                    const activeKeywordGoal = detectKeywordGoalFromText(activeMarketingGoal || '');
                    if (activeKeywordGoal === 'è‡ªå®šä¹‰æ¨å¹¿') {
                        const pushKeywordCustomSettingRow = ({
                            label = '',
                            aliases = [],
                            options = [],
                            defaultValue = '',
                            popup = null
                        } = {}) => {
                            const normalizedLabel = normalizeSceneRenderFieldLabel(label) || label;
                            const key = normalizeSceneFieldKey(normalizedLabel);
                            if (!normalizedLabel || !key) return;
                            const aliasKeys = (Array.isArray(aliases) ? aliases : [])
                                .map(item => normalizeSceneFieldKey(item))
                                .filter(Boolean);
                            const optionList = uniqueBy(
                                resolveSceneFieldOptions(profile, normalizedLabel)
                                    .concat(Array.isArray(options) ? options : [])
                                    .map(item => normalizeSceneSettingValue(item))
                                    .filter(Boolean),
                                item => item
                            ).slice(0, 24);
                            const currentValue = normalizeSceneSettingValue(
                                bucket[key]
                                || aliasKeys.map(aliasKey => bucket[aliasKey]).find(val => normalizeSceneSettingValue(val))
                                || defaultValue
                                || optionList[0]
                                || ''
                            );
                            if (currentValue) {
                                bucket[key] = currentValue;
                                aliasKeys.forEach(aliasKey => {
                                    if (!aliasKey || touchedBucket[aliasKey]) return;
                                    if (normalizeSceneSettingValue(bucket[aliasKey])) return;
                                    bucket[aliasKey] = currentValue;
                                });
                            }
                            const popupControlHtml = isPlainObject(popup) ? buildScenePopupControl(popup) : '';
                            staticRows.push(buildSceneOptionRow(normalizedLabel, key, optionList, currentValue, {
                                segmented: true,
                                inlineControlHtml: popupControlHtml
                            }));
                        };
                        const crowdCampaignField = 'campaign.crowdList';
                        const crowdAdgroupField = 'adgroup.rightList';
                        const adzoneField = 'campaign.adzoneList';
                        const launchPeriodField = 'campaign.launchPeriodList';
                        const launchAreaField = 'campaign.launchAreaStrList';
                        const crowdCampaignRaw = normalizeSceneSettingValue(
                            bucket[crowdCampaignField]
                            || bucket[normalizeSceneFieldKey(crowdCampaignField)]
                            || '[]'
                        ) || '[]';
                        const crowdAdgroupRaw = normalizeSceneSettingValue(
                            bucket[crowdAdgroupField]
                            || bucket[normalizeSceneFieldKey(crowdAdgroupField)]
                            || (Array.isArray(wizardState.crowdList) && wizardState.crowdList.length
                                ? JSON.stringify(wizardState.crowdList)
                                : '[]')
                        ) || '[]';
                        const launchPeriodList = parseScenePopupJsonArray(
                            normalizeSceneSettingValue(
                                bucket[launchPeriodField]
                                || bucket[normalizeSceneFieldKey(launchPeriodField)]
                                || ''
                            ),
                            buildDefaultLaunchPeriodList()
                        );
                        const launchPeriodRaw = JSON.stringify(
                            Array.isArray(launchPeriodList) && launchPeriodList.length
                                ? launchPeriodList
                                : buildDefaultLaunchPeriodList()
                        );
                        const launchAreaList = uniqueBy(
                            parseScenePopupJsonArray(
                                normalizeSceneSettingValue(
                                    bucket[launchAreaField]
                                    || bucket[normalizeSceneFieldKey(launchAreaField)]
                                    || '["all"]'
                                ),
                                ['all']
                            )
                                .map(item => String(item || '').trim())
                                .filter(Boolean),
                            item => item
                        );
                        const launchAreaRaw = JSON.stringify(
                            launchAreaList.length ? launchAreaList : ['all']
                        );
                        const adzoneRawValue = normalizeSceneSettingValue(
                            bucket[adzoneField]
                            || bucket[normalizeSceneFieldKey(adzoneField)]
                            || '[]'
                        ) || '[]';
                        const adzoneList = normalizeAdzoneListForAdvanced(adzoneRawValue);
                        const adzoneRaw = JSON.stringify(adzoneList);
                        bucket[crowdCampaignField] = crowdCampaignRaw;
                        bucket[crowdAdgroupField] = crowdAdgroupRaw;
                        bucket[adzoneField] = adzoneRaw;
                        bucket[launchPeriodField] = launchPeriodRaw;
                        bucket[launchAreaField] = launchAreaRaw;
                        const itemModeCode = normalizeSceneSettingValue(
                            bucket[normalizeSceneFieldKey('campaign.itemSelectedMode')]
                            || keywordGoalRuntime.itemSelectedMode
                            || ''
                        );
                        const defaultItemModeLabel = /shop/i.test(itemModeCode) ? 'è¡Œä¸šæ¨èé€‰å“' : 'è‡ªå®šä¹‰é€‰å“';
                        pushKeywordCustomSettingRow({
                            label: 'é€‰å“æ–¹å¼',
                            aliases: ['é€‰æ‹©æ¨å¹¿å•†å“'],
                            options: ['è‡ªå®šä¹‰é€‰å“', 'è¡Œä¸šæ¨èé€‰å“'],
                            defaultValue: defaultItemModeLabel
                        });
                        pushKeywordCustomSettingRow({
                            label: 'å†·å¯åŠ é€Ÿ',
                            aliases: ['å¼€å¯å†·å¯åŠ é€Ÿ'],
                            options: ['å¼€å¯', 'å…³é—­'],
                            defaultValue: normalizeSceneSettingValue(
                                SCENE_SPEC_FIELD_FALLBACK?.['å…³é”®è¯æ¨å¹¿']?.å†·å¯åŠ é€Ÿ
                                || SCENE_SPEC_FIELD_FALLBACK?.['å…³é”®è¯æ¨å¹¿']?.å¼€å¯å†·å¯åŠ é€Ÿ
                                || 'å¼€å¯'
                            )
                        });
                        pushKeywordCustomSettingRow({
                            label: 'äººç¾¤è®¾ç½®',
                            aliases: ['è®¾ç½®äººç¾¤', 'è®¾ç½®æ‹‰æ–°äººç¾¤', 'ç§å­äººç¾¤'],
                            options: ['æ™ºèƒ½äººç¾¤', 'æ·»åŠ ç§å­äººç¾¤', 'è®¾ç½®ä¼˜å…ˆæŠ•æ”¾å®¢æˆ·', 'å…³é—­'],
                            defaultValue: 'å…³é—­',
                            popup: {
                                trigger: 'crowd',
                                title: 'é…ç½®äººç¾¤æ˜ç»†',
                                buttonLabel: 'é…ç½®äººç¾¤',
                                summary: describeCrowdSummary(crowdCampaignRaw, crowdAdgroupRaw),
                                hiddenFields: [
                                    { fieldKey: crowdCampaignField, value: crowdCampaignRaw },
                                    { fieldKey: crowdAdgroupField, value: crowdAdgroupRaw }
                                ]
                            }
                        });
                        pushKeywordCustomSettingRow({
                            label: 'åˆ›æ„è®¾ç½®',
                            aliases: ['è®¾ç½®åˆ›æ„', 'åˆ›æ„æ¨¡å¼'],
                            options: ['æ™ºèƒ½', 'ä¸“ä¸š', 'æç®€'],
                            defaultValue: 'æ™ºèƒ½'
                        });
                        pushKeywordCustomSettingRow({
                            label: 'æŠ•æ”¾èµ„æºä½',
                            aliases: ['èµ„æºä½è®¾ç½®', 'æŠ•æ”¾èµ„æºä½/æŠ•æ”¾åœ°åŸŸ/æŠ•æ”¾æ—¶é—´', 'é«˜çº§è®¾ç½®'],
                            options: ['å¹³å°ä¼˜é€‰', 'è‡ªå®šä¹‰èµ„æºä½'],
                            defaultValue: 'å¹³å°ä¼˜é€‰',
                            popup: {
                                trigger: 'adzone',
                                title: 'é«˜çº§è®¾ç½®',
                                buttonLabel: 'é…ç½®èµ„æºä½',
                                summary: describeAdzoneSummary(adzoneRaw),
                                hiddenFields: [
                                    { fieldKey: adzoneField, value: adzoneRaw }
                                ]
                            }
                        });
                        pushKeywordCustomSettingRow({
                            label: 'æŠ•æ”¾æ—¶é—´',
                            aliases: ['æŠ•æ”¾æ—¥æœŸ', 'å‘å¸ƒæ—¥æœŸ'],
                            options: ['é•¿æœŸæŠ•æ”¾', 'ä¸é™æ—¶æ®µ', 'å›ºå®šæ—¶æ®µ'],
                            defaultValue: 'é•¿æœŸæŠ•æ”¾',
                            popup: {
                                trigger: 'launchPeriod',
                                title: 'é«˜çº§è®¾ç½®',
                                buttonLabel: 'é…ç½®æ—¶æ®µ',
                                summary: describeLaunchPeriodSummary(launchPeriodRaw),
                                hiddenFields: [
                                    { fieldKey: launchPeriodField, value: launchPeriodRaw }
                                ]
                            }
                        });
                        pushKeywordCustomSettingRow({
                            label: 'æŠ•æ”¾åœ°åŸŸ',
                            aliases: ['åœ°åŸŸè®¾ç½®'],
                            options: ['å…¨éƒ¨åœ°åŸŸ'],
                            defaultValue: 'å…¨éƒ¨åœ°åŸŸ',
                            popup: {
                                trigger: 'launchArea',
                                title: 'é«˜çº§è®¾ç½®',
                                buttonLabel: 'é…ç½®åœ°åŸŸ',
                                summary: describeLaunchAreaSummary(launchAreaRaw),
                                hiddenFields: [
                                    { fieldKey: launchAreaField, value: launchAreaRaw }
                                ]
                            }
                        });
                    }
                }
                if (sceneName === 'è´§å“å…¨ç«™æ¨å¹¿') {
                    const bidTypeKey = normalizeSceneFieldKey('å‡ºä»·æ–¹å¼');
                    const bidTypeOptions = resolveSceneFieldOptions(profile, 'å‡ºä»·æ–¹å¼');
                    const bidTypeValue = normalizeSceneSettingValue(
                        bucket[bidTypeKey]
                        || SCENE_SPEC_FIELD_FALLBACK?.['è´§å“å…¨ç«™æ¨å¹¿']?.å‡ºä»·æ–¹å¼
                        || bidTypeOptions[0]
                        || ''
                    );
                    if (bidTypeValue) bucket[bidTypeKey] = bidTypeValue;
                    staticRows.push(buildSceneOptionRow('å‡ºä»·æ–¹å¼', bidTypeKey, bidTypeOptions, bidTypeValue, { segmented: true }));

                    const bidTargetKey = normalizeSceneFieldKey('å‡ºä»·ç›®æ ‡');
                    const bidTargetOptions = resolveSceneFieldOptions(profile, 'å‡ºä»·ç›®æ ‡');
                    const bidTargetValue = normalizeSceneSettingValue(
                        bucket[bidTargetKey]
                        || SCENE_SPEC_FIELD_FALLBACK?.['è´§å“å…¨ç«™æ¨å¹¿']?.å‡ºä»·ç›®æ ‡
                        || bidTargetOptions[0]
                        || ''
                    );
                    if (bidTargetValue) bucket[bidTargetKey] = bidTargetValue;
                    const bidConstraintLabel = normalizeSceneRenderFieldLabel(bidConstraintFieldLabel) || 'ç›®æ ‡æŠ•äº§æ¯”';
                    staticRows.push(buildSceneOptionRow('å‡ºä»·ç›®æ ‡', bidTargetKey, bidTargetOptions, bidTargetValue, {
                        segmented: true,
                        inlineControlHtml: (!isFullSiteMaxAmount && bidConstraintFieldKey)
                            ? buildInlineSceneInputControl(
                                bidConstraintLabel,
                                bidConstraintFieldKey,
                                normalizeSceneSettingValue(bucket[bidConstraintFieldKey] || ''),
                                `è¯·è¾“å…¥${bidConstraintLabel}`
                            )
                            : ''
                    }));

                    const budgetTypeKey = normalizeSceneFieldKey('é¢„ç®—ç±»å‹');
                    const budgetTypeOptions = resolveSceneFieldOptions(profile, 'é¢„ç®—ç±»å‹');
                    const budgetTypeValue = normalizeSceneSettingValue(
                        bucket[budgetTypeKey]
                        || SCENE_SPEC_FIELD_FALLBACK?.['è´§å“å…¨ç«™æ¨å¹¿']?.é¢„ç®—ç±»å‹
                        || budgetTypeOptions[0]
                        || ''
                    );
                    if (budgetTypeValue) bucket[budgetTypeKey] = budgetTypeValue;
                    staticRows.push(buildSceneOptionRow('é¢„ç®—ç±»å‹', budgetTypeKey, budgetTypeOptions, budgetTypeValue, {
                        segmented: true,
                        inlineControlHtml: buildInlineProxyInputControl(
                            'é¢„ç®—å€¼',
                            'am-wxt-keyword-budget',
                            wizardState.els.budgetInput?.value || '',
                            'è¯·è¾“å…¥é¢„ç®—'
                        )
                    }));

                    const benefitKey = normalizeSceneFieldKey('ä¸“å±æƒç›Š');
                    const benefitValue = normalizeSceneSettingValue(bucket[benefitKey] || 'æ™ºèƒ½è¡¥è´´åˆ¸');
                    bucket[benefitKey] = benefitValue;
                    staticRows.push(`
                        <div class="am-wxt-scene-setting-row">
                            <div class="am-wxt-scene-setting-label">ä¸“å±æƒç›Š</div>
                            <div class="am-wxt-setting-control">
                                <div class="am-wxt-site-optimize-main">
                                    <span class="am-wxt-site-optimize-title">æ™ºèƒ½è¡¥è´´åˆ¸</span>
                                    ${buildSceneSwitchControl(benefitKey, benefitValue, 'æ™ºèƒ½è¡¥è´´åˆ¸', 'ä¸å¯ç”¨')}
                                    <span class="am-wxt-site-optimize-link">æŠ•æ”¾å³æœ‰æœºä¼šè·å¾—æ¶ˆè´¹è€…è¡¥è´´åˆ¸</span>
                                </div>
                                <input class="am-wxt-hidden-control" data-scene-field="${Utils.escapeHtml(benefitKey)}" value="${Utils.escapeHtml(benefitValue)}" />
                            </div>
                        </div>
                    `);

                    const optimizeModeKey = normalizeSceneFieldKey('æŠ•æ”¾è°ƒä¼˜');
                    const optimizeTargetKey = normalizeSceneFieldKey('ä¼˜åŒ–ç›®æ ‡');
                    const optimizeBudgetKey = normalizeSceneFieldKey('å¤šç›®æ ‡é¢„ç®—');
                    const launchBudgetKey = normalizeSceneFieldKey('ä¸€é”®èµ·é‡é¢„ç®—');
                    const launchTimeKey = normalizeSceneFieldKey('æŠ•æ”¾æ—¶é—´');
                    const launchAreaKey = normalizeSceneFieldKey('æŠ•æ”¾åœ°åŸŸ');
                    const optimizeTargetOptions = uniqueBy(
                        ['ä¼˜åŒ–åŠ è´­', 'ä¼˜åŒ–ç›´æ¥æˆäº¤', 'å¢åŠ æ”¶è—åŠ è´­é‡', 'å¢åŠ æ€»æˆäº¤é‡‘é¢', 'å¢åŠ å‡€æˆäº¤é‡‘é¢']
                            .concat(resolveSceneFieldOptions(profile, 'ä¼˜åŒ–ç›®æ ‡'))
                            .map(item => normalizeSceneSettingValue(item))
                            .filter(Boolean),
                        item => normalizeSceneOptionText(item)
                    ).slice(0, 6);
                    const optimizeModeValue = normalizeSceneSettingValue(
                        bucket[optimizeModeKey]
                        || SCENE_SPEC_FIELD_FALLBACK?.['è´§å“å…¨ç«™æ¨å¹¿']?.æŠ•æ”¾è°ƒä¼˜
                        || 'å¤šç›®æ ‡ä¼˜åŒ–'
                    );
                    const optimizeTargetValue = normalizeSceneSettingValue(
                        bucket[optimizeTargetKey]
                        || SCENE_SPEC_FIELD_FALLBACK?.['è´§å“å…¨ç«™æ¨å¹¿']?.ä¼˜åŒ–ç›®æ ‡
                        || optimizeTargetOptions[0]
                        || 'ä¼˜åŒ–åŠ è´­'
                    );
                    const optimizeBudgetValue = normalizeSceneSettingValue(
                        bucket[optimizeBudgetKey]
                        || SCENE_SPEC_FIELD_FALLBACK?.['è´§å“å…¨ç«™æ¨å¹¿']?.å¤šç›®æ ‡é¢„ç®—
                        || wizardState.els.budgetInput?.value
                        || '50'
                    );
                    const launchBudgetValue = normalizeSceneSettingValue(
                        bucket[launchBudgetKey]
                        || SCENE_SPEC_FIELD_FALLBACK?.['è´§å“å…¨ç«™æ¨å¹¿']?.ä¸€é”®èµ·é‡é¢„ç®—
                        || wizardState.els.budgetInput?.value
                        || '50'
                    );
                    const launchTimeValue = normalizeSceneSettingValue(
                        bucket[launchTimeKey]
                        || SCENE_SPEC_FIELD_FALLBACK?.['è´§å“å…¨ç«™æ¨å¹¿']?.æŠ•æ”¾æ—¶é—´
                        || 'é•¿æœŸæŠ•æ”¾'
                    );
                    const launchAreaValue = normalizeSceneSettingValue(
                        bucket[launchAreaKey]
                        || SCENE_SPEC_FIELD_FALLBACK?.['è´§å“å…¨ç«™æ¨å¹¿']?.æŠ•æ”¾åœ°åŸŸ
                        || 'å…¨éƒ¨åœ°åŸŸ'
                    );
                    bucket[optimizeModeKey] = optimizeModeValue;
                    bucket[optimizeTargetKey] = optimizeTargetValue;
                    bucket[optimizeBudgetKey] = optimizeBudgetValue;
                    bucket[launchBudgetKey] = launchBudgetValue;
                    bucket[launchTimeKey] = launchTimeValue;
                    bucket[launchAreaKey] = launchAreaValue;
                    const optimizeTargetOptionHtml = optimizeTargetOptions.map(opt => `
                        <button
                            type="button"
                            class="am-wxt-option-chip ${isSceneOptionMatch(opt, optimizeTargetValue) ? 'active' : ''}"
                            data-scene-toggle-target="${Utils.escapeHtml(optimizeTargetKey)}"
                            data-scene-toggle-value="${Utils.escapeHtml(opt)}"
                        >${Utils.escapeHtml(opt)}</button>
                    `).join('');
                    staticRows.push(`
                        <div class="am-wxt-scene-setting-row">
                            <div class="am-wxt-scene-setting-label">æŠ•æ”¾è°ƒä¼˜</div>
                            <div class="am-wxt-setting-control am-wxt-site-optimize-box">
                                <div class="am-wxt-site-optimize-item">
                                    <div class="am-wxt-site-optimize-main">
                                        <span class="am-wxt-site-optimize-title">å¤šç›®æ ‡ä¼˜åŒ–</span>
                                        ${buildSceneSwitchControl(optimizeModeKey, optimizeModeValue, 'å¤šç›®æ ‡ä¼˜åŒ–', 'æ—¥å¸¸ä¼˜åŒ–')}
                                    </div>
                                    <div class="am-wxt-site-optimize-inline-row">
                                        <span class="am-wxt-site-optimize-inline-label">ç›®æ ‡ï¼š</span>
                                        <div class="am-wxt-site-toggle am-wxt-site-toggle-wide" data-scene-toggle-group="optimize-target">
                                            ${optimizeTargetOptionHtml}
                                        </div>
                                        <div class="am-wxt-site-optimize-inline-input">
                                            <span>é¢„ç®—ï¼š</span>
                                            <input data-scene-field="${Utils.escapeHtml(optimizeBudgetKey)}" value="${Utils.escapeHtml(optimizeBudgetValue)}" placeholder="é¢„ç®—" />
                                            <span>å…ƒ</span>
                                        </div>
                                    </div>
                                    <div class="am-wxt-site-optimize-hint">å»ºè®®é¢„ç®—ä¸ä½äº50å…ƒ</div>
                                    <input class="am-wxt-hidden-control" data-scene-field="${Utils.escapeHtml(optimizeModeKey)}" value="${Utils.escapeHtml(optimizeModeValue)}" />
                                    <input class="am-wxt-hidden-control" data-scene-field="${Utils.escapeHtml(optimizeTargetKey)}" value="${Utils.escapeHtml(optimizeTargetValue)}" />
                                </div>
                                <div class="am-wxt-site-optimize-item">
                                    <div class="am-wxt-site-optimize-main">
                                        <span class="am-wxt-site-optimize-title">ä¸€é”®èµ·é‡</span>
                                        ${buildSceneSwitchControl(launchTimeKey, launchTimeValue, 'é•¿æœŸæŠ•æ”¾', 'å›ºå®šæ—¶æ®µ')}
                                        <span class="am-wxt-site-optimize-link">èµ·é‡æ—¶é—´åœ°åŸŸè®¾ç½®</span>
                                    </div>
                                    <div class="am-wxt-site-optimize-inline-row">
                                        <div class="am-wxt-site-optimize-inline-input">
                                            <span>é¢„ç®—ï¼š</span>
                                            <input data-scene-field="${Utils.escapeHtml(launchBudgetKey)}" value="${Utils.escapeHtml(launchBudgetValue)}" placeholder="é¢„ç®—" />
                                            <span>å…ƒ</span>
                                        </div>
                                    </div>
                                    <div class="am-wxt-site-optimize-hint">å»ºè®®é¢„ç®—ä¸ä½äº133å…ƒ</div>
                                    <div class="am-wxt-site-optimize-config">
                                        <input data-scene-field="${Utils.escapeHtml(launchTimeKey)}" value="${Utils.escapeHtml(launchTimeValue)}" placeholder="æŠ•æ”¾æ—¶é—´ï¼ˆå¦‚ï¼šé•¿æœŸæŠ•æ”¾ï¼‰" />
                                        <input data-scene-field="${Utils.escapeHtml(launchAreaKey)}" value="${Utils.escapeHtml(launchAreaValue)}" placeholder="æŠ•æ”¾åœ°åŸŸï¼ˆå¦‚ï¼šå…¨éƒ¨åœ°åŸŸï¼‰" />
                                    </div>
                                </div>
                            </div>
                        </div>
                    `);
                }
                if (shouldRenderStandaloneBudgetRow) {
                    staticRows.push(buildProxyInputRow('é¢„ç®—å€¼', 'am-wxt-keyword-budget', wizardState.els.budgetInput?.value || '', 'è¯·è¾“å…¥é¢„ç®—'));
                }
                if (isKeywordScene) {
                    staticRows.push(`
                        <div class="am-wxt-scene-setting-row">
                            <div class="am-wxt-scene-setting-label">å¹³å‡ç›´æ¥æˆäº¤æˆæœ¬</div>
                            <div class="am-wxt-setting-control am-wxt-setting-control-inline">
                                <label class="am-wxt-inline-check">
                                    <input type="checkbox" data-proxy-check-target="am-wxt-keyword-single-cost-enable" ${wizardState.els.singleCostEnableInput?.checked ? 'checked' : ''} />
                                    <span>å¯ç”¨ï¼ˆéå¿…è¦ï¼‰</span>
                                </label>
                                <input
                                    data-proxy-input-target="am-wxt-keyword-single-cost"
                                    value="${Utils.escapeHtml(wizardState.els.singleCostInput?.value || '')}"
                                    placeholder="æˆæœ¬ä¸Šé™"
                                    style="width:140px;"
                                    ${wizardState.els.singleCostInput?.disabled ? 'disabled' : ''}
                                />
                            </div>
                        </div>
                    `);
                    staticRows.push(buildManualKeywordDesignerRow('æ‰‹åŠ¨å…³é”®è¯'));
                }
                const staticGridHtml = staticRows.join('');
                const API_SCENE_FIELD_LABEL_MAP = {
                    'campaign.promotionScene': 'æ¨å¹¿åœºæ™¯ä»£ç ',
                    'campaign.itemSelectedMode': 'é€‰å“æ¨¡å¼ä»£ç ',
                    'campaign.bidTargetV2': 'å‡ºä»·ç›®æ ‡ä»£ç ',
                    'campaign.optimizeTarget': 'ä¼˜åŒ–ç›®æ ‡ä»£ç '
                };
                const getSceneFieldDisplayLabel = (rawFieldLabel = '') => {
                    const raw = String(normalizeSceneRenderFieldLabel(rawFieldLabel) || rawFieldLabel || '').trim();
                    if (!raw) return '';
                    const mapped = API_SCENE_FIELD_LABEL_MAP[raw];
                    if (!mapped) return raw;
                    return `${mapped}ï¼ˆ${raw}ï¼‰`;
                };

                const gridRows = fields.map(fieldLabel => {
                    const normalizedFieldLabel = normalizeSceneRenderFieldLabel(fieldLabel) || fieldLabel;
                    const key = normalizeSceneFieldKey(normalizedFieldLabel);
                    const renderFieldToken = normalizeSceneRenderFieldToken(normalizedFieldLabel);
                    if (bidConstraintFieldToken && renderFieldToken === bidConstraintFieldToken) return '';
                    const options = resolveSceneFieldOptions(profile, normalizedFieldLabel);
                    let value = normalizeSceneSettingValue(bucket[key] || '');
                    const fieldMeta = profile?.fieldMeta?.[key] || {};
                    const token = normalizeSceneLabelToken(normalizedFieldLabel);
                    const isApiPathField = /^(campaign\.|adgroup\.)/i.test(token);
                    const displayFieldLabel = getSceneFieldDisplayLabel(normalizedFieldLabel) || normalizedFieldLabel;
                    const optionType = resolveSceneFieldOptionType(normalizedFieldLabel);
                    const inlineControlHtml = (() => {
                        if (shouldInlineBudgetWithBudgetType && renderFieldToken === budgetTypeFieldToken) {
                            return buildInlineProxyInputControl(
                                'é¢„ç®—å€¼',
                                'am-wxt-keyword-budget',
                                wizardState.els.budgetInput?.value || '',
                                'è¯·è¾“å…¥é¢„ç®—'
                            );
                        }
                        if (bidConstraintFieldKey && /^(å‡ºä»·ç›®æ ‡|ä¼˜åŒ–ç›®æ ‡)$/.test(renderFieldToken)) {
                            const fieldLabelText = normalizeSceneRenderFieldLabel(bidConstraintFieldLabel) || bidConstraintFieldLabel || 'ç›®æ ‡æŠ•äº§æ¯”';
                            const fieldValue = normalizeSceneSettingValue(bucket[bidConstraintFieldKey] || '');
                            return buildInlineSceneInputControl(
                                fieldLabelText,
                                bidConstraintFieldKey,
                                fieldValue,
                                `è¯·è¾“å…¥${fieldLabelText}`
                            );
                        }
                        return '';
                    })();
                    const rowControlClass = `am-wxt-setting-control${inlineControlHtml ? ' am-wxt-setting-control-pair' : ''}`;
                    const hasExactOptionMatch = (candidate = '') => {
                        const normalizedCandidate = normalizeSceneOptionText(candidate);
                        if (!normalizedCandidate) return false;
                        return options.some(opt => normalizeSceneOptionText(opt) === normalizedCandidate);
                    };
                    if (
                        options.length >= 2
                        && value
                        && SCENE_STRICT_OPTION_TYPE_SET.has(optionType)
                        && !hasExactOptionMatch(value)
                    ) {
                        value = options[0] || '';
                        bucket[key] = value;
                    }
                    if (options.length < 2 || isApiPathField) {
                        const forceKeepInputField = /^(è¥é”€åœºæ™¯|ç›®æ ‡æŠ•äº§æ¯”|ROIç›®æ ‡å€¼|å‡ºä»·ç›®æ ‡å€¼|çº¦æŸå€¼|æŠ•æ”¾åœ°åŸŸ|è®¡åˆ’ç»„|å‘å¸ƒæ—¥æœŸ)$/.test(token);
                        const shouldKeepInputField = (
                            isApiPathField
                            || (
                                token
                                && token.length <= 14
                                && !SCENE_SECTION_ONLY_LABEL_RE.test(token)
                                && !/æ·»åŠ å•†å“|é€‰æ‹©æ¨å¹¿å•†å“/.test(token)
                                && (
                                    normalizeSceneSettingValue(value) !== ''
                                    || fieldMeta?.requiredGuess === true
                                    || fieldMeta?.criticalGuess === true
                                    || forceKeepInputField
                                )
                            )
                        );
                        if (!shouldKeepInputField) return '';
                        const optionHint = isApiPathField && options.length
                            ? `æ¨èå€¼ï¼š${options.slice(0, 6).join(' / ')}`
                            : '';
                        return `
                            <div class="am-wxt-scene-setting-row">
                                <div class="am-wxt-scene-setting-label">${Utils.escapeHtml(displayFieldLabel)}</div>
                                <div class="${rowControlClass}">
                                    <input data-scene-field="${Utils.escapeHtml(key)}" value="${Utils.escapeHtml(value)}" placeholder="${isApiPathField ? 'å¯å¡« JSON / æ•°å­— / å¸ƒå°” / æ–‡æœ¬' : `è¯·è¾“å…¥${Utils.escapeHtml(normalizedFieldLabel)}`}" />
                                    ${inlineControlHtml}
                                    ${optionHint ? `<div style="margin-top:4px;font-size:12px;color:#6b7280;">${Utils.escapeHtml(optionHint)}</div>` : ''}
                                </div>
                            </div>
                        `;
                    }
                    const includeCurrentValue = !!(
                        value
                        && (isApiPathField || isLikelySceneOptionValue(value))
                        && (
                            !SCENE_STRICT_OPTION_TYPE_SET.has(optionType)
                            || hasExactOptionMatch(value)
                        )
                    );
                    const optionList = (() => {
                        const baseList = uniqueBy(
                            (Array.isArray(options) ? options : [])
                                .map(item => normalizeSceneSettingValue(item))
                                .filter(Boolean),
                            item => item
                        );
                        if (includeCurrentValue && value && !baseList.some(opt => isSceneOptionMatch(opt, value))) {
                            baseList.push(value);
                        }
                        return baseList.slice(0, 18);
                    })();
                    const optionHtml = optionList.map(opt => `
                        <button
                            type="button"
                            class="am-wxt-option-chip ${opt === value ? 'active' : ''}"
                            data-scene-option="1"
                            data-scene-option-value="${Utils.escapeHtml(opt)}"
                        >${Utils.escapeHtml(opt)}</button>
                    `).join('');
                    return `
                        <div class="am-wxt-scene-setting-row">
                            <div class="am-wxt-scene-setting-label">${Utils.escapeHtml(displayFieldLabel)}</div>
                            <div class="${rowControlClass}">
                                <div class="am-wxt-option-line segmented">${optionHtml}</div>
                                <input class="am-wxt-hidden-control" data-scene-field="${Utils.escapeHtml(key)}" value="${Utils.escapeHtml(value)}" />
                                ${inlineControlHtml}
                            </div>
                        </div>
                    `;
                }).filter(Boolean);
                const gridHtml = gridRows.join('');

                wizardState.els.sceneDynamic.innerHTML = `
                    <div class="title">
                        <span>åœºæ™¯é…ç½®ï¼š${Utils.escapeHtml(sceneName)}</span>
                        <span class="meta">${profile.source === 'scan' ? 'åŠ¨æ€è¯»å–' : 'åŸºç¡€æ¨¡æ¿'} Â· å·²è®¾ç½® ${filledCount} é¡¹</span>
                    </div>
                    <div class="am-wxt-scene-grid">
                        ${staticGridHtml}
                        ${gridRows.length ? gridHtml : '<div class="am-wxt-scene-empty">å½“å‰åœºæ™¯æš‚æ— é¢å¤–åŠ¨æ€é…ç½®é¡¹</div>'}
                    </div>
                `;

                const proxySelectButtons = wizardState.els.sceneDynamic.querySelectorAll('[data-proxy-select-target]');
                proxySelectButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const targetId = String(button.getAttribute('data-proxy-select-target') || '').trim();
                        const nextValue = String(button.getAttribute('data-proxy-select-value') || '').trim();
                        const target = targetId ? wizardState.els.overlay.querySelector(`#${targetId}`) : null;
                        if (!(target instanceof HTMLSelectElement) || target.disabled) return;
                        if (target.value !== nextValue) {
                            target.value = nextValue;
                            target.dispatchEvent(new Event('input', { bubbles: true }));
                        }
                        target.dispatchEvent(new Event('change', { bubbles: true }));
                        if (targetId !== 'am-wxt-keyword-scene-select') {
                            renderSceneDynamicConfig();
                        }
                    });
                });

                const proxyChecks = wizardState.els.sceneDynamic.querySelectorAll('[data-proxy-check-target]');
                proxyChecks.forEach(checkbox => {
                    checkbox.addEventListener('change', () => {
                        const targetId = String(checkbox.getAttribute('data-proxy-check-target') || '').trim();
                        const target = targetId ? wizardState.els.overlay.querySelector(`#${targetId}`) : null;
                        if (!(target instanceof HTMLInputElement)) return;
                        target.checked = !!checkbox.checked;
                        target.dispatchEvent(new Event('input', { bubbles: true }));
                        target.dispatchEvent(new Event('change', { bubbles: true }));
                        renderSceneDynamicConfig();
                    });
                });

                const proxyInputs = wizardState.els.sceneDynamic.querySelectorAll('[data-proxy-input-target]');
                proxyInputs.forEach(proxy => {
                    const syncProxyValue = () => {
                        const targetId = String(proxy.getAttribute('data-proxy-input-target') || '').trim();
                        const target = targetId ? wizardState.els.overlay.querySelector(`#${targetId}`) : null;
                        if (!(target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement)) return;
                        const nextValue = String(proxy.value || '');
                        if (target.value !== nextValue) target.value = nextValue;
                        target.dispatchEvent(new Event('input', { bubbles: true }));
                        target.dispatchEvent(new Event('change', { bubbles: true }));
                    };
                    proxy.addEventListener('input', syncProxyValue);
                    proxy.addEventListener('change', syncProxyValue);
                });

                const sceneToggleButtons = wizardState.els.sceneDynamic.querySelectorAll('[data-scene-toggle-target]');
                sceneToggleButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const fieldKey = String(button.getAttribute('data-scene-toggle-target') || '').trim();
                        const nextValue = String(button.getAttribute('data-scene-toggle-value') || '').trim();
                        if (!fieldKey) return;
                        const targetControl = Array.from(wizardState.els.sceneDynamic.querySelectorAll('[data-scene-field]')).find(control => (
                            String(control.getAttribute('data-scene-field') || '').trim() === fieldKey
                        ));
                        if (!(targetControl instanceof HTMLInputElement || targetControl instanceof HTMLTextAreaElement)) return;
                        targetControl.value = nextValue;
                        targetControl.dispatchEvent(new Event('input', { bubbles: true }));
                        targetControl.dispatchEvent(new Event('change', { bubbles: true }));
                        const toggleGroup = button.closest('[data-scene-toggle-group]');
                        if (toggleGroup) {
                            toggleGroup.querySelectorAll('[data-scene-toggle-target]').forEach(chip => {
                                chip.classList.toggle('active', chip === button);
                            });
                        }
                    });
                });

                const syncSceneSwitchVisual = (switchButton, enabled) => {
                    if (!(switchButton instanceof HTMLButtonElement)) return;
                    const onLabel = normalizeSceneSettingValue(switchButton.getAttribute('data-scene-switch-on-label') || 'å¼€') || 'å¼€';
                    const offLabel = normalizeSceneSettingValue(switchButton.getAttribute('data-scene-switch-off-label') || 'å…³') || 'å…³';
                    const isOn = !!enabled;
                    switchButton.classList.toggle('is-on', isOn);
                    switchButton.classList.toggle('is-off', !isOn);
                    switchButton.setAttribute('aria-pressed', isOn ? 'true' : 'false');
                    const stateEl = switchButton.querySelector('.am-wxt-site-switch-state');
                    if (stateEl) stateEl.textContent = isOn ? onLabel : offLabel;
                };

                const sceneSwitchButtons = wizardState.els.sceneDynamic.querySelectorAll('[data-scene-switch-target]');
                sceneSwitchButtons.forEach(button => {
                    if (!(button instanceof HTMLButtonElement)) return;
                    button.addEventListener('click', () => {
                        const fieldKey = String(button.getAttribute('data-scene-switch-target') || '').trim();
                        const onValue = normalizeSceneSettingValue(button.getAttribute('data-scene-switch-on') || 'å¼€') || 'å¼€';
                        const offValue = normalizeSceneSettingValue(button.getAttribute('data-scene-switch-off') || 'å…³') || 'å…³';
                        if (!fieldKey) return;
                        const targetControl = Array.from(wizardState.els.sceneDynamic.querySelectorAll('[data-scene-field]')).find(control => (
                            String(control.getAttribute('data-scene-field') || '').trim() === fieldKey
                        ));
                        if (!(targetControl instanceof HTMLInputElement || targetControl instanceof HTMLTextAreaElement)) return;
                        const currentValue = normalizeSceneSettingValue(targetControl.value);
                        const nextValue = isSceneOptionMatch(currentValue, onValue) ? offValue : onValue;
                        targetControl.value = nextValue;
                        targetControl.dispatchEvent(new Event('input', { bubbles: true }));
                        targetControl.dispatchEvent(new Event('change', { bubbles: true }));
                        const isOn = isSceneOptionMatch(nextValue, onValue);
                        wizardState.els.sceneDynamic.querySelectorAll('[data-scene-switch-target]').forEach(peer => {
                            if (!(peer instanceof HTMLButtonElement)) return;
                            if (String(peer.getAttribute('data-scene-switch-target') || '').trim() !== fieldKey) return;
                            syncSceneSwitchVisual(peer, isOn);
                        });
                    });
                });

                const sceneOptionButtons = wizardState.els.sceneDynamic.querySelectorAll('[data-scene-option]');
                sceneOptionButtons.forEach(button => {
                    button.addEventListener('click', () => {
                        const row = button.closest('.am-wxt-scene-setting-row');
                        const hiddenControl = row?.querySelector('input.am-wxt-hidden-control[data-scene-field]')
                            || row?.querySelector('input[data-scene-field]');
                        if (!(hiddenControl instanceof HTMLInputElement)) return;
                        const nextValue = String(button.getAttribute('data-scene-option-value') || '').trim();
                        hiddenControl.value = nextValue;
                        row.querySelectorAll('[data-scene-option]').forEach(chip => {
                            chip.classList.toggle('active', chip === button);
                        });
                        hiddenControl.dispatchEvent(new Event('input', { bubbles: true }));
                        hiddenControl.dispatchEvent(new Event('change', { bubbles: true }));
                    });
                });

                const updateScenePopupSummary = (row, trigger, text) => {
                    const summaryEl = row?.querySelector?.(`[data-scene-popup-summary="${trigger}"]`);
                    if (summaryEl instanceof HTMLElement) {
                        summaryEl.textContent = String(text || '').trim() || 'æœªé…ç½®';
                    }
                };
                const dispatchSceneControlUpdate = (control, nextValue = '') => {
                    if (!(control instanceof HTMLInputElement || control instanceof HTMLTextAreaElement)) return;
                    control.value = String(nextValue || '');
                    control.dispatchEvent(new Event('input', { bubbles: true }));
                    control.dispatchEvent(new Event('change', { bubbles: true }));
                };
                const openScenePopupDialog = ({
                    title = '',
                    bodyHtml = '',
                    onMounted = null,
                    onSave = null,
                    dialogClassName = '',
                    closeLabel = 'å…³é—­',
                    cancelLabel = 'å–æ¶ˆ',
                    saveLabel = 'ä¿å­˜',
                    hideCloseButton = false
                } = {}) => (
                    new Promise((resolve) => {
                        const previousMask = document.getElementById('am-wxt-scene-popup-mask');
                        if (previousMask) previousMask.remove();
                        const mask = document.createElement('div');
                        mask.id = 'am-wxt-scene-popup-mask';
                        mask.className = 'am-wxt-scene-popup-mask';
                        const dialogClass = `am-wxt-scene-popup-dialog${String(dialogClassName || '').trim() ? ` ${String(dialogClassName || '').trim()}` : ''}`;
                        const closeBtnHtml = hideCloseButton
                            ? ''
                            : `<button type="button" class="am-wxt-btn" data-scene-popup-close="1">${Utils.escapeHtml(closeLabel || 'å…³é—­')}</button>`;
                        mask.innerHTML = `
                            <div class="${Utils.escapeHtml(dialogClass)}" role="dialog" aria-modal="true">
                                <div class="am-wxt-scene-popup-head">
                                    <span>${Utils.escapeHtml(title || 'é…ç½®è®¾ç½®')}</span>
                                    ${closeBtnHtml}
                                </div>
                                <div class="am-wxt-scene-popup-body">${bodyHtml || ''}</div>
                                <div class="am-wxt-scene-popup-foot">
                                    <button type="button" class="am-wxt-btn" data-scene-popup-cancel="1">${Utils.escapeHtml(cancelLabel || 'å–æ¶ˆ')}</button>
                                    <button type="button" class="am-wxt-btn primary" data-scene-popup-save="1">${Utils.escapeHtml(saveLabel || 'ä¿å­˜')}</button>
                                </div>
                            </div>
                        `;
                        const close = (payload = null) => {
                            if (typeof mask._amWxtCleanup === 'function') {
                                try {
                                    mask._amWxtCleanup();
                                } catch {}
                            }
                            mask.remove();
                            resolve(payload);
                        };
                        mask.addEventListener('click', (event) => {
                            if (event.target === mask) close(null);
                        });
                        const closeBtn = mask.querySelector('[data-scene-popup-close]');
                        const cancelBtn = mask.querySelector('[data-scene-popup-cancel]');
                        const saveBtn = mask.querySelector('[data-scene-popup-save]');
                        if (closeBtn instanceof HTMLButtonElement) closeBtn.onclick = () => close(null);
                        if (cancelBtn instanceof HTMLButtonElement) cancelBtn.onclick = () => close(null);
                        if (saveBtn instanceof HTMLButtonElement) {
                            saveBtn.onclick = () => {
                                try {
                                    const payload = typeof onSave === 'function' ? onSave(mask) : {};
                                    if (payload && payload.ok === false) return;
                                    close(payload || {});
                                } catch (err) {
                                    appendWizardLog(`ä¿å­˜é…ç½®å¤±è´¥ï¼š${err?.message || err}`, 'error');
                                }
                            };
                        }
                        document.body.appendChild(mask);
                        if (typeof onMounted === 'function') {
                            try {
                                onMounted(mask);
                            } catch (err) {
                                appendWizardLog(`åˆå§‹åŒ–é…ç½®å¼¹çª—å¤±è´¥ï¼š${err?.message || err}`, 'error');
                            }
                        }
                    })
                );
                const resolveScenePopupControl = (fieldKey = '', popupTrigger = '') => {
                    if (!wizardState.els.sceneDynamic) return null;
                    const normalizedFieldKey = String(fieldKey || '').trim();
                    if (!normalizedFieldKey) return null;
                    const triggerSelector = String(popupTrigger || '').trim()
                        ? `[data-scene-popup-field="${String(popupTrigger || '').trim()}"]`
                        : '';
                    return wizardState.els.sceneDynamic.querySelector(
                        `input[data-scene-field="${normalizedFieldKey}"]${triggerSelector}`
                    );
                };
                const resolveScenePopupRowByTrigger = (popupTrigger = '') => {
                    if (!wizardState.els.sceneDynamic) return null;
                    const triggerButton = wizardState.els.sceneDynamic.querySelector(
                        `[data-scene-popup-trigger="${String(popupTrigger || '').trim()}"]`
                    );
                    return triggerButton instanceof HTMLElement
                        ? triggerButton.closest('.am-wxt-scene-setting-row')
                        : null;
                };
                function normalizeAdzoneListForAdvanced(rawValue = '') {
                    const parsed = parseScenePopupJsonArray(rawValue, []);
                    return parsed
                        .map((item, idx) => {
                            if (isPlainObject(item)) return deepClone(item);
                            const token = normalizeSceneSettingValue(item);
                            if (!token) return null;
                            return {
                                adzoneCode: token,
                                adzoneName: token || `èµ„æºä½${idx + 1}`,
                                status: '1'
                            };
                        })
                        .filter(item => isPlainObject(item));
                }
                const getAdzoneDisplayName = (item = {}, idx = 0) => (
                    normalizeSceneSettingValue(
                        item.adzoneName
                        || item.name
                        || item.title
                        || item.adzoneCode
                        || item.code
                        || item.resourceCode
                        || item.resourceName
                        || item.tagName
                    ) || `èµ„æºä½${idx + 1}`
                );
                const getAdzoneDisplayDesc = (item = {}) => normalizeSceneSettingValue(
                    item.description
                    || item.desc
                    || item.subTitle
                    || item.sceneDesc
                    || item.resourceTypeDesc
                    || item.resourceDesc
                    || ''
                );
                const parseLaunchAreaList = (rawValue = '') => {
                    const list = uniqueBy(
                        parseScenePopupJsonArray(rawValue, ['all'])
                            .map(item => String(item || '').trim())
                            .filter(Boolean),
                        item => item
                    );
                    return list.length ? list : ['all'];
                };
                const normalizeNativeAdzoneCode = (item = {}, idx = 0) => {
                    const token = normalizeSceneSettingValue(
                        item.adzoneCode
                        || item.adzoneId
                        || item.code
                        || item.id
                        || item.resourceCode
                        || item.properties?.adzoneId
                        || ''
                    );
                    if (token) return token;
                    const fallbackName = normalizeSceneSettingValue(
                        item.adzoneName
                        || item.name
                        || item.properties?.adzoneName
                        || ''
                    );
                    if (fallbackName) return fallbackName;
                    return `native_adzone_${idx + 1}`;
                };
                const normalizeNativeAdzoneName = (item = {}, idx = 0) => (
                    normalizeSceneSettingValue(
                        item.adzoneName
                        || item.name
                        || item.title
                        || item.properties?.adzoneName
                        || ''
                    ) || `èµ„æºä½${idx + 1}`
                );
                const isAdzoneListPlaceholderForSync = (list = []) => {
                    const normalized = Array.isArray(list) ? list : [];
                    if (!normalized.length) return true;
                    return normalized.every((item, idx) => {
                        const code = normalizeSceneSettingValue(
                            item?.adzoneCode
                            || item?.adzoneId
                            || item?.code
                            || item?.id
                            || ''
                        );
                        const name = normalizeNativeAdzoneName(item, idx);
                        if (/^(DEFAULT_SEARCH|A_TEST_SLOT|B_TEST_SLOT|TEST_|native_adzone_)/i.test(code)) return true;
                        if (/^(DEFAULT_SEARCH|A_TEST_SLOT|B_TEST_SLOT|TEST_|native_adzone_)/i.test(name)) return true;
                        if (/^èµ„æºä½\d+$/.test(name)) return true;
                        return false;
                    });
                };
                const extractNativeAdvancedDefaultsSnapshot = (stateData = {}) => {
                    if (!isPlainObject(stateData)) return null;
                    const selected = isPlainObject(stateData.selected) ? stateData.selected : {};
                    const selectedAdzoneList = Array.isArray(selected.adzoneList)
                        ? selected.adzoneList.filter(item => isPlainObject(item))
                        : [];
                    const allAdzoneListRaw = Array.isArray(stateData.adzoneList)
                        ? stateData.adzoneList
                        : selectedAdzoneList;
                    const selectedCodeSet = new Set(
                        selectedAdzoneList
                            .map((item, idx) => normalizeNativeAdzoneCode(item, idx))
                            .filter(Boolean)
                    );
                    const adzoneList = allAdzoneListRaw
                        .filter(item => isPlainObject(item))
                        .map((item, idx) => {
                            const adzoneCode = normalizeNativeAdzoneCode(item, idx);
                            const adzoneName = normalizeNativeAdzoneName(item, idx);
                            const isEnabledBySelection = selectedCodeSet.size
                                ? selectedCodeSet.has(adzoneCode)
                                : true;
                            return {
                                adzoneCode,
                                adzoneId: normalizeSceneSettingValue(item.adzoneId || item.id || item.properties?.adzoneId || adzoneCode),
                                adzoneName,
                                resourceName: normalizeSceneSettingValue(
                                    item.resourceName
                                    || item.description
                                    || item.desc
                                    || item.subTitle
                                    || item.properties?.desc
                                    || ''
                                ),
                                status: isEnabledBySelection ? '1' : '0'
                            };
                        });
                    const launchAreaList = uniqueBy(
                        (Array.isArray(selected.launchAreaStrList) ? selected.launchAreaStrList : ['all'])
                            .map(item => String(item || '').trim())
                            .filter(Boolean),
                        item => item
                    );
                    const launchPeriodList = Array.isArray(selected.launchPeriodList)
                        ? selected.launchPeriodList.filter(item => isPlainObject(item))
                        : [];
                    if (!adzoneList.length && !launchAreaList.length && !launchPeriodList.length) return null;
                    return {
                        adzoneList,
                        launchAreaList: launchAreaList.length ? launchAreaList : ['all'],
                        launchPeriodList: launchPeriodList.length ? launchPeriodList : buildDefaultLaunchPeriodList()
                    };
                };
                const scoreNativeAdvancedDefaultsSnapshot = (snapshot = {}) => {
                    if (!isPlainObject(snapshot)) return -1;
                    const adzoneList = Array.isArray(snapshot.adzoneList) ? snapshot.adzoneList : [];
                    const launchAreaList = Array.isArray(snapshot.launchAreaList) ? snapshot.launchAreaList : [];
                    const launchPeriodList = Array.isArray(snapshot.launchPeriodList) ? snapshot.launchPeriodList : [];
                    let score = 0;
                    score += Math.min(60, adzoneList.length * 12);
                    if (adzoneList.some((item, idx) => !/^èµ„æºä½\d+$/.test(normalizeNativeAdzoneName(item, idx)))) {
                        score += 20;
                    }
                    if (launchAreaList.length) score += Math.min(10, launchAreaList.length);
                    if (launchPeriodList.length) score += 8;
                    if (launchPeriodList.some(item => Array.isArray(item?.timeSpanList) && item.timeSpanList.length)) {
                        score += 4;
                    }
                    return score;
                };
                const isNativeAdvancedSnapshotRich = (snapshot = {}) => {
                    if (!isPlainObject(snapshot)) return false;
                    const adzoneList = Array.isArray(snapshot.adzoneList) ? snapshot.adzoneList : [];
                    if (!adzoneList.length) return false;
                    return adzoneList.some((item, idx) => {
                        const code = normalizeSceneSettingValue(
                            item?.adzoneCode
                            || item?.adzoneId
                            || item?.code
                            || item?.id
                            || ''
                        );
                        const name = normalizeNativeAdzoneName(item, idx);
                        if (!name || /^èµ„æºä½\d+$/.test(name)) return false;
                        if (/^(DEFAULT_SEARCH|A_TEST_SLOT|B_TEST_SLOT|TEST_|native_adzone_)/i.test(code)) return false;
                        if (/^(DEFAULT_SEARCH|A_TEST_SLOT|B_TEST_SLOT|TEST_|native_adzone_)/i.test(name)) return false;
                        return true;
                    });
                };
                const resolveNativeAdvancedDefaultsFromDialog = () => {
                    const stateHosts = Array.from(document.querySelectorAll('[id^="content_cnt_dlg_"][id$="_adzoneList"], [id^="cnt_dlg_"]'));
                    let bestSnapshot = null;
                    let bestScore = -1;
                    for (const host of stateHosts) {
                        const stateData = host?.vframe?.$v?.updater?.$d;
                        const snapshot = extractNativeAdvancedDefaultsSnapshot(stateData);
                        if (!snapshot) continue;
                        const score = scoreNativeAdvancedDefaultsSnapshot(snapshot);
                        if (score > bestScore) {
                            bestSnapshot = snapshot;
                            bestScore = score;
                        }
                    }
                    return bestSnapshot;
                };
                const resolveNativeAdvancedDialogRoot = () => (
                    document.querySelector('[data-daynamic-view="onebp/views/pages/main/campaign/advance-dlg"]')
                );
                const resolveNativeAdvancedDialogCloseButton = () => {
                    const root = resolveNativeAdvancedDialogRoot();
                    if (!(root instanceof HTMLElement)) return null;
                    return root.querySelector('[data-spm-click*="dialog_close"] button')
                        || root.querySelector('[mx-click*="magix-portsbN"]')
                        || root.querySelector('[data-spm-click*="dialog_close"]');
                };
                const findNativeAdvancedEntryButton = () => {
                    const root = pickPlanConfigRoot();
                    const searchScopes = [root, document];
                    const visited = new Set();
                    for (const scope of searchScopes) {
                        if (!scope || visited.has(scope) || typeof scope.querySelectorAll !== 'function') continue;
                        visited.add(scope);
                        const candidates = Array.from(scope.querySelectorAll('button,a,[role="button"]'));
                        const target = candidates.find(item => {
                            if (!(item instanceof HTMLElement)) return false;
                            const style = window.getComputedStyle(item);
                            if (style.display === 'none' || style.visibility === 'hidden') return false;
                            const text = normalizeText(item.textContent || '').replace(/\s+/g, '');
                            if (!text) return false;
                            return /æŠ•æ”¾èµ„æºä½\/æŠ•æ”¾åœ°åŸŸ\/æŠ•æ”¾æ—¶é—´/.test(text)
                                || (/æŠ•æ”¾èµ„æºä½/.test(text) && /æŠ•æ”¾åœ°åŸŸ/.test(text) && /æŠ•æ”¾æ—¶é—´/.test(text));
                        });
                        if (target instanceof HTMLElement) return target;
                    }
                    return null;
                };
                const loadNativeAdvancedDefaultsSnapshot = async () => {
                    let latestSnapshot = resolveNativeAdvancedDefaultsFromDialog();
                    if (isNativeAdvancedSnapshotRich(latestSnapshot)) return latestSnapshot;
                    const openButton = findNativeAdvancedEntryButton();
                    if (!(openButton instanceof HTMLElement)) return latestSnapshot;
                    try {
                        openButton.scrollIntoView({ block: 'center', inline: 'nearest', behavior: 'instant' });
                    } catch {
                        try {
                            openButton.scrollIntoView({ block: 'center', inline: 'nearest' });
                        } catch {}
                    }
                    let openedByScript = false;
                    if (!(resolveNativeAdvancedDialogRoot() instanceof HTMLElement)) {
                        openedByScript = clickElement(openButton) === true;
                    }
                    await waitUntil(
                        () => {
                            latestSnapshot = resolveNativeAdvancedDefaultsFromDialog();
                            return isNativeAdvancedSnapshotRich(latestSnapshot);
                        },
                        2200,
                        90
                    );
                    if (!latestSnapshot) {
                        latestSnapshot = resolveNativeAdvancedDefaultsFromDialog();
                    }
                    if (!isNativeAdvancedSnapshotRich(latestSnapshot)) {
                        await waitUntil(
                            () => {
                                latestSnapshot = resolveNativeAdvancedDefaultsFromDialog();
                                return !!latestSnapshot;
                            },
                            500,
                            80
                        );
                    }
                    if (openedByScript) {
                        const closeButton = resolveNativeAdvancedDialogCloseButton();
                        if (closeButton instanceof HTMLElement) {
                            clickElement(closeButton);
                            await sleep(80);
                        }
                    }
                    return latestSnapshot;
                };
                const ADVANCED_DAY_COLUMNS = [
                    { key: '1', label: 'æ˜ŸæœŸä¸€' },
                    { key: '2', label: 'æ˜ŸæœŸäºŒ' },
                    { key: '3', label: 'æ˜ŸæœŸä¸‰' },
                    { key: '4', label: 'æ˜ŸæœŸå››' },
                    { key: '5', label: 'æ˜ŸæœŸäº”' },
                    { key: '6', label: 'æ˜ŸæœŸå…­' },
                    { key: '7', label: 'æ˜ŸæœŸæ—¥' }
                ];
                const ADVANCED_TIME_SLOTS = [
                    { key: '00:00-06:00', label: '00:00 - 06:00', start: 0, end: 360 },
                    { key: '06:00-12:00', label: '06:00 - 12:00', start: 360, end: 720 },
                    { key: '12:00-18:00', label: '12:00 - 18:00', start: 720, end: 1080 },
                    { key: '18:00-24:00', label: '18:00 - 24:00', start: 1080, end: 1440 }
                ];
                const parseTimeRangeToMinutes = (timeText = '') => {
                    const match = String(timeText || '').trim().match(/^(\d{2}):(\d{2})-(\d{2}):(\d{2})$/);
                    if (!match) return null;
                    const start = toNumber(match[1], 0) * 60 + toNumber(match[2], 0);
                    let end = toNumber(match[3], 0) * 60 + toNumber(match[4], 0);
                    if (!Number.isFinite(start) || !Number.isFinite(end)) return null;
                    if (end <= start) end += 24 * 60;
                    return { start, end };
                };
                const formatMinutesToClock = (minutes = 0) => {
                    const safeMinutes = toNumber(minutes, 0);
                    const base = ((safeMinutes % (24 * 60)) + (24 * 60)) % (24 * 60);
                    if (safeMinutes >= 24 * 60 && base === 0) return '24:00';
                    const hour = Math.floor(base / 60);
                    const minute = base % 60;
                    return `${String(hour).padStart(2, '0')}:${String(minute).padStart(2, '0')}`;
                };
                const createEmptyLaunchPeriodGridState = () => {
                    const state = {};
                    ADVANCED_DAY_COLUMNS.forEach(day => {
                        state[day.key] = {};
                        ADVANCED_TIME_SLOTS.forEach(slot => {
                            state[day.key][slot.key] = false;
                        });
                    });
                    return state;
                };
                const buildLaunchPeriodGridState = (rawValue = '') => {
                    const state = createEmptyLaunchPeriodGridState();
                    const list = parseScenePopupJsonArray(rawValue, []);
                    list.forEach(item => {
                        const dayKey = String(item?.dayOfWeek || '').trim();
                        if (!state[dayKey]) return;
                        const spanList = Array.isArray(item?.timeSpanList) ? item.timeSpanList : [];
                        spanList.forEach(span => {
                            const timeText = String(span?.time || '').trim();
                            if (!timeText) return;
                            if (timeText === '00:00-24:00') {
                                ADVANCED_TIME_SLOTS.forEach(slot => {
                                    state[dayKey][slot.key] = true;
                                });
                                return;
                            }
                            const range = parseTimeRangeToMinutes(timeText);
                            if (!range) return;
                            ADVANCED_TIME_SLOTS.forEach(slot => {
                                const slotStart = slot.start;
                                const slotEnd = slot.end <= slot.start ? slot.end + 24 * 60 : slot.end;
                                if (range.start < slotEnd && range.end > slotStart) {
                                    state[dayKey][slot.key] = true;
                                }
                            });
                        });
                    });
                    return state;
                };
                const buildLaunchPeriodListFromGridState = (gridState = {}) => {
                    const output = [];
                    ADVANCED_DAY_COLUMNS.forEach(day => {
                        const dayState = isPlainObject(gridState?.[day.key]) ? gridState[day.key] : {};
                        const enabledSlots = ADVANCED_TIME_SLOTS
                            .filter(slot => !!dayState[slot.key])
                            .map(slot => ({ start: slot.start, end: slot.end }));
                        if (!enabledSlots.length) return;
                        if (enabledSlots.length === ADVANCED_TIME_SLOTS.length) {
                            output.push({
                                dayOfWeek: day.key,
                                timeSpanList: [{ discount: 100, time: '00:00-24:00' }]
                            });
                            return;
                        }
                        const merged = [];
                        enabledSlots.forEach(slot => {
                            const prev = merged[merged.length - 1];
                            if (prev && prev.end === slot.start) {
                                prev.end = slot.end;
                            } else {
                                merged.push({ start: slot.start, end: slot.end });
                            }
                        });
                        output.push({
                            dayOfWeek: day.key,
                            timeSpanList: merged.map(span => ({
                                discount: 100,
                                time: `${formatMinutesToClock(span.start)}-${formatMinutesToClock(span.end)}`
                            }))
                        });
                    });
                    return output;
                };
                const isLaunchPeriodAllDay = (rawValue = '') => {
                    const list = parseScenePopupJsonArray(rawValue, []);
                    if (!list.length) return false;
                    return list.every(item => {
                        const spanList = Array.isArray(item?.timeSpanList) ? item.timeSpanList : [];
                        return spanList.length === 1 && String(spanList[0]?.time || '').trim() === '00:00-24:00';
                    });
                };
                const openKeywordAdvancedSettingPopup = async (initialTab = 'adzone') => {
                    const adzoneControl = resolveScenePopupControl('campaign.adzoneList', 'adzone');
                    const launchPeriodControl = resolveScenePopupControl('campaign.launchPeriodList', 'launchPeriod');
                    const launchAreaControl = resolveScenePopupControl('campaign.launchAreaStrList', 'launchArea');
                    if (!(adzoneControl instanceof HTMLInputElement)) return null;
                    if (!(launchPeriodControl instanceof HTMLInputElement)) return null;
                    if (!(launchAreaControl instanceof HTMLInputElement)) return null;

                    const adzoneFieldKey = normalizeSceneFieldKey('campaign.adzoneList');
                    const launchAreaFieldKey = normalizeSceneFieldKey('campaign.launchAreaStrList');
                    const launchPeriodFieldKey = normalizeSceneFieldKey('campaign.launchPeriodList');
                    const adzoneTouched = !!(adzoneFieldKey && touchedBucket[adzoneFieldKey]);
                    const launchAreaTouched = !!(launchAreaFieldKey && touchedBucket[launchAreaFieldKey]);
                    const launchPeriodTouched = !!(launchPeriodFieldKey && touchedBucket[launchPeriodFieldKey]);

                    let adzoneRaw = normalizeSceneSettingValue(adzoneControl.value || '') || '[]';
                    let launchPeriodRaw = normalizeSceneSettingValue(launchPeriodControl.value || '') || JSON.stringify(buildDefaultLaunchPeriodList());
                    let launchAreaRaw = normalizeSceneSettingValue(launchAreaControl.value || '') || '["all"]';
                    let initialAdzoneList = normalizeAdzoneListForAdvanced(adzoneRaw);
                    let initialAreaList = parseLaunchAreaList(launchAreaRaw);
                    let initialPeriodGridState = buildLaunchPeriodGridState(launchPeriodRaw);
                    const needNativeAdzoneDefaults = !adzoneTouched || isAdzoneListPlaceholderForSync(initialAdzoneList);
                    const needNativeAreaDefaults = !launchAreaTouched || !initialAreaList.length;
                    const needNativePeriodDefaults = !launchPeriodTouched || !parseScenePopupJsonArray(launchPeriodRaw, []).length;
                    if (needNativeAdzoneDefaults || needNativeAreaDefaults || needNativePeriodDefaults) {
                        const nativeDefaults = await loadNativeAdvancedDefaultsSnapshot();
                        if (nativeDefaults) {
                            if (needNativeAdzoneDefaults && Array.isArray(nativeDefaults.adzoneList) && nativeDefaults.adzoneList.length) {
                                adzoneRaw = JSON.stringify(nativeDefaults.adzoneList);
                                initialAdzoneList = normalizeAdzoneListForAdvanced(adzoneRaw);
                            }
                            if (needNativeAreaDefaults && Array.isArray(nativeDefaults.launchAreaList) && nativeDefaults.launchAreaList.length) {
                                launchAreaRaw = JSON.stringify(nativeDefaults.launchAreaList);
                                initialAreaList = parseLaunchAreaList(launchAreaRaw);
                            }
                            if (needNativePeriodDefaults && Array.isArray(nativeDefaults.launchPeriodList) && nativeDefaults.launchPeriodList.length) {
                                launchPeriodRaw = JSON.stringify(nativeDefaults.launchPeriodList);
                                initialPeriodGridState = buildLaunchPeriodGridState(launchPeriodRaw);
                            }
                        }
                    }
                    const defaultFallbackAdzone = {
                        adzoneCode: 'DEFAULT_SEARCH',
                        adzoneName: 'æ·˜å®æœç´¢',
                        resourceName: 'ç§»åŠ¨è®¾å¤‡ï¼ˆå«é”€é‡æ˜æ˜Ÿï¼‰ã€è®¡ç®—æœºè®¾å¤‡',
                        status: '1',
                        __defaultSynthetic: true
                    };
                    const initialTabValue = ['adzone', 'launchArea', 'launchPeriod'].includes(String(initialTab || '').trim())
                        ? String(initialTab || '').trim()
                        : 'adzone';

                    const result = await openScenePopupDialog({
                        title: 'é«˜çº§è®¾ç½®',
                        dialogClassName: 'am-wxt-scene-popup-dialog-advanced',
                        closeLabel: 'Ã—',
                        cancelLabel: 'å–æ¶ˆ',
                        saveLabel: 'ç¡®å®š',
                        bodyHtml: `
                            <div class="am-wxt-scene-advanced-layout">
                                <div class="am-wxt-scene-advanced-tabs">
                                    <button type="button" class="am-wxt-scene-advanced-tab" data-scene-popup-advanced-tab="adzone">æŠ•æ”¾èµ„æºä½</button>
                                    <button type="button" class="am-wxt-scene-advanced-tab" data-scene-popup-advanced-tab="launchArea">æŠ•æ”¾åœ°åŸŸ</button>
                                    <button type="button" class="am-wxt-scene-advanced-tab" data-scene-popup-advanced-tab="launchPeriod">æŠ•æ”¾æ—¶é—´</button>
                                </div>
                                <div class="am-wxt-scene-advanced-main">
                                    <div class="am-wxt-scene-advanced-content">
                                        <section class="am-wxt-scene-advanced-panel" data-scene-popup-advanced-panel="adzone">
                                            <div class="am-wxt-scene-advanced-tip">å¹³å°ä¸ºæ‚¨ä¼˜é€‰å¹¿å‘Šä½ï¼Œæ›´å…¨é¢è·å–ä¼˜è´¨æµé‡ï¼Œå»ºè®®å…¨éƒ¨å¼€å¯</div>
                                            <div class="am-wxt-scene-advanced-toolbar">
                                                <button type="button" class="am-wxt-btn" data-scene-popup-adzone-batch="on">å…¨éƒ¨å¼€å¯</button>
                                                <button type="button" class="am-wxt-btn" data-scene-popup-adzone-batch="off">å…¨éƒ¨å…³é—­</button>
                                            </div>
                                            <div class="am-wxt-scene-advanced-adzone-table" data-scene-popup-adzone-table="1">
                                                <div class="am-wxt-scene-advanced-adzone-head">
                                                    <span>èµ„æºä½</span>
                                                    <span>æ“ä½œ</span>
                                                </div>
                                                <div class="am-wxt-scene-advanced-adzone-list" data-scene-popup-adzone-list="1"></div>
                                            </div>
                                        </section>
                                        <section class="am-wxt-scene-advanced-panel" data-scene-popup-advanced-panel="launchArea">
                                            <div class="am-wxt-scene-advanced-toolbar">
                                                <button type="button" class="am-wxt-btn" data-scene-popup-area-template="current">å½“å‰è®¾ç½®</button>
                                                <button type="button" class="am-wxt-btn" data-scene-popup-area-template="recommended">æ¨èæŠ•æ”¾åœ°åŸŸæ¨¡æ¿</button>
                                                <button type="button" class="am-wxt-btn" data-scene-popup-area-template="custom">è‡ªå®šä¹‰æŠ•æ”¾åœ°åŸŸæ¨¡æ¿</button>
                                            </div>
                                            <div class="am-wxt-scene-advanced-toolbar">
                                                <button type="button" class="am-wxt-btn" data-scene-popup-area-mode="alpha">æŒ‰é¦–å­—æ¯é€‰æ‹©</button>
                                                <button type="button" class="am-wxt-btn" data-scene-popup-area-mode="geo">æŒ‰åœ°ç†åŒºé€‰æ‹©</button>
                                            </div>
                                            <div class="am-wxt-scene-advanced-tip">è¾“å…¥åœ°åŸŸç¼–ç ï¼Œé€—å·æˆ–æ¢è¡Œåˆ†éš”ã€‚è¾“å…¥ all ä»£è¡¨å…¨éƒ¨åœ°åŸŸã€‚</div>
                                            <div class="am-wxt-scene-advanced-area-presets">
                                                <span class="am-wxt-scene-advanced-area-label">å½“å‰è®¾ç½®</span>
                                                <button type="button" class="am-wxt-btn" data-scene-popup-area-preset="all">å…¨éƒ¨åœ°åŸŸ</button>
                                                <button type="button" class="am-wxt-btn" data-scene-popup-area-preset="popular">å¸¸ç”¨åŒºåŸŸ</button>
                                            </div>
                                            <textarea class="am-wxt-scene-popup-textarea am-wxt-scene-advanced-area-editor" data-scene-popup-editor="launchArea"></textarea>
                                        </section>
                                        <section class="am-wxt-scene-advanced-panel" data-scene-popup-advanced-panel="launchPeriod">
                                            <div class="am-wxt-scene-advanced-toolbar">
                                                <button type="button" class="am-wxt-btn" data-scene-popup-time-template="current">å½“å‰è®¾ç½®</button>
                                                <button type="button" class="am-wxt-btn" data-scene-popup-time-template="full">å…¨æ—¥åˆ¶æŠ•æ”¾</button>
                                                <button type="button" class="am-wxt-btn" data-scene-popup-time-template="custom">è‡ªå®šä¹‰æŠ•æ”¾æ—¶é—´æ¨¡æ¿</button>
                                            </div>
                                            <div class="am-wxt-scene-advanced-toolbar">
                                                <button type="button" class="am-wxt-btn" data-scene-popup-time-action="clear">æ¸…ç©º</button>
                                                <button type="button" class="am-wxt-btn" data-scene-popup-time-action="reset">é‡ç½®</button>
                                                <span class="am-wxt-scene-advanced-tip-inline">æ”¯æŒå•å‡»ä¸æ‹–æ‹½é€‰æ‹©æŠ•æ”¾æ—¶é—´</span>
                                            </div>
                                            <div class="am-wxt-scene-popup-time-grid" data-scene-popup-time-grid="1"></div>
                                        </section>
                                    </div>
                                    <aside class="am-wxt-scene-advanced-preview">
                                        <div class="am-wxt-scene-advanced-preview-phone">
                                            <div class="am-wxt-scene-advanced-preview-screen">
                                                <div class="am-wxt-scene-advanced-preview-card"></div>
                                                <div class="am-wxt-scene-advanced-preview-card"></div>
                                                <div class="am-wxt-scene-advanced-preview-card"></div>
                                            </div>
                                        </div>
                                        <div class="am-wxt-scene-advanced-preview-desc">æ¨¡æ‹Ÿå±•ç¤ºæ•ˆæœï¼ˆä¸åŸç«™äº¤äº’ä¸€è‡´ï¼‰</div>
                                    </aside>
                                </div>
                            </div>
                        `,
                        onMounted: (mask) => {
                            let currentTab = initialTabValue;
                            let areaList = Array.isArray(initialAreaList) ? initialAreaList.slice() : ['all'];
                            const initialAreaListSnapshot = Array.isArray(initialAreaList) ? initialAreaList.slice() : ['all'];
                            let areaTemplate = 'current';
                            let areaMode = 'alpha';
                            let launchPeriodGridState = deepClone(initialPeriodGridState);
                            const initialLaunchPeriodGridState = deepClone(initialPeriodGridState);
                            let timeTemplate = 'current';
                            let adzoneList = initialAdzoneList.length
                                ? initialAdzoneList.map(item => deepClone(item))
                                : [deepClone(defaultFallbackAdzone)];
                            const syntheticOnly = !initialAdzoneList.length;
                            let dragState = { active: false, next: null };

                            const tabButtons = Array.from(mask.querySelectorAll('[data-scene-popup-advanced-tab]'));
                            const panelEls = Array.from(mask.querySelectorAll('[data-scene-popup-advanced-panel]'));
                            const adzoneListEl = mask.querySelector('[data-scene-popup-adzone-list]');
                            const areaEditor = mask.querySelector('[data-scene-popup-editor="launchArea"]');
                            const timeGrid = mask.querySelector('[data-scene-popup-time-grid]');
                            const areaTemplateButtons = Array.from(mask.querySelectorAll('[data-scene-popup-area-template]'));
                            const areaModeButtons = Array.from(mask.querySelectorAll('[data-scene-popup-area-mode]'));
                            const timeTemplateButtons = Array.from(mask.querySelectorAll('[data-scene-popup-time-template]'));

                            const renderTabs = () => {
                                tabButtons.forEach(btn => {
                                    if (!(btn instanceof HTMLButtonElement)) return;
                                    const tab = String(btn.getAttribute('data-scene-popup-advanced-tab') || '').trim();
                                    const active = tab === currentTab;
                                    btn.classList.toggle('active', active);
                                    btn.setAttribute('aria-pressed', active ? 'true' : 'false');
                                });
                                panelEls.forEach(panel => {
                                    if (!(panel instanceof HTMLElement)) return;
                                    const tab = String(panel.getAttribute('data-scene-popup-advanced-panel') || '').trim();
                                    const active = tab === currentTab;
                                    panel.classList.toggle('active', active);
                                    panel.hidden = !active;
                                });
                            };
                            const renderAreaTemplateButtons = () => {
                                areaTemplateButtons.forEach(btn => {
                                    if (!(btn instanceof HTMLButtonElement)) return;
                                    const key = String(btn.getAttribute('data-scene-popup-area-template') || '').trim();
                                    const active = key === areaTemplate;
                                    btn.classList.toggle('primary', active);
                                    btn.setAttribute('aria-pressed', active ? 'true' : 'false');
                                });
                            };
                            const renderAreaModeButtons = () => {
                                areaModeButtons.forEach(btn => {
                                    if (!(btn instanceof HTMLButtonElement)) return;
                                    const key = String(btn.getAttribute('data-scene-popup-area-mode') || '').trim();
                                    const active = key === areaMode;
                                    btn.classList.toggle('primary', active);
                                    btn.setAttribute('aria-pressed', active ? 'true' : 'false');
                                });
                            };
                            const renderTimeTemplateButtons = () => {
                                timeTemplateButtons.forEach(btn => {
                                    if (!(btn instanceof HTMLButtonElement)) return;
                                    const key = String(btn.getAttribute('data-scene-popup-time-template') || '').trim();
                                    const active = key === timeTemplate;
                                    btn.classList.toggle('primary', active);
                                    btn.setAttribute('aria-pressed', active ? 'true' : 'false');
                                });
                            };

                            const renderAdzoneList = () => {
                                if (!(adzoneListEl instanceof HTMLElement)) return;
                                adzoneListEl.innerHTML = adzoneList.map((item, idx) => {
                                    const enabled = isAdzoneStatusEnabled(item);
                                    const name = getAdzoneDisplayName(item, idx);
                                    const desc = getAdzoneDisplayDesc(item) || 'ç§»åŠ¨è®¾å¤‡ï¼ˆå«é”€é‡æ˜æ˜Ÿï¼‰ã€è®¡ç®—æœºè®¾å¤‡';
                                    return `
                                        <div class="am-wxt-scene-advanced-adzone-row">
                                            <div class="am-wxt-scene-advanced-adzone-cell">
                                                <div class="am-wxt-scene-advanced-adzone-name">${Utils.escapeHtml(name)}</div>
                                                <div class="am-wxt-scene-advanced-adzone-desc">${Utils.escapeHtml(desc)}</div>
                                            </div>
                                            <div class="am-wxt-scene-advanced-adzone-actions">
                                                <button type="button" class="am-wxt-btn ${enabled ? 'primary' : ''}" data-scene-popup-adzone-row-toggle="${idx}" data-scene-popup-adzone-next="on">å¼€</button>
                                                <button type="button" class="am-wxt-btn ${enabled ? '' : 'primary'}" data-scene-popup-adzone-row-toggle="${idx}" data-scene-popup-adzone-next="off">å…³</button>
                                            </div>
                                        </div>
                                    `;
                                }).join('');
                            };

                            const parseAreaEditorValue = () => {
                                const text = String(areaEditor instanceof HTMLTextAreaElement ? areaEditor.value : '').trim();
                                const list = uniqueBy(
                                    text
                                        .split(/[\n,ï¼Œ\s]+/)
                                        .map(item => String(item || '').trim())
                                        .filter(Boolean),
                                    item => item
                                );
                                areaList = !list.length || list.some(item => /^all$/i.test(item))
                                    ? ['all']
                                    : list;
                                areaTemplate = areaList.length === 1 && /^all$/i.test(areaList[0]) ? 'current' : 'custom';
                            };
                            const renderAreaEditor = () => {
                                if (!(areaEditor instanceof HTMLTextAreaElement)) return;
                                areaEditor.value = (areaList.length ? areaList : ['all']).join('\n');
                                renderAreaTemplateButtons();
                                renderAreaModeButtons();
                            };

                            const setAllLaunchPeriodSlots = (enabled = true) => {
                                ADVANCED_DAY_COLUMNS.forEach(day => {
                                    ADVANCED_TIME_SLOTS.forEach(slot => {
                                        setTimeSlot(day.key, slot.key, enabled);
                                    });
                                });
                            };
                            const setTimeSlot = (dayKey = '', slotKey = '', enabled = true) => {
                                if (!isPlainObject(launchPeriodGridState?.[dayKey])) return;
                                if (!hasOwn(launchPeriodGridState[dayKey], slotKey)) return;
                                launchPeriodGridState[dayKey][slotKey] = !!enabled;
                            };
                            const renderTimeGrid = () => {
                                if (!(timeGrid instanceof HTMLElement)) return;
                                const headerHtml = ADVANCED_DAY_COLUMNS.map(day => `
                                    <div class="am-wxt-scene-time-day">${Utils.escapeHtml(day.label)}</div>
                                `).join('');
                                const rowHtml = ADVANCED_TIME_SLOTS.map(slot => {
                                    const cells = ADVANCED_DAY_COLUMNS.map(day => {
                                        const active = !!launchPeriodGridState?.[day.key]?.[slot.key];
                                        return `
                                            <button
                                                type="button"
                                                class="am-wxt-scene-time-cell ${active ? 'active' : ''}"
                                                data-scene-popup-time-slot="${Utils.escapeHtml(`${day.key}:${slot.key}`)}"
                                                data-scene-popup-time-day="${Utils.escapeHtml(day.key)}"
                                                data-scene-popup-time-range="${Utils.escapeHtml(slot.key)}"
                                            ></button>
                                        `;
                                    }).join('');
                                    return `
                                        <div class="am-wxt-scene-time-row">
                                            <div class="am-wxt-scene-time-label">${Utils.escapeHtml(slot.label)}</div>
                                            <div class="am-wxt-scene-time-cells">${cells}</div>
                                        </div>
                                    `;
                                }).join('');
                                timeGrid.innerHTML = `
                                    <div class="am-wxt-scene-time-head">
                                        <div class="am-wxt-scene-time-head-spacer"></div>
                                        <div class="am-wxt-scene-time-days">${headerHtml}</div>
                                    </div>
                                    <div class="am-wxt-scene-time-body">${rowHtml}</div>
                                `;
                                renderTimeTemplateButtons();
                            };

                            tabButtons.forEach(btn => {
                                if (!(btn instanceof HTMLButtonElement)) return;
                                btn.onclick = () => {
                                    currentTab = String(btn.getAttribute('data-scene-popup-advanced-tab') || '').trim() || currentTab;
                                    renderTabs();
                                };
                            });
                            if (adzoneListEl instanceof HTMLElement) {
                                adzoneListEl.addEventListener('click', (event) => {
                                    const target = event.target instanceof HTMLElement
                                        ? event.target.closest('[data-scene-popup-adzone-row-toggle]')
                                        : null;
                                    if (!(target instanceof HTMLElement)) return;
                                    const index = toNumber(target.getAttribute('data-scene-popup-adzone-row-toggle'), -1);
                                    const nextEnabled = String(target.getAttribute('data-scene-popup-adzone-next') || '').trim() === 'on';
                                    if (!Number.isFinite(index) || index < 0 || index >= adzoneList.length) return;
                                    adzoneList[index] = setAdzoneStatus(adzoneList[index], nextEnabled);
                                    renderAdzoneList();
                                });
                            }
                            mask.querySelectorAll('[data-scene-popup-adzone-batch]').forEach(btn => {
                                if (!(btn instanceof HTMLButtonElement)) return;
                                btn.onclick = () => {
                                    const nextEnabled = String(btn.getAttribute('data-scene-popup-adzone-batch') || '').trim() === 'on';
                                    adzoneList = adzoneList.map(item => setAdzoneStatus(item, nextEnabled));
                                    renderAdzoneList();
                                };
                            });
                            if (areaEditor instanceof HTMLTextAreaElement) {
                                areaEditor.addEventListener('input', () => {
                                    parseAreaEditorValue();
                                    renderAreaTemplateButtons();
                                });
                            }
                            areaTemplateButtons.forEach(btn => {
                                if (!(btn instanceof HTMLButtonElement)) return;
                                btn.onclick = () => {
                                    const templateKey = String(btn.getAttribute('data-scene-popup-area-template') || '').trim();
                                    if (templateKey === 'recommended') {
                                        areaList = ['110000', '310000', '330100', '440100'];
                                        areaTemplate = 'recommended';
                                        areaMode = 'geo';
                                    } else if (templateKey === 'custom') {
                                        if (!areaList.length || (areaList.length === 1 && /^all$/i.test(areaList[0]))) {
                                            areaList = ['110000'];
                                        }
                                        areaTemplate = 'custom';
                                    } else {
                                        areaList = initialAreaListSnapshot.length ? initialAreaListSnapshot.slice() : ['all'];
                                        areaTemplate = 'current';
                                    }
                                    renderAreaEditor();
                                };
                            });
                            areaModeButtons.forEach(btn => {
                                if (!(btn instanceof HTMLButtonElement)) return;
                                btn.onclick = () => {
                                    const modeKey = String(btn.getAttribute('data-scene-popup-area-mode') || '').trim();
                                    if (!modeKey) return;
                                    areaMode = modeKey;
                                    renderAreaModeButtons();
                                };
                            });
                            mask.querySelectorAll('[data-scene-popup-area-preset]').forEach(btn => {
                                if (!(btn instanceof HTMLButtonElement)) return;
                                btn.onclick = () => {
                                    const preset = String(btn.getAttribute('data-scene-popup-area-preset') || '').trim();
                                    if (preset === 'popular') {
                                        areaList = ['110000', '310000', '330100', '440100'];
                                        areaTemplate = 'recommended';
                                        areaMode = 'geo';
                                    } else {
                                        areaList = ['all'];
                                        areaTemplate = 'current';
                                    }
                                    renderAreaEditor();
                                };
                            });
                            timeTemplateButtons.forEach(btn => {
                                if (!(btn instanceof HTMLButtonElement)) return;
                                btn.onclick = () => {
                                    const templateKey = String(btn.getAttribute('data-scene-popup-time-template') || '').trim();
                                    if (templateKey === 'full') {
                                        launchPeriodGridState = createEmptyLaunchPeriodGridState();
                                        setAllLaunchPeriodSlots(true);
                                        timeTemplate = 'full';
                                    } else if (templateKey === 'custom') {
                                        timeTemplate = 'custom';
                                    } else {
                                        launchPeriodGridState = deepClone(initialLaunchPeriodGridState);
                                        timeTemplate = 'current';
                                    }
                                    renderTimeGrid();
                                };
                            });
                            if (timeGrid instanceof HTMLElement) {
                                const applyFromCell = (cell, enabled) => {
                                    const dayKey = String(cell.getAttribute('data-scene-popup-time-day') || '').trim();
                                    const slotKey = String(cell.getAttribute('data-scene-popup-time-range') || '').trim();
                                    if (!dayKey || !slotKey) return;
                                    setTimeSlot(dayKey, slotKey, enabled);
                                };
                                timeGrid.addEventListener('mousedown', (event) => {
                                    const cell = event.target instanceof HTMLElement
                                        ? event.target.closest('[data-scene-popup-time-slot]')
                                        : null;
                                    if (!(cell instanceof HTMLElement)) return;
                                    event.preventDefault();
                                    const dayKey = String(cell.getAttribute('data-scene-popup-time-day') || '').trim();
                                    const slotKey = String(cell.getAttribute('data-scene-popup-time-range') || '').trim();
                                    const current = !!launchPeriodGridState?.[dayKey]?.[slotKey];
                                    dragState = { active: true, next: !current };
                                    applyFromCell(cell, !current);
                                    timeTemplate = 'custom';
                                    renderTimeGrid();
                                });
                                timeGrid.addEventListener('mouseover', (event) => {
                                    if (!dragState.active) return;
                                    const cell = event.target instanceof HTMLElement
                                        ? event.target.closest('[data-scene-popup-time-slot]')
                                        : null;
                                    if (!(cell instanceof HTMLElement)) return;
                                    applyFromCell(cell, !!dragState.next);
                                    timeTemplate = 'custom';
                                    renderTimeGrid();
                                });
                                const handleMouseUp = () => {
                                    dragState = { active: false, next: null };
                                };
                                document.addEventListener('mouseup', handleMouseUp);
                                mask._amWxtCleanup = () => {
                                    document.removeEventListener('mouseup', handleMouseUp);
                                };
                            }
                            mask.querySelectorAll('[data-scene-popup-time-action]').forEach(btn => {
                                if (!(btn instanceof HTMLButtonElement)) return;
                                btn.onclick = () => {
                                    const action = String(btn.getAttribute('data-scene-popup-time-action') || '').trim();
                                    if (action === 'clear') {
                                        launchPeriodGridState = createEmptyLaunchPeriodGridState();
                                        timeTemplate = 'custom';
                                    } else if (action === 'reset') {
                                        launchPeriodGridState = deepClone(initialPeriodGridState);
                                        timeTemplate = 'current';
                                    }
                                    renderTimeGrid();
                                };
                            });

                            renderTabs();
                            renderAdzoneList();
                            renderAreaEditor();
                            renderTimeGrid();

                            mask.dataset.scenePopupSyntheticAdzone = syntheticOnly ? '1' : '0';
                            mask._scenePopupState = {
                                getAdzoneList: () => deepClone(adzoneList),
                                getLaunchAreaList: () => (Array.isArray(areaList) ? areaList.slice() : ['all']),
                                getLaunchPeriodGridState: () => deepClone(launchPeriodGridState)
                            };
                        },
                        onSave: (mask) => {
                            const syntheticOnly = String(mask.dataset.scenePopupSyntheticAdzone || '') === '1';
                            const state = mask._scenePopupState || {};
                            const adzoneListRaw = typeof state.getAdzoneList === 'function' ? state.getAdzoneList() : [];
                            const launchAreaListRaw = typeof state.getLaunchAreaList === 'function' ? state.getLaunchAreaList() : ['all'];
                            const launchPeriodGridState = typeof state.getLaunchPeriodGridState === 'function'
                                ? state.getLaunchPeriodGridState()
                                : createEmptyLaunchPeriodGridState();

                            const normalizedAdzoneList = Array.isArray(adzoneListRaw)
                                ? adzoneListRaw
                                    .filter(item => isPlainObject(item))
                                    .map(item => {
                                        const next = deepClone(item);
                                        delete next.__defaultSynthetic;
                                        return next;
                                    })
                                : [];
                            const useDefaultAdzone = syntheticOnly && normalizedAdzoneList.every(item => isAdzoneStatusEnabled(item));
                            const finalAdzoneList = useDefaultAdzone ? [] : normalizedAdzoneList;
                            const finalLaunchAreaList = uniqueBy(
                                (Array.isArray(launchAreaListRaw) ? launchAreaListRaw : ['all'])
                                    .map(item => String(item || '').trim())
                                    .filter(Boolean),
                                item => item
                            );
                            const nextAreaList = !finalLaunchAreaList.length || finalLaunchAreaList.some(item => /^all$/i.test(item))
                                ? ['all']
                                : finalLaunchAreaList;
                            const nextLaunchPeriodList = buildLaunchPeriodListFromGridState(launchPeriodGridState);
                            const nextAdzoneRaw = JSON.stringify(finalAdzoneList);
                            const nextLaunchAreaRaw = JSON.stringify(nextAreaList);
                            const nextLaunchPeriodRaw = JSON.stringify(nextLaunchPeriodList);

                            return {
                                ok: true,
                                adzoneRaw: nextAdzoneRaw,
                                launchAreaRaw: nextLaunchAreaRaw,
                                launchPeriodRaw: nextLaunchPeriodRaw,
                                adzoneSummary: describeAdzoneSummary(nextAdzoneRaw),
                                launchAreaSummary: describeLaunchAreaSummary(nextLaunchAreaRaw),
                                launchPeriodSummary: describeLaunchPeriodSummary(nextLaunchPeriodRaw)
                            };
                        }
                    });
                    if (!result || result.ok !== true) return null;
                    return {
                        ok: true,
                        result,
                        adzoneControl,
                        launchPeriodControl,
                        launchAreaControl
                    };
                };
                const scenePopupButtons = wizardState.els.sceneDynamic.querySelectorAll('[data-scene-popup-trigger]');
                scenePopupButtons.forEach(button => {
                    button.addEventListener('click', async () => {
                        const trigger = String(button.getAttribute('data-scene-popup-trigger') || '').trim();
                        const popupTitle = String(button.getAttribute('data-scene-popup-title') || '').trim();
                        const row = button.closest('.am-wxt-scene-setting-row');
                        if (!trigger || !(row instanceof HTMLElement)) return;
                        const findPopupControl = (fieldKey) => row.querySelector(`input[data-scene-field="${fieldKey}"][data-scene-popup-field="${trigger}"]`);
                        const findMainControl = () => row.querySelector('input.am-wxt-hidden-control[data-scene-field]:not([data-scene-popup-field])');

                        if (trigger === 'adzone' || trigger === 'launchPeriod' || trigger === 'launchArea') {
                            const popupPayload = await openKeywordAdvancedSettingPopup(trigger);
                            if (!popupPayload || popupPayload.ok !== true) return;
                            const { result, adzoneControl, launchPeriodControl, launchAreaControl } = popupPayload;
                            dispatchSceneControlUpdate(adzoneControl, result.adzoneRaw || '[]');
                            dispatchSceneControlUpdate(
                                launchPeriodControl,
                                result.launchPeriodRaw || JSON.stringify(buildDefaultLaunchPeriodList())
                            );
                            dispatchSceneControlUpdate(launchAreaControl, result.launchAreaRaw || '["all"]');

                            const adzoneRow = resolveScenePopupRowByTrigger('adzone');
                            const launchPeriodRow = resolveScenePopupRowByTrigger('launchPeriod');
                            const launchAreaRow = resolveScenePopupRowByTrigger('launchArea');
                            updateScenePopupSummary(
                                adzoneRow,
                                'adzone',
                                result.adzoneSummary || describeAdzoneSummary(result.adzoneRaw || '[]')
                            );
                            updateScenePopupSummary(
                                launchPeriodRow,
                                'launchPeriod',
                                result.launchPeriodSummary || describeLaunchPeriodSummary(result.launchPeriodRaw || '[]')
                            );
                            updateScenePopupSummary(
                                launchAreaRow,
                                'launchArea',
                                result.launchAreaSummary || describeLaunchAreaSummary(result.launchAreaRaw || '["all"]')
                            );

                            const adzoneMainControl = adzoneRow?.querySelector(
                                'input.am-wxt-hidden-control[data-scene-field]:not([data-scene-popup-field])'
                            );
                            if (adzoneMainControl instanceof HTMLInputElement) {
                                const parsedAdzone = parseScenePopupJsonArray(result.adzoneRaw || '[]', [])
                                    .filter(item => isPlainObject(item));
                                const enabledCount = parsedAdzone.filter(item => isAdzoneStatusEnabled(item)).length;
                                dispatchSceneControlUpdate(
                                    adzoneMainControl,
                                    parsedAdzone.length && enabledCount !== parsedAdzone.length ? 'è‡ªå®šä¹‰èµ„æºä½' : 'å¹³å°ä¼˜é€‰'
                                );
                            }
                            const launchPeriodMainControl = launchPeriodRow?.querySelector(
                                'input.am-wxt-hidden-control[data-scene-field]:not([data-scene-popup-field])'
                            );
                            if (launchPeriodMainControl instanceof HTMLInputElement) {
                                const nextLaunchPeriodRaw = String(result.launchPeriodRaw || '').trim();
                                let nextLabel = 'é•¿æœŸæŠ•æ”¾';
                                if (nextLaunchPeriodRaw && nextLaunchPeriodRaw !== '[]') {
                                    nextLabel = isLaunchPeriodAllDay(nextLaunchPeriodRaw)
                                        ? 'ä¸é™æ—¶æ®µ'
                                        : 'å›ºå®šæ—¶æ®µ';
                                }
                                dispatchSceneControlUpdate(launchPeriodMainControl, nextLabel);
                            }
                        } else if (trigger === 'crowd') {
                            const crowdCampaignControl = findPopupControl('campaign.crowdList');
                            const crowdAdgroupControl = findPopupControl('adgroup.rightList');
                            if (!(crowdCampaignControl instanceof HTMLInputElement) || !(crowdAdgroupControl instanceof HTMLInputElement)) return;
                            const crowdCampaignRaw = normalizeSceneSettingValue(crowdCampaignControl.value || '') || '[]';
                            const crowdAdgroupRaw = normalizeSceneSettingValue(crowdAdgroupControl.value || '') || '[]';
                            const result = await openScenePopupDialog({
                                title: popupTitle || 'é…ç½®äººç¾¤æ˜ç»†',
                                bodyHtml: `
                                    <div class="am-wxt-scene-popup-tips">ä¼˜å…ˆæŠ•æ”¾å®¢æˆ·ä¸ç§å­äººç¾¤å‡æ”¯æŒ JSON æ•°ç»„ã€‚ç§å­äººç¾¤å»ºè®®ä½¿ç”¨ rightList æ ¼å¼ã€‚</div>
                                    <label class="am-wxt-scene-popup-label">ä¼˜å…ˆæŠ•æ”¾å®¢æˆ·ï¼ˆcampaign.crowdListï¼‰</label>
                                    <textarea class="am-wxt-scene-popup-textarea" data-scene-popup-editor="crowdCampaign"></textarea>
                                    <label class="am-wxt-scene-popup-label">ç§å­äººç¾¤ï¼ˆadgroup.rightListï¼‰</label>
                                    <textarea class="am-wxt-scene-popup-textarea" data-scene-popup-editor="crowdAdgroup"></textarea>
                                    <div class="am-wxt-scene-popup-actions">
                                        <button type="button" class="am-wxt-btn" data-scene-popup-copy-right-list="1">ä½¿ç”¨å½“å‰è®¡åˆ’äººç¾¤</button>
                                    </div>
                                `,
                                onMounted: (mask) => {
                                    const campaignEditor = mask.querySelector('[data-scene-popup-editor="crowdCampaign"]');
                                    const adgroupEditor = mask.querySelector('[data-scene-popup-editor="crowdAdgroup"]');
                                    if (campaignEditor instanceof HTMLTextAreaElement) {
                                        campaignEditor.value = JSON.stringify(
                                            parseScenePopupJsonArray(crowdCampaignRaw, []),
                                            null,
                                            2
                                        );
                                    }
                                    if (adgroupEditor instanceof HTMLTextAreaElement) {
                                        adgroupEditor.value = JSON.stringify(
                                            parseScenePopupJsonArray(crowdAdgroupRaw, []),
                                            null,
                                            2
                                        );
                                    }
                                    const copyBtn = mask.querySelector('[data-scene-popup-copy-right-list]');
                                    if (copyBtn instanceof HTMLButtonElement && adgroupEditor instanceof HTMLTextAreaElement) {
                                        copyBtn.onclick = () => {
                                            adgroupEditor.value = JSON.stringify(
                                                Array.isArray(wizardState.crowdList) ? wizardState.crowdList : [],
                                                null,
                                                2
                                            );
                                        };
                                    }
                                },
                                onSave: (mask) => {
                                    const campaignEditor = mask.querySelector('[data-scene-popup-editor="crowdCampaign"]');
                                    const adgroupEditor = mask.querySelector('[data-scene-popup-editor="crowdAdgroup"]');
                                    const campaignParsed = tryParseMaybeJSON(
                                        String(campaignEditor instanceof HTMLTextAreaElement ? campaignEditor.value : '').trim() || '[]'
                                    );
                                    const adgroupParsed = tryParseMaybeJSON(
                                        String(adgroupEditor instanceof HTMLTextAreaElement ? adgroupEditor.value : '').trim() || '[]'
                                    );
                                    if (!Array.isArray(campaignParsed) || !Array.isArray(adgroupParsed)) {
                                        appendWizardLog('äººç¾¤é…ç½®æ ¼å¼é”™è¯¯ï¼šè¯·å¡«å†™ JSON æ•°ç»„', 'error');
                                        return { ok: false };
                                    }
                                    return {
                                        ok: true,
                                        campaignRaw: JSON.stringify(campaignParsed),
                                        adgroupRaw: JSON.stringify(adgroupParsed),
                                        summary: describeCrowdSummary(JSON.stringify(campaignParsed), JSON.stringify(adgroupParsed)),
                                        adgroupList: adgroupParsed
                                    };
                                }
                            });
                            if (!result || result.ok !== true) return;
                            dispatchSceneControlUpdate(crowdCampaignControl, result.campaignRaw || '[]');
                            dispatchSceneControlUpdate(crowdAdgroupControl, result.adgroupRaw || '[]');
                            if (Array.isArray(result.adgroupList)) {
                                wizardState.crowdList = deepClone(result.adgroupList);
                                if (typeof wizardState.renderCrowdList === 'function') {
                                    wizardState.renderCrowdList();
                                }
                            }
                            updateScenePopupSummary(row, trigger, result.summary || describeCrowdSummary(result.campaignRaw || '[]', result.adgroupRaw || '[]'));
                        } else {
                            return;
                        }

                        syncSceneSettingValuesFromUI();
                        syncDraftFromUI();
                        renderSceneDynamicConfig();
                        if (typeof wizardState.buildRequest === 'function') {
                            wizardState.renderPreview(wizardState.buildRequest());
                        }
                    });
                });

                const scenePopupSummaryTriggers = wizardState.els.sceneDynamic.querySelectorAll('[data-scene-popup-trigger-proxy]');
                scenePopupSummaryTriggers.forEach(summary => {
                    if (!(summary instanceof HTMLElement)) return;
                    const resolveScenePopupButton = () => {
                        const row = summary.closest('.am-wxt-scene-setting-row');
                        if (!(row instanceof HTMLElement)) return null;
                        const trigger = String(summary.getAttribute('data-scene-popup-trigger-proxy') || '').trim();
                        if (!trigger) return null;
                        const popupButtons = row.querySelectorAll('[data-scene-popup-trigger]');
                        return Array.from(popupButtons).find(candidate => (
                            candidate instanceof HTMLButtonElement
                            && String(candidate.getAttribute('data-scene-popup-trigger') || '').trim() === trigger
                        )) || null;
                    };
                    summary.addEventListener('click', (event) => {
                        event.preventDefault();
                        const button = resolveScenePopupButton();
                        if (!(button instanceof HTMLButtonElement)) return;
                        button.click();
                    });
                    summary.addEventListener('keydown', (event) => {
                        if (event.key !== 'Enter' && event.key !== ' ') return;
                        event.preventDefault();
                        const button = resolveScenePopupButton();
                        if (!(button instanceof HTMLButtonElement)) return;
                        button.click();
                    });
                });

                const controls = wizardState.els.sceneDynamic.querySelectorAll('[data-scene-field]');
                controls.forEach(control => {
                    const onChange = () => {
                        const activeScene = String(wizardState.els.sceneSelect?.value || wizardState.draft?.sceneName || 'å…³é”®è¯æ¨å¹¿').trim();
                        const fieldKey = String(control.getAttribute('data-scene-field') || '').trim();
                        const localTouchedBucket = ensureSceneTouchedBucket(activeScene);
                        if (activeScene && fieldKey) {
                            localTouchedBucket[fieldKey] = true;
                        }
                        if (activeScene === 'å…³é”®è¯æ¨å¹¿' && isGoalSelectorField(fieldKey)) {
                            const localSceneBucket = ensureSceneSettingBucket(activeScene);
                            [
                                normalizeSceneFieldKey('å‡ºä»·ç›®æ ‡'),
                                normalizeSceneFieldKey('ä¼˜åŒ–ç›®æ ‡'),
                                normalizeSceneFieldKey('æ ¸å¿ƒè¯è®¾ç½®'),
                                normalizeSceneFieldKey('å…³é”®è¯è®¾ç½®'),
                                normalizeSceneFieldKey('åŒ¹é…æ–¹å¼'),
                                normalizeSceneFieldKey('æµé‡æ™ºé€‰'),
                                normalizeSceneFieldKey('å¼€å¯å†·å¯åŠ é€Ÿ'),
                                normalizeSceneFieldKey('å†·å¯åŠ é€Ÿ'),
                                normalizeSceneFieldKey('å¡ä½æ–¹å¼'),
                                normalizeSceneFieldKey('campaign.promotionScene'),
                                normalizeSceneFieldKey('campaign.itemSelectedMode'),
                                normalizeSceneFieldKey('campaign.bidTargetV2'),
                                normalizeSceneFieldKey('campaign.optimizeTarget')
                            ].forEach(key => {
                                if (!key) return;
                                localTouchedBucket[key] = false;
                                if (key !== fieldKey) delete localSceneBucket[key];
                            });
                            const selectedGoal = normalizeGoalCandidateLabel(
                                normalizeSceneSettingValue(control.value)
                                || normalizeSceneSettingValue(localSceneBucket[normalizeSceneFieldKey('è¥é”€ç›®æ ‡')] || '')
                                || normalizeSceneSettingValue(localSceneBucket[normalizeSceneFieldKey('é€‰æ‹©å¡ä½æ–¹æ¡ˆ')] || '')
                            );
                            const keywordRuntime = resolveKeywordGoalRuntime(selectedGoal || 'è¶‹åŠ¿æ˜æ˜Ÿ');
                            if (keywordRuntime.marketingGoal) {
                                const goalFieldKey = normalizeSceneFieldKey('è¥é”€ç›®æ ‡');
                                const goalSchemeFieldKey = normalizeSceneFieldKey('é€‰æ‹©å¡ä½æ–¹æ¡ˆ');
                                if (goalFieldKey) {
                                    localSceneBucket[goalFieldKey] = keywordRuntime.marketingGoal;
                                    localTouchedBucket[goalFieldKey] = false;
                                }
                                if (goalSchemeFieldKey) {
                                    localSceneBucket[goalSchemeFieldKey] = keywordRuntime.marketingGoal;
                                    localTouchedBucket[goalSchemeFieldKey] = false;
                                }
                            }
                            if (keywordRuntime.promotionScene) {
                                const campaignPromotionSceneKey = normalizeSceneFieldKey('campaign.promotionScene');
                                if (campaignPromotionSceneKey) localSceneBucket[campaignPromotionSceneKey] = keywordRuntime.promotionScene;
                            }
                            if (keywordRuntime.itemSelectedMode) {
                                const campaignItemSelectedModeKey = normalizeSceneFieldKey('campaign.itemSelectedMode');
                                if (campaignItemSelectedModeKey) localSceneBucket[campaignItemSelectedModeKey] = keywordRuntime.itemSelectedMode;
                            }
                        }
                        syncSceneSettingValuesFromUI();
                        syncDraftFromUI();
                        const shouldRerenderSceneConfig = isGoalSelectorField(fieldKey)
                            || (activeScene === 'è´§å“å…¨ç«™æ¨å¹¿' && isSceneLabelMatch(fieldKey, 'å‡ºä»·æ–¹å¼'));
                        if (shouldRerenderSceneConfig) {
                            renderSceneDynamicConfig();
                        }
                        if (typeof wizardState.buildRequest === 'function') {
                            wizardState.renderPreview(wizardState.buildRequest());
                        }
                    };
                    control.addEventListener('input', onChange);
                    control.addEventListener('change', onChange);
                });
            };
            const collectManualKeywordRowsFromPanel = (panel) => (
                Array.from(panel?.querySelectorAll?.('[data-manual-keyword-row]') || [])
                    .map(row => {
                        const word = String(row?.getAttribute?.('data-manual-keyword-word') || '').trim();
                        if (!word) return null;
                        const bidPrice = toNumber(row?.getAttribute?.('data-manual-keyword-bid'), toNumber(wizardState.els.bidInput?.value, 1));
                        const matchScope = parseMatchScope(row?.getAttribute?.('data-manual-keyword-match'), DEFAULTS.matchScope);
                        const enabledInput = row?.querySelector?.('input[data-manual-keyword-enable]');
                        const enabled = !enabledInput || enabledInput.checked !== false;
                        return {
                            word,
                            bidPrice: Number.isFinite(bidPrice) ? bidPrice : 1,
                            matchScope,
                            onlineStatus: DEFAULTS.keywordOnlineStatus,
                            enabled
                        };
                    })
                    .filter(Boolean)
            );
            const resolveManualKeywordHiddenInput = (panel) => {
                const scope = panel?.closest?.('.am-wxt-setting-control')
                    || panel?.parentElement
                    || wizardState.els?.sceneDynamic
                    || null;
                return scope?.querySelector?.('textarea[data-manual-keyword-hidden]') || null;
            };
            const applyManualKeywordRowsFromPanel = (panel, rows = []) => {
                const hidden = resolveManualKeywordHiddenInput(panel);
                if (!hidden) return;
                const enabledRows = rows.filter(item => item?.enabled !== false);
                const nextRows = uniqueBy(enabledRows, item => String(item?.word || '').trim()).slice(0, 200);
                const nextText = nextRows.map(item => formatKeywordLine(item)).join('\n');
                if (hidden.value !== nextText) hidden.value = nextText;
                hidden.dispatchEvent(new Event('input', { bubbles: true }));
                hidden.dispatchEvent(new Event('change', { bubbles: true }));
                renderSceneDynamicConfig();
            };
            const normalizeManualKeywordBidValue = (value, fallback = 1) => {
                const num = toNumber(value, fallback);
                const safeNum = Number.isFinite(num) ? Math.max(0, num) : Math.max(0, fallback);
                return String(safeNum.toFixed(4)).replace(/(?:\.0+|(\.\d+?)0+)$/, '$1');
            };
            const ensureManualKeywordPanelDelegates = () => {
                if (wizardState.manualKeywordDelegatedBound) return;
                if (!(wizardState.els?.sceneDynamic instanceof HTMLElement)) return;
                wizardState.manualKeywordDelegatedBound = true;

                wizardState.els.sceneDynamic.addEventListener('click', (event) => {
                    const target = event.target instanceof Element ? event.target.closest('button') : null;
                    if (!(target instanceof Element)) return;
                    const panel = target.closest('[data-manual-keyword-panel]');
                    if (!(panel instanceof Element)) return;
                    if (!target.matches('button[data-manual-keyword-menu-toggle]') && !target.matches('button[data-manual-keyword-batch-match]')) {
                        panel.querySelectorAll('[data-manual-keyword-match-menu].open').forEach(menu => menu.classList.remove('open'));
                    }

                    if (target.matches('button[data-manual-keyword-menu-toggle]')) {
                        const menu = target.closest('[data-manual-keyword-match-menu]');
                        if (!(menu instanceof Element)) return;
                        menu.classList.toggle('open');
                        return;
                    }

                    if (target.matches('button[data-manual-keyword-collapse-toggle]')) {
                        const nextCollapsed = !panel.classList.contains('is-collapsed');
                        panel.classList.toggle('is-collapsed', nextCollapsed);
                        panel.setAttribute('data-manual-keyword-collapsed', nextCollapsed ? '1' : '0');
                        target.setAttribute('aria-expanded', nextCollapsed ? 'false' : 'true');
                        target.textContent = nextCollapsed ? 'å±•å¼€' : 'æ”¶èµ·';
                        wizardState.manualKeywordPanelCollapsed = nextCollapsed;
                        wizardState.draft = wizardState.draft || wizardDefaultDraft();
                        wizardState.draft.manualKeywordPanelCollapsed = nextCollapsed;
                        syncDraftFromUI();
                        return;
                    }

                    if (target.matches('button[data-manual-keyword-flow-toggle]')) {
                        const nextOn = !target.classList.contains('is-on');
                        target.classList.toggle('is-on', nextOn);
                        target.classList.toggle('is-off', !nextOn);
                        target.setAttribute('aria-pressed', nextOn ? 'true' : 'false');
                        const state = target.querySelector('.am-wxt-site-switch-state');
                        if (state) state.textContent = nextOn ? 'å¼€' : 'å…³';
                        const flowCheckbox = target.closest('.am-wxt-manual-keyword-left-item')?.querySelector('input[data-manual-package-enable]');
                        if (flowCheckbox instanceof HTMLInputElement) {
                            flowCheckbox.checked = nextOn;
                        }
                        const status = target.closest('.am-wxt-manual-keyword-left-item')?.querySelector('.am-wxt-manual-left-meta.status');
                        if (status) status.textContent = nextOn ? 'ç”Ÿæ•ˆä¸­' : 'å·²å…³é—­';
                        const flowScope = panel.closest('.am-wxt-setting-control') || panel.parentElement || panel;
                        const flowHidden = flowScope?.querySelector?.('input[data-manual-keyword-flow-hidden]');
                        if (flowHidden instanceof HTMLInputElement) {
                            flowHidden.value = nextOn ? 'å¼€å¯' : 'å…³é—­';
                            flowHidden.dispatchEvent(new Event('input', { bubbles: true }));
                            flowHidden.dispatchEvent(new Event('change', { bubbles: true }));
                        }
                        const comboCount = Math.max(0, toNumber(panel.getAttribute('data-manual-keyword-combo-count'), 0));
                        const keywordCount = Math.max(0, toNumber(panel.getAttribute('data-manual-keyword-count'), 0));
                        const toolbarTips = panel.querySelector('.am-wxt-manual-keyword-toolbar .tips');
                        if (toolbarTips) {
                            toolbarTips.textContent = `å·²è®¾ç½®ï¼š${nextOn ? 'å¼€å¯' : 'å…³é—­'}æµé‡æ™ºé€‰ï¼Œå…³é”®è¯ç»„åˆ ${comboCount} ä¸ªã€è‡ªé€‰è¯ ${keywordCount} ä¸ª`;
                        }
                        const editingStrategy = getStrategyById(wizardState.editingStrategyId);
                        if (editingStrategy) {
                            editingStrategy.useWordPackage = nextOn;
                        }
                        syncSceneSettingValuesFromUI();
                        syncDraftFromUI();
                        renderStrategyList();
                        if (typeof wizardState.buildRequest === 'function') {
                            wizardState.renderPreview(wizardState.buildRequest());
                        }
                        return;
                    }

                    if (target.matches('button[data-manual-keyword-batch-bid]')) {
                        const selectedRows = Array.from(panel.querySelectorAll('[data-manual-keyword-row]')).filter(row => (
                            row.querySelector('input[data-manual-keyword-enable]')?.checked !== false
                        ));
                        if (!selectedRows.length) {
                            appendWizardLog('è¯·å…ˆå‹¾é€‰å…³é”®è¯ï¼Œå†æ‰¹é‡ä¿®æ”¹å‡ºä»·', 'error');
                            return;
                        }
                        const defaultBid = selectedRows[0]?.getAttribute('data-manual-keyword-bid') || String(toNumber(wizardState.els.bidInput?.value, 1));
                        const bidText = window.prompt('è¯·è¾“å…¥æ‰¹é‡åŸºç¡€å‡ºä»·ï¼ˆå•ä½ï¼šå…ƒï¼‰', defaultBid) || '';
                        const inputText = String(bidText || '').trim();
                        if (!inputText) return;
                        const normalizedBid = normalizeManualKeywordBidValue(inputText, toNumber(defaultBid, toNumber(wizardState.els.bidInput?.value, 1)));
                        selectedRows.forEach(row => {
                            row.setAttribute('data-manual-keyword-bid', normalizedBid);
                            const bidInput = row.querySelector('input[data-manual-keyword-bid-input]');
                            if (bidInput instanceof HTMLInputElement) bidInput.value = normalizedBid;
                        });
                        applyManualKeywordRowsFromPanel(panel, collectManualKeywordRowsFromPanel(panel));
                        return;
                    }

                    if (target.matches('button[data-manual-keyword-batch-match]')) {
                        const nextMatch = parseMatchScope(target.getAttribute('data-manual-keyword-batch-match'), DEFAULTS.matchScope);
                        const selectedRows = Array.from(panel.querySelectorAll('[data-manual-keyword-row]')).filter(row => (
                            row.querySelector('input[data-manual-keyword-enable]')?.checked !== false
                        ));
                        if (!selectedRows.length) {
                            appendWizardLog('è¯·å…ˆå‹¾é€‰å…³é”®è¯ï¼Œå†æ‰¹é‡ä¿®æ”¹åŒ¹é…æ–¹æ¡ˆ', 'error');
                            return;
                        }
                        selectedRows.forEach(row => {
                            row.setAttribute('data-manual-keyword-match', String(nextMatch));
                        });
                        applyManualKeywordRowsFromPanel(panel, collectManualKeywordRowsFromPanel(panel));
                        return;
                    }

                    if (target.matches('button[data-manual-keyword-match]')) {
                        const row = target.closest('[data-manual-keyword-row]');
                        if (!(row instanceof Element)) return;
                        const nextMatch = parseMatchScope(target.getAttribute('data-manual-keyword-match'), DEFAULTS.matchScope);
                        row.setAttribute('data-manual-keyword-match', String(nextMatch));
                        applyManualKeywordRowsFromPanel(panel, collectManualKeywordRowsFromPanel(panel));
                        return;
                    }

                    if (target.matches('button[data-manual-keyword-add]')) {
                        const addedText = window.prompt('è¯·è¾“å…¥å…³é”®è¯ï¼Œæ¯è¡Œä¸€ä¸ªï¼Œæ”¯æŒï¼šå…³é”®è¯,å‡ºä»·,åŒ¹é…æ–¹å¼ï¼ˆå¹¿æ³›/ç²¾å‡†ï¼‰', '') || '';
                        const inputText = String(addedText || '').trim();
                        if (!inputText) return;
                        const existingRows = collectManualKeywordRowsFromPanel(panel).filter(item => item?.enabled !== false);
                        const parsedRows = parseKeywords(inputText, {
                            bidPrice: toNumber(wizardState.els.bidInput?.value, 1),
                            matchScope: DEFAULTS.matchScope,
                            onlineStatus: DEFAULTS.keywordOnlineStatus
                        });
                        applyManualKeywordRowsFromPanel(
                            panel,
                            existingRows.concat(parsedRows).map(item => ({ ...item, enabled: true }))
                        );
                        return;
                    }

                    if (target.matches('button[data-manual-keyword-clear]')) {
                        applyManualKeywordRowsFromPanel(panel, []);
                    }
                });

                wizardState.els.sceneDynamic.addEventListener('change', (event) => {
                    const target = event.target instanceof Element ? event.target : null;
                    if (!(target instanceof Element)) return;
                    const panel = target.closest('[data-manual-keyword-panel]');
                    if (!(panel instanceof Element)) return;

                    if (target.matches('input[data-manual-keyword-check-all]')) {
                        const checkAll = !!target.checked;
                        panel.querySelectorAll('input[data-manual-keyword-enable]').forEach(input => {
                            input.checked = checkAll;
                        });
                        applyManualKeywordRowsFromPanel(panel, collectManualKeywordRowsFromPanel(panel));
                        return;
                    }

                    if (target.matches('input[data-manual-package-check-all]')) {
                        const checkAll = !!target.checked;
                        panel.querySelectorAll('input[data-manual-package-enable]').forEach(input => {
                            input.checked = checkAll;
                        });
                        return;
                    }

                    if (target.matches('input[data-manual-package-enable]')) {
                        const packageInputs = Array.from(panel.querySelectorAll('input[data-manual-package-enable]'));
                        const allChecked = packageInputs.length > 0 && packageInputs.every(input => !!input.checked);
                        const checkAllInput = panel.querySelector('input[data-manual-package-check-all]');
                        if (checkAllInput instanceof HTMLInputElement) {
                            checkAllInput.checked = allChecked;
                        }
                        return;
                    }

                    if (target.matches('input[data-manual-keyword-enable]')) {
                        applyManualKeywordRowsFromPanel(panel, collectManualKeywordRowsFromPanel(panel));
                        return;
                    }

                    if (target.matches('input[data-manual-keyword-bid-input]')) {
                        const row = target.closest('[data-manual-keyword-row]');
                        if (!(row instanceof Element)) return;
                        const normalizedBid = normalizeManualKeywordBidValue(
                            target.value,
                            toNumber(row.getAttribute('data-manual-keyword-bid'), toNumber(wizardState.els.bidInput?.value, 1))
                        );
                        target.value = normalizedBid;
                        row.setAttribute('data-manual-keyword-bid', normalizedBid);
                        applyManualKeywordRowsFromPanel(panel, collectManualKeywordRowsFromPanel(panel));
                    }
                });
            };
            ensureManualKeywordPanelDelegates();

            const normalizeStrategyList = (rawList, fallbackBudget = '') => {
                const fallback = getDefaultStrategyList();
                const input = Array.isArray(rawList) && rawList.length ? rawList : fallback;
                return input.map((item, idx) => {
                    const base = fallback[idx] || fallback[0];
                    const sceneName = SCENE_OPTIONS.includes(String(item?.sceneName || '').trim())
                        ? String(item.sceneName).trim()
                        : (SCENE_OPTIONS.includes(String(wizardState?.draft?.sceneName || '').trim())
                            ? String(wizardState.draft.sceneName).trim()
                            : getCurrentEditorSceneName());
                    const id = String(item?.id || base?.id || `strategy_${idx + 1}`).trim();
                    const name = String(item?.name || base?.name || `${getCurrentEditorSceneName()}-ç­–ç•¥${idx + 1}`).trim();
                    const enabled = item?.enabled !== false;
                    const dayAverageBudget = String(item?.dayAverageBudget ?? fallbackBudget ?? '').trim();
                    const defaultBidPrice = String(item?.defaultBidPrice ?? '1').trim() || '1';
                    const keywordMode = String(item?.keywordMode || DEFAULTS.keywordMode).trim() || DEFAULTS.keywordMode;
                    const useWordPackage = item?.useWordPackage !== false;
                    const recommendCount = String(item?.recommendCount ?? DEFAULTS.recommendCount).trim() || String(DEFAULTS.recommendCount);
                    const manualKeywords = String(item?.manualKeywords || '').trim();
                    const bidMode = normalizeBidMode(
                        item?.bidMode
                            || item?.campaignOverride?.bidTypeV2
                            || base?.bidMode
                            || wizardState?.draft?.bidMode
                            || 'smart',
                        'smart'
                    );
                    const bidTargetV2 = String(item?.bidTargetV2 || DEFAULTS.bidTargetV2).trim() || DEFAULTS.bidTargetV2;
                    const budgetType = String(item?.budgetType || 'day_average').trim() || 'day_average';
                    const setSingleCostV2 = bidMode === 'smart' && item?.setSingleCostV2 === true;
                    const singleCostV2 = String(item?.singleCostV2 || '').trim();
                    const planName = String(item?.planName || '').trim();
                    const autoPlanPrefix = String(item?.autoPlanPrefix || '').trim();
                    const copyBatchCount = Math.min(99, Math.max(1, toNumber(item?.copyBatchCount ?? item?.copyCount, 1)));
                    const sceneSettingValues = normalizeSceneSettingBucketValues(item?.sceneSettingValues || {});
                    const sceneSettingTouched = normalizeSceneSettingTouchedValues(item?.sceneSettingTouched || {});
                    const sceneSettings = normalizeSceneSettingsObject(item?.sceneSettings || {});
                    const marketingGoal = normalizeGoalLabel(resolveStrategyMarketingGoal({
                        ...item,
                        bidMode,
                        bidTargetV2,
                        marketingGoal: item?.marketingGoal || base?.marketingGoal || ''
                    }, {}, sceneName));
                    return {
                        sceneName,
                        id,
                        name,
                        marketingGoal,
                        enabled,
                        bidMode,
                        dayAverageBudget,
                        defaultBidPrice,
                        keywordMode,
                        useWordPackage,
                        recommendCount,
                        manualKeywords,
                        bidTargetV2,
                        budgetType,
                        setSingleCostV2,
                        singleCostV2,
                        planName,
                        autoPlanPrefix,
                        copyBatchCount,
                        sceneSettingValues,
                        sceneSettingTouched,
                        sceneSettings
                    };
                });
            };

            const getStrategyById = (strategyId) => wizardState.strategyList.find(item => item.id === strategyId) || null;

            const applyStrategyToDetailForm = (strategy) => {
                if (!strategy) return;
                if (wizardState.els.detailTitle) {
                    wizardState.els.detailTitle.textContent = getStrategyMainLabel(strategy);
                }
                const strategyScene = SCENE_OPTIONS.includes(String(strategy?.sceneName || '').trim())
                    ? String(strategy.sceneName).trim()
                    : (SCENE_OPTIONS.includes(String(wizardState.draft?.sceneName || '').trim())
                        ? String(wizardState.draft.sceneName).trim()
                        : 'å…³é”®è¯æ¨å¹¿');
                strategy.sceneName = strategyScene;
                if (wizardState.els.sceneSelect) {
                    wizardState.els.sceneSelect.value = strategyScene;
                }
                if (wizardState.draft) wizardState.draft.sceneName = strategyScene;
                const strategySceneSettingValues = normalizeSceneSettingBucketValues(strategy.sceneSettingValues || {});
                const strategySceneSettingTouched = normalizeSceneSettingTouchedValues(strategy.sceneSettingTouched || {});
                if (!Object.keys(strategySceneSettingValues).length && isPlainObject(strategy.sceneSettings)) {
                    const fromPayload = normalizeSceneSettingBucketValues(strategy.sceneSettings);
                    if (Object.keys(fromPayload).length) {
                        Object.assign(strategySceneSettingValues, fromPayload);
                    }
                }
                wizardState.draft = wizardState.draft || wizardDefaultDraft();
                if (!isPlainObject(wizardState.draft.sceneSettingValues)) {
                    wizardState.draft.sceneSettingValues = {};
                }
                wizardState.draft.sceneSettingValues[strategyScene] = mergeDeep({}, strategySceneSettingValues);
                if (!isPlainObject(wizardState.draft.sceneSettingTouched)) {
                    wizardState.draft.sceneSettingTouched = {};
                }
                wizardState.draft.sceneSettingTouched[strategyScene] = mergeDeep({}, strategySceneSettingTouched);
                const currentSceneName = getCurrentEditorSceneName();
                if (currentSceneName === 'å…³é”®è¯æ¨å¹¿') {
                    const strategyGoal = normalizeGoalLabel(strategy.marketingGoal || resolveStrategyMarketingGoal(strategy, {}, currentSceneName));
                    if (strategyGoal) {
                        const bucket = ensureSceneSettingBucket(currentSceneName);
                        if (!normalizeSceneSettingValue(bucket.è¥é”€ç›®æ ‡) || normalizeGoalLabel(bucket.è¥é”€ç›®æ ‡) !== strategyGoal) {
                            bucket.è¥é”€ç›®æ ‡ = strategyGoal;
                        }
                        if (!normalizeSceneSettingValue(bucket.é€‰æ‹©å¡ä½æ–¹æ¡ˆ) || normalizeGoalLabel(bucket.é€‰æ‹©å¡ä½æ–¹æ¡ˆ) !== strategyGoal) {
                            bucket.é€‰æ‹©å¡ä½æ–¹æ¡ˆ = strategyGoal;
                        }
                        strategy.marketingGoal = strategyGoal;
                    }
                }
                const bidMode = normalizeBidMode(strategy.bidMode || wizardState.draft?.bidMode || 'smart', 'smart');
                if (wizardState.els.bidTargetSelect) {
                    const strategyBidTargetValue = normalizeKeywordBidTargetOptionValue(
                        strategy.bidTargetV2 || DEFAULTS.bidTargetV2
                    ) || DEFAULTS.bidTargetV2;
                    wizardState.els.bidTargetSelect.value = strategyBidTargetValue;
                }
                if (wizardState.els.budgetTypeSelect) wizardState.els.budgetTypeSelect.value = strategy.budgetType || 'day_average';
                if (wizardState.els.budgetInput) wizardState.els.budgetInput.value = strategy.dayAverageBudget || wizardState.draft?.dayAverageBudget || '';
                if (wizardState.els.bidInput) wizardState.els.bidInput.value = strategy.defaultBidPrice || wizardState.draft?.defaultBidPrice || '1';
                if (wizardState.els.modeSelect) wizardState.els.modeSelect.value = strategy.keywordMode || wizardState.draft?.keywordMode || DEFAULTS.keywordMode;
                if (wizardState.els.recommendCountInput) wizardState.els.recommendCountInput.value = strategy.recommendCount || wizardState.draft?.recommendCount || String(DEFAULTS.recommendCount);
                if (wizardState.els.manualInput) wizardState.els.manualInput.value = strategy.manualKeywords || '';
                const visiblePlanName = getStrategyMainLabel(strategy);
                if (!String(strategy.autoPlanPrefix || '').trim()) {
                    strategy.autoPlanPrefix = stripAutoPlanSerialSuffix(visiblePlanName);
                }
                if (wizardState.els.prefixInput) {
                    wizardState.els.prefixInput.value = visiblePlanName || strategy.autoPlanPrefix || wizardState.draft?.planNamePrefix || '';
                }
                if (wizardState.els.singleCostEnableInput) wizardState.els.singleCostEnableInput.checked = bidMode === 'smart' && !!strategy.setSingleCostV2;
                if (wizardState.els.singleCostInput) {
                    wizardState.els.singleCostInput.value = strategy.singleCostV2 || '';
                }
                updateBidModeControls(bidMode);
                renderSceneDynamicConfig();
            };

            const pullDetailFormToStrategy = (strategy) => {
                if (!strategy) return;
                const bidMode = normalizeBidMode(
                    wizardState.els.bidModeSelect?.value || strategy.bidMode || wizardState.draft?.bidMode || 'smart',
                    'smart'
                );
                const sceneName = getCurrentEditorSceneName();
                const sceneSettings = buildSceneSettingsPayload(sceneName);
                strategy.sceneName = sceneName;
                strategy.bidMode = bidMode;
                if (wizardState.els.bidTargetSelect) strategy.bidTargetV2 = wizardState.els.bidTargetSelect.value || DEFAULTS.bidTargetV2;
                if (wizardState.els.budgetTypeSelect) strategy.budgetType = wizardState.els.budgetTypeSelect.value || 'day_average';
                if (wizardState.els.budgetInput) strategy.dayAverageBudget = wizardState.els.budgetInput.value.trim();
                if (wizardState.els.bidInput) strategy.defaultBidPrice = wizardState.els.bidInput.value.trim() || '1';
                if (wizardState.els.modeSelect) strategy.keywordMode = wizardState.els.modeSelect.value;
                if (wizardState.els.recommendCountInput) strategy.recommendCount = wizardState.els.recommendCountInput.value.trim() || String(DEFAULTS.recommendCount);
                if (wizardState.els.manualInput) strategy.manualKeywords = wizardState.els.manualInput.value.trim();
                if (wizardState.els.prefixInput) {
                    const inputPlanName = wizardState.els.prefixInput.value.trim();
                    if (isAutoGeneratedPlanPrefix(inputPlanName)) {
                        strategy.planName = '';
                        strategy.autoPlanPrefix = stripAutoPlanSerialSuffix(inputPlanName);
                    } else {
                        strategy.planName = inputPlanName;
                    }
                }
                if (wizardState.els.singleCostEnableInput) strategy.setSingleCostV2 = bidMode === 'smart' && !!wizardState.els.singleCostEnableInput.checked;
                if (wizardState.els.singleCostInput) strategy.singleCostV2 = wizardState.els.singleCostInput.value.trim();
                strategy.marketingGoal = resolveStrategyMarketingGoal(strategy, sceneSettings, sceneName);
                strategy.sceneSettingValues = mergeDeep({}, normalizeSceneSettingBucketValues(ensureSceneSettingBucket(sceneName)));
                strategy.sceneSettingTouched = mergeDeep({}, normalizeSceneSettingTouchedValues(ensureSceneTouchedBucket(sceneName)));
                strategy.sceneSettings = normalizeSceneSettingsObject(sceneSettings);
            };

            const setDetailVisible = (visible) => {
                wizardState.detailVisible = !!visible;
                if (wizardState.els.detailConfig) {
                    wizardState.els.detailConfig.classList.toggle('collapsed', !wizardState.detailVisible);
                }
                if (wizardState.els.detailBackdrop) {
                    wizardState.els.detailBackdrop.classList.toggle('open', wizardState.detailVisible);
                }
            };

            const openStrategyDetail = (strategyId) => {
                const strategy = getStrategyById(strategyId);
                if (!strategy) return;
                const previous = getStrategyById(wizardState.editingStrategyId);
                if (previous) pullDetailFormToStrategy(previous);
                if (wizardState.editingStrategyId === strategy.id && wizardState.detailVisible) {
                    setDetailVisible(false);
                    syncDraftFromUI();
                    renderStrategyList();
                    return;
                }
                wizardState.editingStrategyId = strategy.id;
                applyStrategyToDetailForm(strategy);
                setDetailVisible(true);
                syncDraftFromUI();
                renderStrategyList();
                maybeAutoLoadManualKeywords(strategy);
            };
            const addNewStrategy = () => {
                const editing = getStrategyById(wizardState.editingStrategyId);
                if (editing) pullDetailFormToStrategy(editing);
                const sceneName = getCurrentEditorSceneName();
                const bidMode = normalizeBidMode(
                    wizardState.els.bidModeSelect?.value || wizardState.draft?.bidMode || 'smart',
                    'smart'
                );
                const rawPlanName = String(
                    wizardState.els.prefixInput?.value
                    || wizardState.draft?.planNamePrefix
                    || buildDefaultPlanPrefixByScene(sceneName)
                ).trim();
                const sceneSettings = buildSceneSettingsPayload(sceneName);
                const next = {
                    sceneName,
                    id: createStrategyCloneId('strategy'),
                    name: createNewStrategyName(sceneName),
                    enabled: true,
                    bidMode,
                    marketingGoal: resolveStrategyMarketingGoal({
                        bidMode,
                        bidTargetV2: String(wizardState.els.bidTargetSelect?.value || DEFAULTS.bidTargetV2).trim() || DEFAULTS.bidTargetV2
                    }, sceneSettings, sceneName),
                    dayAverageBudget: String(wizardState.els.budgetInput?.value || wizardState.draft?.dayAverageBudget || '100').trim() || '100',
                    defaultBidPrice: String(wizardState.els.bidInput?.value || wizardState.draft?.defaultBidPrice || '1').trim() || '1',
                    keywordMode: String(wizardState.els.modeSelect?.value || wizardState.draft?.keywordMode || DEFAULTS.keywordMode).trim() || DEFAULTS.keywordMode,
                    useWordPackage: wizardState?.draft?.useWordPackage !== false,
                    recommendCount: String(wizardState.els.recommendCountInput?.value || wizardState.draft?.recommendCount || DEFAULTS.recommendCount).trim() || String(DEFAULTS.recommendCount),
                    manualKeywords: String(wizardState.els.manualInput?.value || '').trim(),
                    bidTargetV2: String(wizardState.els.bidTargetSelect?.value || DEFAULTS.bidTargetV2).trim() || DEFAULTS.bidTargetV2,
                    budgetType: String(wizardState.els.budgetTypeSelect?.value || 'day_average').trim() || 'day_average',
                    setSingleCostV2: bidMode === 'smart' && !!wizardState.els.singleCostEnableInput?.checked,
                    singleCostV2: String(wizardState.els.singleCostInput?.value || '').trim(),
                    planName: ensureUniqueStrategyPlanName(rawPlanName || buildDefaultPlanPrefixByScene(sceneName)),
                    copyBatchCount: 1,
                    sceneSettingValues: mergeDeep({}, normalizeSceneSettingBucketValues(ensureSceneSettingBucket(sceneName))),
                    sceneSettingTouched: mergeDeep({}, normalizeSceneSettingTouchedValues(ensureSceneTouchedBucket(sceneName))),
                    sceneSettings: normalizeSceneSettingsObject(sceneSettings)
                };
                wizardState.strategyList.push(next);
                wizardState.editingStrategyId = next.id;
                setDetailVisible(true);
                applyStrategyToDetailForm(next);
                syncDraftFromUI();
                renderStrategyList();
                if (typeof wizardState.buildRequest === 'function') {
                    wizardState.renderPreview(wizardState.buildRequest());
                }
                appendWizardLog(`å·²æ–°å»ºè®¡åˆ’ï¼š${next.name}`, 'success');
                maybeAutoLoadManualKeywords(next, { delayMs: 320 });
            };
            const resolveKeywordGoalRuntime = (goalLabel = '') => {
                const normalizedGoal = detectKeywordGoalFromText(goalLabel) || normalizeGoalCandidateLabel(goalLabel);
                const runtimeRule = resolveKeywordGoalRuntimeFallback(normalizedGoal);
                const bidTargetV2 = String(
                    runtimeRule?.bidTargetV2
                    || (normalizedGoal === 'è‡ªå®šä¹‰æ¨å¹¿' ? 'conv' : DEFAULTS.bidTargetV2)
                ).trim() || DEFAULTS.bidTargetV2;
                const optimizeTarget = String(runtimeRule?.optimizeTarget || bidTargetV2).trim() || bidTargetV2;
                const promotionScene = String(runtimeRule?.promotionScene || '').trim();
                const itemSelectedMode = String(runtimeRule?.itemSelectedMode || '').trim();
                return {
                    marketingGoal: normalizedGoal || 'è¶‹åŠ¿æ˜æ˜Ÿ',
                    bidMode: 'smart',
                    bidTargetV2,
                    optimizeTarget,
                    promotionScene,
                    itemSelectedMode
                };
            };
            const handleGenerateOtherStrategies = () => {
                const editing = getStrategyById(wizardState.editingStrategyId);
                if (editing) pullDetailFormToStrategy(editing);
                const sceneName = getCurrentEditorSceneName();
                const sceneSettings = buildSceneSettingsPayload(sceneName);
                const goalCandidates = getSceneMarketingGoalFallbackList(sceneName);
                if (!goalCandidates.length) {
                    addNewStrategy();
                    return;
                }
                const existingGoalSet = new Set(
                    (wizardState.strategyList || [])
                        .map(strategy => normalizeGoalLabel(resolveStrategyMarketingGoal(strategy, sceneSettings, sceneName)))
                        .filter(Boolean)
                );
                const missingGoals = goalCandidates
                    .map(goal => (sceneName === 'å…³é”®è¯æ¨å¹¿' ? normalizeGoalCandidateLabel(goal) : normalizeGoalLabel(goal)))
                    .filter(Boolean)
                    .filter(goal => !existingGoalSet.has(normalizeGoalLabel(goal)));
                if (!missingGoals.length) {
                    appendWizardLog(`å½“å‰ç­–ç•¥å·²è¦†ç›–ã€Œ${sceneName}ã€å€™é€‰ç›®æ ‡ï¼Œæ— éœ€æ–°å¢`, 'success');
                    return;
                }
                const seedStrategy = deepClone(editing || wizardState.strategyList[0] || {});
                const seedSceneSettings = normalizeSceneSettingsObject(seedStrategy.sceneSettings || sceneSettings);
                const seedSceneSettingValues = normalizeSceneSettingBucketValues(
                    seedStrategy.sceneSettingValues || ensureSceneSettingBucket(sceneName)
                );
                const seedSceneSettingTouched = normalizeSceneSettingTouchedValues(
                    seedStrategy.sceneSettingTouched || ensureSceneTouchedBucket(sceneName)
                );
                const usedNameSet = new Set(
                    (wizardState.strategyList || [])
                        .map(item => String(item?.name || '').trim())
                        .filter(Boolean)
                );
                const created = [];
                const createUniqueStrategyNameByGoal = (goalLabel = '') => {
                    const base = `${sceneName}-${goalLabel || 'ç­–ç•¥'}`;
                    if (!usedNameSet.has(base)) {
                        usedNameSet.add(base);
                        return base;
                    }
                    let cursor = 2;
                    let candidate = `${base}${cursor}`;
                    while (usedNameSet.has(candidate) && cursor < 99) {
                        cursor += 1;
                        candidate = `${base}${cursor}`;
                    }
                    usedNameSet.add(candidate);
                    return candidate;
                };
                missingGoals.forEach(goal => {
                    const runtime = sceneName === 'å…³é”®è¯æ¨å¹¿'
                        ? resolveKeywordGoalRuntime(goal)
                        : {
                            marketingGoal: goal,
                            bidMode: normalizeBidMode(seedStrategy.bidMode || wizardState.draft?.bidMode || 'smart', 'smart'),
                            bidTargetV2: String(seedStrategy.bidTargetV2 || DEFAULTS.bidTargetV2).trim() || DEFAULTS.bidTargetV2
                        };
                    const strategySceneSettings = mergeDeep({}, seedSceneSettings);
                    if (runtime.marketingGoal) {
                        if (sceneName === 'å…³é”®è¯æ¨å¹¿') {
                            strategySceneSettings.è¥é”€ç›®æ ‡ = runtime.marketingGoal;
                            strategySceneSettings.é€‰æ‹©å¡ä½æ–¹æ¡ˆ = runtime.marketingGoal;
                        } else if (!normalizeGoalLabel(strategySceneSettings.è¥é”€ç›®æ ‡ || '')) {
                            strategySceneSettings.è¥é”€ç›®æ ‡ = runtime.marketingGoal;
                        }
                    }
                    const strategySceneSettingValues = mergeDeep({}, seedSceneSettingValues);
                    if (runtime.marketingGoal) {
                        const goalFieldKey = normalizeSceneFieldKey('è¥é”€ç›®æ ‡');
                        if (goalFieldKey) strategySceneSettingValues[goalFieldKey] = runtime.marketingGoal;
                        if (sceneName === 'å…³é”®è¯æ¨å¹¿') {
                            const schemeFieldKey = normalizeSceneFieldKey('é€‰æ‹©å¡ä½æ–¹æ¡ˆ');
                            if (schemeFieldKey) strategySceneSettingValues[schemeFieldKey] = runtime.marketingGoal;
                        }
                    }
                    const strategySceneSettingTouched = mergeDeep({}, seedSceneSettingTouched);
                    if (runtime.marketingGoal) {
                        const goalFieldKey = normalizeSceneFieldKey('è¥é”€ç›®æ ‡');
                        if (goalFieldKey) strategySceneSettingTouched[goalFieldKey] = true;
                        if (sceneName === 'å…³é”®è¯æ¨å¹¿') {
                            const schemeFieldKey = normalizeSceneFieldKey('é€‰æ‹©å¡ä½æ–¹æ¡ˆ');
                            if (schemeFieldKey) strategySceneSettingTouched[schemeFieldKey] = true;
                        }
                    }
                    const planNameSeed = String(
                        seedStrategy.planName
                        || wizardState.els.prefixInput?.value
                        || wizardState.draft?.planNamePrefix
                        || buildDefaultPlanPrefixByScene(sceneName)
                    ).trim() || buildDefaultPlanPrefixByScene(sceneName);
                    const next = {
                        sceneName,
                        id: createStrategyCloneId('strategy'),
                        name: createUniqueStrategyNameByGoal(runtime.marketingGoal),
                        enabled: true,
                        bidMode: runtime.bidMode,
                        marketingGoal: runtime.marketingGoal,
                        dayAverageBudget: String(seedStrategy.dayAverageBudget || wizardState.els.budgetInput?.value || wizardState.draft?.dayAverageBudget || '100').trim() || '100',
                        defaultBidPrice: String(seedStrategy.defaultBidPrice || wizardState.els.bidInput?.value || wizardState.draft?.defaultBidPrice || '1').trim() || '1',
                        keywordMode: String(seedStrategy.keywordMode || wizardState.els.modeSelect?.value || wizardState.draft?.keywordMode || DEFAULTS.keywordMode).trim() || DEFAULTS.keywordMode,
                        useWordPackage: seedStrategy.useWordPackage !== false && wizardState?.draft?.useWordPackage !== false,
                        recommendCount: String(seedStrategy.recommendCount || wizardState.els.recommendCountInput?.value || wizardState.draft?.recommendCount || DEFAULTS.recommendCount).trim() || String(DEFAULTS.recommendCount),
                        manualKeywords: String(seedStrategy.manualKeywords || wizardState.els.manualInput?.value || '').trim(),
                        bidTargetV2: runtime.bidTargetV2,
                        budgetType: String(seedStrategy.budgetType || wizardState.els.budgetTypeSelect?.value || 'day_average').trim() || 'day_average',
                        setSingleCostV2: runtime.bidMode === 'smart' && !!seedStrategy.setSingleCostV2,
                        singleCostV2: runtime.bidMode === 'smart' ? String(seedStrategy.singleCostV2 || '').trim() : '',
                        planName: ensureUniqueStrategyPlanName(`${planNameSeed}_${runtime.marketingGoal}`),
                        copyBatchCount: 1,
                        sceneSettingValues: strategySceneSettingValues,
                        sceneSettingTouched: strategySceneSettingTouched,
                        sceneSettings: strategySceneSettings
                    };
                    wizardState.strategyList.push(next);
                    created.push(next);
                });
                const currentEditing = created[created.length - 1] || created[0];
                if (currentEditing) {
                    wizardState.editingStrategyId = currentEditing.id;
                    setDetailVisible(true);
                    applyStrategyToDetailForm(currentEditing);
                }
                syncDraftFromUI();
                renderStrategyList();
                if (typeof wizardState.buildRequest === 'function') {
                    wizardState.renderPreview(wizardState.buildRequest());
                }
                appendWizardLog(
                    `å·²ç”Ÿæˆå…¶ä»–ç­–ç•¥ï¼š${created.length} ä¸ªï¼ˆ${created.map(item => item.marketingGoal || item.name).slice(0, 4).join('ã€')}ï¼‰`,
                    'success'
                );
            };

            const renderStrategyList = () => {
                if (!wizardState.els.strategyList || !wizardState.els.strategyCount) return;
                wizardState.els.strategyList.innerHTML = '';
                const enabledCount = wizardState.strategyList.filter(item => item.enabled).length;
                wizardState.els.strategyCount.textContent = String(enabledCount);
                const fallbackSceneName = getCurrentEditorSceneName();
                const sceneSettingsCache = new Map();
                const getSceneSettingsFor = (sceneName = '') => {
                    const targetScene = SCENE_OPTIONS.includes(String(sceneName || '').trim())
                        ? String(sceneName).trim()
                        : fallbackSceneName;
                    if (targetScene === 'å…³é”®è¯æ¨å¹¿') return {};
                    if (!sceneSettingsCache.has(targetScene)) {
                        sceneSettingsCache.set(targetScene, buildSceneSettingsPayload(targetScene));
                    }
                    return sceneSettingsCache.get(targetScene) || {};
                };
                wizardState.strategyList.forEach((strategy) => {
                    const strategySceneName = SCENE_OPTIONS.includes(String(strategy?.sceneName || '').trim())
                        ? String(strategy.sceneName).trim()
                        : fallbackSceneName;
                    strategy.sceneName = strategySceneName;
                    const bidMode = normalizeBidMode(strategy.bidMode || 'smart', 'smart');
                    strategy.bidMode = bidMode;
                    const strategySceneSettings = normalizeSceneSettingsObject(strategy.sceneSettings || {});
                    const goalSceneSettings = Object.keys(strategySceneSettings).length
                        ? strategySceneSettings
                        : getSceneSettingsFor(strategySceneName);
                    strategy.marketingGoal = resolveStrategyMarketingGoal(strategy, goalSceneSettings, strategySceneName);
                    const bidTargetLabel = BID_TARGET_OPTIONS.find(item => item.value === strategy.bidTargetV2)?.label || 'è·å–æˆäº¤é‡';
                    const bidModeLabel = bidMode === 'manual' ? 'æ‰‹åŠ¨å‡ºä»·' : 'æ™ºèƒ½å‡ºä»·';
                    const goalLabel = normalizeGoalLabel(strategy.marketingGoal || '') || 'æœªè®¾ç½®ç›®æ ‡';
                    const budgetLabel = String(strategy.dayAverageBudget || '').trim() || '100';
                    const copyBatchCount = Math.min(99, Math.max(1, toNumber(strategy.copyBatchCount, 1)));
                    strategy.copyBatchCount = copyBatchCount;
                    const row = document.createElement('div');
                    row.className = 'am-wxt-strategy-item';
                    row.innerHTML = `
                        <div class="am-wxt-strategy-main">
                            <div class="am-wxt-strategy-left">
                                <input type="checkbox" ${strategy.enabled ? 'checked' : ''} />
                                <span>${Utils.escapeHtml(getStrategyMainLabel(strategy))}</span>
                            </div>
                            <div class="am-wxt-strategy-right">
                                <span>${Utils.escapeHtml(goalLabel)} / ${Utils.escapeHtml(bidModeLabel)} / ${Utils.escapeHtml(bidTargetLabel)} / é¢„ç®— ${Utils.escapeHtml(budgetLabel)} å…ƒ</span>
                                <button class="am-wxt-btn am-wxt-copy-btn" data-action="copy">
                                    <span>å¤åˆ¶</span>
                                    <span class="am-wxt-copy-multi" data-action="copy-count-badge" title="ç‚¹å‡»å¢åŠ ï¼Œå³é”®å‡å°‘ï¼Œæ»šè½®å¯è°ƒèŠ‚">
                                        <span class="am-wxt-copy-multi-icon">Ã—</span>
                                        <span class="am-wxt-copy-multi-num">${copyBatchCount}</span>
                                    </span>
                                </button>
                                <button class="am-wxt-btn" data-action="delete">åˆ é™¤</button>
                                <button class="am-wxt-btn" data-action="edit">${wizardState.detailVisible && wizardState.editingStrategyId === strategy.id ? 'ç¼–è¾‘ä¸­' : 'ç¼–è¾‘è®¡åˆ’'}</button>
                            </div>
                        </div>
                    `;
                    const checkbox = row.querySelector('input[type="checkbox"]');
                    const copyCountBadge = row.querySelector('[data-action="copy-count-badge"]');
                    const copyCountNum = row.querySelector('.am-wxt-copy-multi-num');
                    const copyBtn = row.querySelector('button[data-action="copy"]');
                    const deleteBtn = row.querySelector('button[data-action="delete"]');
                    const editBtn = row.querySelector('button[data-action="edit"]');
                    checkbox.onchange = () => {
                        strategy.enabled = !!checkbox.checked;
                        syncDraftFromUI();
                        renderStrategyList();
                    };
                    if (copyCountBadge instanceof HTMLElement) {
                        const refreshCopyCount = () => {
                            if (copyCountNum instanceof HTMLElement) {
                                copyCountNum.textContent = String(strategy.copyBatchCount);
                            }
                        };
                        const setCopyCount = (next) => {
                            const nextCount = Math.min(99, Math.max(1, toNumber(next, 1)));
                            strategy.copyBatchCount = nextCount;
                            refreshCopyCount();
                            syncDraftFromUI();
                        };
                        copyCountBadge.addEventListener('click', (event) => {
                            event.preventDefault();
                            event.stopPropagation();
                            setCopyCount(strategy.copyBatchCount + 1);
                        });
                        copyCountBadge.addEventListener('contextmenu', (event) => {
                            event.preventDefault();
                            event.stopPropagation();
                            setCopyCount(strategy.copyBatchCount - 1);
                        });
                        copyCountBadge.addEventListener('wheel', (event) => {
                            event.preventDefault();
                            event.stopPropagation();
                            const delta = event.deltaY > 0 ? -1 : 1;
                            setCopyCount(strategy.copyBatchCount + delta);
                        }, { passive: false });
                    }
                    copyBtn.onclick = () => {
                        const editing = getStrategyById(wizardState.editingStrategyId);
                        if (editing) pullDetailFormToStrategy(editing);
                        const targetCopyCount = Math.min(99, Math.max(1, toNumber(strategy.copyBatchCount, 1)));
                        for (let idx = 1; idx <= targetCopyCount; idx++) {
                            const clone = deepClone(strategy);
                            clone.id = createStrategyCloneId(strategy.id || 'strategy');
                            clone.name = createStrategyCloneName(strategy.name || 'è®¡åˆ’');
                            clone.planName = buildCopiedStrategyPlanName(
                                strategy.planName || wizardState?.draft?.planNamePrefix || '',
                                getCurrentEditorSceneName(),
                                idx
                            );
                            clone.enabled = true;
                            clone.copyBatchCount = 1;
                            wizardState.strategyList.push(clone);
                        }
                        syncDraftFromUI();
                        renderStrategyList();
                        if (typeof wizardState.buildRequest === 'function') {
                            wizardState.renderPreview(wizardState.buildRequest());
                        }
                        appendWizardLog(`å·²å¤åˆ¶è®¡åˆ’ï¼š${targetCopyCount} ä¸ª`, 'success');
                    };
                    deleteBtn.onclick = () => {
                        if ((wizardState.strategyList || []).length <= 1) {
                            appendWizardLog('è‡³å°‘ä¿ç•™ 1 ä¸ªè®¡åˆ’', 'error');
                            return;
                        }
                        const removeIndex = wizardState.strategyList.findIndex(item => item.id === strategy.id);
                        if (removeIndex < 0) return;
                        const removed = wizardState.strategyList.splice(removeIndex, 1)[0];
                        if (wizardState.editingStrategyId === removed.id) {
                            const fallback = wizardState.strategyList[Math.max(0, removeIndex - 1)] || wizardState.strategyList[0] || null;
                            wizardState.editingStrategyId = fallback?.id || '';
                            if (fallback && wizardState.detailVisible) {
                                applyStrategyToDetailForm(fallback);
                            }
                        }
                        syncDraftFromUI();
                        renderStrategyList();
                        if (typeof wizardState.buildRequest === 'function') {
                            wizardState.renderPreview(wizardState.buildRequest());
                        }
                        appendWizardLog(`å·²åˆ é™¤è®¡åˆ’ï¼š${removed?.name || ''}`, 'success');
                    };
                    editBtn.onclick = () => {
                        openStrategyDetail(strategy.id);
                    };
                    wizardState.els.strategyList.appendChild(row);
                });
                setDetailVisible(wizardState.detailVisible);
            };

            const syncDraftFromUI = () => {
                wizardState.draft = wizardState.draft || wizardDefaultDraft();
                wizardState.draft.schemaVersion = SESSION_DRAFT_SCHEMA_VERSION;
                const editingStrategy = getStrategyById(wizardState.editingStrategyId);
                const syncGlobalDefaults = !editingStrategy || !wizardState.detailVisible;
                const selectedScene = wizardState.els.sceneSelect?.value || wizardState.draft.sceneName || 'å…³é”®è¯æ¨å¹¿';
                wizardState.draft.sceneName = SCENE_OPTIONS.includes(selectedScene) ? selectedScene : 'å…³é”®è¯æ¨å¹¿';
                syncSceneSettingValuesFromUI();
                const prefixValue = wizardState.els.prefixInput?.value?.trim() || '';
                if (!editingStrategy || !wizardState.detailVisible) {
                    wizardState.draft.planNamePrefix = prefixValue || wizardState.draft.planNamePrefix || buildSceneTimePrefix(wizardState.draft.sceneName);
                } else if (!wizardState.draft.planNamePrefix) {
                    wizardState.draft.planNamePrefix = buildSceneTimePrefix(wizardState.draft.sceneName);
                }
                if (syncGlobalDefaults) {
                    wizardState.draft.dayAverageBudget = wizardState.els.budgetInput?.value?.trim() || wizardState.draft.dayAverageBudget || '';
                    wizardState.draft.defaultBidPrice = wizardState.els.bidInput?.value?.trim() || wizardState.draft.defaultBidPrice || '1';
                    wizardState.draft.bidMode = normalizeBidMode(
                        wizardState.els.bidModeSelect?.value || wizardState.draft.bidMode || 'smart',
                        'smart'
                    );
                    wizardState.draft.keywordMode = wizardState.els.modeSelect?.value || wizardState.draft.keywordMode || DEFAULTS.keywordMode;
                    wizardState.draft.recommendCount = wizardState.els.recommendCountInput?.value?.trim() || wizardState.draft.recommendCount || String(DEFAULTS.recommendCount);
                    wizardState.draft.manualKeywords = wizardState.els.manualInput?.value || wizardState.draft.manualKeywords || '';
                }
                wizardState.manualKeywordPanelCollapsed = wizardState.manualKeywordPanelCollapsed !== false;
                wizardState.draft.manualKeywordPanelCollapsed = wizardState.manualKeywordPanelCollapsed !== false;
                wizardState.draft.useWordPackage = wizardState.draft.useWordPackage !== false;
                wizardState.draft.fallbackPolicy = normalizeWizardFallbackPolicy(wizardState.draft.fallbackPolicy);
                if (editingStrategy) {
                    pullDetailFormToStrategy(editingStrategy);
                }
                wizardState.draft.addedItems = wizardState.addedItems.map(item => ({ ...item }));
                wizardState.draft.crowdList = wizardState.crowdList.map(item => deepClone(item));
                wizardState.draft.debugVisible = !!wizardState.debugVisible;
                wizardState.draft.itemSplitExpanded = wizardState.itemSplitExpanded === true;
                wizardState.draft.candidateListExpanded = wizardState.candidateListExpanded === true;
                wizardState.draft.strategyList = wizardState.strategyList.map(item => deepClone(item));
                wizardState.draft.editingStrategyId = wizardState.editingStrategyId || '';
                wizardState.draft.detailVisible = !!wizardState.detailVisible;
                saveSessionDraft(wizardState.draft);
            };

            const fillUIFromDraft = () => {
                wizardState.draft = wizardState.draft || wizardDefaultDraft();
                wizardState.draft.fallbackPolicy = normalizeWizardFallbackPolicy(wizardState.draft.fallbackPolicy);
                if (!isPlainObject(wizardState.draft.sceneSettingValues)) {
                    wizardState.draft.sceneSettingValues = {};
                }
                if (!isPlainObject(wizardState.draft.sceneSettingTouched)) {
                    wizardState.draft.sceneSettingTouched = {};
                }
                wizardState.draft.itemSplitExpanded = wizardState.draft.itemSplitExpanded === true;
                wizardState.draft.candidateListExpanded = wizardState.draft.candidateListExpanded === true;
                wizardState.draft.manualKeywordPanelCollapsed = wizardState.draft.manualKeywordPanelCollapsed !== false;
                wizardState.itemSplitExpanded = wizardState.draft.itemSplitExpanded;
                wizardState.candidateListExpanded = wizardState.draft.candidateListExpanded;
                wizardState.manualKeywordPanelCollapsed = wizardState.draft.manualKeywordPanelCollapsed;
                const sceneName = SCENE_OPTIONS.includes(wizardState.draft.sceneName) ? wizardState.draft.sceneName : 'å…³é”®è¯æ¨å¹¿';
                wizardState.draft.sceneName = sceneName || 'å…³é”®è¯æ¨å¹¿';
                wizardState.draft.useWordPackage = wizardState.draft.useWordPackage !== false;
                if (isAutoGeneratedPlanPrefix(wizardState.draft.planNamePrefix || '') || !String(wizardState.draft.planNamePrefix || '').trim()) {
                    wizardState.draft.planNamePrefix = buildDefaultPlanPrefixByScene(wizardState.draft.sceneName);
                }
                if (wizardState.els.sceneSelect) wizardState.els.sceneSelect.value = wizardState.draft.sceneName;
                wizardState.sceneProfiles = buildSceneProfiles();
                if (wizardState.els.prefixInput) wizardState.els.prefixInput.value = wizardState.draft.planNamePrefix || '';
                if (wizardState.els.budgetInput) wizardState.els.budgetInput.value = wizardState.draft.dayAverageBudget || '';
                if (wizardState.els.bidInput) wizardState.els.bidInput.value = wizardState.draft.defaultBidPrice || '';
                if (wizardState.els.bidModeSelect) wizardState.els.bidModeSelect.value = normalizeBidMode(wizardState.draft.bidMode || 'smart', 'smart');
                if (wizardState.els.modeSelect) wizardState.els.modeSelect.value = wizardState.draft.keywordMode || DEFAULTS.keywordMode;
                if (wizardState.els.recommendCountInput) wizardState.els.recommendCountInput.value = wizardState.draft.recommendCount || String(DEFAULTS.recommendCount);
                if (wizardState.els.manualInput) wizardState.els.manualInput.value = wizardState.draft.manualKeywords || '';
                wizardState.crowdList = Array.isArray(wizardState.draft.crowdList) ? wizardState.draft.crowdList.map(item => deepClone(item)) : [];
                wizardState.strategyList = normalizeStrategyList(
                    wizardState.draft.strategyList,
                    wizardState.draft.dayAverageBudget || ''
                );
                wizardState.editingStrategyId = String(wizardState.draft.editingStrategyId || wizardState.strategyList[0]?.id || '').trim();
                setDetailVisible(!!wizardState.draft.detailVisible);
                const editingStrategy = getStrategyById(wizardState.editingStrategyId);
                applyStrategyToDetailForm(editingStrategy || wizardState.strategyList[0] || null);
                updateBidModeControls(editingStrategy?.bidMode || wizardState.draft.bidMode || 'smart');
                setDebugVisible(!!wizardState.draft.debugVisible);
                setItemSplitExpanded(wizardState.itemSplitExpanded);
                setCandidateListExpanded(wizardState.candidateListExpanded);
            };

            const setCandidateSource = (source = 'all') => {
                wizardState.candidateSource = source === 'recommend' ? 'recommend' : 'all';
                if (wizardState.els.hotBtn) {
                    wizardState.els.hotBtn.classList.toggle('primary', wizardState.candidateSource === 'recommend');
                }
                if (wizardState.els.allBtn) {
                    wizardState.els.allBtn.classList.toggle('primary', wizardState.candidateSource === 'all');
                }
            };

            const renderCrowdList = () => {
                if (!wizardState.els.crowdList || !wizardState.els.crowdCount) return;
                wizardState.els.crowdCount.textContent = String(wizardState.crowdList.length);
                wizardState.els.crowdList.innerHTML = '';
                if (!wizardState.crowdList.length) {
                    wizardState.els.crowdList.innerHTML = '<div class="am-wxt-crowd-item"><span>æœªè®¾ç½®äººç¾¤ï¼ˆé»˜è®¤ä¸é™ï¼‰</span></div>';
                    return;
                }
                wizardState.crowdList.forEach((crowdItem, idx) => {
                    const row = document.createElement('div');
                    row.className = 'am-wxt-crowd-item';
                    const labelId = crowdItem?.crowd?.label?.labelId || '';
                    row.innerHTML = `
                        <span>${Utils.escapeHtml(getCrowdDisplayName(crowdItem))}${labelId ? `ï¼ˆ${Utils.escapeHtml(labelId)}ï¼‰` : ''}</span>
                        <button class="am-wxt-btn">ç§»é™¤</button>
                    `;
                    const removeBtn = row.querySelector('button');
                    removeBtn.onclick = () => {
                        wizardState.crowdList = wizardState.crowdList.filter((_, i) => i !== idx);
                        syncDraftFromUI();
                        renderCrowdList();
                    };
                    wizardState.els.crowdList.appendChild(row);
                });
            };

            const renderCandidateList = () => {
                const addedSet = new Set(wizardState.addedItems.map(item => String(item.materialId)));
                wizardState.els.candidateList.innerHTML = '';
                if (!wizardState.candidates.length) {
                    wizardState.els.candidateList.innerHTML = '<div class="am-wxt-item"><div class="name">æš‚æ— å€™é€‰å•†å“</div></div>';
                    return;
                }
                wizardState.candidates.forEach(item => {
                    const row = document.createElement('div');
                    row.className = 'am-wxt-item';
                    row.innerHTML = `
                        <div>
                            <div class="name">${Utils.escapeHtml(item.materialName || '(æ— æ ‡é¢˜å•†å“)')}</div>
                            <div class="meta">å®è´IDï¼š${Utils.escapeHtml(item.materialId)}</div>
                        </div>
                        <div class="actions">
                            <button class="am-wxt-btn">${addedSet.has(String(item.materialId)) ? 'å·²æ·»åŠ ' : 'æ·»åŠ '}</button>
                        </div>
                    `;
                    const addBtn = row.querySelector('button');
                    addBtn.disabled = addedSet.has(String(item.materialId));
                    addBtn.onclick = () => {
                        if (wizardState.addedItems.length >= WIZARD_MAX_ITEMS) {
                            appendWizardLog(`æœ€å¤šæ·»åŠ  ${WIZARD_MAX_ITEMS} ä¸ªå•†å“`, 'error');
                            return;
                        }
                        if (addedSet.has(String(item.materialId))) return;
                        wizardState.addedItems.push(item);
                        wizardState.addedItems = uniqueBy(wizardState.addedItems, x => String(x.materialId)).slice(0, WIZARD_MAX_ITEMS);
                        syncDraftFromUI();
                        renderAddedList();
                        renderCandidateList();
                    };
                    wizardState.els.candidateList.appendChild(row);
                });
            };

            const renderAddedList = () => {
                wizardState.els.addedCount.textContent = String(wizardState.addedItems.length);
                wizardState.els.addedList.innerHTML = '';
                if (!wizardState.addedItems.length) {
                    wizardState.els.addedList.innerHTML = '<div class="am-wxt-item"><div class="name">è¯·ç‚¹å‡»ä¸Šæ–¹â€œæ·»åŠ å•†å“â€æŒ‰é’®</div></div>';
                    return;
                }
                wizardState.addedItems.forEach((item, idx) => {
                    const row = document.createElement('div');
                    row.className = 'am-wxt-item';
                    row.innerHTML = `
                        <div>
                            <div class="name">${Utils.escapeHtml(item.materialName || '(æ— æ ‡é¢˜å•†å“)')}</div>
                            <div class="meta">å®è´IDï¼š${Utils.escapeHtml(item.materialId)}</div>
                        </div>
                        <div class="actions">
                            <button class="am-wxt-btn">ä¸Šç§»</button>
                            <button class="am-wxt-btn">ä¸‹ç§»</button>
                            <button class="am-wxt-btn">ç§»é™¤</button>
                        </div>
                    `;
                    const [upBtn, downBtn, removeBtn] = row.querySelectorAll('button');
                    upBtn.disabled = idx === 0;
                    downBtn.disabled = idx === wizardState.addedItems.length - 1;
                    upBtn.onclick = () => {
                        if (idx === 0) return;
                        const clone = wizardState.addedItems.slice();
                        [clone[idx - 1], clone[idx]] = [clone[idx], clone[idx - 1]];
                        wizardState.addedItems = clone;
                        syncDraftFromUI();
                        renderAddedList();
                    };
                    downBtn.onclick = () => {
                        if (idx >= wizardState.addedItems.length - 1) return;
                        const clone = wizardState.addedItems.slice();
                        [clone[idx + 1], clone[idx]] = [clone[idx], clone[idx + 1]];
                        wizardState.addedItems = clone;
                        syncDraftFromUI();
                        renderAddedList();
                    };
                    removeBtn.onclick = () => {
                        wizardState.addedItems = wizardState.addedItems.filter((_, i) => i !== idx);
                        syncDraftFromUI();
                        renderAddedList();
                        renderCandidateList();
                    };
                    wizardState.els.addedList.appendChild(row);
                });
            };

            const loadCandidates = async (query = '', source = wizardState.candidateSource || 'all') => {
                const normalizedQuery = String(query || '').trim();
                const effectiveSource = normalizedQuery ? 'all' : source;
                setCandidateSource(effectiveSource);
                wizardState.els.candidateList.innerHTML = '<div class="am-wxt-item"><div class="name">æ­£åœ¨åŠ è½½å€™é€‰å•†å“...</div></div>';
                try {
                    const useAll = wizardState.candidateSource === 'all';
                    const res = await searchItems({
                        bizCode: wizardState.draft?.bizCode || DEFAULTS.bizCode,
                        promotionScene: wizardState.draft?.promotionScene || DEFAULTS.promotionScene,
                        query: normalizedQuery,
                        pageSize: 40,
                        tagId: useAll ? null : '101111310',
                        channelKey: useAll ? '' : (normalizedQuery ? '' : 'effect')
                    });
                    wizardState.candidates = res.list;
                    renderCandidateList();
                    appendWizardLog(`å€™é€‰å•†å“å·²åŠ è½½ ${res.list.length} æ¡ï¼ˆ${useAll ? 'å…¨éƒ¨å•†å“' : 'æœºä¼šå“æ¨è'}${normalizedQuery ? `ï¼Œå…³é”®è¯ï¼š${normalizedQuery}` : ''}ï¼‰`, 'success');
                } catch (err) {
                    wizardState.candidates = [];
                    renderCandidateList();
                    appendWizardLog(`åŠ è½½å€™é€‰å•†å“å¤±è´¥ï¼š${err?.message || err}`, 'error');
                }
            };

            const buildRequestFromWizard = () => {
                syncDraftFromUI();
                const selectedSceneName = SCENE_OPTIONS.includes(wizardState.draft.sceneName) ? wizardState.draft.sceneName : 'å…³é”®è¯æ¨å¹¿';
                const selectedSceneSettings = buildSceneSettingsPayload(selectedSceneName);
                const selectedSceneGoalFromSettings = normalizeGoalLabel(resolveKeywordGoalFromSceneSettings(selectedSceneSettings));
                const prefix = wizardState.draft.planNamePrefix || buildSceneTimePrefix(selectedSceneName);
                const dayAverageBudget = wizardState.draft.dayAverageBudget;
                const isSelectedKeywordScene = selectedSceneName === 'å…³é”®è¯æ¨å¹¿';
                const enabledStrategies = (wizardState.strategyList || []).filter(item => item.enabled);
                const strategyGoalSetByScene = new Map();
                const sceneSettingsCache = new Map();
                const getSceneSettingsForRequest = (sceneName = '') => {
                    const targetScene = SCENE_OPTIONS.includes(String(sceneName || '').trim())
                        ? String(sceneName).trim()
                        : selectedSceneName;
                    if (targetScene === 'å…³é”®è¯æ¨å¹¿') return {};
                    if (!sceneSettingsCache.has(targetScene)) {
                        sceneSettingsCache.set(targetScene, buildSceneSettingsPayload(targetScene));
                    }
                    return sceneSettingsCache.get(targetScene) || {};
                };
                const plans = [];
                const usedPlanNameInRequest = new Set();
                const ensureUniquePlanNameInRequest = (rawName = '') => {
                    const seed = String(rawName || '').trim();
                    let candidate = seed || `${prefix}_${String(usedPlanNameInRequest.size + 1).padStart(2, '0')}`;
                    let cursor = 2;
                    while (usedPlanNameInRequest.has(candidate) && cursor < 999) {
                        candidate = `${seed || prefix}_${String(cursor).padStart(2, '0')}`;
                        cursor += 1;
                    }
                    usedPlanNameInRequest.add(candidate);
                    return candidate;
                };
                wizardState.addedItems.forEach((item, itemIdx) => {
                    enabledStrategies.forEach((strategy, strategyIdx) => {
                        const strategySceneName = SCENE_OPTIONS.includes(String(strategy?.sceneName || '').trim())
                            ? String(strategy.sceneName).trim()
                            : selectedSceneName;
                        const isKeywordScene = strategySceneName === 'å…³é”®è¯æ¨å¹¿';
                        let strategySceneSettings = normalizeSceneSettingsObject(
                            strategy?.sceneSettings || getSceneSettingsForRequest(strategySceneName)
                        );
                        const strategyBidMode = normalizeBidMode(strategy.bidMode || wizardState.draft.bidMode || 'smart', 'smart');
                        const strategyBidTargetV2 = String(strategy.bidTargetV2 || DEFAULTS.bidTargetV2).trim() || DEFAULTS.bidTargetV2;
                        const strategyBidTargetOptionValue = normalizeKeywordBidTargetOptionValue(strategyBidTargetV2) || strategyBidTargetV2;
                        if (isKeywordScene) {
                            strategySceneSettings = mergeDeep({}, strategySceneSettings);
                            strategySceneSettings.å‡ºä»·æ–¹å¼ = strategyBidMode === 'manual' ? 'æ‰‹åŠ¨å‡ºä»·' : 'æ™ºèƒ½å‡ºä»·';
                            delete strategySceneSettings['campaign.bidTypeV2'];
                            delete strategySceneSettings['campaign.bidTargetV2'];
                            delete strategySceneSettings['campaign.optimizeTarget'];
                            if (strategyBidMode === 'manual') {
                                delete strategySceneSettings.å‡ºä»·ç›®æ ‡;
                                delete strategySceneSettings.ä¼˜åŒ–ç›®æ ‡;
                            } else {
                                const strategyBidTargetLabel = BID_TARGET_OPTIONS.find(item => item.value === strategyBidTargetOptionValue)?.label || 'è·å–æˆäº¤é‡';
                                strategySceneSettings.å‡ºä»·ç›®æ ‡ = strategyBidTargetLabel;
                            }
                        }
                        const strategyKeywordMode = strategy.keywordMode || wizardState.draft.keywordMode || DEFAULTS.keywordMode;
                        const strategyUseWordPackage = strategy.useWordPackage !== false && wizardState.draft.useWordPackage !== false;
                        const strategyRecommendCount = Math.max(0, toNumber(strategy.recommendCount, toNumber(wizardState.draft.recommendCount, DEFAULTS.recommendCount)));
                        const strategyDefaultBid = toNumber(strategy.defaultBidPrice, toNumber(wizardState.draft.defaultBidPrice, 1));
                        const strategyManualKeywords = parseKeywords(strategy.manualKeywords || wizardState.draft.manualKeywords || '', {
                            bidPrice: strategyDefaultBid,
                            matchScope: DEFAULTS.matchScope,
                            onlineStatus: DEFAULTS.keywordOnlineStatus
                        });
                        const explicitPlanName = String(strategy.planName || '').trim();
                        const autoStrategyPlanName = getStrategyMainLabel(strategy);
                        const autoPlanName = wizardState.addedItems.length > 1
                            ? `${autoStrategyPlanName}_${String(itemIdx + 1).padStart(2, '0')}`
                            : autoStrategyPlanName;
                        const finalPlanName = ensureUniquePlanNameInRequest(
                            explicitPlanName
                            || autoPlanName
                            || `${prefix}_${String(strategyIdx + 1).padStart(2, '0')}`
                        );
                        const strategyMarketingGoal = normalizeGoalLabel(
                            resolveStrategyMarketingGoal(strategy, strategySceneSettings, strategySceneName)
                        );
                        const strategySubmitBidTargetV2 = resolveKeywordCustomBidTargetAlias(strategyBidTargetV2, strategyMarketingGoal);
                        if (strategyMarketingGoal) {
                            if (!strategyGoalSetByScene.has(strategySceneName)) {
                                strategyGoalSetByScene.set(strategySceneName, new Set());
                            }
                            strategyGoalSetByScene.get(strategySceneName).add(strategyMarketingGoal);
                        }
                        const plan = {
                            sceneName: strategySceneName,
                            planName: finalPlanName,
                            item,
                            bidMode: strategyBidMode,
                            keywords: strategyManualKeywords,
                            keywordDefaults: {
                                bidPrice: strategyDefaultBid,
                                matchScope: DEFAULTS.matchScope,
                                onlineStatus: DEFAULTS.keywordOnlineStatus
                            },
                            keywordSource: {
                                mode: strategyKeywordMode,
                                recommendCount: strategyRecommendCount,
                                useWordPackage: strategyUseWordPackage
                            }
                        };
                        if (strategyMarketingGoal) {
                            plan.marketingGoal = strategyMarketingGoal;
                        }
                        if (Object.keys(strategySceneSettings).length) {
                            plan.sceneSettings = mergeDeep({}, strategySceneSettings);
                        }
                        const strategyBudget = String(strategy.dayAverageBudget || '').trim();
                        const finalBudget = strategyBudget !== '' ? strategyBudget : dayAverageBudget;
                        if (finalBudget !== '') {
                            if (strategy.budgetType === 'day_budget') {
                                plan.budget = { dayBudget: toNumber(finalBudget, 0) };
                            } else {
                                plan.budget = { dayAverageBudget: toNumber(finalBudget, 0) };
                            }
                        }
                        const campaignOverride = {};
                        if (isKeywordScene) {
                            campaignOverride.bidTypeV2 = bidModeToBidType(strategyBidMode);
                            if (strategyBidMode === 'smart') {
                                if (strategySubmitBidTargetV2) {
                                    campaignOverride.bidTargetV2 = strategySubmitBidTargetV2;
                                    campaignOverride.optimizeTarget = strategySubmitBidTargetV2;
                                }
                                campaignOverride.setSingleCostV2 = !!strategy.setSingleCostV2;
                                if (strategy.setSingleCostV2 && strategy.singleCostV2 !== '') {
                                    campaignOverride.singleCostV2 = toNumber(strategy.singleCostV2, 0);
                                }
                            } else {
                                campaignOverride.setSingleCostV2 = false;
                            }
                        }
                        if (Object.keys(campaignOverride).length) {
                            plan.campaignOverride = campaignOverride;
                        }
                        plans.push(plan);
                    });
                });

                const commonKeywordMode = wizardState.draft.keywordMode || DEFAULTS.keywordMode;
                const commonUseWordPackage = wizardState.draft.useWordPackage !== false;
                const commonRecommendCount = Math.max(0, toNumber(wizardState.draft.recommendCount, DEFAULTS.recommendCount));
                const commonDefaultBid = toNumber(wizardState.draft.defaultBidPrice, 1);
                const commonBidMode = normalizeBidMode(
                    wizardState.draft.bidMode || enabledStrategies[0]?.bidMode || 'smart',
                    'smart'
                );
                const common = {
                    keywordDefaults: {
                        bidPrice: commonDefaultBid,
                        matchScope: DEFAULTS.matchScope,
                        onlineStatus: DEFAULTS.keywordOnlineStatus
                    },
                    useWordPackage: commonUseWordPackage,
                    keywordMode: commonKeywordMode,
                    recommendCount: commonRecommendCount
                };
                if (isSelectedKeywordScene) {
                    common.bidMode = commonBidMode;
                }
                if (wizardState.crowdList.length) {
                    common.adgroupOverride = {
                        rightList: wizardState.crowdList.map(item => deepClone(item))
                    };
                }

                const sceneBizCodeHint = resolveSceneBizCodeHint(selectedSceneName);
                const requestBizCode = sceneBizCodeHint || wizardState.draft.bizCode || DEFAULTS.bizCode;
                const requestPromotionSceneDefault = resolveSceneDefaultPromotionScene(selectedSceneName, wizardState.draft.promotionScene || DEFAULTS.promotionScene);
                const requestPromotionScene = requestBizCode === DEFAULTS.bizCode
                    ? requestPromotionSceneDefault
                    : (wizardState.draft.promotionScene || '');
                const selectedSceneGoalSet = strategyGoalSetByScene.get(selectedSceneName) || new Set();
                const sceneMarketingGoal = (() => {
                    if (!isSelectedKeywordScene) {
                        return normalizeGoalLabel(
                            selectedSceneSettings.è¥é”€ç›®æ ‡
                            || selectedSceneSettings.ä¼˜åŒ–ç›®æ ‡
                            || ''
                        );
                    }
                    if (selectedSceneGoalFromSettings) return selectedSceneGoalFromSettings;
                    if (selectedSceneGoalSet.size === 1) return Array.from(selectedSceneGoalSet)[0] || '';
                    if (selectedSceneGoalSet.size > 1) return Array.from(selectedSceneGoalSet)[0] || '';
                    return normalizeBidMode(commonBidMode, 'smart') === 'manual' ? 'è‡ªå®šä¹‰æ¨å¹¿' : 'è¶‹åŠ¿æ˜æ˜Ÿ';
                })();

                return {
                    bizCode: requestBizCode,
                    promotionScene: requestPromotionScene,
                    sceneName: selectedSceneName,
                    marketingGoal: sceneMarketingGoal || undefined,
                    sceneSettings: selectedSceneSettings,
                    fallbackPolicy: normalizeWizardFallbackPolicy(wizardState.draft.fallbackPolicy),
                    plans,
                    common
                };
            };

            const buildSceneRequestsFromWizard = (request = {}) => {
                const selectedSceneName = SCENE_OPTIONS.includes(String(request?.sceneName || '').trim())
                    ? String(request.sceneName).trim()
                    : 'å…³é”®è¯æ¨å¹¿';
                const planList = Array.isArray(request?.plans) ? request.plans : [];
                const requestSceneSettings = normalizeSceneSettingsObject(request?.sceneSettings || {});
                const normalizeSceneSettingsForGroup = (rawSettings = {}) => {
                    const normalized = normalizeSceneSettingsObject(rawSettings);
                    const ordered = {};
                    Object.keys(normalized).sort().forEach(key => {
                        const value = normalizeSceneSettingValue(normalized[key]);
                        if (!value) return;
                        ordered[key] = value;
                    });
                    return ordered;
                };
                const groupedPlans = new Map();
                planList.forEach(plan => {
                    const planSceneName = SCENE_OPTIONS.includes(String(plan?.sceneName || '').trim())
                        ? String(plan.sceneName).trim()
                        : selectedSceneName;
                    const nextPlan = mergeDeep({}, plan);
                    const planSceneSettings = normalizeSceneSettingsForGroup(
                        nextPlan.sceneSettings || requestSceneSettings
                    );
                    delete nextPlan.sceneName;
                    delete nextPlan.sceneSettings;
                    const groupKey = `${planSceneName}::${JSON.stringify(planSceneSettings)}`;
                    if (!groupedPlans.has(groupKey)) {
                        groupedPlans.set(groupKey, {
                            sceneName: planSceneName,
                            sceneSettings: planSceneSettings,
                            plans: []
                        });
                    }
                    groupedPlans.get(groupKey).plans.push(nextPlan);
                });
                if (!groupedPlans.size) {
                    const fallbackSceneSettings = normalizeSceneSettingsForGroup(requestSceneSettings);
                    groupedPlans.set(`${selectedSceneName}::${JSON.stringify(fallbackSceneSettings)}`, {
                        sceneName: selectedSceneName,
                        sceneSettings: fallbackSceneSettings,
                        plans: []
                    });
                }
                const fallbackPolicy = normalizeWizardFallbackPolicy(request?.fallbackPolicy || wizardState.draft?.fallbackPolicy);
                const sceneRequests = [];
                groupedPlans.forEach(group => {
                    const sceneName = SCENE_OPTIONS.includes(String(group?.sceneName || '').trim())
                        ? String(group.sceneName).trim()
                        : selectedSceneName;
                    const plans = Array.isArray(group?.plans) ? group.plans : [];
                    const sceneSettings = Object.keys(group?.sceneSettings || {}).length
                        ? mergeDeep({}, group.sceneSettings)
                        : normalizeSceneSettingsObject(buildSceneSettingsPayload(sceneName));
                    const sceneBizCodeHint = resolveSceneBizCodeHint(sceneName);
                    const bizCode = sceneBizCodeHint || request?.bizCode || wizardState.draft?.bizCode || DEFAULTS.bizCode;
                    const promotionSceneDefault = resolveSceneDefaultPromotionScene(
                        sceneName,
                        request?.promotionScene || wizardState.draft?.promotionScene || DEFAULTS.promotionScene
                    );
                    const promotionScene = bizCode === DEFAULTS.bizCode
                        ? promotionSceneDefault
                        : (request?.promotionScene || wizardState.draft?.promotionScene || '');
                    const sceneGoalFromSettings = normalizeGoalLabel(
                        sceneName === 'å…³é”®è¯æ¨å¹¿'
                            ? resolveKeywordGoalFromSceneSettings(sceneSettings)
                            : (sceneSettings.è¥é”€ç›®æ ‡ || sceneSettings.ä¼˜åŒ–ç›®æ ‡ || '')
                    );
                    const buildSceneCommon = () => {
                        const sceneCommon = mergeDeep({}, request?.common || {});
                        if (sceneName === 'å…³é”®è¯æ¨å¹¿') {
                            const keywordBidMode = normalizeBidMode(
                                sceneCommon.bidMode || request?.common?.bidMode || 'smart',
                                'smart'
                            );
                            sceneCommon.bidMode = keywordBidMode;
                        } else {
                            delete sceneCommon.bidMode;
                        }
                        return sceneCommon;
                    };
                    const fallbackGoal = sceneName === 'å…³é”®è¯æ¨å¹¿'
                        ? (normalizeBidMode(request?.common?.bidMode || 'smart', 'smart') === 'manual' ? 'è‡ªå®šä¹‰æ¨å¹¿' : 'è¶‹åŠ¿æ˜æ˜Ÿ')
                        : normalizeGoalLabel(request?.marketingGoal || '');
                    const isSiteScene = sceneName === 'è´§å“å…¨ç«™æ¨å¹¿';
                    const plansForSync = Array.isArray(plans) ? plans : [];
                    if (isSiteScene) {
                        const siteSceneGoal = normalizeGoalLabel(
                            sceneGoalFromSettings
                            || request?.marketingGoal
                            || fallbackGoal
                            || ''
                        );
                        sceneRequests.push({
                            bizCode,
                            promotionScene,
                            sceneName,
                            marketingGoal: siteSceneGoal || undefined,
                            sceneSettings,
                            fallbackPolicy,
                            plans: plansForSync,
                            common: buildSceneCommon()
                        });
                        return;
                    }
                    const plansForAsync = plansForSync;
                    plansForAsync.forEach(plan => {
                        const planGoal = normalizeGoalLabel(plan?.marketingGoal || '');
                        const sceneMarketingGoal = sceneGoalFromSettings || planGoal || fallbackGoal;
                        sceneRequests.push({
                            bizCode,
                            promotionScene,
                            sceneName,
                            marketingGoal: sceneMarketingGoal || undefined,
                            sceneSettings,
                            fallbackPolicy,
                            plans: [plan],
                            common: buildSceneCommon()
                        });
                    });
                });
                return sceneRequests;
            };

            const normalizePlanNameForCompare = (rawName = '') => {
                const text = String(rawName || '').replace(/\s+/g, ' ').trim();
                if (!text) return '';
                let normalized = text;
                try {
                    if (MagicReport && typeof MagicReport.sanitizeCampaignName === 'function') {
                        normalized = MagicReport.sanitizeCampaignName(text) || text;
                    }
                } catch { }
                return String(normalized || '').replace(/\s+/g, ' ').trim();
            };

            const extractExistingPlanNamesFromPage = () => {
                const names = [];
                const pushName = (rawName = '') => {
                    const name = normalizePlanNameForCompare(rawName);
                    if (!name) return;
                    if (/^(æœªçŸ¥è®¡åˆ’|-|â€”)$/.test(name)) return;
                    names.push(name);
                };

                document.querySelectorAll('a[href*="campaignId="], a[href*="campaign_id="], a[mx-href*="campaignId="], a[mx-href*="campaign_id="]')
                    .forEach(anchor => {
                        pushName(anchor?.getAttribute?.('title') || anchor?.textContent || '');
                    });

                document.querySelectorAll('input[type="checkbox"][value]').forEach(input => {
                    const id = String(input?.value || '').trim();
                    if (!/^\d{6,}$/.test(id)) return;
                    const row = input.closest('tr, [role="row"], li, [class*="row"], [class*="item"]');
                    if (!(row instanceof Element)) return;
                    const strictAnchor = row.querySelector('span + a[title]');
                    if (strictAnchor) {
                        pushName(strictAnchor.getAttribute('title') || strictAnchor.textContent || '');
                    }
                    row.querySelectorAll('a[title]').forEach(anchor => {
                        const prevText = (anchor.previousElementSibling?.textContent || '').replace(/\s+/g, '');
                        const parentText = (anchor.parentElement?.textContent || '').replace(/\s+/g, '');
                        if (!/^è®¡åˆ’[:ï¼š]?$/.test(prevText) && !/è®¡åˆ’[:ï¼š]/.test(parentText)) return;
                        pushName(anchor.getAttribute('title') || anchor.textContent || '');
                    });
                });

                return uniqueBy(names, item => item);
            };

            const validatePlanNameUniqueness = (request = {}) => {
                const planEntries = (Array.isArray(request?.plans) ? request.plans : [])
                    .map((plan, idx) => {
                        const rawName = String(plan?.planName || '').trim();
                        const normalized = normalizePlanNameForCompare(rawName);
                        return {
                            index: idx + 1,
                            rawName: rawName || `plans[${idx + 1}]`,
                            normalized
                        };
                    })
                    .filter(item => item.normalized);

                const firstSeen = new Map();
                const duplicateInRequest = [];
                planEntries.forEach(item => {
                    if (!firstSeen.has(item.normalized)) {
                        firstSeen.set(item.normalized, item.rawName);
                        return;
                    }
                    duplicateInRequest.push(firstSeen.get(item.normalized));
                    duplicateInRequest.push(item.rawName);
                });

                const existingNames = extractExistingPlanNamesFromPage();
                const existingSet = new Set(existingNames.map(name => normalizePlanNameForCompare(name)).filter(Boolean));
                const duplicateWithExisting = planEntries
                    .filter(item => existingSet.has(item.normalized))
                    .map(item => item.rawName);

                return {
                    ok: duplicateInRequest.length === 0 && duplicateWithExisting.length === 0,
                    duplicateInRequest: uniqueBy(duplicateInRequest, item => item),
                    duplicateWithExisting: uniqueBy(duplicateWithExisting, item => item),
                    existingPlanNameCount: existingNames.length
                };
            };

            const summarizePlanForPreview = (plan = null) => {
                if (!plan || !isPlainObject(plan)) return null;
                const item = isPlainObject(plan.item) ? plan.item : {};
                const budget = isPlainObject(plan.budget) ? plan.budget : null;
                const campaignOverride = isPlainObject(plan.campaignOverride) ? plan.campaignOverride : null;
                return {
                    sceneName: String(plan.sceneName || '').trim(),
                    planName: plan.planName || '',
                    marketingGoal: normalizeGoalLabel(plan.marketingGoal || ''),
                    bidMode: normalizeBidMode(plan.bidMode || '', 'smart'),
                    item: {
                        materialId: item.materialId || item.itemId || '',
                        materialName: item.materialName || ''
                    },
                    keywordCount: Array.isArray(plan.keywords) ? plan.keywords.length : 0,
                    keywordSource: isPlainObject(plan.keywordSource) ? plan.keywordSource : {},
                    budget,
                    campaignOverride
                };
            };

            const renderPreview = (request) => {
                const scenePlanGroups = Array.isArray(request?.plans)
                    ? uniqueBy(
                        request.plans.map(plan => String(plan?.sceneName || request?.sceneName || '').trim()).filter(Boolean),
                        item => item
                    ).map(sceneName => ({
                        sceneName,
                        count: request.plans.filter(plan => String(plan?.sceneName || request?.sceneName || '').trim() === sceneName).length
                    }))
                    : [];
                const preview = {
                    bizCode: request.bizCode,
                    promotionScene: request.promotionScene,
                    sceneName: request.sceneName || wizardState.draft?.sceneName || '',
                    scenePlanGroups,
                    sceneSettingCount: isPlainObject(request.sceneSettings) ? Object.keys(request.sceneSettings).filter(key => String(request.sceneSettings[key] || '').trim() !== '').length : 0,
                    planCount: request.plans.length,
                    strategyCount: (wizardState.strategyList || []).filter(item => item.enabled).length,
                    bidMode: request.common?.bidMode || 'smart',
                    fallbackPolicy: request.fallbackPolicy || 'confirm',
                    keywordMode: request.common?.keywordMode,
                    recommendCount: request.common?.recommendCount,
                    crowdCount: Array.isArray(request.common?.adgroupOverride?.rightList) ? request.common.adgroupOverride.rightList.length : 0,
                    firstPlan: summarizePlanForPreview(request.plans[0] || null)
                };
                wizardState.els.preview.textContent = JSON.stringify(preview, null, 2);
            };

            const buildKeywordConsoleRows = (words = []) => (
                (Array.isArray(words) ? words : [])
                    .map(item => {
                        const word = String(item?.word || item?.keyword || '').trim();
                        if (!word) return null;
                        const metricEntry = getKeywordMetricByWord(word) || {};
                        return {
                            keyword: word,
                            bidPrice: toNumber(item?.bidPrice, 1),
                            matchScope: parseMatchScope(item?.matchScope, DEFAULTS.matchScope) === 1 ? 'ç²¾å‡†' : 'å¹¿æ³›',
                            onlineStatus: toNumber(item?.onlineStatus, DEFAULTS.keywordOnlineStatus),
                            searchIndex: String(metricEntry.searchIndexText || '-'),
                            marketClickRate: String(metricEntry.marketClickRateText || '-'),
                            marketClickConversionRate: String(metricEntry.marketClickConversionRateText || '-'),
                            marketAverageBid: String(metricEntry.marketAverageBidText || '-'),
                            relevance: String(metricEntry.relevanceText || '-')
                        };
                    })
                    .filter(Boolean)
            );

            const logRecommendedKeywordConsoleReport = ({
                triggerSource = 'manual',
                targetItem = {},
                runtime = {},
                keywordDefaults = {},
                recommendCount = 0,
                recommendedWords = [],
                normalizedRecommend = [],
                manualWords = [],
                mergedWords = []
            } = {}) => {
                if (typeof console === 'undefined') return;
                const sourceTag = String(triggerSource || 'manual').trim() || 'manual';
                const targetItemSnapshot = {
                    materialId: toIdValue(targetItem?.materialId || targetItem?.itemId),
                    materialName: String(targetItem?.materialName || '').trim()
                };
                const runtimeSnapshot = {
                    bizCode: String(runtime?.bizCode || '').trim(),
                    promotionScene: String(runtime?.promotionScene || '').trim(),
                    itemSelectedMode: String(runtime?.itemSelectedMode || '').trim(),
                    bidTypeV2: String(runtime?.bidTypeV2 || '').trim(),
                    bidTargetV2: String(runtime?.bidTargetV2 || '').trim()
                };
                const keywordDefaultsSnapshot = {
                    bidPrice: toNumber(keywordDefaults?.bidPrice, 1),
                    matchScope: parseMatchScope(keywordDefaults?.matchScope, DEFAULTS.matchScope),
                    onlineStatus: toNumber(keywordDefaults?.onlineStatus, DEFAULTS.keywordOnlineStatus)
                };
                const summary = {
                    source: sourceTag,
                    recommendCount,
                    rawRecommendCount: Array.isArray(recommendedWords) ? recommendedWords.length : 0,
                    normalizedRecommendCount: Array.isArray(normalizedRecommend) ? normalizedRecommend.length : 0,
                    manualWordCount: Array.isArray(manualWords) ? manualWords.length : 0,
                    mergedWordCount: Array.isArray(mergedWords) ? mergedWords.length : 0
                };
                const reportTitle = `${TAG} æ¨èå…³é”®è¯åŠ è½½ç»“æœ [${sourceTag}] item=${targetItemSnapshot.materialId || '-'}`;

                if (typeof console.groupCollapsed === 'function') {
                    console.groupCollapsed(reportTitle);
                } else if (typeof console.log === 'function') {
                    console.log(reportTitle);
                }
                try {
                    if (typeof console.log === 'function') {
                        console.log('summary', summary);
                        console.log('targetItem', targetItemSnapshot);
                        console.log('runtime', runtimeSnapshot);
                        console.log('keywordDefaults', keywordDefaultsSnapshot);
                        console.log('recommendedWords(raw)', recommendedWords);
                        console.log('normalizedRecommend', normalizedRecommend);
                        console.log('manualWords(beforeMerge)', manualWords);
                        console.log('mergedWords(afterMerge)', mergedWords);
                    }
                    const mergedRows = buildKeywordConsoleRows(mergedWords);
                    if (mergedRows.length && typeof console.table === 'function') {
                        console.table(mergedRows);
                    } else if (typeof console.log === 'function') {
                        console.log('mergedWords(rows)', mergedRows);
                    }
                } finally {
                    if (typeof console.groupEnd === 'function') {
                        console.groupEnd();
                    }
                }
            };

            const loadRecommendedKeywords = async (options = {}) => {
                const triggerSource = String(options?.triggerSource || 'manual').trim() || 'manual';
                if (!wizardState.addedItems.length) {
                    appendWizardLog('è¯·å…ˆæ·»åŠ å•†å“ï¼Œå†åŠ è½½æ¨èå…³é”®è¯', 'error');
                    return false;
                }
                const editingStrategy = getStrategyById(wizardState.editingStrategyId) || wizardState.strategyList.find(item => item.enabled) || wizardState.strategyList[0];
                if (!editingStrategy) {
                    appendWizardLog('è¯·å…ˆé€‰æ‹©ä¸€ä¸ªç­–ç•¥å¹¶ç‚¹å‡»â€œç¼–è¾‘è®¡åˆ’â€', 'error');
                    return false;
                }
                const targetItem = wizardState.addedItems[0];
                const recommendCount = Math.max(1, toNumber(wizardState.els.recommendCountInput.value.trim(), DEFAULTS.recommendCount));
                const defaultBid = toNumber(wizardState.els.bidInput.value.trim(), 1);
                const keywordDefaults = {
                    bidPrice: defaultBid,
                    matchScope: DEFAULTS.matchScope,
                    onlineStatus: DEFAULTS.keywordOnlineStatus
                };
                appendWizardLog(`å¼€å§‹åŠ è½½æ¨èå…³é”®è¯ï¼š${targetItem.materialName || targetItem.materialId}`);
                try {
                    const runtime = await getRuntimeDefaults(false);
                    runtime.bizCode = wizardState.draft?.bizCode || runtime.bizCode || DEFAULTS.bizCode;
                    runtime.promotionScene = wizardState.draft?.promotionScene || runtime.promotionScene || DEFAULTS.promotionScene;
                    const recommendedWords = await fetchRecommendWordList({
                        bizCode: runtime.bizCode,
                        materialId: targetItem.materialId || targetItem.itemId,
                        defaults: runtime,
                        source: 'auto'
                    });
                    mergeKeywordMetricMap(recommendedWords);
                    const normalizedRecommend = recommendedWords
                        .map(word => applyKeywordDefaults(word, keywordDefaults))
                        .filter(word => word.word)
                        .slice(0, recommendCount);
                    if (!normalizedRecommend.length) {
                        appendWizardLog('æœªè·å–åˆ°æ¨èå…³é”®è¯ï¼Œè¯·ç¨åé‡è¯•', 'error');
                        return false;
                    }

                    const manualWords = parseKeywords(wizardState.els.manualInput.value || '', keywordDefaults)
                        .map(word => applyKeywordDefaults(word, keywordDefaults));
                    const dedupMap = new Map();
                    manualWords.forEach(word => dedupMap.set(word.word, word));
                    normalizedRecommend.forEach(word => {
                        if (!dedupMap.has(word.word)) dedupMap.set(word.word, word);
                    });
                    const mergedWords = Array.from(dedupMap.values()).slice(0, 200);
                    wizardState.els.manualInput.value = mergedWords.map(formatKeywordLine).join('\n');
                    pullDetailFormToStrategy(editingStrategy);
                    syncDraftFromUI();
                    renderStrategyList();
                    renderSceneDynamicConfig();
                    if (typeof wizardState.buildRequest === 'function') {
                        wizardState.renderPreview(wizardState.buildRequest());
                    }
                    logRecommendedKeywordConsoleReport({
                        triggerSource,
                        targetItem,
                        runtime,
                        keywordDefaults,
                        recommendCount,
                        recommendedWords,
                        normalizedRecommend,
                        manualWords,
                        mergedWords
                    });
                    appendWizardLog(`æ¨èå…³é”®è¯å·²åŠ è½½ ${normalizedRecommend.length} æ¡ï¼ˆåˆå¹¶å ${mergedWords.length} æ¡ï¼‰`, 'success');
                    return true;
                } catch (err) {
                    appendWizardLog(`åŠ è½½æ¨èå…³é”®è¯å¤±è´¥ï¼š${err?.message || err}`, 'error');
                    return false;
                }
            };

            const maybeAutoLoadManualKeywords = (strategy = null, options = {}) => {
                const targetStrategy = strategy || getStrategyById(wizardState.editingStrategyId);
                if (!isPlainObject(targetStrategy)) return;
                if (!wizardState.detailVisible) return;
                if (String(targetStrategy.sceneName || '').trim() !== 'å…³é”®è¯æ¨å¹¿') return;
                if (!wizardState.addedItems.length) return;
                const manualText = String(wizardState.els.manualInput?.value || targetStrategy.manualKeywords || '').trim();
                if (manualText) return;
                const materialId = String(wizardState.addedItems[0]?.materialId || wizardState.addedItems[0]?.itemId || '').trim();
                const strategyId = String(targetStrategy.id || '').trim();
                if (!materialId || !strategyId) return;
                wizardState.autoKeywordLoadMap = isPlainObject(wizardState.autoKeywordLoadMap) ? wizardState.autoKeywordLoadMap : {};
                const autoLoadKey = `${strategyId}::${materialId}`;
                const currentStatus = String(wizardState.autoKeywordLoadMap[autoLoadKey] || '').trim();
                if (currentStatus === 'pending' || currentStatus === 'done') return;
                wizardState.autoKeywordLoadMap[autoLoadKey] = 'pending';
                appendWizardLog('æ£€æµ‹åˆ°æ‰‹åŠ¨å…³é”®è¯ä¸ºç©ºï¼Œè‡ªåŠ¨åŠ è½½æ¨èå…³é”®è¯...');
                const delayMs = Math.max(120, toNumber(options.delayMs, 240));
                window.setTimeout(async () => {
                    const latestStrategy = getStrategyById(strategyId);
                    if (!latestStrategy || wizardState.editingStrategyId !== strategyId || !wizardState.detailVisible) {
                        delete wizardState.autoKeywordLoadMap[autoLoadKey];
                        return;
                    }
                    const loadOk = await loadRecommendedKeywords({ triggerSource: 'auto_fill' });
                    if (!loadOk) {
                        delete wizardState.autoKeywordLoadMap[autoLoadKey];
                        return;
                    }
                    wizardState.autoKeywordLoadMap[autoLoadKey] = 'done';
                }, delayMs);
            };

            const loadRecommendedCrowds = async () => {
                appendWizardLog('å¼€å§‹åŠ è½½æ¨èäººç¾¤...');
                try {
                    const runtime = await getRuntimeDefaults(false);
                    runtime.bizCode = wizardState.draft?.bizCode || runtime.bizCode || DEFAULTS.bizCode;
                    runtime.promotionScene = wizardState.draft?.promotionScene || runtime.promotionScene || DEFAULTS.promotionScene;
                    const materialIdList = wizardState.addedItems
                        .map(item => toIdValue(item.materialId || item.itemId))
                        .filter(Boolean)
                        .slice(0, 10);
                    const crowdList = await fetchRecommendCrowdList({
                        bizCode: runtime.bizCode,
                        defaults: runtime,
                        labelIdList: DEFAULTS.recommendCrowdLabelIds,
                        materialIdList
                    });
                    const fallbackRightList = Array.isArray(runtime?.solutionTemplate?.adgroupList?.[0]?.rightList)
                        ? runtime.solutionTemplate.adgroupList[0].rightList.map(item => deepClone(item))
                        : [];
                    const mergedCrowdList = crowdList.length ? crowdList : fallbackRightList;
                    if (!mergedCrowdList.length) {
                        appendWizardLog('æœªè·å–åˆ°æ¨èäººç¾¤ï¼Œå¯ç›´æ¥åˆ›å»ºï¼ˆé»˜è®¤ä¸é™äººç¾¤ï¼‰', 'error');
                        return;
                    }
                    wizardState.crowdList = uniqueBy(
                        mergedCrowdList,
                        item => item?.mx_crowdId || `${item?.crowd?.label?.labelId || ''}_${item?.crowd?.label?.optionList?.[0]?.optionValue || ''}`
                    ).slice(0, 50);
                    syncDraftFromUI();
                    renderCrowdList();
                    if (typeof wizardState.buildRequest === 'function') {
                        wizardState.renderPreview(wizardState.buildRequest());
                    }
                    appendWizardLog(`æ¨èäººç¾¤å·²åŠ è½½ ${wizardState.crowdList.length} æ¡`, 'success');
                } catch (err) {
                    appendWizardLog(`åŠ è½½æ¨èäººç¾¤å¤±è´¥ï¼š${err?.message || err}`, 'error');
                }
            };

            const resolveSceneSyncItemId = () => {
                const fromWizard = wizardState.addedItems
                    .map(item => String(item?.materialId || item?.itemId || '').trim())
                    .find(Boolean);
                if (fromWizard) return fromWizard;
                const pageItemIds = extractPageAddedItemIds();
                if (Array.isArray(pageItemIds) && pageItemIds.length) {
                    return String(pageItemIds[0] || '').trim();
                }
                return SCENE_SYNC_DEFAULT_ITEM_ID;
            };

            const scheduleSceneCreateContractSync = (sceneName, options = {}) => {
                const targetScene = String(sceneName || '').trim();
                if (!SCENE_OPTIONS.includes(targetScene)) return;
                const forceRefresh = options.forceRefresh === true;
                if (!forceRefresh) {
                    const cached = getCachedSceneCreateContract(targetScene, '');
                    if (cached) return;
                }
                if (wizardState.sceneSyncTimer) {
                    clearTimeout(wizardState.sceneSyncTimer);
                    wizardState.sceneSyncTimer = 0;
                }
                const delayMs = Math.max(180, toNumber(options.delayMs, 420));
                const token = `${Date.now()}_${Math.random().toString(36).slice(2, 8)}`;
                wizardState.sceneSyncPendingToken = token;
                wizardState.sceneSyncTimer = window.setTimeout(async () => {
                    if (wizardState.sceneSyncPendingToken !== token) return;
                    if (wizardState.sceneSyncInFlight) return;
                    wizardState.sceneSyncInFlight = true;
                    const itemId = resolveSceneSyncItemId();
                    appendWizardLog(`åœºæ™¯æ¥å£åŒæ­¥ï¼š${targetScene}ï¼ˆitemId=${itemId}ï¼‰`);
                    try {
                        const capture = await captureSceneCreateInterfaces(targetScene, {
                            itemId,
                            passMode: 'interface',
                            captureInterfaces: true,
                            fallbackPolicy: 'none',
                            batchRetry: 0,
                            maxRetries: 1,
                            timeoutMs: Math.max(18000, toNumber(options.timeoutMs, 35000)),
                            requestTimeout: Math.max(10000, toNumber(options.requestTimeout, 22000)),
                            dayAverageBudget: Math.max(50, toNumber(options.dayAverageBudget, 100))
                        });
                        const row = isPlainObject(capture?.row) ? capture.row : {};
                        const createInterfaces = Array.isArray(row?.capture?.createInterfaces)
                            ? row.capture.createInterfaces
                            : [];
                        if (createInterfaces.length) {
                            const goalLabel = normalizeGoalLabel(row?.requestPreview?.marketingGoal || '');
                            const rememberedContract = rememberSceneCreateInterfaces(
                                targetScene,
                                goalLabel,
                                createInterfaces,
                                { source: 'scene_switch_sync' }
                            );
                            appendWizardLog(
                                `åœºæ™¯æ¥å£å·²åŒæ­¥ï¼š${targetScene} æ¥å£=${rememberedContract?.endpoint || row.submitEndpoint || '-'} è¯·æ±‚å­—æ®µæ•°=${toNumber(rememberedContract?.requestKeys?.length, 0)}`,
                                'success'
                            );
                        } else {
                            appendWizardLog(`åœºæ™¯æ¥å£åŒæ­¥æœªæ•è·åˆ°åˆ›å»ºè¯·æ±‚ï¼š${targetScene}${row?.error ? `ï¼ˆ${row.error}ï¼‰` : ''}`, 'error');
                        }
                    } catch (err) {
                        appendWizardLog(`åœºæ™¯æ¥å£åŒæ­¥å¤±è´¥ï¼š${targetScene} -> ${err?.message || err}`, 'error');
                    } finally {
                        wizardState.sceneSyncInFlight = false;
                    }
                }, delayMs);
            };

            const switchSceneFromEditor = (sceneName) => {
                const nextScene = String(sceneName || '').trim();
                if (!SCENE_OPTIONS.includes(nextScene)) return;
                wizardState.draft = wizardState.draft || wizardDefaultDraft();
                const prevScene = wizardState.draft.sceneName;
                const prevPrefix = String(wizardState.draft.planNamePrefix || '').trim();
                const editingStrategy = getStrategyById(wizardState.editingStrategyId)
                    || wizardState.strategyList[0]
                    || null;
                if (!wizardState.editingStrategyId && editingStrategy?.id) {
                    wizardState.editingStrategyId = editingStrategy.id;
                }
                const applyToAllStrategies = !editingStrategy;
                wizardState.draft.sceneName = nextScene;
                const sceneBizCodeHint = resolveSceneBizCodeHint(nextScene);
                if (sceneBizCodeHint) wizardState.draft.bizCode = sceneBizCodeHint;
                if (sceneBizCodeHint && sceneBizCodeHint !== DEFAULTS.bizCode) {
                    wizardState.draft.promotionScene = '';
                } else if (!wizardState.draft.promotionScene) {
                    wizardState.draft.promotionScene = DEFAULTS.promotionScene;
                }
                if (wizardState.els.sceneSelect && wizardState.els.sceneSelect.value !== nextScene) {
                    wizardState.els.sceneSelect.value = nextScene;
                }
                const nextPrefix = buildDefaultPlanPrefixByScene(nextScene);
                const prefixInputValue = String(wizardState.els.prefixInput?.value || '').trim();
                const shouldSyncDefaultPrefix = !prefixInputValue
                    || isAutoGeneratedPlanPrefix(prefixInputValue)
                    || (prevPrefix && prefixInputValue === prevPrefix);
                if (applyToAllStrategies || shouldSyncDefaultPrefix) {
                    wizardState.draft.planNamePrefix = nextPrefix;
                    if (wizardState.els.prefixInput) wizardState.els.prefixInput.value = nextPrefix;
                }
                const shouldSyncAutoPlanName = (rawPlanName = '') => {
                    const value = String(rawPlanName || '').trim();
                    if (!value) return true;
                    if (isAutoGeneratedPlanPrefix(value)) return true;
                    if (prevPrefix && value === prevPrefix) return true;
                    return SCENE_OPTIONS.some(scene => {
                        const escaped = escapeRegExp(scene);
                        return new RegExp(`^${escaped}_\\d{8,14}(?:_|$)`).test(value);
                    });
                };
                const targetStrategies = applyToAllStrategies
                    ? (wizardState.strategyList || [])
                    : [editingStrategy];
                targetStrategies.forEach(strategy => {
                    if (!isPlainObject(strategy)) return;
                    strategy.sceneName = nextScene;
                    strategy.sceneSettings = {};
                    strategy.sceneSettingValues = {};
                    strategy.sceneSettingTouched = {};
                    if (shouldSyncAutoPlanName(strategy.planName || '')) {
                        strategy.planName = '';
                        strategy.autoPlanPrefix = nextPrefix;
                    }
                });
                renderSceneDynamicConfig();
                const sceneSettingsForStrategy = nextScene === 'å…³é”®è¯æ¨å¹¿'
                    ? {}
                    : buildSceneSettingsPayload(nextScene);
                targetStrategies.forEach(strategy => {
                    if (!isPlainObject(strategy)) return;
                    strategy.marketingGoal = resolveStrategyMarketingGoal(strategy, sceneSettingsForStrategy, nextScene);
                });
                if (editingStrategy && wizardState.detailVisible) {
                    applyStrategyToDetailForm(editingStrategy);
                }
                renderStaticOptionLines();
                syncDraftFromUI();
                renderStrategyList();
                if (typeof wizardState.buildRequest === 'function') {
                    wizardState.renderPreview(wizardState.buildRequest());
                }
                if (prevScene !== nextScene) {
                    const sceneHintText = sceneBizCodeHint ? `ï¼ˆ${sceneBizCodeHint}ï¼‰` : '';
                    const scopeText = applyToAllStrategies ? 'å…¨éƒ¨è®¡åˆ’' : (editingStrategy?.name || 'å½“å‰è®¡åˆ’');
                    appendWizardLog(`åœºæ™¯é…ç½®å·²åˆ‡æ¢ï¼š${nextScene}${sceneHintText}ï¼ˆ${scopeText}ï¼‰${WIZARD_FORCE_API_ONLY_SCENE_CONFIG ? ' [APIæ¨¡å¼]' : ''}`, 'success');
                }
                if (!WIZARD_FORCE_API_ONLY_SCENE_CONFIG) {
                    refreshSceneProfileFromSpec(nextScene, {
                        scanMode: 'full_top_down',
                        unlockPolicy: 'safe_only',
                        goalScan: true,
                        silent: true
                    });
                    scheduleSceneCreateContractSync(nextScene, {
                        forceRefresh: prevScene !== nextScene
                    });
                }
            };

            wizardState.els.closeBtn.onclick = () => {
                if (wizardState.repairRunning) {
                    wizardState.repairStopRequested = true;
                    appendWizardLog('å¼¹çª—å·²å…³é—­ï¼Œåœæ­¢ä¿¡å·å·²å‘é€ï¼ˆå½“å‰ case ç»“æŸååœæ­¢ï¼‰', 'error');
                }
                syncDraftFromUI();
                setDetailVisible(false);
                overlay.classList.remove('open');
                wizardState.visible = false;
            };
            overlay.addEventListener('click', (e) => {
                if (e.target === overlay) wizardState.els.closeBtn.click();
            });
            wizardState.els.searchBtn.onclick = () => loadCandidates(wizardState.els.searchInput.value.trim(), wizardState.candidateSource);
            wizardState.els.hotBtn.onclick = () => {
                wizardState.els.searchInput.value = '';
                loadCandidates('', 'recommend');
            };
            wizardState.els.allBtn.onclick = () => {
                wizardState.els.searchInput.value = '';
                loadCandidates('', 'all');
            };
            wizardState.els.searchInput.addEventListener('keydown', (e) => {
                if (e.key === 'Enter') {
                    e.preventDefault();
                    wizardState.els.searchBtn.click();
                }
            });
            wizardState.els.toggleCandidateBtn.onclick = () => {
                const nextExpanded = wizardState.itemSplitExpanded !== true;
                setItemSplitExpanded(nextExpanded);
                if (nextExpanded) {
                    if (!wizardState.candidates.length) {
                        loadCandidates('', wizardState.candidateSource || 'all');
                    }
                    if (wizardState.els.searchInput instanceof HTMLInputElement) {
                        wizardState.els.searchInput.focus();
                    }
                }
                syncDraftFromUI();
            };
            wizardState.els.toggleCandidateListBtn.onclick = () => {
                setCandidateListExpanded(wizardState.candidateListExpanded !== true);
                syncDraftFromUI();
            };
            wizardState.els.addAllBtn.onclick = () => {
                if (!wizardState.candidates.length) return;
                const room = Math.max(0, WIZARD_MAX_ITEMS - wizardState.addedItems.length);
                if (!room) {
                    appendWizardLog(`å·²è¾¾åˆ°ä¸Šé™ ${WIZARD_MAX_ITEMS} ä¸ªå•†å“`, 'error');
                    return;
                }
                const addedSet = new Set(wizardState.addedItems.map(item => String(item.materialId)));
                const pick = wizardState.candidates.filter(item => !addedSet.has(String(item.materialId))).slice(0, room);
                wizardState.addedItems = wizardState.addedItems.concat(pick);
                syncDraftFromUI();
                renderAddedList();
                renderCandidateList();
                appendWizardLog(`å·²æ‰¹é‡æ·»åŠ  ${pick.length} ä¸ªå•†å“`, 'success');
            };
            wizardState.els.clearAddedBtn.onclick = () => {
                wizardState.addedItems = [];
                syncDraftFromUI();
                renderAddedList();
                renderCandidateList();
            };
            wizardState.els.loadRecommendBtn.onclick = () => {
                loadRecommendedKeywords({ triggerSource: 'button_click' });
            };
            wizardState.els.loadCrowdBtn.onclick = () => {
                loadRecommendedCrowds();
            };
            wizardState.els.sceneSelect.onchange = () => {
                switchSceneFromEditor(wizardState.els.sceneSelect.value);
            };
            [wizardState.els.sceneSelect, wizardState.els.bidModeSelect, wizardState.els.bidTargetSelect, wizardState.els.budgetTypeSelect, wizardState.els.modeSelect]
                .forEach(select => {
                    if (!(select instanceof HTMLSelectElement)) return;
                    select.addEventListener('change', () => {
                        renderSelectOptionLine(select);
                    });
                });
            wizardState.els.clearCrowdBtn.onclick = () => {
                wizardState.crowdList = [];
                syncDraftFromUI();
                renderCrowdList();
                if (typeof wizardState.buildRequest === 'function') {
                    wizardState.renderPreview(wizardState.buildRequest());
                }
                appendWizardLog('å·²æ¸…ç©ºäººç¾¤è®¾ç½®');
            };
            (Array.isArray(wizardState.els.toggleDebugBtns) ? wizardState.els.toggleDebugBtns : [])
                .forEach(btn => {
                    if (!(btn instanceof HTMLButtonElement)) return;
                    btn.onclick = () => {
                        setDebugVisible(!wizardState.debugVisible);
                        syncDraftFromUI();
                        renderSceneDynamicConfig();
                        if (typeof wizardState.buildRequest === 'function') {
                            wizardState.renderPreview(wizardState.buildRequest());
                        }
                    };
                });

            const closeDetailDialog = () => {
                const editingStrategy = getStrategyById(wizardState.editingStrategyId);
                if (editingStrategy) pullDetailFormToStrategy(editingStrategy);
                setDetailVisible(false);
                syncDraftFromUI();
                renderStrategyList();
                if (typeof wizardState.buildRequest === 'function') {
                    wizardState.renderPreview(wizardState.buildRequest());
                }
            };
            wizardState.els.backSimpleBtn.onclick = closeDetailDialog;
            if (wizardState.els.detailCloseBtn) {
                wizardState.els.detailCloseBtn.onclick = closeDetailDialog;
            }
            if (wizardState.els.detailBackdrop) {
                wizardState.els.detailBackdrop.onclick = closeDetailDialog;
            }

            const handlePreview = () => {
                try {
                    const req = buildRequestFromWizard();
                    renderPreview(req);
                    appendWizardLog(`é¢„è§ˆå·²ç”Ÿæˆï¼š${req.plans.length} ä¸ªè®¡åˆ’`, 'success');
                } catch (err) {
                    appendWizardLog(`é¢„è§ˆå¤±è´¥ï¼š${err?.message || err}`, 'error');
                }
            };
            wizardState.els.previewBtn.onclick = handlePreview;
            wizardState.els.previewQuickBtn.onclick = handleGenerateOtherStrategies;

            const handleRun = async () => {
                const req = buildRequestFromWizard();
                if (!req.plans.length) {
                    appendWizardLog('è¯·å…ˆæ·»åŠ å•†å“å¹¶å‹¾é€‰ç­–ç•¥åå†åˆ›å»º', 'error');
                    return;
                }
                const planNameCheck = validatePlanNameUniqueness(req);
                if (!planNameCheck.ok) {
                    if (planNameCheck.duplicateInRequest.length) {
                        appendWizardLog(
                            `è®¡åˆ’åæ ¡éªŒå¤±è´¥ï¼šæœ¬æ¬¡æ–°å»ºè®¡åˆ’å†…å­˜åœ¨é‡å¤ -> ${planNameCheck.duplicateInRequest.slice(0, 8).join('ã€')}`,
                            'error'
                        );
                    }
                    if (planNameCheck.duplicateWithExisting.length) {
                        appendWizardLog(
                            `è®¡åˆ’åæ ¡éªŒå¤±è´¥ï¼šä¸å½“å‰å·²æœ‰è®¡åˆ’é‡å -> ${planNameCheck.duplicateWithExisting.slice(0, 8).join('ã€')}`,
                            'error'
                        );
                    }
                    appendWizardLog('è¯·ä¿®æ”¹è®¡åˆ’ååå†æäº¤ï¼Œå½“å‰å·²æ‹¦æˆªæäº¤', 'error');
                    if (wizardState.els.preview) {
                        wizardState.els.preview.textContent = JSON.stringify({
                            sceneName: req.sceneName,
                            blocked: true,
                            reason: 'duplicate_plan_name',
                            duplicateInRequest: planNameCheck.duplicateInRequest,
                            duplicateWithExisting: planNameCheck.duplicateWithExisting,
                            existingPlanNameCount: planNameCheck.existingPlanNameCount
                        }, null, 2);
                    }
                    return;
                }
                const sceneRequests = buildSceneRequestsFromWizard(req)
                    .filter(sceneReq => Array.isArray(sceneReq?.plans) && sceneReq.plans.length);
                if (!sceneRequests.length) {
                    appendWizardLog('æœªè¯†åˆ«åˆ°å¯æäº¤çš„åœºæ™¯è®¡åˆ’ï¼Œè¯·æ£€æŸ¥ç­–ç•¥åœºæ™¯è®¾ç½®', 'error');
                    return;
                }
                const runCount = req.plans.length || 0;
                renderPreview(req);
                const sceneSummaryText = sceneRequests.map(item => `${item.sceneName}Ã—${item.plans.length}`).join('ã€');
                appendWizardLog(`å¼€å§‹æ‰¹é‡åˆ›å»º ${runCount} ä¸ªè®¡åˆ’ï¼ˆ${sceneSummaryText}ï¼‰...`);
                wizardState.els.runBtn.disabled = true;
                wizardState.els.runQuickBtn.disabled = true;
                const onRunProgress = ({ event, ...payload }) => {
                    const sceneTag = payload.sceneName ? `ã€${payload.sceneName}ã€‘` : '';
                    const fallbackPolicyText = ({
                        auto: 'è‡ªåŠ¨',
                        confirm: 'ç¡®è®¤',
                        none: 'ä¸é™çº§'
                    })[String(payload.policy || '').trim()] || String(payload.policy || '-');
                    if (event === 'scene_runtime_sync_start') {
                        appendWizardLog(`${sceneTag}åœºæ™¯è¿è¡Œæ—¶åŒæ­¥ï¼š${payload.currentBizCode || '-'} -> ${payload.expectedBizCode || '-'}ï¼ˆ${payload.sceneName || 'æœªå‘½ååœºæ™¯'}ï¼‰`);
                    } else if (event === 'scene_runtime_synced') {
                        if (payload.matched === false) {
                            appendWizardLog(`${sceneTag}åœºæ™¯è¿è¡Œæ—¶åŒæ­¥ç»“æœä¸åŒ¹é…ï¼šå½“å‰ ${payload.currentBizCode || '-'}ï¼ŒæœŸæœ› ${payload.expectedBizCode || '-'}ï¼ˆ${payload.sceneName || 'æœªå‘½ååœºæ™¯'}ï¼‰`, 'error');
                        } else {
                            appendWizardLog(`${sceneTag}åœºæ™¯è¿è¡Œæ—¶å·²åŒæ­¥ï¼š${payload.currentBizCode || '-'}ï¼ˆ${payload.sceneName || 'æœªå‘½ååœºæ™¯'}ï¼‰`, 'success');
                        }
                    } else if (event === 'scene_runtime_sync_failed') {
                        appendWizardLog(`${sceneTag}åœºæ™¯è¿è¡Œæ—¶åŒæ­¥å¤±è´¥ï¼š${payload.error || 'æœªçŸ¥é”™è¯¯'}`, 'error');
                    } else if (event === 'scene_runtime_sync_abort') {
                        if (payload.error) {
                            appendWizardLog(`${sceneTag}åœºæ™¯è¿è¡Œæ—¶åŒæ­¥ä¸­æ­¢ï¼š${payload.error}`, 'error');
                        } else {
                            appendWizardLog(`${sceneTag}åœºæ™¯è¿è¡Œæ—¶åŒæ­¥ä¸­æ­¢ï¼šå½“å‰ ${payload.currentBizCode || '-'}ï¼ŒæœŸæœ› ${payload.expectedBizCode || '-'}ï¼ˆ${payload.sceneName || 'æœªå‘½ååœºæ™¯'}ï¼‰`, 'error');
                        }
                    } else if (event === 'scene_runtime_sync_bypass') {
                        appendWizardLog(`${sceneTag}åœºæ™¯è¿è¡Œæ—¶ä¸åŒ¹é…ï¼Œå·²æŒ‰çº¯APIæ¨¡å¼ç»§ç»­ï¼šå½“å‰ ${payload.currentBizCode || '-'}ï¼ŒæœŸæœ› ${payload.expectedBizCode || '-'}ï¼ˆ${payload.sceneName || 'æœªå‘½ååœºæ™¯'}ï¼‰`);
                    } else if (event === 'goal_resolution_warning') {
                        const warningList = Array.isArray(payload.warnings) ? payload.warnings : [];
                        if (warningList.length) {
                            warningList.slice(0, 5).forEach(msg => {
                                appendWizardLog(`${sceneTag}è¥é”€ç›®æ ‡å‘Šè­¦ï¼š${msg}`, 'error');
                            });
                        }
                    } else if (event === 'build_solution_item') {
                        appendWizardLog(`${sceneTag}ç»„è£…è®¡åˆ’ï¼š${payload.planName} (${payload.index}/${payload.total})`);
                    } else if (event === 'submit_batch_start') {
                        appendWizardLog(`${sceneTag}æäº¤æ‰¹æ¬¡ ${payload.batchIndex}/${payload.batchTotal}ï¼Œæ•°é‡ ${payload.size}${payload.endpoint ? `ï¼Œæ¥å£=${payload.endpoint}` : ''}`);
                    } else if (event === 'submit_payload_snapshot') {
                        const campaignKeys = Array.isArray(payload.campaignKeys) ? payload.campaignKeys.join(',') : '';
                        const adgroupKeys = Array.isArray(payload.adgroupKeys) ? payload.adgroupKeys.join(',') : '';
                        appendWizardLog(`${sceneTag}æäº¤é¢„è§ˆï¼šåœºæ™¯=${payload.sceneName || '-'} ç›®æ ‡=${payload.marketingGoal || '-'} æ¨å¹¿åœºæ™¯=${payload.promotionScene || '-'} å‡ºä»·ç±»å‹=${payload.bidTypeV2 || '-'} å‡ºä»·ç›®æ ‡=${payload.bidTargetV2 || '-'} ä¼˜åŒ–ç›®æ ‡=${payload.optimizeTarget || '-'} å‡ºä»·æ¨¡å¼=${payload.bidMode || '-'} æäº¤æ¥å£=${payload.submitEndpoint || '-'} å•†å“ID=${payload.materialId || '-'} å…³é”®è¯æ•°=${payload.wordListCount || 0} è¯åŒ…æ•°=${payload.wordPackageCount || 0} æ˜¯å¦è§¦å‘é™çº§=${payload.fallbackTriggered ? 'æ˜¯' : 'å¦'} æ˜¯å¦ç›®æ ‡å›é€€=${payload.goalFallbackUsed ? 'æ˜¯' : 'å¦'} è®¡åˆ’å­—æ®µ=[${campaignKeys}] å•å…ƒå­—æ®µ=[${adgroupKeys}]`);
                    } else if (event === 'submit_batch_retry') {
                        appendWizardLog(`${sceneTag}æ‰¹æ¬¡é‡è¯• #${payload.attempt}ï¼š${payload.error}`, 'error');
                    } else if (event === 'submit_batch_success') {
                        if (payload.failedCount > 0) {
                            appendWizardLog(`${sceneTag}æ‰¹æ¬¡éƒ¨åˆ†æˆåŠŸï¼šæˆåŠŸ ${payload.createdCount}ï¼Œå¤±è´¥ ${payload.failedCount}${payload.error ? `ï¼ˆ${payload.error}ï¼‰` : ''}`, 'error');
                        } else {
                            appendWizardLog(`${sceneTag}æ‰¹æ¬¡æˆåŠŸï¼š${payload.createdCount} ä¸ª`, 'success');
                        }
                    } else if (event === 'fallback_downgrade_pending') {
                        const pendingText = payload.policy === 'auto'
                            ? 'æ£€æµ‹åˆ°è¯åŒ…æ ¡éªŒå¤±è´¥ï¼Œå‡†å¤‡è‡ªåŠ¨é™çº§é‡è¯•'
                            : 'æ£€æµ‹åˆ°è¯åŒ…æ ¡éªŒå¤±è´¥ï¼Œç­‰å¾…é™çº§ç¡®è®¤';
                        appendWizardLog(`${sceneTag}${pendingText}ï¼ˆæ‰¹æ¬¡ ${payload.batchIndex}ï¼Œå¤±è´¥ ${payload.count}ï¼Œç­–ç•¥=${fallbackPolicyText}ï¼‰`, 'error');
                    } else if (event === 'fallback_downgrade_confirmed') {
                        appendWizardLog(`${sceneTag}ç”¨æˆ·ç¡®è®¤é™çº§é‡è¯•ï¼ˆæ‰¹æ¬¡ ${payload.batchIndex}ï¼Œæ•°é‡ ${payload.count}${payload.auto ? 'ï¼Œè‡ªåŠ¨ç­–ç•¥' : ''}ï¼‰`, 'success');
                    } else if (event === 'fallback_downgrade_canceled') {
                        appendWizardLog(`${sceneTag}ç”¨æˆ·å–æ¶ˆé™çº§ï¼ˆæ‰¹æ¬¡ ${payload.batchIndex}ï¼Œæ•°é‡ ${payload.count}ï¼‰`, 'error');
                    } else if (event === 'fallback_downgrade_result') {
                        appendWizardLog(`${sceneTag}é™çº§é‡è¯•ç»“æœï¼šæˆåŠŸ${payload.successCount || 0}/å¤±è´¥${payload.failCount || 0}`, (payload.failCount || 0) > 0 ? 'error' : 'success');
                    } else if (event === 'submit_batch_fallback_single') {
                        appendWizardLog(`${sceneTag}${payload.fallbackTriggered ? 'æ‰¹æ¬¡é™çº§å•è®¡åˆ’é‡è¯•' : 'æ‰¹æ¬¡å•è®¡åˆ’é‡è¯•'}ï¼š${payload.error}`, 'error');
                    } else if (event === 'conflict_resolve_start') {
                        appendWizardLog(`${sceneTag}æ£€æµ‹åˆ°åœ¨æŠ•å†²çªï¼Œå¼€å§‹è‡ªåŠ¨å¤„ç†ï¼šè®¡åˆ’=${payload.planName || '-'} å•†å“ID=${payload.itemId || '-'}ï¼ˆ${payload.error || 'å†²çª' }ï¼‰`);
                    } else if (event === 'conflict_resolve_done') {
                        if (payload.resolved) {
                            const oneClickHint = payload.oneClickUsed ? 'ï¼ˆä¸€é”®å¤„ç†ï¼‰' : '';
                            appendWizardLog(`${sceneTag}å†²çªå¤„ç†å®Œæˆ${oneClickHint}ï¼šå·²åœç”¨ ${payload.stoppedCount || 0} ä¸ªå†²çªè®¡åˆ’ï¼Œç»§ç»­é‡è¯•åˆ›å»º`, 'success');
                        } else {
                            const extra = payload.oneClickError ? `ï¼›ä¸€é”®å¤„ç†=${payload.oneClickError}` : '';
                            appendWizardLog(`${sceneTag}å†²çªå¤„ç†å¤±è´¥ï¼šå·²å¤„ç† ${payload.stoppedCount || 0}ï¼Œæœªè§£å†³ ${payload.unresolvedCount || 0}${payload.error ? `ï¼ˆ${payload.error}${extra}ï¼‰` : (extra ? `ï¼ˆ${extra.slice(1)}ï¼‰` : '')}`, 'error');
                        }
                    }
                };
                try {
                    const result = {
                        ok: true,
                        partial: false,
                        successCount: 0,
                        failCount: 0,
                        successes: [],
                        failures: [],
                        byScene: []
                    };
                    const sceneTasks = sceneRequests.map((sceneReq, sceneIdx) => (async () => {
                        appendWizardLog(`åœºæ™¯åˆ†ç»„å¹¶å‘æäº¤ ${sceneIdx + 1}/${sceneRequests.length}ï¼š${sceneReq.sceneName}ï¼ˆ${sceneReq.plans.length} ä¸ªï¼‰`);
                        try {
                            const sceneResult = await createPlansByScene(sceneReq.sceneName, sceneReq, {
                                ...API_ONLY_CREATE_OPTIONS,
                                conflictPolicy: sceneReq.sceneName === 'è´§å“å…¨ç«™æ¨å¹¿'
                                    ? 'none'
                                    : String(API_ONLY_CREATE_OPTIONS.conflictPolicy || 'auto_stop_retry').trim() || 'auto_stop_retry',
                                onProgress: ({ event, ...payload }) => {
                                    onRunProgress({
                                        event,
                                        ...payload,
                                        sceneName: payload.sceneName || sceneReq.sceneName
                                    });
                                }
                            });
                            return {
                                sceneIdx,
                                sceneReq,
                                sceneResult
                            };
                        } catch (sceneErr) {
                            return {
                                sceneIdx,
                                sceneReq,
                                sceneErrorText: sceneErr?.message || String(sceneErr)
                            };
                        }
                    })());
                    const sceneTaskResults = await Promise.all(sceneTasks);
                    sceneTaskResults
                        .sort((a, b) => toNumber(a?.sceneIdx, 0) - toNumber(b?.sceneIdx, 0))
                        .forEach(taskResult => {
                            const sceneReq = taskResult?.sceneReq || {};
                            const sceneResult = taskResult?.sceneResult;
                            const sceneErrorText = String(taskResult?.sceneErrorText || '').trim();
                            if (sceneErrorText) {
                                const fallbackFailCount = Math.max(1, sceneReq.plans?.length || 0);
                                result.ok = false;
                                result.failCount += fallbackFailCount;
                                result.failures.push({
                                    sceneName: sceneReq.sceneName,
                                    error: sceneErrorText
                                });
                                result.byScene.push({
                                    sceneName: sceneReq.sceneName,
                                    planCount: sceneReq.plans?.length || 0,
                                    ok: false,
                                    successCount: 0,
                                    failCount: fallbackFailCount
                                });
                                appendWizardLog(`åœºæ™¯ ${sceneReq.sceneName} åˆ›å»ºå¼‚å¸¸ï¼š${sceneErrorText}`, 'error');
                                return;
                            }
                            result.byScene.push({
                                sceneName: sceneReq.sceneName,
                                planCount: sceneReq.plans?.length || 0,
                                ok: !!sceneResult?.ok,
                                successCount: toNumber(sceneResult?.successCount, 0),
                                failCount: toNumber(sceneResult?.failCount, 0)
                            });
                            result.successCount += toNumber(sceneResult?.successCount, 0);
                            result.failCount += toNumber(sceneResult?.failCount, 0);
                            if (Array.isArray(sceneResult?.successes) && sceneResult.successes.length) {
                                result.successes.push(...sceneResult.successes);
                            }
                            if (Array.isArray(sceneResult?.failures) && sceneResult.failures.length) {
                                result.failures.push(...sceneResult.failures.map(item => ({
                                    ...item,
                                    sceneName: item?.sceneName || sceneReq.sceneName
                                })));
                            }
                            if (!sceneResult?.ok) {
                                result.ok = false;
                            }
                        });
                    result.partial = result.successCount > 0 && result.failCount > 0;
                    appendWizardLog(`å®Œæˆï¼šæˆåŠŸ ${result.successCount}ï¼Œå¤±è´¥ ${result.failCount}`, result.ok ? 'success' : 'error');
                    if (result.failures.length) {
                        result.failures.slice(0, 3).forEach(item => {
                            appendWizardLog(`å¤±è´¥æ˜ç»†ï¼š${item.planName || '-'} -> ${item.error || 'æœªçŸ¥é”™è¯¯'}`, 'error');
                        });
                    }
                } catch (err) {
                    appendWizardLog(`åˆ›å»ºå¼‚å¸¸ï¼š${err?.message || err}`, 'error');
                } finally {
                    wizardState.els.runBtn.disabled = false;
                    wizardState.els.runQuickBtn.disabled = false;
                }
            };
            wizardState.els.runBtn.onclick = handleRun;
            wizardState.els.runQuickBtn.onclick = handleRun;
            if (wizardState.els.addStrategyBtn) {
                wizardState.els.addStrategyBtn.onclick = () => {
                    addNewStrategy();
                };
            }
            wizardState.els.clearDraftBtn.onclick = () => {
                clearSessionDraft();
                wizardState.draft = wizardDefaultDraft();
                wizardState.draft.sceneName = 'å…³é”®è¯æ¨å¹¿';
                wizardState.addedItems = [];
                wizardState.crowdList = [];
                wizardState.candidates = [];
                wizardState.keywordMetricMap = {};
                wizardState.repairRunToken = toNumber(wizardState.repairRunToken, 0) + 1;
                wizardState.repairRunning = false;
                wizardState.repairStopRequested = false;
                wizardState.repairLastSummary = null;
                setRepairControlState(false);
                setRepairStatusText('åœºæ™¯=- ç”¨ä¾‹=0/0 é€šè¿‡=0 ä¿®å¤=0 å¤±è´¥=0 åˆ é™¤=0 åœæ­¢=0');
                fillUIFromDraft();
                renderStrategyList();
                renderAddedList();
                renderCrowdList();
                renderCandidateList();
                if (typeof wizardState.buildRequest === 'function') {
                    wizardState.renderPreview(wizardState.buildRequest());
                }
                appendWizardLog('å·²æ¸…ç©ºä¼šè¯è‰ç¨¿');
            };
            [wizardState.els.budgetInput, wizardState.els.bidInput, wizardState.els.bidModeSelect, wizardState.els.modeSelect, wizardState.els.recommendCountInput, wizardState.els.manualInput, wizardState.els.bidTargetSelect, wizardState.els.budgetTypeSelect, wizardState.els.singleCostEnableInput, wizardState.els.singleCostInput]
                .forEach(el => {
                    if (!el) return;
                    el.addEventListener('input', syncDraftFromUI);
                    el.addEventListener('change', syncDraftFromUI);
                });
            if (wizardState.els.manualInput) {
                const syncManualPanelIfStale = () => {
                    if (!wizardState.detailVisible) return;
                    if (getCurrentEditorSceneName() !== 'å…³é”®è¯æ¨å¹¿') return;
                    const panel = wizardState.els.sceneDynamic?.querySelector?.('[data-manual-keyword-panel]');
                    if (!(panel instanceof Element)) return;
                    const hiddenInput = resolveManualKeywordHiddenInput(panel);
                    const manualText = String(wizardState.els.manualInput.value || '').trim();
                    const hiddenText = String(hiddenInput?.value || '').trim();
                    if (manualText === hiddenText) return;
                    renderSceneDynamicConfig();
                };
                wizardState.els.manualInput.addEventListener('input', syncManualPanelIfStale);
                wizardState.els.manualInput.addEventListener('change', syncManualPanelIfStale);
            }
            if (wizardState.els.prefixInput) {
                const syncPlanNameToStrategyList = () => {
                    syncDraftFromUI();
                    renderStrategyList();
                };
                wizardState.els.prefixInput.addEventListener('input', syncPlanNameToStrategyList);
                wizardState.els.prefixInput.addEventListener('change', syncPlanNameToStrategyList);
            }
            wizardState.els.budgetInput.addEventListener('change', renderStrategyList);
            wizardState.els.bidTargetSelect.addEventListener('change', () => {
                syncDraftFromUI();
                renderStrategyList();
                if (typeof wizardState.buildRequest === 'function') {
                    wizardState.renderPreview(wizardState.buildRequest());
                }
            });
            wizardState.els.bidModeSelect.addEventListener('change', () => {
                updateBidModeControls(wizardState.els.bidModeSelect.value);
                const currentSceneName = getCurrentEditorSceneName();
                if (currentSceneName === 'å…³é”®è¯æ¨å¹¿') {
                    const nextMode = normalizeBidMode(wizardState.els.bidModeSelect.value || 'smart', 'smart');
                    const sceneBucket = ensureSceneSettingBucket(currentSceneName);
                    const touchedBucket = ensureSceneTouchedBucket(currentSceneName);
                    const goalFieldKey = normalizeSceneFieldKey('è¥é”€ç›®æ ‡');
                    const schemeFieldKey = normalizeSceneFieldKey('é€‰æ‹©å¡ä½æ–¹æ¡ˆ');
                    const currentGoal = detectKeywordGoalFromText(
                        sceneBucket.è¥é”€ç›®æ ‡ || sceneBucket.é€‰æ‹©å¡ä½æ–¹æ¡ˆ || ''
                    );
                    if (!currentGoal) {
                        const fallbackSmartGoal = detectKeywordGoalFromBidTarget(
                            wizardState.els.bidTargetSelect?.value || wizardState.draft?.bidTargetV2 || DEFAULTS.bidTargetV2
                        ) || (nextMode === 'manual' ? 'è‡ªå®šä¹‰æ¨å¹¿' : 'è¶‹åŠ¿æ˜æ˜Ÿ');
                        sceneBucket.è¥é”€ç›®æ ‡ = fallbackSmartGoal;
                        if (sceneBucket.é€‰æ‹©å¡ä½æ–¹æ¡ˆ !== undefined) {
                            sceneBucket.é€‰æ‹©å¡ä½æ–¹æ¡ˆ = fallbackSmartGoal;
                        }
                        touchedBucket[goalFieldKey] = false;
                        touchedBucket[schemeFieldKey] = false;
                    }
                    renderSceneDynamicConfig();
                }
                syncDraftFromUI();
                renderStrategyList();
                if (typeof wizardState.buildRequest === 'function') {
                    wizardState.renderPreview(wizardState.buildRequest());
                }
            });
            wizardState.els.singleCostEnableInput.addEventListener('change', () => {
                wizardState.els.singleCostInput.disabled = !wizardState.els.singleCostEnableInput.checked;
                syncDraftFromUI();
            });

            wizardState.renderStrategyList = renderStrategyList;
            wizardState.openStrategyDetail = openStrategyDetail;
            wizardState.renderCandidateList = renderCandidateList;
            wizardState.renderAddedList = renderAddedList;
            wizardState.renderCrowdList = renderCrowdList;
            wizardState.loadCandidates = loadCandidates;
            wizardState.loadRecommendedKeywords = loadRecommendedKeywords;
            wizardState.loadRecommendedCrowds = loadRecommendedCrowds;
            wizardState.setCandidateSource = setCandidateSource;
            wizardState.setDebugVisible = setDebugVisible;
            wizardState.setItemSplitExpanded = setItemSplitExpanded;
            wizardState.setCandidateListExpanded = setCandidateListExpanded;
            wizardState.fillUIFromDraft = fillUIFromDraft;
            wizardState.appendWizardLog = appendWizardLog;
            wizardState.renderPreview = renderPreview;
            wizardState.buildRequest = buildRequestFromWizard;
            wizardState.refreshSceneProfileFromSpec = refreshSceneProfileFromSpec;
            setRepairControlState(false);
            setRepairStatusText('åœºæ™¯=- ç”¨ä¾‹=0/0 é€šè¿‡=0 ä¿®å¤=0 å¤±è´¥=0 åˆ é™¤=0 åœæ­¢=0');
            wizardState.mounted = true;
        };

        const openWizard = () => {
            mountWizard();
            wizardState.openToken = (toNumber(wizardState.openToken, 0) + 1);
            const openToken = wizardState.openToken;
            const isStaleOpen = () => openToken !== wizardState.openToken;

            const storedDraft = readSessionDraft() || {};
            wizardState.draft = mergeDeep(wizardDefaultDraft(), storedDraft);
            const draftSchemaVersion = toNumber(storedDraft?.schemaVersion, 0);
            if (draftSchemaVersion !== SESSION_DRAFT_SCHEMA_VERSION) {
                wizardState.draft.sceneSettingValues = {};
                wizardState.draft.sceneSettingTouched = {};
                wizardState.draft.editingStrategyId = '';
                wizardState.draft.detailVisible = false;
            }
            wizardState.draft.schemaVersion = SESSION_DRAFT_SCHEMA_VERSION;
            wizardState.draft.detailVisible = false;
            wizardState.draft.itemSplitExpanded = false;
            wizardState.draft.candidateListExpanded = false;
            wizardState.candidateSource = 'all';
            if (!SCENE_NAME_LIST.includes(wizardState.draft.sceneName)) {
                const currentSceneName = inferCurrentSceneName();
                wizardState.draft.sceneName = SCENE_NAME_LIST.includes(currentSceneName) ? currentSceneName : 'å…³é”®è¯æ¨å¹¿';
            }
            const initSceneBizCodeHint = resolveSceneBizCodeHint(wizardState.draft.sceneName);
            if (initSceneBizCodeHint && !wizardState.draft.bizCode) {
                wizardState.draft.bizCode = initSceneBizCodeHint;
            }
            if (wizardState.draft.bizCode && wizardState.draft.bizCode !== DEFAULTS.bizCode) {
                wizardState.draft.promotionScene = '';
            } else if (!wizardState.draft.promotionScene) {
                wizardState.draft.promotionScene = DEFAULTS.promotionScene;
            }
            wizardState.addedItems = Array.isArray(wizardState.draft.addedItems)
                ? wizardState.draft.addedItems.map(normalizeItem).filter(item => item.materialId).slice(0, WIZARD_MAX_ITEMS)
                : [];

            wizardState.fillUIFromDraft();
            refreshSceneSelect();
            if (typeof wizardState.renderStrategyList === 'function') {
                wizardState.renderStrategyList();
            }
            wizardState.renderAddedList();
            wizardState.renderCrowdList();
            wizardState.renderCandidateList();
            if (typeof wizardState.setCandidateSource === 'function') {
                wizardState.setCandidateSource(wizardState.candidateSource || 'all');
            }
            if (typeof wizardState.buildRequest === 'function') {
                wizardState.renderPreview(wizardState.buildRequest());
            }
            wizardState.els.log.innerHTML = '';
            if (wizardState.els.quickLog) {
                wizardState.els.quickLog.innerHTML = '';
            }
            setRepairControlState(!!wizardState.repairRunning);
            if (wizardState.repairLastSummary) {
                setRepairStatusText(formatRepairStatusText({
                    sceneName: '-',
                    caseIndex: toNumber(wizardState.repairLastSummary.totalCases, 0),
                    caseTotal: toNumber(wizardState.repairLastSummary.totalCases, 0),
                    passCases: toNumber(wizardState.repairLastSummary.passCases, 0),
                    repairedCases: toNumber(wizardState.repairLastSummary.repairedCases, 0),
                    failedCases: toNumber(wizardState.repairLastSummary.failedCases, 0),
                    deletedCount: toNumber(wizardState.repairLastSummary.deletedCount, 0),
                    stoppedCount: toNumber(wizardState.repairLastSummary.stoppedCount, 0)
                }));
            } else {
                setRepairStatusText('åœºæ™¯=- ç”¨ä¾‹=0/0 é€šè¿‡=0 ä¿®å¤=0 å¤±è´¥=0 åˆ é™¤=0 åœæ­¢=0');
            }
            wizardState.appendWizardLog(`å‘å¯¼å·²å°±ç»ªï¼ˆæ„å»º ${BUILD_VERSION}ï¼‰ï¼Œæ”¯æŒåŒåˆ—è¡¨é€‰å“ä¸æ‰¹é‡åˆ›å»º`);
            wizardState.appendWizardLog('æ­£åœ¨åå°é€šè¿‡æ¥å£åˆå§‹åŒ–è¿è¡Œæ—¶å’Œå•†å“åˆ—è¡¨...');

            wizardState.els.overlay.classList.add('open');
            wizardState.visible = true;
            if (!WIZARD_FORCE_API_ONLY_SCENE_CONFIG && typeof wizardState.refreshSceneProfileFromSpec === 'function') {
                wizardState.refreshSceneProfileFromSpec(wizardState.draft.sceneName, {
                    scanMode: 'visible',
                    unlockPolicy: 'safe_only',
                    goalScan: false,
                    silent: true
                });
            }

            if (!wizardState.candidates.length) {
                wizardState.loadCandidates('', wizardState.candidateSource || 'all');
            }

            (async () => {
                let runtimeForInit = null;
                try {
                    runtimeForInit = await getRuntimeDefaults(false);
                    if (isStaleOpen()) return;
                    applyRuntimeToDraft(runtimeForInit, wizardState.draft.sceneName);
                    wizardState.fillUIFromDraft();
                    refreshSceneSelect();
                    if (typeof wizardState.renderStrategyList === 'function') {
                        wizardState.renderStrategyList();
                    }
                    if (typeof wizardState.buildRequest === 'function') {
                        wizardState.renderPreview(wizardState.buildRequest());
                    }
                } catch (err) {
                    log.warn('åˆå§‹åŒ–è¿è¡Œæ—¶é»˜è®¤å€¼å¤±è´¥:', err?.message || err);
                }

                if (wizardState.addedItems.length) return;
                try {
                    const runtime = runtimeForInit || await getRuntimeDefaults(false);
                    if (isStaleOpen()) return;
                    const preferred = await resolvePreferredItems({}, runtime);
                    if (isStaleOpen()) return;
                    wizardState.addedItems = preferred.slice(0, WIZARD_MAX_ITEMS);
                    wizardState.draft.addedItems = wizardState.addedItems;
                    saveSessionDraft(wizardState.draft);
                    wizardState.renderAddedList();
                    wizardState.renderCandidateList();
                    if (typeof wizardState.buildRequest === 'function') {
                        wizardState.renderPreview(wizardState.buildRequest());
                    }
                } catch (err) {
                    log.warn('åˆå§‹åŒ–å·²æ·»åŠ å•†å“å¤±è´¥:', err?.message || err);
                }
            })();
        };

        const getSessionDraft = () => readSessionDraft();
        const withSceneRequest = (sceneName, request = {}) => mergeDeep({}, request, {
            sceneName: String(sceneName || '').trim()
        });
        const createPlansByScene = async (sceneName, request = {}, options = {}) => {
            const nextScene = String(sceneName || request?.sceneName || '').trim();
            const sceneRequest = nextScene ? withSceneRequest(nextScene, request) : mergeDeep({}, request);
            const normalizedOptions = isPlainObject(options) ? mergeDeep({}, options) : {};
            if (WIZARD_FORCE_API_ONLY_SCENE_CONFIG) {
                normalizedOptions.syncSceneRuntime = false;
                normalizedOptions.applySceneSpec = false;
                normalizedOptions.strictSceneRuntimeMatch = false;
                return createPlansBatch(sceneRequest, normalizedOptions);
            }
            if (normalizedOptions?.applySceneSpec === false) {
                return createPlansBatch(sceneRequest, normalizedOptions);
            }
            const sceneValidation = await validateSceneRequest(nextScene, sceneRequest, {
                scanMode: normalizedOptions?.scanMode || 'full_top_down',
                unlockPolicy: normalizedOptions?.unlockPolicy || 'safe_only',
                goalScan: normalizedOptions?.goalScan !== false,
                refresh: !!normalizedOptions?.refreshSceneSpec,
                forceRuntimeRefresh: !!normalizedOptions?.forceRuntimeRefresh
            });
            const normalizedRequest = sceneValidation?.normalizedRequest || sceneRequest;
            const result = await createPlansBatch(normalizedRequest, normalizedOptions);
            result.sceneRequestValidation = {
                filledDefaults: sceneValidation?.filledDefaults || [],
                warnings: sceneValidation?.warnings || [],
                missingCritical: sceneValidation?.missingCritical || [],
                sceneSpecMeta: sceneValidation?.sceneSpecMeta || null,
                resolvedMarketingGoal: sceneValidation?.resolvedMarketingGoal || '',
                goalFallbackUsed: !!sceneValidation?.goalFallbackUsed,
                goalWarnings: sceneValidation?.goalWarnings || []
            };
            return result;
        };
        const buildSmokeTestRequestByScene = (sceneName = '', itemId = '', options = {}) => {
            const stamp = buildTemplateTimestamp(new Date());
            const idx = toNumber(options.index, 1);
            const uniqueTail = `${String(Date.now()).slice(-6)}${Math.floor(Math.random() * 90 + 10)}`;
            const defaultPlanName = `${sceneName}_${stamp}_${String(idx).padStart(2, '0')}_${uniqueTail}`;
            const planName = sceneName === 'è´§å“å…¨ç«™æ¨å¹¿'
                ? `site${stamp}${String(idx).padStart(2, '0')}`
                : defaultPlanName;
            const plan = {
                planName,
                budget: {
                    dayAverageBudget: Math.max(30, toNumber(options.dayAverageBudget, 100))
                }
            };
            if (sceneName === 'è´§å“å…¨ç«™æ¨å¹¿') {
                plan.budget = {
                    dayBudget: Math.max(30, toNumber(options.dayAverageBudget, 100))
                };
            }
            if (itemId) {
                plan.itemId = String(itemId).trim();
            }
            const req = {
                sceneName,
                plans: [plan]
            };
            if (sceneName === 'å…³é”®è¯æ¨å¹¿') {
                req.common = {
                    bidMode: 'manual',
                    keywordMode: 'manual',
                    keywordDefaults: {
                        matchScope: 4,
                        bidPrice: 1,
                        onlineStatus: 1
                    }
                };
                plan.keywords = ['æµ‹è¯•è¯A', 'æµ‹è¯•è¯B', 'æµ‹è¯•è¯C'];
            } else if (sceneName === 'å†…å®¹è¥é”€') {
                req.common = {
                    campaignOverride: {
                        launchTime: buildDefaultLaunchTime({ forever: true }),
                        optimizeTarget: 'ad_strategy_buy_net',
                        itemSelectedMode: 'user_define',
                        promotionModel: 'daily',
                        launchPeriodList: buildDefaultLaunchPeriodList(),
                        launchAreaStrList: ['all']
                    }
                };
            } else if (sceneName === 'çº¿ç´¢æ¨å¹¿') {
                plan.budget = {
                    totalBudget: Math.max(1500, toNumber(options.dayAverageBudget, 3000))
                };
                req.common = {
                    campaignOverride: {
                        dmcType: 'total',
                        promotionModel: 'order',
                        promotionModelMarketing: 'strategy',
                        orderChargeType: 'balance_charge',
                        optimizeTarget: 'leads_cost',
                        itemSelectedMode: 'user_define',
                        launchTime: buildDefaultLaunchTime({ days: 7, forever: false }),
                        planId: 308,
                        planTemplateId: 308,
                        packageTemplateId: 74,
                        launchPeriodList: buildDefaultLaunchPeriodList(),
                        launchAreaStrList: ['all']
                    }
                };
            }
            return req;
        };
        const runSceneSmokeTests = async (options = {}) => {
            const itemId = String(options.itemId || options.materialId || '').trim();
            const scenes = Array.isArray(options.scenes) && options.scenes.length
                ? uniqueBy(options.scenes.map(item => String(item || '').trim()).filter(Boolean), item => item)
                : SCENE_NAME_LIST.slice();
            const timeoutMs = Math.max(15000, toNumber(options.timeoutMs, 50000));
            const createMode = options.createMode !== false;
            const captureInterfaces = createMode && options.captureInterfaces !== false;
            const passMode = (() => {
                const mode = String(options.passMode || '').trim();
                if (mode === 'create' || mode === 'both' || mode === 'interface') return mode;
                return createMode ? 'interface' : 'create';
            })();
            const list = [];
            for (let i = 0; i < scenes.length; i++) {
                const sceneName = scenes[i];
                const request = buildSmokeTestRequestByScene(sceneName, itemId, {
                    index: i + 1,
                    dayAverageBudget: toNumber(options.dayAverageBudget, 100)
                });
                const row = {
                    sceneName,
                    itemId,
                    mode: createMode ? 'create' : 'validate',
                    passMode,
                    requestPreview: {
                        planName: request?.plans?.[0]?.planName || '',
                        submitEndpoint: request.submitEndpoint || '',
                        marketingGoal: request.marketingGoal || ''
                    },
                    ok: false,
                    createOk: false,
                    interfaceOk: false,
                    timeout: false,
                    successCount: 0,
                    failCount: 0,
                    submitEndpoint: '',
                    failTop: '',
                    error: '',
                    capture: {
                        enabled: captureInterfaces,
                        captureId: '',
                        recordCount: 0,
                        contractCount: 0,
                        createInterfaceCount: 0,
                        createEndpoints: [],
                        createInterfaces: [],
                        contracts: []
                    },
                    ts: new Date().toISOString()
                };
                if (typeof options.onProgress === 'function') {
                    try {
                        options.onProgress({
                            event: 'scene_smoke_start',
                            sceneName,
                            index: i + 1,
                            total: scenes.length,
                            mode: row.mode,
                            passMode
                        });
                    } catch { }
                }
                if (!createMode) {
                    try {
                        const validation = await validateSceneRequest(sceneName, request, {
                            scanMode: options.scanMode || 'visible',
                            unlockPolicy: options.unlockPolicy || 'safe_only',
                            refresh: !!options.refresh
                        });
                        row.createOk = !!validation?.ok;
                        row.ok = row.createOk;
                        row.successCount = row.ok ? 1 : 0;
                        row.failCount = row.ok ? 0 : 1;
                        row.submitEndpoint = validation?.normalizedRequest?.submitEndpoint || '';
                        row.failTop = Array.isArray(validation?.warnings) ? (validation.warnings[0] || '') : '';
                    } catch (err) {
                        row.error = err?.message || String(err);
                        row.failCount = 1;
                    }
                } else {
                    let captureId = '';
                    if (captureInterfaces) {
                        try {
                            const capture = startNetworkCapture({ sceneName });
                            captureId = capture?.captureId || '';
                            row.capture.captureId = captureId;
                        } catch (err) {
                            row.error = err?.message || String(err);
                        }
                    }
                    const run = createPlansByScene(sceneName, request, {
                        batchRetry: Math.max(0, toNumber(options.batchRetry, 0)),
                        fallbackPolicy: options.fallbackPolicy || 'none',
                        requestOptions: {
                            maxRetries: Math.max(1, toNumber(options.maxRetries, 1)),
                            timeout: Math.max(8000, toNumber(options.requestTimeout, 20000))
                        }
                    });
                    const wrapped = await Promise.race([
                        run.then(res => ({ type: 'result', res })).catch(err => ({ type: 'error', err: err?.message || String(err) })),
                        new Promise(resolve => setTimeout(() => resolve({ type: 'timeout' }), timeoutMs))
                    ]);
                    if (wrapped.type === 'timeout') {
                        row.timeout = true;
                        row.error = `timeout_${timeoutMs}ms`;
                        row.failCount = 1;
                    } else if (wrapped.type === 'error') {
                        row.error = wrapped.err;
                        row.failCount = 1;
                    } else {
                        const res = wrapped.res || {};
                        row.createOk = !!res.ok;
                        row.successCount = toNumber(res.successCount, 0);
                        row.failCount = toNumber(res.failCount, 0);
                        row.submitEndpoint = res.submitEndpoint || '';
                        row.failTop = Array.isArray(res.failures) && res.failures.length
                            ? String(res.failures[0]?.error || '')
                            : '';
                    }
                    if (captureInterfaces && captureId) {
                        try {
                            const stopped = stopNetworkCapture(captureId, {
                                withRecords: !!options.withRecords
                            });
                            row.capture.recordCount = toNumber(stopped?.recordCount, 0);
                            row.capture.contractCount = toNumber(stopped?.contractCount, 0);
                            row.capture.createInterfaceCount = toNumber(stopped?.createInterfaceCount, 0);
                            row.capture.createEndpoints = Array.isArray(stopped?.createEndpoints)
                                ? stopped.createEndpoints.slice(0, 40)
                                : [];
                            row.capture.createInterfaces = Array.isArray(stopped?.createInterfaces)
                                ? stopped.createInterfaces.slice(0, 40)
                                : [];
                            row.capture.contracts = Array.isArray(stopped?.contracts)
                                ? stopped.contracts.slice(0, 120)
                                : [];
                            const rememberedContract = rememberSceneCreateInterfaces(
                                sceneName,
                                request?.marketingGoal || request?.common?.marketingGoal || '',
                                row.capture.createInterfaces,
                                { source: 'scene_smoke_test' }
                            );
                            if (rememberedContract) {
                                row.capture.rememberedContract = {
                                    endpoint: rememberedContract.endpoint || '',
                                    goalLabel: rememberedContract.goalLabel || '',
                                    requestKeyCount: Array.isArray(rememberedContract.requestKeys) ? rememberedContract.requestKeys.length : 0,
                                    campaignKeyCount: Array.isArray(rememberedContract.campaignKeys) ? rememberedContract.campaignKeys.length : 0,
                                    adgroupKeyCount: Array.isArray(rememberedContract.adgroupKeys) ? rememberedContract.adgroupKeys.length : 0
                                };
                            }
                            row.interfaceOk = row.capture.createInterfaceCount > 0;
                            if (!row.submitEndpoint && row.capture.createEndpoints.length) {
                                row.submitEndpoint = parseCreateEndpointFromMethodPath(row.capture.createEndpoints[0]);
                            }
                        } catch (err) {
                            row.error = row.error || (err?.message || String(err));
                        }
                    }
                    if (passMode === 'create') {
                        row.ok = !!row.createOk;
                    } else if (passMode === 'both') {
                        row.ok = !!row.createOk && !!row.interfaceOk;
                    } else {
                        row.ok = !!row.interfaceOk;
                        if (!row.ok && !row.error) {
                            row.error = 'create_interface_not_captured';
                        }
                    }
                }
                list.push(row);
                if (typeof options.onProgress === 'function') {
                    try {
                        options.onProgress({
                            event: 'scene_smoke_done',
                            sceneName,
                            index: i + 1,
                            total: scenes.length,
                            ok: row.ok,
                            createOk: row.createOk,
                            interfaceOk: row.interfaceOk,
                            createInterfaceCount: toNumber(row.capture?.createInterfaceCount, 0),
                            timeout: row.timeout,
                            successCount: row.successCount,
                            failCount: row.failCount,
                            submitEndpoint: row.submitEndpoint || '',
                            error: row.error || row.failTop || ''
                        });
                    } catch { }
                }
            }
            const result = {
                ok: list.every(item => item.ok),
                mode: createMode ? 'create' : 'validate',
                passMode,
                captureInterfaces,
                itemId,
                scannedAt: new Date().toISOString(),
                count: list.length,
                successCount: list.filter(item => item.ok).length,
                failCount: list.filter(item => !item.ok).length,
                list
            };
            window.__AM_WXT_SCENE_SMOKE_TEST_RESULT__ = result;
            if (captureInterfaces) {
                window.__AM_WXT_SCENE_CREATE_CAPTURE_RESULT__ = result;
            }
            return result;
        };
        const runSceneGoalOptionTests = async (options = {}) => {
            const scenes = Array.isArray(options.scenes) && options.scenes.length
                ? uniqueBy(options.scenes.map(item => String(item || '').trim()).filter(Boolean), item => item)
                : SCENE_NAME_LIST.slice();
            const strict = options.strict === true;
            const list = [];
            for (let i = 0; i < scenes.length; i++) {
                const sceneName = scenes[i];
                if (typeof options.onProgress === 'function') {
                    try {
                        options.onProgress({
                            event: 'scene_goal_option_test_start',
                            sceneName,
                            index: i + 1,
                            total: scenes.length
                        });
                    } catch { }
                }
                let row = {
                    sceneName,
                    ok: false,
                    goalCount: 0,
                    goalsWithFieldRows: 0,
                    goalsWithOptionRows: 0,
                    fieldCount: 0,
                    optionCount: 0,
                    warnings: [],
                    error: ''
                };
                try {
                    const extracted = await extractSceneGoalSpecs(sceneName, {
                        ...options,
                        scanMode: options.scanMode || 'full_top_down',
                        unlockPolicy: options.unlockPolicy || 'safe_only',
                        goalScan: true,
                        goalFieldScan: options.goalFieldScan !== false,
                        goalFieldScanMode: options.goalFieldScanMode || 'full_top_down',
                        goalFieldMaxDepth: toNumber(options.goalFieldMaxDepth, 2),
                        goalFieldMaxSnapshots: toNumber(options.goalFieldMaxSnapshots, 48),
                        goalFieldMaxGroupsPerLevel: toNumber(options.goalFieldMaxGroupsPerLevel, 6),
                        goalFieldMaxOptionsPerGroup: toNumber(options.goalFieldMaxOptionsPerGroup, 8),
                        refresh: options.refresh !== false
                    });
                    const goals = Array.isArray(extracted?.goals) ? extracted.goals : [];
                    const goalsWithFieldRows = goals.filter(goal => Array.isArray(goal?.fieldRows) && goal.fieldRows.length > 0).length;
                    const goalsWithOptionRows = goals.filter(goal => Array.isArray(goal?.fieldRows) && goal.fieldRows.some(field => Array.isArray(field?.options) && field.options.length >= 2)).length;
                    const fieldCount = goals.reduce((sum, goal) => sum + (Array.isArray(goal?.fieldRows) ? goal.fieldRows.length : 0), 0);
                    const optionCount = goals.reduce((sum, goal) => sum + (Array.isArray(goal?.fieldRows)
                        ? goal.fieldRows.reduce((acc, field) => acc + (Array.isArray(field?.options) ? field.options.length : 0), 0)
                        : 0), 0);
                    const warningList = Array.isArray(extracted?.warnings) ? extracted.warnings : [];
                    const fallbackGoalOnly = warningList.some(msg => /æœªè¯†åˆ«åˆ°å¯ç‚¹å‡»çš„è¥é”€ç›®æ ‡é€‰é¡¹/.test(String(msg || '')));
                    const strictPass = goals.length > 0
                        && goalsWithFieldRows === goals.length
                        && goalsWithOptionRows === goals.length;
                    const relaxedPass = goals.length > 0
                        && goalsWithFieldRows > 0
                        && (goalsWithOptionRows > 0 || fallbackGoalOnly);
                    row = {
                        sceneName,
                        ok: !!extracted?.ok && (strict ? strictPass : relaxedPass),
                        goalCount: goals.length,
                        goalsWithFieldRows,
                        goalsWithOptionRows,
                        fieldCount,
                        optionCount,
                        warnings: warningList.slice(0, 40),
                        error: extracted?.error || ''
                    };
                } catch (err) {
                    row.error = err?.message || String(err);
                }
                list.push(row);
                if (typeof options.onProgress === 'function') {
                    try {
                        options.onProgress({
                            event: 'scene_goal_option_test_done',
                            sceneName,
                            index: i + 1,
                            total: scenes.length,
                            ok: row.ok,
                            goalCount: row.goalCount,
                            goalsWithFieldRows: row.goalsWithFieldRows,
                            goalsWithOptionRows: row.goalsWithOptionRows,
                            fieldCount: row.fieldCount,
                            optionCount: row.optionCount,
                            error: row.error || ''
                        });
                    } catch { }
                }
            }
            const result = {
                ok: list.every(item => item.ok),
                strict,
                scannedAt: new Date().toISOString(),
                sceneOrder: scenes,
                count: list.length,
                successCount: list.filter(item => item.ok).length,
                failCount: list.filter(item => !item.ok).length,
                goalCount: list.reduce((sum, item) => sum + toNumber(item?.goalCount, 0), 0),
                goalsWithFieldRows: list.reduce((sum, item) => sum + toNumber(item?.goalsWithFieldRows, 0), 0),
                goalsWithOptionRows: list.reduce((sum, item) => sum + toNumber(item?.goalsWithOptionRows, 0), 0),
                fieldCount: list.reduce((sum, item) => sum + toNumber(item?.fieldCount, 0), 0),
                optionCount: list.reduce((sum, item) => sum + toNumber(item?.optionCount, 0), 0),
                list
            };
            window.__AM_WXT_SCENE_GOAL_OPTION_TEST_RESULT__ = result;
            return result;
        };
        const buildGoalOptionSimulationCases = (goal = {}, options = {}) => {
            const maxOptionsPerField = Math.max(1, Math.min(24, toNumber(options.maxOptionsPerField, 12)));
            const maxCasesPerGoal = Math.max(1, Math.min(360, toNumber(options.maxCasesPerGoal, 96)));
            const includeBaseCase = options.includeBaseCase !== false;
            const fieldRows = normalizeGoalFieldRows(goal?.fieldRows || []);
            const cases = [];
            if (includeBaseCase) {
                cases.push({
                    caseId: 'goal_default',
                    caseType: 'goal_default',
                    fieldLabel: '',
                    optionValue: '',
                    sceneSettingsPatch: {}
                });
            }
            fieldRows.forEach(row => {
                const fieldLabel = normalizeSceneOptionText(row?.label || '');
                if (!fieldLabel) return;
                const defaultValue = normalizeSceneSettingValue(row?.defaultValue || '');
                const optionsList = uniqueBy(
                    (Array.isArray(row?.options) ? row.options : [])
                        .map(item => normalizeSceneSettingValue(item))
                        .filter(Boolean),
                    item => item
                );
                if (defaultValue && !optionsList.includes(defaultValue)) {
                    optionsList.unshift(defaultValue);
                }
                const pickedOptions = optionsList.slice(0, maxOptionsPerField);
                pickedOptions.forEach((optionValue, idx) => {
                    const safeFieldKey = normalizeSceneSpecFieldKey(fieldLabel) || `field_${cases.length + idx + 1}`;
                    const safeValueKey = normalizeSceneSpecFieldKey(optionValue) || `opt_${idx + 1}`;
                    cases.push({
                        caseId: `${safeFieldKey}_${safeValueKey}`,
                        caseType: 'field_option',
                        fieldLabel,
                        optionValue,
                        sceneSettingsPatch: {
                            [fieldLabel]: optionValue
                        },
                        dependsOn: Array.isArray(row?.dependsOn) ? row.dependsOn.slice(0, 12) : [],
                        triggerPath: normalizeText(row?.triggerPath || '')
                    });
                });
            });
            return uniqueBy(cases, item => `${item.caseType}::${item.fieldLabel}::${item.optionValue}`)
                .slice(0, maxCasesPerGoal);
        };
        const runSceneOptionSubmitSimulations = async (options = {}) => {
            const itemId = String(options.itemId || options.materialId || SCENE_SYNC_DEFAULT_ITEM_ID).trim();
            const scenes = Array.isArray(options.scenes) && options.scenes.length
                ? uniqueBy(options.scenes.map(item => String(item || '').trim()).filter(Boolean), item => item)
                : SCENE_NAME_LIST.slice();
            const timeoutMs = Math.max(15000, toNumber(options.timeoutMs, 50000));
            const passMode = (() => {
                const mode = String(options.passMode || '').trim();
                if (mode === 'create' || mode === 'both' || mode === 'interface') return mode;
                return 'interface';
            })();
            const maxGoalsPerScene = Math.max(1, Math.min(40, toNumber(options.maxGoalsPerScene, 16)));
            const maxCasesPerGoal = Math.max(1, Math.min(360, toNumber(options.maxCasesPerGoal, 96)));
            const maxCasesPerScene = Math.max(1, Math.min(520, toNumber(options.maxCasesPerScene, 220)));
            const resolveExplicitGoalLabels = (sceneName = '') => {
                if (Array.isArray(options.goalLabels)) {
                    return uniqueBy(
                        options.goalLabels
                            .map(item => normalizeGoalCandidateLabel(item))
                            .filter(Boolean),
                        item => item
                    ).slice(0, 24);
                }
                if (isPlainObject(options.goalLabels)) {
                    const list = options.goalLabels[sceneName];
                    if (!Array.isArray(list)) return [];
                    return uniqueBy(
                        list
                            .map(item => normalizeGoalCandidateLabel(item))
                            .filter(Boolean),
                        item => item
                    ).slice(0, 24);
                }
                return [];
            };
            const list = [];
            for (let sceneIdx = 0; sceneIdx < scenes.length; sceneIdx++) {
                const sceneName = scenes[sceneIdx];
                if (typeof options.onProgress === 'function') {
                    try {
                        options.onProgress({
                            event: 'scene_option_submit_start',
                            sceneName,
                            index: sceneIdx + 1,
                            total: scenes.length
                        });
                    } catch { }
                }
                let extracted = null;
                const explicitGoalLabels = resolveExplicitGoalLabels(sceneName);
                if (explicitGoalLabels.length) {
                    extracted = {
                        goals: explicitGoalLabels.map((label, idx) => ({
                            goalLabel: label,
                            isDefault: idx === 0,
                            fieldRows: []
                        }))
                    };
                } else {
                    try {
                        extracted = await extractSceneGoalSpecs(sceneName, {
                            ...options,
                            scanMode: options.scanMode || 'full_top_down',
                            unlockPolicy: options.unlockPolicy || 'safe_only',
                            goalScan: true,
                            goalFieldScan: options.goalFieldScan !== false,
                            goalFieldScanMode: options.goalFieldScanMode || 'full_top_down',
                            goalFieldMaxDepth: toNumber(options.goalFieldMaxDepth, 2),
                            goalFieldMaxSnapshots: toNumber(options.goalFieldMaxSnapshots, 48),
                            goalFieldMaxGroupsPerLevel: toNumber(options.goalFieldMaxGroupsPerLevel, 6),
                            goalFieldMaxOptionsPerGroup: toNumber(options.goalFieldMaxOptionsPerGroup, 8),
                            refresh: options.refreshGoalSpecs === true
                        });
                    } catch (err) {
                        list.push({
                            sceneName,
                            goalLabel: '',
                            caseId: '',
                            caseType: 'goal_default',
                            fieldLabel: '',
                            optionValue: '',
                            ok: false,
                            createOk: false,
                            interfaceOk: false,
                            submitEndpoint: '',
                            createInterfaceCount: 0,
                            error: err?.message || String(err),
                            timeout: false,
                            requestPreview: {},
                            capture: {
                                enabled: false,
                                captureId: '',
                                recordCount: 0,
                                contractCount: 0,
                                createInterfaceCount: 0,
                                createEndpoints: [],
                                createInterfaces: [],
                                contracts: []
                            },
                            ts: new Date().toISOString()
                        });
                        continue;
                    }
                }
                const goalsRaw = Array.isArray(extracted?.goals) && extracted.goals.length
                    ? extracted.goals
                    : [{ goalLabel: '', isDefault: true, fieldRows: [] }];
                const fallbackGoalLabels = getSceneMarketingGoalFallbackList(sceneName);
                const goalsExpanded = goalsRaw.slice();
                const existingGoalSet = new Set(
                    goalsExpanded
                        .map(goal => normalizeGoalCandidateLabel(goal?.goalLabel || ''))
                        .filter(Boolean)
                );
                fallbackGoalLabels.forEach(label => {
                    if (existingGoalSet.has(label)) return;
                    goalsExpanded.push({
                        goalLabel: label,
                        isDefault: false,
                        fieldRows: []
                    });
                });
                const goals = goalsExpanded.slice(0, maxGoalsPerScene);
                let sceneCaseCursor = 0;
                for (let goalIdx = 0; goalIdx < goals.length; goalIdx++) {
                    const goal = goals[goalIdx] || {};
                    const goalLabel = normalizeGoalLabel(goal?.goalLabel || '');
                    const cases = buildGoalOptionSimulationCases(goal, {
                        maxOptionsPerField: options.maxOptionsPerField,
                        maxCasesPerGoal,
                        includeBaseCase: options.includeBaseCase !== false
                    });
                    for (let caseIdx = 0; caseIdx < cases.length; caseIdx++) {
                        if (sceneCaseCursor >= maxCasesPerScene) break;
                        sceneCaseCursor += 1;
                        const caseInfo = cases[caseIdx] || {};
                        const request = buildSmokeTestRequestByScene(sceneName, itemId, {
                            index: sceneCaseCursor,
                            dayAverageBudget: toNumber(options.dayAverageBudget, 100)
                        });
                        request.marketingGoal = goalLabel || request.marketingGoal || '';
                        request.common = mergeDeep({}, request.common || {}, {
                            marketingGoal: goalLabel || request?.common?.marketingGoal || ''
                        });
                        request.sceneSettings = mergeDeep({}, request.sceneSettings || {}, caseInfo.sceneSettingsPatch || {});
                        if (isPlainObject(options.requestOverrides)) {
                            mergeDeep(request, options.requestOverrides);
                        }
                        if (Array.isArray(request?.plans) && request.plans[0]) {
                            const tail = `${String(sceneCaseCursor).padStart(3, '0')}${String(Date.now()).slice(-4)}`;
                            request.plans[0].planName = `${request.plans[0].planName}_${tail}`;
                        }
                        const row = {
                            sceneName,
                            goalLabel,
                            caseId: caseInfo.caseId || '',
                            caseType: caseInfo.caseType || 'goal_default',
                            fieldLabel: caseInfo.fieldLabel || '',
                            optionValue: caseInfo.optionValue || '',
                            dependsOn: Array.isArray(caseInfo.dependsOn) ? caseInfo.dependsOn.slice(0, 12) : [],
                            triggerPath: caseInfo.triggerPath || '',
                            ok: false,
                            createOk: false,
                            interfaceOk: false,
                            submitEndpoint: '',
                            createInterfaceCount: 0,
                            error: '',
                            timeout: false,
                            requestPreview: {
                                planName: request?.plans?.[0]?.planName || '',
                                marketingGoal: request.marketingGoal || '',
                                sceneSettings: deepClone(request.sceneSettings || {})
                            },
                            capture: {
                                enabled: true,
                                captureId: '',
                                recordCount: 0,
                                contractCount: 0,
                                createInterfaceCount: 0,
                                createEndpoints: [],
                                createInterfaces: [],
                                contracts: []
                            },
                            ts: new Date().toISOString()
                        };
                        let captureId = '';
                        try {
                            const capture = startNetworkCapture({ sceneName });
                            captureId = capture?.captureId || '';
                            row.capture.captureId = captureId;
                        } catch (err) {
                            row.capture.enabled = false;
                            row.error = err?.message || String(err);
                        }
                        const run = createPlansByScene(sceneName, request, {
                            batchRetry: Math.max(0, toNumber(options.batchRetry, 0)),
                            fallbackPolicy: options.fallbackPolicy || 'none',
                            requestOptions: {
                                maxRetries: Math.max(1, toNumber(options.maxRetries, 1)),
                                timeout: Math.max(8000, toNumber(options.requestTimeout, 20000))
                            }
                        });
                        const wrapped = await Promise.race([
                            run.then(res => ({ type: 'result', res })).catch(err => ({ type: 'error', err: err?.message || String(err) })),
                            new Promise(resolve => setTimeout(() => resolve({ type: 'timeout' }), timeoutMs))
                        ]);
                        if (wrapped.type === 'timeout') {
                            row.timeout = true;
                            row.error = `timeout_${timeoutMs}ms`;
                        } else if (wrapped.type === 'error') {
                            row.error = wrapped.err;
                        } else {
                            const res = wrapped.res || {};
                            row.createOk = !!res.ok;
                            row.submitEndpoint = normalizeGoalCreateEndpoint(res.submitEndpoint || '');
                            if (!row.createOk && !row.error) {
                                row.error = Array.isArray(res?.failures) && res.failures.length
                                    ? String(res.failures[0]?.error || '')
                                    : '';
                            }
                        }
                        if (captureId) {
                            try {
                                const stopped = stopNetworkCapture(captureId, {
                                    withRecords: !!options.withRecords
                                });
                                row.capture.recordCount = toNumber(stopped?.recordCount, 0);
                                row.capture.contractCount = toNumber(stopped?.contractCount, 0);
                                row.capture.createInterfaceCount = toNumber(stopped?.createInterfaceCount, 0);
                                row.capture.createEndpoints = Array.isArray(stopped?.createEndpoints)
                                    ? stopped.createEndpoints.slice(0, 60)
                                    : [];
                                row.capture.createInterfaces = Array.isArray(stopped?.createInterfaces)
                                    ? stopped.createInterfaces.slice(0, 80)
                                    : [];
                                row.capture.contracts = Array.isArray(stopped?.contracts)
                                    ? stopped.contracts.slice(0, 160)
                                    : [];
                                row.createInterfaceCount = row.capture.createInterfaceCount;
                                row.interfaceOk = row.capture.createInterfaceCount > 0;
                                if (!row.submitEndpoint && row.capture.createEndpoints.length) {
                                    row.submitEndpoint = parseCreateEndpointFromMethodPath(row.capture.createEndpoints[0]);
                                }
                                const rememberedContract = rememberSceneCreateInterfaces(
                                    sceneName,
                                    goalLabel,
                                    row.capture.createInterfaces,
                                    { source: 'option_submit_simulation' }
                                );
                                if (rememberedContract) {
                                    row.rememberedContract = {
                                        endpoint: rememberedContract.endpoint || '',
                                        goalLabel: rememberedContract.goalLabel || '',
                                        requestKeyCount: Array.isArray(rememberedContract.requestKeys) ? rememberedContract.requestKeys.length : 0,
                                        campaignKeyCount: Array.isArray(rememberedContract.campaignKeys) ? rememberedContract.campaignKeys.length : 0,
                                        adgroupKeyCount: Array.isArray(rememberedContract.adgroupKeys) ? rememberedContract.adgroupKeys.length : 0
                                    };
                                }
                            } catch (err) {
                                row.error = row.error || (err?.message || String(err));
                            }
                        }
                        if (passMode === 'create') {
                            row.ok = !!row.createOk;
                        } else if (passMode === 'both') {
                            row.ok = !!row.createOk && !!row.interfaceOk;
                        } else {
                            row.ok = !!row.interfaceOk;
                            if (!row.ok && !row.error) row.error = 'create_interface_not_captured';
                        }
                        list.push(row);
                        if (typeof options.onProgress === 'function') {
                            try {
                                options.onProgress({
                                    event: 'scene_option_submit_case_done',
                                    sceneName,
                                    goalLabel,
                                    caseId: row.caseId,
                                    caseType: row.caseType,
                                    fieldLabel: row.fieldLabel,
                                    optionValue: row.optionValue,
                                    ok: row.ok,
                                    createOk: row.createOk,
                                    interfaceOk: row.interfaceOk,
                                    createInterfaceCount: row.createInterfaceCount,
                                    submitEndpoint: row.submitEndpoint || '',
                                    error: row.error || ''
                                });
                            } catch { }
                        }
                    }
                    if (sceneCaseCursor >= maxCasesPerScene) break;
                }
                if (typeof options.onProgress === 'function') {
                    try {
                        const sceneRows = list.filter(item => item.sceneName === sceneName);
                        options.onProgress({
                            event: 'scene_option_submit_done',
                            sceneName,
                            index: sceneIdx + 1,
                            total: scenes.length,
                            caseCount: sceneRows.length,
                            successCount: sceneRows.filter(item => item.ok).length,
                            failCount: sceneRows.filter(item => !item.ok).length
                        });
                    } catch { }
                }
            }
            const byScene = scenes.map(sceneName => {
                const rows = list.filter(item => item.sceneName === sceneName);
                const goalSet = uniqueBy(rows.map(item => normalizeGoalLabel(item.goalLabel || '')).filter(Boolean), item => item);
                return {
                    sceneName,
                    caseCount: rows.length,
                    successCount: rows.filter(item => item.ok).length,
                    failCount: rows.filter(item => !item.ok).length,
                    goalCount: goalSet.length,
                    createInterfaceCount: rows.reduce((sum, item) => sum + toNumber(item?.createInterfaceCount, 0), 0)
                };
            });
            const missingList = list
                .filter(item => !item.ok)
                .map(item => ({
                    sceneName: item.sceneName,
                    goalLabel: item.goalLabel || '',
                    fieldLabel: item.fieldLabel || '',
                    optionValue: item.optionValue || '',
                    caseId: item.caseId || '',
                    error: item.error || ''
                }))
                .slice(0, 400);
            const result = {
                ok: list.length > 0 && list.every(item => item.ok),
                itemId,
                passMode,
                scannedAt: new Date().toISOString(),
                sceneOrder: scenes,
                count: list.length,
                successCount: list.filter(item => item.ok).length,
                failCount: list.filter(item => !item.ok).length,
                missingCount: missingList.length,
                byScene,
                missingList,
                list
            };
            window.__AM_WXT_SCENE_OPTION_SUBMIT_SIM_RESULT__ = result;
            return result;
        };
        const captureSceneCreateInterfaces = async (sceneName = '', options = {}) => {
            const targetScene = String(sceneName || '').trim();
            if (!targetScene) {
                return {
                    ok: false,
                    sceneName: '',
                    error: 'ç¼ºå°‘ sceneName'
                };
            }
            const result = await runSceneSmokeTests({
                ...options,
                scenes: [targetScene],
                createMode: true,
                captureInterfaces: true,
                passMode: options.passMode || 'interface'
            });
            const row = Array.isArray(result?.list) && result.list.length ? result.list[0] : null;
            return {
                ok: !!row?.ok,
                sceneName: targetScene,
                itemId: row?.itemId || String(options.itemId || options.materialId || '').trim(),
                passMode: result?.passMode || 'interface',
                row: row || null,
                error: row?.error || ''
            };
        };
        const captureAllSceneCreateInterfaces = async (options = {}) => runSceneSmokeTests({
            ...options,
            createMode: true,
            captureInterfaces: true,
            passMode: options.passMode || 'interface'
        });
        const WIZARD_PARITY_REQUIRED_API_METHODS = [
            'openWizard',
            'getRuntimeDefaults',
            'searchItems',
            'createPlansBatch',
            'createPlansByScene',
            'createSitePlansBatch',
            'createKeywordPlansBatch',
            'createCrowdPlansBatch',
            'createShopDirectPlansBatch',
            'createContentPlansBatch',
            'createLeadPlansBatch',
            'suggestKeywords',
            'suggestCrowds',
            'getSessionDraft',
            'clearSessionDraft',
            'runSceneSmokeTests',
            'runSceneGoalOptionTests',
            'runSceneOptionSubmitSimulations',
            'captureSceneCreateInterfaces',
            'captureAllSceneCreateInterfaces',
            'buildSceneParityCaseMatrix',
            'collectWizardSubmitSnapshot',
            'runWizardSceneParityTest',
            'checkWizardApiCoverage'
        ];
        const checkWizardApiCoverage = () => {
            const localApi = {
                openWizard,
                getRuntimeDefaults,
                searchItems,
                createPlansBatch,
                createPlansByScene,
                createSitePlansBatch,
                createKeywordPlansBatch,
                createCrowdPlansBatch,
                createShopDirectPlansBatch,
                createContentPlansBatch,
                createLeadPlansBatch,
                suggestKeywords,
                suggestCrowds,
                getSessionDraft,
                clearSessionDraft,
                runSceneSmokeTests,
                runSceneGoalOptionTests,
                runSceneOptionSubmitSimulations,
                captureSceneCreateInterfaces,
                captureAllSceneCreateInterfaces,
                buildSceneParityCaseMatrix,
                collectWizardSubmitSnapshot,
                runWizardSceneParityTest,
                checkWizardApiCoverage
            };
            const pageApi = (typeof window !== 'undefined' && isPlainObject(window.__AM_WXT_KEYWORD_API__))
                ? window.__AM_WXT_KEYWORD_API__
                : {};
            const missingInLocal = WIZARD_PARITY_REQUIRED_API_METHODS
                .filter(name => typeof localApi[name] !== 'function');
            const missingInPage = WIZARD_PARITY_REQUIRED_API_METHODS
                .filter(name => typeof pageApi[name] !== 'function');
            return {
                required: WIZARD_PARITY_REQUIRED_API_METHODS.slice(),
                missingInLocal,
                missingInPage,
                ok: missingInLocal.length === 0 && missingInPage.length === 0
            };
        };
        const buildSceneParityCaseMatrix = (sceneName = '', options = {}) => {
            const targetScene = SCENE_NAME_LIST.includes(String(sceneName || '').trim())
                ? String(sceneName || '').trim()
                : 'å…³é”®è¯æ¨å¹¿';
            const maxGoalCases = Math.max(1, Math.min(6, toNumber(options.maxGoalCases, 3)));
            const maxDynamicCases = Math.max(0, Math.min(10, toNumber(options.maxDynamicCases, 4)));
            const fallbackGoals = getSceneMarketingGoalFallbackList(targetScene);
            const defaultGoal = fallbackGoals[0]
                || (targetScene === 'å…³é”®è¯æ¨å¹¿' ? 'è¶‹åŠ¿æ˜æ˜Ÿ' : normalizeGoalLabel(targetScene));
            const cases = [];
            const pushCase = (entry = {}) => {
                const caseId = String(entry.caseId || '').trim() || `case_${cases.length + 1}`;
                if (cases.some(item => item.caseId === caseId)) return;
                cases.push({
                    caseId,
                    label: String(entry.label || caseId).trim(),
                    strategyPatch: isPlainObject(entry.strategyPatch) ? deepClone(entry.strategyPatch) : {},
                    sceneSettingsPatch: isPlainObject(entry.sceneSettingsPatch) ? deepClone(entry.sceneSettingsPatch) : {}
                });
            };
            pushCase({
                caseId: 'base_default',
                label: 'é»˜è®¤é…ç½®',
                strategyPatch: {
                    marketingGoal: defaultGoal
                },
                sceneSettingsPatch: {
                    è¥é”€ç›®æ ‡: defaultGoal
                }
            });
            fallbackGoals.slice(1, maxGoalCases).forEach((goalLabel, idx) => {
                pushCase({
                    caseId: `goal_${idx + 1}`,
                    label: `è¥é”€ç›®æ ‡-${goalLabel}`,
                    strategyPatch: {
                        marketingGoal: goalLabel
                    },
                    sceneSettingsPatch: {
                        è¥é”€ç›®æ ‡: goalLabel
                    }
                });
            });
            if (targetScene === 'å…³é”®è¯æ¨å¹¿') {
                pushCase({
                    caseId: 'kw_manual',
                    label: 'å…³é”®è¯-æ‰‹åŠ¨å‡ºä»·',
                    strategyPatch: {
                        bidMode: 'manual',
                        marketingGoal: 'è‡ªå®šä¹‰æ¨å¹¿',
                        bidTargetV2: 'conv',
                        keywordMode: 'manual',
                        manualKeywords: 'æµ‹è¯•è¯A,1.20,ç²¾å‡†\næµ‹è¯•è¯B,1.10,å¹¿æ³›',
                        setSingleCostV2: false,
                        singleCostV2: ''
                    },
                    sceneSettingsPatch: {
                        è¥é”€ç›®æ ‡: 'è‡ªå®šä¹‰æ¨å¹¿',
                        é€‰æ‹©å¡ä½æ–¹æ¡ˆ: 'è‡ªå®šä¹‰æ¨å¹¿'
                    }
                });
                pushCase({
                    caseId: 'kw_smart_roi',
                    label: 'å…³é”®è¯-æ™ºèƒ½æŠ•äº§æ¯”',
                    strategyPatch: {
                        bidMode: 'smart',
                        marketingGoal: defaultGoal === 'è‡ªå®šä¹‰æ¨å¹¿' ? 'è¶‹åŠ¿æ˜æ˜Ÿ' : defaultGoal,
                        bidTargetV2: 'roi',
                        keywordMode: 'recommend',
                        recommendCount: '8',
                        manualKeywords: '',
                        setSingleCostV2: true,
                        singleCostV2: '35'
                    },
                    sceneSettingsPatch: {}
                });
                pushCase({
                    caseId: 'kw_day_budget',
                    label: 'å…³é”®è¯-æ—¥å‡é¢„ç®—',
                    strategyPatch: {
                        budgetType: 'day_budget',
                        dayAverageBudget: '188'
                    },
                    sceneSettingsPatch: {
                        é¢„ç®—ç±»å‹: 'æ—¥å‡é¢„ç®—'
                    }
                });
            } else {
                pushCase({
                    caseId: 'scene_day_budget',
                    label: 'åœºæ™¯-æ—¥å‡é¢„ç®—',
                    strategyPatch: {
                        budgetType: 'day_budget',
                        dayAverageBudget: '188'
                    },
                    sceneSettingsPatch: {
                        é¢„ç®—ç±»å‹: 'æ—¥å‡é¢„ç®—'
                    }
                });
                pushCase({
                    caseId: 'scene_day_average',
                    label: 'åœºæ™¯-æ¯æ—¥é¢„ç®—',
                    strategyPatch: {
                        budgetType: 'day_average',
                        dayAverageBudget: '166'
                    },
                    sceneSettingsPatch: {
                        é¢„ç®—ç±»å‹: 'æ¯æ—¥é¢„ç®—'
                    }
                });
            }
            const sceneFallbackOptionMap = (typeof SCENE_FALLBACK_OPTION_MAP !== 'undefined' && isPlainObject(SCENE_FALLBACK_OPTION_MAP))
                ? SCENE_FALLBACK_OPTION_MAP
                : {};
            const sceneOptionMap = isPlainObject(sceneFallbackOptionMap[targetScene])
                ? sceneFallbackOptionMap[targetScene]
                : {};
            const DYNAMIC_FIELD_SKIP_RE = /(è¥é”€ç›®æ ‡|é€‰æ‹©å¡ä½æ–¹æ¡ˆ|é€‰æ‹©æ‹‰æ–°æ–¹æ¡ˆ|é€‰æ‹©æ–¹æ¡ˆ|é€‰æ‹©ä¼˜åŒ–æ–¹å‘|é€‰æ‹©è§£å†³æ–¹æ¡ˆ|æŠ•æ”¾ç­–ç•¥|æ¨å¹¿æ¨¡å¼|å¡ä½æ–¹å¼|é€‰æ‹©æ–¹å¼|é¢„ç®—ç±»å‹|è®¡åˆ’åç§°|è®¡åˆ’å|é¢„ç®—å€¼|æ¯æ—¥é¢„ç®—|æ—¥å‡é¢„ç®—|æ€»é¢„ç®—)/;
            let dynamicCursor = 0;
            Object.keys(sceneOptionMap).forEach(label => {
                if (dynamicCursor >= maxDynamicCases) return;
                const text = normalizeGoalLabel(label);
                if (!text || DYNAMIC_FIELD_SKIP_RE.test(text)) return;
                const optionsList = uniqueBy(
                    (Array.isArray(sceneOptionMap[label]) ? sceneOptionMap[label] : [])
                        .map(item => normalizeGoalLabel(item))
                        .filter(Boolean),
                    item => item
                );
                if (optionsList.length < 2) return;
                const optionValue = optionsList[1];
                dynamicCursor += 1;
                pushCase({
                    caseId: `dynamic_${dynamicCursor}`,
                    label: `${text}-${optionValue}`,
                    strategyPatch: {},
                    sceneSettingsPatch: {
                        [text]: optionValue
                    }
                });
            });
            return {
                sceneName: targetScene,
                count: cases.length,
                cases
            };
        };
        const resolveParityTestItem = async (sceneName = '', options = {}) => {
            const targetScene = String(sceneName || '').trim() || 'å…³é”®è¯æ¨å¹¿';
            const explicitItem = isPlainObject(options.item) ? options.item : null;
            if (explicitItem && (explicitItem.materialId || explicitItem.itemId)) {
                return deepClone(explicitItem);
            }
            const itemList = Array.isArray(options.items) ? options.items : [];
            const firstFromList = itemList.find(item => isPlainObject(item) && (item.materialId || item.itemId));
            if (firstFromList) return deepClone(firstFromList);
            const existing = Array.isArray(wizardState.addedItems)
                ? wizardState.addedItems.find(item => item && (item.materialId || item.itemId))
                : null;
            if (existing) return deepClone(existing);
            const query = String(options.itemQuery || '').trim();
            const runtime = await getRuntimeDefaults(false);
            if (targetScene === 'å…³é”®è¯æ¨å¹¿' && options.useDefaultSyncItem !== false) {
                const defaultItems = await fetchItemsByIds([SCENE_SYNC_DEFAULT_ITEM_ID], runtime);
                if (Array.isArray(defaultItems) && defaultItems.length) {
                    return deepClone(defaultItems[0]);
                }
            }
            const bizCode = resolveSceneBizCodeHint(targetScene) || runtime.bizCode || DEFAULTS.bizCode;
            const promotionScene = resolveSceneDefaultPromotionScene(
                targetScene,
                runtime.promotionScene || DEFAULTS.promotionScene
            );
            const searched = await searchItems({
                bizCode,
                promotionScene,
                query,
                pageSize: Math.max(20, toNumber(options.pageSize, 40)),
                tagId: null,
                channelKey: query ? '' : 'effect'
            });
            const candidate = Array.isArray(searched?.list) ? searched.list[0] : null;
            return candidate ? deepClone(candidate) : null;
        };
        const buildParityStrategyTemplate = (sceneName = '', patch = {}) => {
            const targetScene = String(sceneName || '').trim() || 'å…³é”®è¯æ¨å¹¿';
            const fallbackGoals = getSceneMarketingGoalFallbackList(targetScene);
            const defaultGoal = fallbackGoals[0]
                || (targetScene === 'å…³é”®è¯æ¨å¹¿' ? 'è¶‹åŠ¿æ˜æ˜Ÿ' : normalizeGoalLabel(targetScene));
            const base = {
                id: `parity_${nowStampSeconds()}_${Math.floor(Math.random() * 90 + 10)}`,
                name: `${targetScene}-æ ¡å¯¹`,
                enabled: true,
                bidMode: 'smart',
                marketingGoal: defaultGoal,
                dayAverageBudget: '100',
                defaultBidPrice: '1',
                keywordMode: DEFAULTS.keywordMode,
                useWordPackage: true,
                recommendCount: String(DEFAULTS.recommendCount),
                manualKeywords: '',
                bidTargetV2: DEFAULTS.bidTargetV2,
                budgetType: 'day_average',
                setSingleCostV2: false,
                singleCostV2: '',
                planName: `PARITY_${targetScene}_${nowStampSeconds()}`,
                copyBatchCount: 1
            };
            const merged = mergeDeep({}, base, isPlainObject(patch) ? patch : {});
            merged.bidMode = normalizeBidMode(merged.bidMode || 'smart', 'smart');
            merged.marketingGoal = normalizeGoalLabel(merged.marketingGoal || defaultGoal || '');
            merged.bidTargetV2 = String(merged.bidTargetV2 || DEFAULTS.bidTargetV2).trim() || DEFAULTS.bidTargetV2;
            merged.dayAverageBudget = String(merged.dayAverageBudget || '100').trim() || '100';
            merged.defaultBidPrice = String(merged.defaultBidPrice || '1').trim() || '1';
            merged.keywordMode = String(merged.keywordMode || DEFAULTS.keywordMode).trim() || DEFAULTS.keywordMode;
            merged.recommendCount = String(merged.recommendCount || DEFAULTS.recommendCount).trim() || String(DEFAULTS.recommendCount);
            merged.planName = String(merged.planName || '').trim() || `PARITY_${targetScene}_${nowStampSeconds()}`;
            merged.copyBatchCount = Math.max(1, Math.min(99, toNumber(merged.copyBatchCount, 1)));
            if (targetScene !== 'å…³é”®è¯æ¨å¹¿') {
                merged.manualKeywords = '';
                merged.keywordMode = DEFAULTS.keywordMode;
                merged.setSingleCostV2 = false;
                merged.singleCostV2 = '';
            }
            return merged;
        };
        const pickBudgetValueFromObject = (obj = {}) => {
            if (!isPlainObject(obj)) return 0;
            const value = toNumber(
                obj.dayAverageBudget
                || obj.dayBudget
                || obj.totalBudget
                || obj.orderAmount
                || obj.futureBudget,
                0
            );
            return Number.isFinite(value) && value > 0 ? value : 0;
        };
        const collectWizardSubmitSnapshot = async (request = {}, options = {}) => {
            const sceneName = String(request?.sceneName || options?.sceneName || '').trim();
            if (!sceneName) {
                return {
                    ok: false,
                    error: 'missing_scene_name',
                    submitPayloadSnapshot: {},
                    result: null,
                    progressEvents: []
                };
            }
            const progressEvents = [];
            let submitPayloadSnapshot = null;
            const userOnProgress = typeof options.onProgress === 'function' ? options.onProgress : null;
            const runOptions = mergeDeep({
                fallbackPolicy: 'none',
                batchRetry: 0,
                syncSceneRuntime: false,
                strictSceneRuntimeMatch: false,
                dryRunOnly: true
            }, isPlainObject(options) ? options : {});
            runOptions.onProgress = (payload = {}) => {
                progressEvents.push(payload);
                if (payload?.event === 'submit_payload_snapshot') {
                    submitPayloadSnapshot = {
                        ...payload
                    };
                    delete submitPayloadSnapshot.event;
                }
                if (userOnProgress) {
                    try {
                        userOnProgress(payload);
                    } catch { }
                }
            };
            const result = await createPlansByScene(sceneName, request, runOptions);
            if (!submitPayloadSnapshot && isPlainObject(result?.submitPayloadSnapshot)) {
                submitPayloadSnapshot = deepClone(result.submitPayloadSnapshot);
            }
            return {
                ok: !!result?.ok,
                error: result?.error || '',
                submitPayloadSnapshot: submitPayloadSnapshot || {},
                result,
                progressEvents
            };
        };
        const collectWizardParityUiSnapshot = (sceneName = '', strategy = {}, request = {}, caseInfo = {}) => {
            const els = wizardState.els || {};
            const firstPlan = Array.isArray(request?.plans) && request.plans.length ? request.plans[0] : {};
            const manualKeywordCount = parseKeywords(
                els?.manualInput?.value || strategy?.manualKeywords || '',
                {
                    bidPrice: toNumber(strategy?.defaultBidPrice, 1),
                    matchScope: DEFAULTS.matchScope,
                    onlineStatus: DEFAULTS.keywordOnlineStatus
                }
            ).length;
            return {
                caseId: String(caseInfo?.caseId || '').trim(),
                label: String(caseInfo?.label || '').trim(),
                sceneName: String(sceneName || '').trim(),
                staticControls: {
                    bidMode: String(els?.bidModeSelect?.value || strategy?.bidMode || '').trim(),
                    bidTargetV2: String(els?.bidTargetSelect?.value || strategy?.bidTargetV2 || '').trim(),
                    budgetType: String(els?.budgetTypeSelect?.value || strategy?.budgetType || '').trim(),
                    budgetValue: String(els?.budgetInput?.value || strategy?.dayAverageBudget || '').trim(),
                    keywordMode: String(els?.modeSelect?.value || strategy?.keywordMode || '').trim(),
                    recommendCount: String(els?.recommendCountInput?.value || strategy?.recommendCount || '').trim(),
                    planName: String(els?.prefixInput?.value || strategy?.planName || '').trim(),
                    singleCostEnabled: !!els?.singleCostEnableInput?.checked,
                    singleCostValue: String(els?.singleCostInput?.value || strategy?.singleCostV2 || '').trim(),
                    manualKeywordCount
                },
                strategy: deepClone(strategy || {}),
                requestPreview: {
                    sceneName: request?.sceneName || '',
                    marketingGoal: normalizeGoalLabel(firstPlan?.marketingGoal || request?.marketingGoal || ''),
                    planName: String(firstPlan?.planName || '').trim(),
                    bidMode: normalizeBidMode(firstPlan?.bidMode || strategy?.bidMode || 'smart', 'smart'),
                    budgetValue: pickBudgetValueFromObject(firstPlan?.budget || {}),
                    budget: deepClone(firstPlan?.budget || {}),
                    sceneSettingCount: isPlainObject(request?.sceneSettings)
                        ? Object.keys(request.sceneSettings).filter(key => String(request.sceneSettings[key] || '').trim() !== '').length
                        : 0
                },
                sceneSettings: deepClone(request?.sceneSettings || {})
            };
        };
        const applyWizardParityCase = async (sceneName = '', caseInfo = {}, options = {}) => {
            const targetScene = SCENE_NAME_LIST.includes(String(sceneName || '').trim())
                ? String(sceneName || '').trim()
                : 'å…³é”®è¯æ¨å¹¿';
            openWizard();
            const item = await resolveParityTestItem(targetScene, options);
            if (!item || !(item.materialId || item.itemId)) {
                throw new Error(`åœºæ™¯ã€Œ${targetScene}ã€æœªæ‰¾åˆ°å¯ç”¨å•†å“`);
            }
            const strategy = buildParityStrategyTemplate(targetScene, caseInfo?.strategyPatch || {});
            const draft = mergeDeep(wizardDefaultDraft(), wizardState.draft || {});
            const planPrefix = String(strategy.planName || caseInfo?.planNamePrefix || '').trim() || `PARITY_${targetScene}_${nowStampSeconds()}`;
            draft.sceneName = targetScene;
            draft.planNamePrefix = planPrefix;
            draft.bidMode = normalizeBidMode(strategy.bidMode || draft.bidMode || 'smart', 'smart');
            draft.keywordMode = strategy.keywordMode || draft.keywordMode || DEFAULTS.keywordMode;
            draft.recommendCount = String(strategy.recommendCount || draft.recommendCount || DEFAULTS.recommendCount).trim() || String(DEFAULTS.recommendCount);
            draft.defaultBidPrice = String(strategy.defaultBidPrice || draft.defaultBidPrice || '1').trim() || '1';
            draft.dayAverageBudget = String(strategy.dayAverageBudget || draft.dayAverageBudget || '100').trim() || '100';
            draft.manualKeywords = String(strategy.manualKeywords || '').trim();
            draft.useWordPackage = strategy.useWordPackage !== false;
            draft.fallbackPolicy = normalizeWizardFallbackPolicy(draft.fallbackPolicy || 'auto');
            draft.addedItems = [deepClone(item)];
            draft.strategyList = [deepClone(strategy)];
            draft.editingStrategyId = strategy.id;
            draft.detailVisible = false;
            draft.sceneSettings = isPlainObject(draft.sceneSettings) ? draft.sceneSettings : {};
            draft.sceneSettingTouched = isPlainObject(draft.sceneSettingTouched) ? draft.sceneSettingTouched : {};
            const sceneSettingsPatch = mergeDeep({}, isPlainObject(caseInfo?.sceneSettingsPatch) ? caseInfo.sceneSettingsPatch : {});
            if (strategy.marketingGoal) {
                sceneSettingsPatch.è¥é”€ç›®æ ‡ = sceneSettingsPatch.è¥é”€ç›®æ ‡ || strategy.marketingGoal;
                if (targetScene === 'å…³é”®è¯æ¨å¹¿') {
                    sceneSettingsPatch.é€‰æ‹©å¡ä½æ–¹æ¡ˆ = sceneSettingsPatch.é€‰æ‹©å¡ä½æ–¹æ¡ˆ || strategy.marketingGoal;
                }
            }
            draft.sceneSettings[targetScene] = mergeDeep({}, draft.sceneSettings[targetScene] || {}, sceneSettingsPatch);
            draft.sceneSettingTouched[targetScene] = isPlainObject(draft.sceneSettingTouched[targetScene])
                ? draft.sceneSettingTouched[targetScene]
                : {};
            Object.keys(sceneSettingsPatch).forEach(label => {
                const key = typeof normalizeSceneFieldKey === 'function'
                    ? normalizeSceneFieldKey(label)
                    : String(label || '').trim();
                if (!key) return;
                draft.sceneSettingTouched[targetScene][key] = true;
            });
            wizardState.draft = draft;
            wizardState.addedItems = [deepClone(item)];
            wizardState.crowdList = Array.isArray(caseInfo?.crowdList) ? deepClone(caseInfo.crowdList) : [];
            wizardState.strategyList = [deepClone(strategy)];
            wizardState.editingStrategyId = strategy.id;
            wizardState.detailVisible = false;
            if (typeof wizardState.fillUIFromDraft === 'function') {
                wizardState.fillUIFromDraft();
            }
            if (wizardState.els?.sceneSelect instanceof HTMLSelectElement && wizardState.els.sceneSelect.value !== targetScene) {
                wizardState.els.sceneSelect.value = targetScene;
                wizardState.els.sceneSelect.dispatchEvent(new Event('change', { bubbles: true }));
            }
            if (typeof wizardState.renderStrategyList === 'function') {
                wizardState.renderStrategyList();
            }
            if (typeof wizardState.buildRequest !== 'function') {
                throw new Error('wizard_build_request_unavailable');
            }
            const request = wizardState.buildRequest();
            const activeStrategy = deepClone((wizardState.strategyList || [])[0] || strategy);
            const uiSnapshot = collectWizardParityUiSnapshot(targetScene, activeStrategy, request, caseInfo);
            return {
                sceneName: targetScene,
                request,
                strategy: activeStrategy,
                item: deepClone(item),
                uiSnapshot
            };
        };
        const compareWizardParityCase = ({
            sceneName = '',
            request = {},
            uiSnapshot = {},
            submitPayloadSnapshot = {},
            dryRunResult = {}
        } = {}) => {
            const targetScene = String(sceneName || request?.sceneName || '').trim();
            const firstPlan = Array.isArray(request?.plans) && request.plans.length ? request.plans[0] : {};
            const sampleCampaign = isPlainObject(dryRunResult?.sample?.campaign) ? dryRunResult.sample.campaign : {};
            const expectedMarketingGoal = normalizeGoalLabel(
                firstPlan?.marketingGoal
                || request?.marketingGoal
                || uiSnapshot?.strategy?.marketingGoal
                || ''
            );
            const actualMarketingGoal = normalizeGoalLabel(
                submitPayloadSnapshot?.marketingGoal
                || dryRunResult?.sample?.meta?.marketingGoal
                || ''
            );
            const diffs = [];
            if (expectedMarketingGoal && actualMarketingGoal && expectedMarketingGoal !== actualMarketingGoal) {
                diffs.push({
                    field: 'marketingGoal',
                    expected: expectedMarketingGoal,
                    actual: actualMarketingGoal
                });
            }
            const expectedPlanName = String(firstPlan?.planName || '').trim();
            const actualPlanName = String(sampleCampaign?.campaignName || '').trim();
            const isSiteScene = targetScene === 'è´§å“å…¨ç«™æ¨å¹¿';
            const expectedPlanNameLooksSiteSafe = /^[A-Za-z0-9]{2,64}$/.test(expectedPlanName);
            const siteNameAutoNormalized = isSiteScene && actualPlanName && /^site\d{8,}$/.test(actualPlanName) && !expectedPlanNameLooksSiteSafe;
            if (expectedPlanName && actualPlanName && expectedPlanName !== actualPlanName && !siteNameAutoNormalized) {
                diffs.push({
                    field: 'planName',
                    expected: expectedPlanName,
                    actual: actualPlanName
                });
            }
            const expectedBudgetValue = pickBudgetValueFromObject(firstPlan?.budget || {});
            const actualBudgetValue = pickBudgetValueFromObject(sampleCampaign || {});
            const isLeadSceneBudgetAutoRaised = targetScene === 'çº¿ç´¢æ¨å¹¿'
                && expectedBudgetValue > 0
                && actualBudgetValue >= 1500
                && actualBudgetValue >= expectedBudgetValue;
            if (!isLeadSceneBudgetAutoRaised && expectedBudgetValue > 0 && actualBudgetValue > 0 && Math.abs(expectedBudgetValue - actualBudgetValue) > 0.001) {
                diffs.push({
                    field: 'budgetValue',
                    expected: expectedBudgetValue,
                    actual: actualBudgetValue
                });
            } else if (!isLeadSceneBudgetAutoRaised && expectedBudgetValue > 0 && !(actualBudgetValue > 0)) {
                diffs.push({
                    field: 'budgetValue',
                    expected: expectedBudgetValue,
                    actual: actualBudgetValue
                });
            }
            if (targetScene === 'å…³é”®è¯æ¨å¹¿') {
                const expectedBidMode = normalizeBidMode(
                    firstPlan?.bidMode
                    || uiSnapshot?.strategy?.bidMode
                    || request?.common?.bidMode
                    || 'smart',
                    'smart'
                );
                const actualBidMode = normalizeBidMode(
                    submitPayloadSnapshot?.bidMode
                    || dryRunResult?.sample?.meta?.bidMode
                    || '',
                    expectedBidMode
                );
                if (expectedBidMode !== actualBidMode) {
                    diffs.push({
                        field: 'bidMode',
                        expected: expectedBidMode,
                        actual: actualBidMode
                    });
                }
                const expectedBidTarget = expectedBidMode === 'smart'
                    ? String(firstPlan?.campaignOverride?.bidTargetV2 || '').trim()
                    : '';
                const actualBidTarget = String(
                    submitPayloadSnapshot?.bidTargetV2
                    || dryRunResult?.sample?.campaign?.bidTargetV2
                    || ''
                ).trim();
                if (expectedBidTarget !== actualBidTarget) {
                    diffs.push({
                        field: 'bidTargetV2',
                        expected: expectedBidTarget,
                        actual: actualBidTarget
                    });
                }
                const expectedManualKeywordCount = parseKeywords(
                    uiSnapshot?.strategy?.manualKeywords || '',
                    {
                        bidPrice: toNumber(uiSnapshot?.strategy?.defaultBidPrice, 1),
                        matchScope: DEFAULTS.matchScope,
                        onlineStatus: DEFAULTS.keywordOnlineStatus
                    }
                ).length;
                const actualWordListCount = toNumber(submitPayloadSnapshot?.wordListCount, 0);
                if (expectedManualKeywordCount > 0 && actualWordListCount < expectedManualKeywordCount) {
                    diffs.push({
                        field: 'wordListCount',
                        expected: `>=${expectedManualKeywordCount}`,
                        actual: actualWordListCount
                    });
                }
                if (expectedBidMode === 'manual' && toNumber(submitPayloadSnapshot?.wordPackageCount, 0) > 0) {
                    diffs.push({
                        field: 'wordPackageCount',
                        expected: 0,
                        actual: toNumber(submitPayloadSnapshot?.wordPackageCount, 0)
                    });
                }
            }
            return {
                ok: diffs.length === 0,
                diffs,
                expected: {
                    sceneName: targetScene,
                    marketingGoal: expectedMarketingGoal,
                    planName: expectedPlanName,
                    budgetValue: expectedBudgetValue
                },
                actual: {
                    sceneName: submitPayloadSnapshot?.sceneName || targetScene,
                    marketingGoal: actualMarketingGoal,
                    planName: actualPlanName,
                    budgetValue: actualBudgetValue
                }
            };
        };
        const runWizardSceneParityTest = async (options = {}) => {
            const rounds = Math.max(1, Math.min(10, toNumber(options.rounds, 1)));
            const scenes = Array.isArray(options.scenes) && options.scenes.length
                ? uniqueBy(options.scenes.map(item => String(item || '').trim()).filter(Boolean), item => item)
                    .filter(scene => SCENE_NAME_LIST.includes(scene))
                : SCENE_NAME_LIST.slice();
            const maxCasesPerScene = Math.max(1, Math.min(24, toNumber(options.maxCasesPerScene, 8)));
            const dryRunOnly = options.dryRunOnly !== false;
            const rows = [];
            const onProgress = typeof options.onProgress === 'function' ? options.onProgress : null;
            const apiCoverage = checkWizardApiCoverage();
            for (let round = 1; round <= rounds; round += 1) {
                for (let sceneIdx = 0; sceneIdx < scenes.length; sceneIdx += 1) {
                    const sceneName = scenes[sceneIdx];
                    const matrix = buildSceneParityCaseMatrix(sceneName, options);
                    const sceneCases = Array.isArray(matrix?.cases) ? matrix.cases.slice(0, maxCasesPerScene) : [];
                    for (let caseIdx = 0; caseIdx < sceneCases.length; caseIdx += 1) {
                        const caseInfo = sceneCases[caseIdx];
                        const row = {
                            round,
                            sceneName,
                            caseId: caseInfo?.caseId || '',
                            caseLabel: caseInfo?.label || '',
                            index: caseIdx + 1,
                            total: sceneCases.length,
                            ok: false,
                            error: '',
                            diffCount: 0,
                            diffs: [],
                            requestPreview: {},
                            submitPayloadSnapshot: {},
                            uiSnapshot: {}
                        };
                        if (onProgress) {
                            try {
                                onProgress({
                                    event: 'wizard_parity_case_start',
                                    round,
                                    sceneName,
                                    caseId: row.caseId,
                                    caseLabel: row.caseLabel,
                                    index: row.index,
                                    total: row.total
                                });
                            } catch { }
                        }
                        try {
                            const applied = await applyWizardParityCase(sceneName, caseInfo, options);
                            row.uiSnapshot = deepClone(applied.uiSnapshot || {});
                            row.requestPreview = {
                                sceneName: applied.request?.sceneName || '',
                                planName: applied.request?.plans?.[0]?.planName || '',
                                marketingGoal: normalizeGoalLabel(
                                    applied.request?.plans?.[0]?.marketingGoal
                                    || applied.request?.marketingGoal
                                    || ''
                                )
                            };
                            const submit = await collectWizardSubmitSnapshot(applied.request, {
                                ...options,
                                dryRunOnly,
                                onProgress: null
                            });
                            row.submitPayloadSnapshot = deepClone(submit?.submitPayloadSnapshot || {});
                            const compare = compareWizardParityCase({
                                sceneName,
                                request: applied.request,
                                uiSnapshot: applied.uiSnapshot,
                                submitPayloadSnapshot: submit?.submitPayloadSnapshot || {},
                                dryRunResult: submit?.result || {}
                            });
                            row.ok = !!compare.ok;
                            row.diffCount = Array.isArray(compare?.diffs) ? compare.diffs.length : 0;
                            row.diffs = Array.isArray(compare?.diffs) ? compare.diffs : [];
                            if (!submit?.ok && !row.error) {
                                row.error = submit?.error || (submit?.result?.error || '');
                            }
                        } catch (err) {
                            row.ok = false;
                            row.error = err?.message || String(err);
                        }
                        rows.push(row);
                        if (onProgress) {
                            try {
                                onProgress({
                                    event: 'wizard_parity_case_done',
                                    round,
                                    sceneName,
                                    caseId: row.caseId,
                                    caseLabel: row.caseLabel,
                                    index: row.index,
                                    total: row.total,
                                    ok: row.ok,
                                    diffCount: row.diffCount,
                                    error: row.error || ''
                                });
                            } catch { }
                        }
                    }
                }
            }
            const byScene = scenes.map(sceneName => {
                const sceneRows = rows.filter(item => item.sceneName === sceneName);
                return {
                    sceneName,
                    total: sceneRows.length,
                    pass: sceneRows.filter(item => item.ok).length,
                    fail: sceneRows.filter(item => !item.ok).length,
                    diffCount: sceneRows.reduce((sum, item) => sum + toNumber(item.diffCount, 0), 0)
                };
            });
            const byRound = Array.from({ length: rounds }).map((_, idx) => {
                const round = idx + 1;
                const roundRows = rows.filter(item => item.round === round);
                return {
                    round,
                    total: roundRows.length,
                    pass: roundRows.filter(item => item.ok).length,
                    fail: roundRows.filter(item => !item.ok).length,
                    diffCount: roundRows.reduce((sum, item) => sum + toNumber(item.diffCount, 0), 0)
                };
            });
            const result = {
                ok: rows.length > 0 && rows.every(item => item.ok),
                dryRunOnly,
                rounds,
                scenes,
                scannedAt: new Date().toISOString(),
                count: rows.length,
                successCount: rows.filter(item => item.ok).length,
                failCount: rows.filter(item => !item.ok).length,
                byScene,
                byRound,
                apiCoverage,
                list: rows
            };
            window.__AM_WXT_WIZARD_PARITY_RESULT__ = result;
            return result;
        };

        const CREATE_FAILURE_CONFLICT_RE = /(onebpsite-existed|horizontal-onebpsite-existed|daily-existed|crossaccount-existed|order-existed|diffbizcode-existed|å­˜åœ¨åœ¨æŠ•è®¡åˆ’|åœ¨æŠ•è®¡åˆ’|æŒç»­æ¨å¹¿è®¡åˆ’|å†²çª|å·²å­˜åœ¨.*è®¡åˆ’|è®¡åˆ’å·²å­˜åœ¨|already.*exist|conflict)/i;
        const CREATE_FAILURE_ONE_CLICK_CONFLICT_CODE_RE = /(crossaccount-existed|onebpsite-existed|horizontal-onebpsite-existed|order-existed|daily-existed|diffbizcode-existed)/i;
        const CREATE_FAILURE_PERMISSION_RE = /(csrf|403|æ— æƒé™|æƒé™ä¸è¶³|é£æ§|ç™»å½•å¤±æ•ˆ|bizlogin|forbidden)/i;
        const CREATE_FAILURE_MAPPING_RE = /(ä¸æ”¯æŒçš„å‡ºä»·ç±»å‹|INVALID_PARAMETER|å‚æ•°.*(éæ³•|é”™è¯¯|æ ¡éªŒå¤±è´¥)|å­—æ®µ.*(ç¼ºå¤±|é”™è¯¯)|unsupported)/i;

        const classifyCreateFailure = (errorText = '') => {
            const text = String(errorText || '').trim();
            if (!text) return 'unknown';
            if (isWordPackageValidationError(text)) return 'keyword_word_package';
            if (CREATE_FAILURE_CONFLICT_RE.test(text)) return 'conflict';
            if (CREATE_FAILURE_PERMISSION_RE.test(text)) return 'permission_or_risk';
            if (CREATE_FAILURE_MAPPING_RE.test(text)) return 'mapping';
            return 'unknown';
        };

        const toPositiveIdText = (value) => {
            if (value === undefined || value === null || value === '') return '';
            const text = String(value).trim();
            if (!/^\d{4,}$/.test(text)) return '';
            return text;
        };

        const normalizeCampaignRefList = (list = []) => uniqueBy(
            (Array.isArray(list) ? list : [])
                .map(item => {
                    const campaignId = toPositiveIdText(item?.campaignId || item?.planId || item?.id || '');
                    if (!campaignId) return null;
                    return {
                        campaignId,
                        itemId: toPositiveIdText(item?.itemId || item?.materialId || ''),
                        status: item?.status,
                        source: normalizeText(item?.source || '')
                    };
                })
                .filter(Boolean),
            item => `${item.campaignId}::${item.itemId || ''}`
        );

        const collectCampaignRefsFromNode = (node, out = [], state = {}) => {
            if (!node || typeof node !== 'object') return;
            const seen = state.seen || new WeakSet();
            const depth = toNumber(state.depth, 0);
            if (depth > 12) return;
            if (node && typeof node === 'object') {
                if (seen.has(node)) return;
                seen.add(node);
            }
            if (Array.isArray(node)) {
                node.forEach(item => collectCampaignRefsFromNode(item, out, { seen, depth: depth + 1 }));
                return;
            }
            if (!isPlainObject(node)) return;

            const localItemId = toPositiveIdText(
                node.itemId
                || node.materialId
                || node.auctionId
                || node.targetItemId
                || node.targetMaterialId
            );
            const localStatus = node.status !== undefined
                ? node.status
                : (node.onlineStatus !== undefined ? node.onlineStatus : node.campaignStatus);
            const idKeys = ['campaignId', 'campaign_id', 'planId', 'plan_id', 'bpCampaignId', 'targetCampaignId'];
            idKeys.forEach(key => {
                const campaignId = toPositiveIdText(node[key]);
                if (!campaignId) return;
                out.push({
                    campaignId,
                    itemId: localItemId || '',
                    status: localStatus,
                    source: `node.${key}`
                });
            });
            const idListKeys = ['campaignIdList', 'campaign_id_list', 'planIdList', 'plan_id_list', 'campaignIds', 'planIds', 'idList'];
            idListKeys.forEach(key => {
                const list = Array.isArray(node[key]) ? node[key] : [];
                list.forEach(id => {
                    const campaignId = toPositiveIdText(id);
                    if (!campaignId) return;
                    out.push({
                        campaignId,
                        itemId: localItemId || '',
                        status: localStatus,
                        source: `node.${key}`
                    });
                });
            });
            Object.keys(node).forEach(key => {
                const val = node[key];
                if (!val || typeof val !== 'object') return;
                collectCampaignRefsFromNode(val, out, { seen, depth: depth + 1 });
            });
        };

        const extractCampaignRefsFromErrorText = (errorText = '') => {
            const text = String(errorText || '').trim();
            if (!text) return [];
            const refs = [];
            const scoped = text.match(/(?:campaignId|campaign_id|planId|plan_id)[=:ï¼š\s]*(\d{4,})/ig) || [];
            scoped.forEach(segment => {
                const id = toPositiveIdText((segment.match(/(\d{4,})/) || [])[1]);
                if (!id) return;
                refs.push({
                    campaignId: id,
                    itemId: '',
                    status: '',
                    source: 'error_text_scoped'
                });
            });
            if (!refs.length) {
                const fallbackNumbers = text.match(/\d{6,}/g) || [];
                fallbackNumbers.slice(0, 8).forEach(id => {
                    refs.push({
                        campaignId: toPositiveIdText(id),
                        itemId: '',
                        status: '',
                        source: 'error_text_fallback'
                    });
                });
            }
            return normalizeCampaignRefList(refs);
        };

        const extractConflictCampaignRefs = (failureEntry = {}, itemId = '') => {
            const refs = [];
            if (isPlainObject(failureEntry?.response)) {
                collectCampaignRefsFromNode(failureEntry.response, refs, { depth: 0, seen: new WeakSet() });
            }
            if (isPlainObject(failureEntry?.detail)) {
                collectCampaignRefsFromNode(failureEntry.detail, refs, { depth: 0, seen: new WeakSet() });
            }
            if (isPlainObject(failureEntry?.fullResponse)) {
                collectCampaignRefsFromNode(failureEntry.fullResponse, refs, { depth: 0, seen: new WeakSet() });
            }
            const textRefs = extractCampaignRefsFromErrorText(failureEntry?.error || '');
            refs.push(...textRefs);
            const normalized = normalizeCampaignRefList(refs);
            const targetItemId = toPositiveIdText(itemId);
            if (!targetItemId) return normalized;
            const sameItem = normalized.filter(item => item.itemId && item.itemId === targetItemId);
            if (sameItem.length) return sameItem;
            return normalized;
        };

        const isCampaignStatusActive = (statusValue) => {
            if (statusValue === undefined || statusValue === null || statusValue === '') return null;
            if (typeof statusValue === 'boolean') return statusValue;
            const num = Number(statusValue);
            if (Number.isFinite(num)) {
                if (num === 1) return true;
                if (num === 0) return false;
            }
            const text = String(statusValue).trim().toLowerCase();
            if (!text) return null;
            if (/(online|active|running|enable|æŠ•æ”¾|åœ¨æŠ•|å¼€å¯|on)/.test(text)) return true;
            if (/(offline|pause|stop|suspend|disable|åˆ é™¤|ä¸‹çº¿|æš‚åœ|å…³é—­|off)/.test(text)) return false;
            return null;
        };

        const buildLifecyclePayloadByContract = (contract = {}, context = {}) => {
            const requestKeys = Array.isArray(contract?.requestKeys) ? contract.requestKeys : [];
            const bodyKeys = Array.isArray(contract?.bodyKeys) ? contract.bodyKeys : requestKeys;
            const keyList = uniqueBy(requestKeys.concat(bodyKeys).map(item => normalizeText(item)).filter(Boolean), item => item);
            const itemId = toPositiveIdText(context?.itemId || '');
            const campaignId = toPositiveIdText(context?.campaignId || '');
            const campaignIdList = uniqueBy(
                (Array.isArray(context?.campaignIdList) ? context.campaignIdList : [campaignId])
                    .map(item => toPositiveIdText(item))
                    .filter(Boolean),
                item => item
            );
            const fallbackPayload = {
                itemId,
                materialId: itemId,
                campaignId,
                campaignIdList: campaignIdList.slice(0, 50),
                pageNo: 1,
                pageSize: 50,
                offset: 0
            };
            if (!keyList.length) {
                return Object.keys(fallbackPayload).reduce((acc, key) => {
                    const value = fallbackPayload[key];
                    if (value === undefined || value === null || value === '' || (Array.isArray(value) && !value.length)) return acc;
                    acc[key] = value;
                    return acc;
                }, {});
            }
            const payload = {};
            keyList.forEach(rawKey => {
                const key = String(rawKey || '').trim();
                const lower = key.toLowerCase();
                if (!key) return;
                if (lower === 'bizcode' || lower === 'csrfid' || lower === 'loginpointid') return;
                if (/itemidlist|materialidlist/.test(lower)) {
                    payload[key] = itemId ? [itemId] : [];
                    return;
                }
                if (/itemid|materialid|auctionid/.test(lower)) {
                    if (itemId) payload[key] = itemId;
                    return;
                }
                if (/campaignidlist|planidlist|campaignids|planids|idlist/.test(lower)) {
                    if (campaignIdList.length) payload[key] = campaignIdList.slice(0, 50);
                    return;
                }
                if (/campaignid|planid|targetcampaignid/.test(lower)) {
                    if (campaignId) payload[key] = campaignId;
                    return;
                }
                if (/pagesize|limit|size/.test(lower)) {
                    payload[key] = Math.max(20, toNumber(context?.pageSize, 50));
                    return;
                }
                if (/pageno|pageindex|page|offset|start/.test(lower)) {
                    payload[key] = /offset|start/.test(lower) ? 0 : 1;
                    return;
                }
                if (/status|online/.test(lower) && context?.desiredStatus !== undefined) {
                    payload[key] = context.desiredStatus;
                    return;
                }
                if (/keyword|search|query/.test(lower) && context?.query !== undefined) {
                    payload[key] = context.query;
                }
            });
            return payload;
        };

        const executeLifecycleActionByContract = async (sceneName = '', action = '', context = {}, options = {}) => {
            const targetScene = String(sceneName || '').trim();
            const normalizedAction = normalizeLifecycleAction(action);
            const bizCode = normalizeSceneBizCode(
                context?.bizCode
                || options?.bizCode
                || resolveSceneBizCodeHint(targetScene)
                || SCENE_BIZCODE_HINT_FALLBACK[targetScene]
                || DEFAULTS.bizCode
            ) || DEFAULTS.bizCode;
            const contractResult = getLifecycleContract(targetScene, normalizedAction, options);
            if (!contractResult?.ok || !contractResult.contract) {
                return {
                    ok: false,
                    sceneName: targetScene,
                    action: normalizedAction,
                    contract: null,
                    payload: {},
                    response: null,
                    error: contractResult?.error || 'lifecycle_contract_not_ready'
                };
            }
            const contract = contractResult.contract;
            const payload = buildLifecyclePayloadByContract(contract, context);
            let captureId = '';
            if (options.capture !== false) {
                try {
                    captureId = startNetworkCapture({ sceneName: targetScene }).captureId || '';
                } catch { }
            }
            try {
                const response = await requestOne(contract.endpoint, bizCode, payload, options.requestOptions || {});
                return {
                    ok: true,
                    sceneName: targetScene,
                    action: normalizedAction,
                    contract,
                    payload,
                    response,
                    error: ''
                };
            } catch (err) {
                return {
                    ok: false,
                    sceneName: targetScene,
                    action: normalizedAction,
                    contract,
                    payload,
                    response: null,
                    error: err?.message || String(err)
                };
            } finally {
                if (captureId) {
                    try {
                        const stopped = stopNetworkCapture(captureId, { withRecords: false });
                        if (Array.isArray(stopped?.contracts) && stopped.contracts.length) {
                            rememberLifecycleContractsFromContractList(targetScene, stopped.contracts, {
                                source: `lifecycle_action_${normalizedAction}`
                            });
                        }
                    } catch { }
                }
            }
        };

        const queryConflictCampaignRefsByItem = async (sceneName = '', itemId = '', options = {}) => {
            const targetItemId = toPositiveIdText(itemId);
            const listAction = await executeLifecycleActionByContract(sceneName, 'list_conflict', {
                itemId: targetItemId,
                bizCode: options.bizCode || '',
                pageSize: Math.max(20, toNumber(options.pageSize, 80)),
                query: targetItemId
            }, options);
            if (!listAction.ok) {
                return {
                    ok: false,
                    refs: [],
                    response: null,
                    error: listAction.error || 'list_conflict_failed'
                };
            }
            const refs = [];
            collectCampaignRefsFromNode(listAction.response, refs, { depth: 0, seen: new WeakSet() });
            const normalized = normalizeCampaignRefList(refs);
            const filtered = targetItemId
                ? normalized.filter(item => !item.itemId || item.itemId === targetItemId)
                : normalized;
            return {
                ok: true,
                refs: filtered,
                response: listAction.response,
                error: ''
            };
        };

        const extractConflictItemIdList = (failureEntry = {}, fallbackItemId = '') => {
            const out = [];
            const pushId = (value) => {
                const id = toPositiveIdText(value);
                if (!id) return;
                out.push(id);
            };
            pushId(fallbackItemId);
            if (isPlainObject(failureEntry?.detail)) {
                pushId(failureEntry.detail.itemId || failureEntry.detail.materialId || failureEntry.detail.auctionId || '');
            }
            if (isPlainObject(failureEntry?.response)) {
                pushId(failureEntry.response.itemId || failureEntry.response.materialId || failureEntry.response.auctionId || '');
            }
            const detailList = Array.isArray(failureEntry?.fullResponse?.data?.errorDetails)
                ? failureEntry.fullResponse.data.errorDetails
                : [];
            detailList.forEach(detail => {
                if (!isPlainObject(detail?.result)) return;
                pushId(detail.result.itemId || detail.result.materialId || detail.result.auctionId || '');
            });
            return uniqueBy(out, item => item);
        };

        const resolveConflictByOneClick = async (failureEntry = {}, context = {}) => {
            const failureCode = normalizeText(failureEntry?.code || '');
            const failureError = normalizeText(failureEntry?.error || '');
            const applicable = (failureCode && CREATE_FAILURE_ONE_CLICK_CONFLICT_CODE_RE.test(failureCode))
                || (!failureCode && CREATE_FAILURE_ONE_CLICK_CONFLICT_CODE_RE.test(failureError));
            if (!applicable) {
                return {
                    ok: false,
                    handled: false,
                    itemIdList: [],
                    pauseCampaignList: [],
                    stoppedCampaignIds: [],
                    failedItems: [],
                    conflictBizCode: '',
                    fromBizCode: '',
                    error: 'one_click_not_applicable'
                };
            }
            const itemIdList = extractConflictItemIdList(failureEntry, context?.itemId || '');
            if (!itemIdList.length) {
                return {
                    ok: false,
                    handled: false,
                    itemIdList: [],
                    pauseCampaignList: [],
                    stoppedCampaignIds: [],
                    failedItems: [],
                    conflictBizCode: '',
                    fromBizCode: '',
                    error: 'one_click_item_missing'
                };
            }
            const detailBizCode = normalizeSceneBizCode(
                failureEntry?.detail?.bizCode
                || failureEntry?.response?.bizCode
                || ''
            );
            const conflictBizCode = normalizeSceneBizCode(
                context?.conflictBizCode
                || detailBizCode
                || resolveSceneBizCodeHint(context?.sceneName || '')
                || 'onebpSite'
            ) || 'onebpSite';
            const fromBizCode = normalizeSceneBizCode(
                context?.fromBizCode
                || context?.entryBizCode
                || context?.bizCode
                || resolveSceneBizCodeHint(context?.entrySceneName || '')
                || DEFAULTS.bizCode
            ) || DEFAULTS.bizCode;
            const errorExtInfo = isPlainObject(context?.errorExtInfo)
                ? deepClone(context.errorExtInfo)
                : (isPlainObject(failureEntry?.fullResponse?.data?.errorExtInfo)
                    ? deepClone(failureEntry.fullResponse.data.errorExtInfo)
                    : {});
            const pauseCampaignList = [];
            const failedItems = [];
            for (let i = 0; i < itemIdList.length; i++) {
                const itemId = itemIdList[i];
                try {
                    const response = await requestOne('/campaign/onebpSite/oneClick.json', conflictBizCode, {
                        ...errorExtInfo,
                        fromBizCode,
                        itemIdList: [itemId],
                        bizCode: conflictBizCode
                    }, context?.requestOptions || {});
                    const list = Array.isArray(response?.data?.list) ? response.data.list : [];
                    if (list.length) pauseCampaignList.push(...list);
                    const errorDetails = Array.isArray(response?.data?.errorDetails) ? response.data.errorDetails : [];
                    if (errorDetails.length) {
                        failedItems.push({
                            itemId,
                            error: errorDetails.map(detail => `${detail?.code || 'ERROR'}ï¼š${detail?.msg || 'one_click_failed'}`).join('ï¼›')
                        });
                    }
                } catch (err) {
                    failedItems.push({
                        itemId,
                        error: err?.message || String(err)
                    });
                }
            }
            const stoppedCampaignIds = uniqueBy(
                pauseCampaignList
                    .map(item => toPositiveIdText(item?.campaignId || item?.planId || item?.id || ''))
                    .filter(Boolean),
                item => item
            );
            const ok = failedItems.length === 0;
            return {
                ok,
                handled: itemIdList.length > 0 && ok,
                itemIdList,
                pauseCampaignList,
                stoppedCampaignIds,
                failedItems,
                conflictBizCode,
                fromBizCode,
                error: ok ? '' : 'one_click_partial_failed'
            };
        };

        const resolveCreateConflicts = async (failureEntry = {}, context = {}) => {
            const sceneName = String(context?.sceneName || '').trim();
            const itemId = toPositiveIdText(context?.itemId || '');
            const conflictPolicy = String(context?.conflictPolicy || 'auto_stop_retry').trim();
            const stopScope = String(context?.stopScope || 'same_item_only').trim();
            const classification = classifyCreateFailure(failureEntry?.error || '');
            if (classification !== 'conflict') {
                return {
                    ok: false,
                    handled: false,
                    classification,
                    sceneName,
                    itemId,
                    stoppedCampaignIds: [],
                    unresolvedCampaignIds: [],
                    error: 'not_conflict_failure'
                };
            }
            if (conflictPolicy !== 'auto_stop_retry') {
                return {
                    ok: false,
                    handled: false,
                    classification,
                    sceneName,
                    itemId,
                    stoppedCampaignIds: [],
                    unresolvedCampaignIds: [],
                    error: 'conflict_policy_disabled'
                };
            }

            let oneClickResult = null;
            if (context?.oneClickConflictResolve !== false) {
                oneClickResult = await resolveConflictByOneClick(failureEntry, {
                    ...context,
                    sceneName,
                    itemId
                });
                if (oneClickResult?.handled && oneClickResult?.ok) {
                    const stoppedIds = Array.isArray(oneClickResult?.stoppedCampaignIds)
                        ? oneClickResult.stoppedCampaignIds
                        : [];
                    return {
                        ok: true,
                        handled: true,
                        classification,
                        sceneName,
                        itemId,
                        stoppedCampaignIds: uniqueBy(stoppedIds, id => id),
                        unresolvedCampaignIds: [],
                        pauseConfirmedIds: uniqueBy(stoppedIds, id => id),
                        deletedFallbackCampaignIds: [],
                        oneClickResult,
                        error: ''
                    };
                }
            }

            let refs = extractConflictCampaignRefs(failureEntry, itemId);
            if (!refs.length) {
                const queried = await queryConflictCampaignRefsByItem(sceneName, itemId, {
                    bizCode: context?.bizCode || '',
                    requestOptions: context?.requestOptions || {},
                    capture: context?.capture !== false
                });
                if (queried.ok) refs = queried.refs;
            }
            if (stopScope === 'same_item_only') {
                refs = refs.filter(item => item.itemId && item.itemId === itemId);
            }
            if (!refs.length) {
                return {
                    ok: false,
                    handled: false,
                    classification,
                    sceneName,
                    itemId,
                    stoppedCampaignIds: [],
                    unresolvedCampaignIds: [],
                    oneClickResult,
                    error: oneClickResult?.error || 'conflict_campaign_not_found'
                };
            }

            const stoppedCampaignIds = [];
            const unresolvedCampaignIds = [];
            const deletedFallbackCampaignIds = [];
            for (let i = 0; i < refs.length; i++) {
                const ref = refs[i];
                const campaignId = toPositiveIdText(ref.campaignId);
                if (!campaignId) continue;
                const pauseAction = await executeLifecycleActionByContract(sceneName, 'pause', {
                    itemId,
                    campaignId,
                    campaignIdList: [campaignId],
                    desiredStatus: 0,
                    bizCode: context?.bizCode || ''
                }, {
                    requestOptions: context?.requestOptions || {},
                    capture: context?.capture !== false
                });
                if (pauseAction.ok) {
                    stoppedCampaignIds.push(campaignId);
                } else {
                    const allowDeleteFallback = context?.conflictDeleteFallback !== false;
                    if (allowDeleteFallback) {
                        const deleteAction = await executeLifecycleActionByContract(sceneName, 'delete', {
                            itemId,
                            campaignId,
                            campaignIdList: [campaignId],
                            bizCode: context?.bizCode || ''
                        }, {
                            requestOptions: context?.requestOptions || {},
                            capture: context?.capture !== false
                        });
                        if (deleteAction.ok) {
                            stoppedCampaignIds.push(campaignId);
                            deletedFallbackCampaignIds.push(campaignId);
                        } else {
                            unresolvedCampaignIds.push(campaignId);
                        }
                    } else {
                        unresolvedCampaignIds.push(campaignId);
                    }
                }
            }

            const pollTimes = Math.max(1, toNumber(context?.pollTimes, 3));
            const pollIntervalMs = Math.max(500, toNumber(context?.pollIntervalMs, 2000));
            let pauseConfirmedIds = [];
            let pausePendingIds = stoppedCampaignIds.slice();
            if (stoppedCampaignIds.length) {
                for (let i = 0; i < pollTimes; i++) {
                    const query = await queryConflictCampaignRefsByItem(sceneName, itemId, {
                        bizCode: context?.bizCode || '',
                        requestOptions: context?.requestOptions || {},
                        capture: false
                    });
                    if (!query.ok) break;
                    const activeSet = new Set(
                        query.refs
                            .filter(ref => {
                                const active = isCampaignStatusActive(ref.status);
                                return active !== false;
                            })
                            .map(ref => ref.campaignId)
                    );
                    pauseConfirmedIds = stoppedCampaignIds.filter(id => !activeSet.has(id));
                    pausePendingIds = stoppedCampaignIds.filter(id => activeSet.has(id));
                    if (!pausePendingIds.length) break;
                    await sleep(pollIntervalMs);
                }
            }
            unresolvedCampaignIds.push(...pausePendingIds);
            return {
                ok: unresolvedCampaignIds.length === 0 && stoppedCampaignIds.length > 0,
                handled: stoppedCampaignIds.length > 0,
                classification,
                sceneName,
                itemId,
                stoppedCampaignIds: uniqueBy(stoppedCampaignIds, id => id),
                unresolvedCampaignIds: uniqueBy(unresolvedCampaignIds, id => id),
                pauseConfirmedIds: uniqueBy(pauseConfirmedIds, id => id),
                deletedFallbackCampaignIds: uniqueBy(deletedFallbackCampaignIds, id => id),
                oneClickResult,
                error: unresolvedCampaignIds.length ? 'pause_not_fully_confirmed' : ''
            };
        };

        const cleanupCreatedPlansByLifecycle = async (records = [], options = {}) => {
            const list = Array.isArray(records) ? records : [];
            const deletedCampaignIds = [];
            const pausedFallbackCampaignIds = [];
            const failedList = [];
            for (let i = 0; i < list.length; i++) {
                const entry = list[i] || {};
                const sceneName = String(entry.sceneName || '').trim();
                const campaignId = toPositiveIdText(entry.campaignId || '');
                const itemId = toPositiveIdText(entry.itemId || '');
                if (!sceneName || !campaignId) continue;
                const deleteAction = await executeLifecycleActionByContract(sceneName, 'delete', {
                    itemId,
                    campaignId,
                    campaignIdList: [campaignId],
                    bizCode: options.bizCode || ''
                }, {
                    requestOptions: options.requestOptions || {},
                    capture: options.capture !== false
                });
                if (deleteAction.ok) {
                    deletedCampaignIds.push(campaignId);
                    continue;
                }
                const pauseFallback = await executeLifecycleActionByContract(sceneName, 'pause', {
                    itemId,
                    campaignId,
                    campaignIdList: [campaignId],
                    desiredStatus: 0,
                    bizCode: options.bizCode || ''
                }, {
                    requestOptions: options.requestOptions || {},
                    capture: options.capture !== false
                });
                if (pauseFallback.ok) {
                    pausedFallbackCampaignIds.push(campaignId);
                    failedList.push({
                        sceneName,
                        campaignId,
                        itemId,
                        error: `delete_failed_fallback_paused: ${deleteAction.error || ''}`.trim()
                    });
                } else {
                    failedList.push({
                        sceneName,
                        campaignId,
                        itemId,
                        error: `delete_failed:${deleteAction.error || 'unknown'}; pause_failed:${pauseFallback.error || 'unknown'}`
                    });
                }
            }
            return {
                ok: failedList.length === 0,
                deletedCampaignIds: uniqueBy(deletedCampaignIds, id => id),
                pausedFallbackCampaignIds: uniqueBy(pausedFallbackCampaignIds, id => id),
                failedList
            };
        };

        const buildSceneGoalOptionCaseMatrix = async (sceneName = '', options = {}) => {
            const targetScene = String(sceneName || '').trim();
            if (!targetScene) {
                return {
                    ok: false,
                    sceneName: '',
                    caseCount: 0,
                    list: [],
                    warnings: ['ç¼ºå°‘ sceneName']
                };
            }
            const maxGoalsPerScene = Math.max(1, Math.min(40, toNumber(options.maxGoalsPerScene, 24)));
            const maxCasesPerGoal = Math.max(1, Math.min(360, toNumber(options.maxCasesPerGoal, 120)));
            const maxCasesPerScene = Math.max(1, Math.min(900, toNumber(options.maxCasesPerScene, 360)));
            const resolveExplicitGoalLabels = () => {
                if (Array.isArray(options.goalLabels)) {
                    return uniqueBy(
                        options.goalLabels
                            .map(item => normalizeGoalCandidateLabel(item))
                            .filter(Boolean),
                        item => item
                    ).slice(0, 24);
                }
                if (isPlainObject(options.goalLabels)) {
                    const list = options.goalLabels[targetScene];
                    if (!Array.isArray(list)) return [];
                    return uniqueBy(
                        list
                            .map(item => normalizeGoalCandidateLabel(item))
                            .filter(Boolean),
                        item => item
                    ).slice(0, 24);
                }
                return [];
            };
            const explicitGoalLabels = resolveExplicitGoalLabels();
            const quickCaseOnly = options.quickCaseOnly === true;
            const shouldSkipScan = quickCaseOnly || explicitGoalLabels.length > 0 || options.skipGoalSpecScan === true;
            let extracted = { goals: [], warnings: [] };
            if (!shouldSkipScan) {
                extracted = await extractSceneGoalSpecs(targetScene, {
                    scanMode: options.scanMode || 'full_top_down',
                    unlockPolicy: options.unlockPolicy || 'safe_only',
                    goalScan: true,
                    goalFieldScan: options.goalFieldScan !== false,
                    goalFieldScanMode: options.goalFieldScanMode || 'full_top_down',
                    goalFieldMaxDepth: toNumber(options.goalFieldMaxDepth, 2),
                    goalFieldMaxSnapshots: toNumber(options.goalFieldMaxSnapshots, 48),
                    goalFieldMaxGroupsPerLevel: toNumber(options.goalFieldMaxGroupsPerLevel, 6),
                    goalFieldMaxOptionsPerGroup: toNumber(options.goalFieldMaxOptionsPerGroup, 8),
                    refresh: !!options.refreshGoalSpecs
                });
            }
            const goalsRaw = explicitGoalLabels.length
                ? explicitGoalLabels.map((label, idx) => ({
                    goalLabel: label,
                    isDefault: idx === 0,
                    fieldRows: []
                }))
                : (Array.isArray(extracted?.goals) && extracted.goals.length
                    ? extracted.goals
                    : [{ goalLabel: '', isDefault: true, fieldRows: [] }]);
            const fallbackGoalLabels = getSceneMarketingGoalFallbackList(targetScene);
            const goalsExpanded = goalsRaw.slice();
            const existingGoalSet = new Set(
                goalsExpanded.map(goal => normalizeGoalCandidateLabel(goal?.goalLabel || '')).filter(Boolean)
            );
            fallbackGoalLabels.forEach(label => {
                if (existingGoalSet.has(label)) return;
                goalsExpanded.push({
                    goalLabel: label,
                    isDefault: false,
                    fieldRows: []
                });
            });
            const goals = goalsExpanded.slice(0, maxGoalsPerScene);
            const cases = [];
            goals.forEach(goal => {
                const goalLabel = normalizeGoalLabel(goal?.goalLabel || '');
                const fallbackFieldRows = getSceneGoalFieldRowFallback(targetScene, goalLabel);
                const goalForCases = {
                    ...goal,
                    fieldRows: Array.isArray(goal?.fieldRows) && goal.fieldRows.length
                        ? goal.fieldRows
                        : fallbackFieldRows
                };
                if (quickCaseOnly) {
                    cases.push({
                        sceneName: targetScene,
                        goalLabel,
                        caseId: 'goal_default',
                        caseType: 'goal_default',
                        fieldLabel: '',
                        optionValue: '',
                        triggerPath: '',
                        dependsOn: [],
                        sceneSettingsPatch: {}
                    });
                    return;
                }
                const rowCases = buildGoalOptionSimulationCases(goalForCases, {
                    maxOptionsPerField: options.maxOptionsPerField,
                    maxCasesPerGoal,
                    includeBaseCase: options.includeBaseCase !== false
                });
                rowCases.forEach(caseInfo => {
                    cases.push({
                        sceneName: targetScene,
                        goalLabel,
                        caseId: caseInfo.caseId || '',
                        caseType: caseInfo.caseType || 'goal_default',
                        fieldLabel: caseInfo.fieldLabel || '',
                        optionValue: caseInfo.optionValue || '',
                        triggerPath: caseInfo.triggerPath || '',
                        dependsOn: Array.isArray(caseInfo.dependsOn) ? caseInfo.dependsOn.slice(0, 12) : [],
                        sceneSettingsPatch: isPlainObject(caseInfo.sceneSettingsPatch) ? deepClone(caseInfo.sceneSettingsPatch) : {}
                    });
                });
            });
            const deduped = uniqueBy(cases, item => `${item.sceneName}::${item.goalLabel}::${JSON.stringify(normalizeSceneSettingsObject(item.sceneSettingsPatch || {}))}`)
                .slice(0, maxCasesPerScene);
            return {
                ok: true,
                sceneName: targetScene,
                caseCount: deduped.length,
                list: deduped,
                warnings: Array.isArray(extracted?.warnings) ? extracted.warnings.slice(0, 80) : []
            };
        };

        const runCreateRepairByItem = async (itemId, options = {}) => {
            const targetItemId = toPositiveIdText(itemId || options.itemId || options.materialId || '');
            if (!targetItemId) {
                return {
                    ok: false,
                    summary: null,
                    createdCampaignIds: [],
                    stoppedCampaignIds: [],
                    deletedCampaignIds: [],
                    unresolvedFailures: [{
                        sceneName: '',
                        goalLabel: '',
                        caseId: '',
                        error: 'ç¼ºå°‘ itemId'
                    }],
                    warnings: ['itemId ä¸èƒ½ä¸ºç©º']
                };
            }

            const coverageMode = String(options.coverageMode || 'scene_goal_option_full').trim();
            const conflictPolicy = String(options.conflictPolicy || 'auto_stop_retry').trim();
            const stopScope = String(options.stopScope || 'same_item_only').trim();
            const postCleanup = String(options.postCleanup || 'delete').trim();
            const fallbackPolicy = normalizeFallbackPolicy(options.fallbackPolicy || 'auto', 'auto');
            const scenes = Array.isArray(options.scenes) && options.scenes.length
                ? uniqueBy(options.scenes.map(item => String(item || '').trim()).filter(Boolean), item => item)
                : SCENE_NAME_LIST.slice();
            const requestOptions = mergeDeep({
                maxRetries: 1,
                timeout: Math.max(8000, toNumber(options.requestTimeout, 22000))
            }, isPlainObject(options.requestOptions) ? options.requestOptions : {});
            const shouldStop = typeof options.shouldStop === 'function'
                ? options.shouldStop
                : () => false;
            const isStopRequested = () => {
                try {
                    return !!shouldStop();
                } catch {
                    return false;
                }
            };
            const skipGoalSpecScan = options.skipGoalSpecScan !== false;
            const quickCaseOnly = coverageMode !== 'scene_goal_option_full';

            const createdRecords = [];
            const stoppedCampaignIds = [];
            const unresolvedFailures = [];
            const byScene = [];
            let globalCaseSeq = 0;
            let stopped = false;

            for (let sceneIdx = 0; sceneIdx < scenes.length; sceneIdx++) {
                if (isStopRequested()) {
                    stopped = true;
                    break;
                }
                const sceneName = scenes[sceneIdx];
                emitProgress(options, 'scene_option_submit_start', {
                    sceneName,
                    index: sceneIdx + 1,
                    total: scenes.length,
                    coverageMode
                });

                const lifecycleReady = await extractLifecycleContracts(sceneName, {
                    refresh: options.refreshLifecycleContracts === true,
                    scanMode: options.scanMode || 'full_top_down',
                    unlockPolicy: options.unlockPolicy || 'safe_only',
                    fromSceneGoalSpecs: options.lifecycleFromSceneGoalSpecs === true,
                    includeActiveCaptures: options.includeActiveCaptures !== false,
                    includeHookHistory: options.includeHookHistory !== false
                });
                const missingLifecycle = Array.isArray(lifecycleReady?.actions)
                    ? lifecycleReady.actions.filter(item => !item?.ok).map(item => item.action)
                    : [];
                if (missingLifecycle.length) {
                    emitProgress(options, 'scene_lifecycle_contract_missing', {
                        sceneName,
                        missingActions: missingLifecycle
                    });
                }

                const matrix = await buildSceneGoalOptionCaseMatrix(sceneName, {
                    ...options,
                    includeBaseCase: true,
                    quickCaseOnly,
                    skipGoalSpecScan
                });
                const cases = Array.isArray(matrix?.list) ? matrix.list : [];
                const sceneStats = {
                    sceneName,
                    total: cases.length,
                    pass: 0,
                    repaired: 0,
                    failed: 0,
                    deleted: 0,
                    stopped: 0
                };

                for (let caseIdx = 0; caseIdx < cases.length; caseIdx++) {
                    if (isStopRequested()) {
                        stopped = true;
                        break;
                    }
                    const caseInfo = cases[caseIdx] || {};
                    globalCaseSeq += 1;
                    const request = buildSmokeTestRequestByScene(sceneName, targetItemId, {
                        index: globalCaseSeq,
                        dayAverageBudget: Math.max(30, toNumber(options.dayAverageBudget, 100))
                    });
                    const goalLabel = normalizeGoalLabel(caseInfo.goalLabel || request.marketingGoal || '');
                    request.marketingGoal = goalLabel || request.marketingGoal || '';
                    request.common = mergeDeep({}, request.common || {}, {
                        marketingGoal: goalLabel || request?.common?.marketingGoal || ''
                    });
                    request.sceneSettings = mergeDeep({}, request.sceneSettings || {}, caseInfo.sceneSettingsPatch || {});
                    if (Array.isArray(request?.plans) && request.plans[0]) {
                        request.plans[0].itemId = targetItemId;
                        request.plans[0].planName = `${sceneName}_${nowStampSeconds()}_${String(globalCaseSeq).padStart(4, '0')}`;
                    }
                    if (isPlainObject(options.requestOverrides)) {
                        mergeDeep(request, options.requestOverrides);
                    }

                    emitProgress(options, 'case_start', {
                        sceneName,
                        goalLabel,
                        caseId: caseInfo.caseId || '',
                        caseType: caseInfo.caseType || '',
                        index: caseIdx + 1,
                        total: cases.length,
                        planName: request?.plans?.[0]?.planName || ''
                    });

                    const captureStart = startNetworkCapture({ sceneName });
                    let runResult = null;
                    let runError = '';
                    try {
                        runResult = await createPlansByScene(sceneName, request, {
                            fallbackPolicy,
                            batchRetry: Math.max(0, toNumber(options.batchRetry, 1)),
                            chunkSize: Math.max(1, toNumber(options.chunkSize, 1)),
                            applySceneSpec: false,
                            syncSceneRuntime: false,
                            strictSceneRuntimeMatch: false,
                            requestOptions
                        });
                    } catch (err) {
                        runError = err?.message || String(err);
                    }
                    let stoppedCapture = null;
                    try {
                        stoppedCapture = stopNetworkCapture(captureStart?.captureId || '', { withRecords: false });
                    } catch { }
                    if (Array.isArray(stoppedCapture?.contracts) && stoppedCapture.contracts.length) {
                        rememberLifecycleContractsFromContractList(sceneName, stoppedCapture.contracts, {
                            source: 'run_create_repair_case'
                        });
                    }

                    if (!runError && runResult?.ok) {
                        const successes = Array.isArray(runResult.successes) ? runResult.successes : [];
                        successes.forEach(entry => {
                            const campaignId = toPositiveIdText(entry?.campaignId || '');
                            if (!campaignId) return;
                            createdRecords.push({
                                sceneName,
                                goalLabel,
                                caseId: caseInfo.caseId || '',
                                campaignId,
                                itemId: targetItemId
                            });
                        });
                        sceneStats.pass += 1;
                        continue;
                    }

                    const failures = Array.isArray(runResult?.failures) && runResult.failures.length
                        ? runResult.failures
                        : [{
                            planName: request?.plans?.[0]?.planName || '',
                            item: { materialId: targetItemId },
                            error: runError || 'create_failed'
                        }];
                    const primaryFailure = failures[0] || {};
                    const classification = classifyCreateFailure(primaryFailure?.error || runError || '');
                    if (classification === 'conflict' && conflictPolicy === 'auto_stop_retry') {
                        emitProgress(options, 'conflict_detected', {
                            sceneName,
                            goalLabel,
                            caseId: caseInfo.caseId || '',
                            error: primaryFailure?.error || runError || ''
                        });
                        const resolved = await resolveCreateConflicts(primaryFailure, {
                            sceneName,
                            itemId: targetItemId,
                            conflictPolicy,
                            stopScope,
                            requestOptions,
                            pollTimes: Math.max(1, toNumber(options.pausePollTimes, 3)),
                            pollIntervalMs: Math.max(500, toNumber(options.pausePollIntervalMs, 2000))
                        });
                        if (resolved.stoppedCampaignIds.length) {
                            stoppedCampaignIds.push(...resolved.stoppedCampaignIds);
                            sceneStats.stopped += resolved.stoppedCampaignIds.length;
                        }
                        emitProgress(options, 'pause_retry_result', {
                            sceneName,
                            goalLabel,
                            caseId: caseInfo.caseId || '',
                            stoppedCampaignIds: resolved.stoppedCampaignIds || [],
                            unresolvedCampaignIds: resolved.unresolvedCampaignIds || [],
                            ok: !!resolved.ok
                        });
                        if (resolved.handled) {
                            if (Array.isArray(request?.plans) && request.plans[0]) {
                                request.plans[0].planName = `${sceneName}_${nowStampSeconds()}_${String(globalCaseSeq).padStart(4, '0')}_retry`;
                            }
                            let retryResult = null;
                            let retryError = '';
                            try {
                                retryResult = await createPlansByScene(sceneName, request, {
                                    fallbackPolicy,
                                    batchRetry: 0,
                                    chunkSize: 1,
                                    applySceneSpec: false,
                                    syncSceneRuntime: false,
                                    strictSceneRuntimeMatch: false,
                                    requestOptions
                                });
                            } catch (err) {
                                retryError = err?.message || String(err);
                            }
                            if (!retryError && retryResult?.ok) {
                                const retrySuccesses = Array.isArray(retryResult.successes) ? retryResult.successes : [];
                                retrySuccesses.forEach(entry => {
                                    const campaignId = toPositiveIdText(entry?.campaignId || '');
                                    if (!campaignId) return;
                                    createdRecords.push({
                                        sceneName,
                                        goalLabel,
                                        caseId: caseInfo.caseId || '',
                                        campaignId,
                                        itemId: targetItemId
                                    });
                                });
                                sceneStats.pass += 1;
                                sceneStats.repaired += 1;
                                emitProgress(options, 'case_passed_after_repair', {
                                    sceneName,
                                    goalLabel,
                                    caseId: caseInfo.caseId || '',
                                    successCount: retrySuccesses.length
                                });
                                continue;
                            }
                            unresolvedFailures.push({
                                sceneName,
                                goalLabel,
                                caseId: caseInfo.caseId || '',
                                itemId: targetItemId,
                                classification,
                                error: retryError || (Array.isArray(retryResult?.failures) && retryResult.failures.length
                                    ? retryResult.failures[0]?.error || 'retry_failed'
                                    : 'retry_failed')
                            });
                            sceneStats.failed += 1;
                            continue;
                        }
                    }

                    unresolvedFailures.push({
                        sceneName,
                        goalLabel,
                        caseId: caseInfo.caseId || '',
                        itemId: targetItemId,
                        classification,
                        error: primaryFailure?.error || runError || 'create_failed'
                    });
                    sceneStats.failed += 1;
                }
                byScene.push(sceneStats);
                emitProgress(options, 'scene_option_submit_done', {
                    sceneName,
                    index: sceneIdx + 1,
                    total: scenes.length,
                    caseCount: sceneStats.total,
                    successCount: sceneStats.pass,
                    failCount: sceneStats.failed,
                    repairedCount: sceneStats.repaired
                });
                if (stopped) break;
            }

            const createdCampaignIds = uniqueBy(
                createdRecords.map(item => toPositiveIdText(item.campaignId)).filter(Boolean),
                item => item
            );
            const stoppedUniqueIds = uniqueBy(stoppedCampaignIds.map(item => toPositiveIdText(item)).filter(Boolean), item => item);
            let deletedCampaignIds = [];
            let cleanupFailures = [];
            if (postCleanup === 'delete' && createdRecords.length) {
                const cleanup = await cleanupCreatedPlansByLifecycle(createdRecords, {
                    requestOptions,
                    capture: options.capture !== false
                });
                deletedCampaignIds = cleanup.deletedCampaignIds || [];
                cleanupFailures = cleanup.failedList || [];
                emitProgress(options, 'delete_cleanup_result', {
                    deletedCount: deletedCampaignIds.length,
                    failedCount: cleanupFailures.length,
                    pausedFallbackCount: Array.isArray(cleanup.pausedFallbackCampaignIds) ? cleanup.pausedFallbackCampaignIds.length : 0
                });
                byScene.forEach(row => {
                    row.deleted = createdRecords.filter(item => item.sceneName === row.sceneName && deletedCampaignIds.includes(item.campaignId)).length;
                });
                cleanupFailures.forEach(item => {
                    unresolvedFailures.push({
                        sceneName: item.sceneName || '',
                        goalLabel: '',
                        caseId: '',
                        itemId: item.itemId || '',
                        classification: 'cleanup',
                        error: item.error || 'cleanup_failed'
                    });
                });
            }

            const summary = {
                coverageMode,
                conflictPolicy,
                stopScope,
                postCleanup,
                fallbackPolicy,
                itemId: targetItemId,
                stopped,
                totalCases: byScene.reduce((sum, row) => sum + toNumber(row.total, 0), 0),
                passCases: byScene.reduce((sum, row) => sum + toNumber(row.pass, 0), 0),
                repairedCases: byScene.reduce((sum, row) => sum + toNumber(row.repaired, 0), 0),
                failedCases: byScene.reduce((sum, row) => sum + toNumber(row.failed, 0), 0),
                deletedCount: deletedCampaignIds.length,
                stoppedCount: stoppedUniqueIds.length,
                byScene
            };
            if (stopped) {
                emitProgress(options, 'repair_stopped', {
                    itemId: targetItemId,
                    totalScenes: scenes.length,
                    processedScenes: byScene.length
                });
            }

            return {
                ok: unresolvedFailures.length === 0 && !stopped,
                stopped,
                summary,
                createdCampaignIds,
                stoppedCampaignIds: stoppedUniqueIds,
                deletedCampaignIds,
                unresolvedFailures
            };
        };

        const createSitePlansBatch = (request = {}, options = {}) => createPlansByScene('è´§å“å…¨ç«™æ¨å¹¿', request, options);
        const createKeywordPlansBatch = (request = {}, options = {}) => createPlansByScene('å…³é”®è¯æ¨å¹¿', request, options);
        const createCrowdPlansBatch = (request = {}, options = {}) => createPlansByScene('äººç¾¤æ¨å¹¿', request, options);
        const createShopDirectPlansBatch = (request = {}, options = {}) => createPlansByScene('åº—é“ºç›´è¾¾', request, options);
        const createContentPlansBatch = (request = {}, options = {}) => createPlansByScene('å†…å®¹è¥é”€', request, options);
        const createLeadPlansBatch = (request = {}, options = {}) => createPlansByScene('çº¿ç´¢æ¨å¹¿', request, options);

        return {
            buildVersion: BUILD_VERSION,
            openWizard,
            getRuntimeDefaults,
            searchItems,
            createPlansBatch,
            createPlansByScene,
            createSitePlansBatch,
            createKeywordPlansBatch,
            createCrowdPlansBatch,
            createShopDirectPlansBatch,
            createContentPlansBatch,
            createLeadPlansBatch,
            appendKeywords,
            suggestKeywords,
            suggestCrowds,
            runSceneSmokeTests,
            runSceneGoalOptionTests,
            runSceneOptionSubmitSimulations,
            captureSceneCreateInterfaces,
            captureAllSceneCreateInterfaces,
            buildSceneParityCaseMatrix,
            collectWizardSubmitSnapshot,
            runWizardSceneParityTest,
            checkWizardApiCoverage,
            validate,
            getSessionDraft,
            clearSessionDraft
        };
    })();

    // ==================== UI æ¸²æŸ“æ¨¡å— ====================
    const UI = {
        // å…¬å…±æ ·å¼
        styles: {
            table: `width:100%;border-collapse:collapse;font-size:10px;margin:4px 0 8px;border-radius:12px;overflow:hidden;border:1px solid var(--am26-border,rgba(255,255,255,.4));background:rgb(227 227 227 / 20%);`,
            th: `padding:5px 6px;text-align:left;font-weight:600;border-bottom:1px solid var(--am26-border,rgba(255,255,255,.4));background:rgba(255,255,255,.14);color:var(--am26-text,#1b2438);`,
            td: `padding:4px 6px;border-bottom:1px solid var(--am26-border,rgba(255,255,255,.28));color:var(--am26-text-soft,#505a74);`
        },

        // å…¨å±€çŠ¶æ€æ—¥å¿—ï¼ˆç”¨äºéè®¡åˆ’ç›¸å…³çš„æ¶ˆæ¯ï¼‰
        updateStatus: (text, color = '#aaa') => {
            const container = document.getElementById(`${CONFIG.UI_ID}-log`);
            if (!container) return;

            const time = new Date().toLocaleTimeString('zh-CN', { hour12: false });
            const line = document.createElement('div');
            const timeSpan = document.createElement('span');
            timeSpan.style.cssText = 'color:#666;margin-right:4px;';
            timeSpan.textContent = `[${time}]`;
            const textSpan = document.createElement('span');
            textSpan.style.color = color;
            textSpan.textContent = text;
            line.appendChild(timeSpan);
            line.appendChild(textSpan);
            container.appendChild(line);

            while (container.children.length > 50) container.removeChild(container.firstChild);
            container.parentElement.scrollTop = container.parentElement.scrollHeight;
        },

        // åˆ›å»ºè®¡åˆ’å¡ç‰‡ï¼ˆæ¯ä¸ªè®¡åˆ’ç‹¬ç«‹çš„æ—¥å¿—åŒºåŸŸï¼‰
        createCampaignCard: (campaignId, campaignName, index, total) => {
            const container = document.getElementById(`${CONFIG.UI_ID}-log`);
            if (!container) return null;

            const cardId = `${CONFIG.UI_ID}-card-${campaignId}`;
            const safeCampaignName = Utils.escapeHtml(campaignName);
            const safeCampaignId = Utils.escapeHtml(campaignId);
            const card = document.createElement('div');
            card.id = cardId;
            card.style.cssText = `
                background:var(--am26-surface,rgba(255,255,255,.25));
                border:1px solid var(--am26-border,rgba(255,255,255,.4));
                border-radius:12px;margin-bottom:8px;overflow:hidden;transition:all 0.3s ease;
                backdrop-filter:blur(6px);
            `;
            card.innerHTML = `
                <div class="card-header" style="
                    padding:8px 12px;background:rgba(255,255,255,.22);border-bottom:1px solid var(--am26-border,rgba(255,255,255,.4));
                    display:flex;justify-content:space-between;align-items:center;cursor:pointer;
                ">
                    <div style="display:flex;align-items:center;gap:8px;">
                        <span style="
                            display:inline-block;min-width:24px;height:18px;line-height:18px;
                            background:var(--am26-primary,#2a5bff);color:#fff;border-radius:9px;text-align:center;font-size:10px;
                        ">${index}/${total}</span>
                        <span style="font-weight:500;color:var(--am26-text,#1b2438);max-width:200px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"
                              title="${safeCampaignName}">${safeCampaignName}</span>
                        <span style="color:var(--am26-text-soft,#505a74);font-size:10px;">(${safeCampaignId})</span>
                    </div>
                    <div style="display:flex;align-items:center;gap:8px;">
                        <span class="status-badge" style="
                            padding:2px 8px;border-radius:10px;font-size:10px;
                            background:rgba(42,91,255,.12);color:var(--am26-primary,#2a5bff);border:1px solid rgba(42,91,255,.28);
                        ">å¤„ç†ä¸­</span>
                        <span class="arrow" style="
                            display:inline-block;transition:transform 0.2s;
                            font-size:10px;color:var(--am26-text-soft,#505a74);
                        ">â–¼</span>
                    </div>
                </div>
                <div class="card-body" style="padding:8px 12px;font-size:11px;max-height:150px;overflow-y:auto;background:rgba(255,255,255,.12);">
                    <div class="log-content" style="display:flex;flex-direction:column;gap:2px;"></div>
                </div>
                <style>
                    #${cardId} .card-body.collapsed { display:none; }
                    #${cardId} .arrow.rotated { transform:rotate(-90deg); }
                </style>
            `;
            container.appendChild(card);
            container.parentElement.scrollTop = container.parentElement.scrollHeight;

            const header = card.querySelector('.card-header');
            const body = card.querySelector('.card-body');
            const arrow = card.querySelector('.arrow');
            if (header) {
                header.style.setProperty('border', '0', 'important');
                header.style.setProperty('border-bottom', '0', 'important');
            }
            if (header && body && arrow) {
                header.addEventListener('click', () => {
                    body.classList.toggle('collapsed');
                    arrow.classList.toggle('rotated');
                });
            }

            // è¿”å›å¡ç‰‡æ“ä½œå¯¹è±¡
            return {
                log: (text, color = '#555', options = {}) => {
                    const logContent = card.querySelector('.log-content');
                    if (!logContent) return;
                    const time = new Date().toLocaleTimeString('zh-CN', { hour12: false });
                    const line = document.createElement('div');
                    const timeSpan = document.createElement('span');
                    timeSpan.style.cssText = 'color:#aaa;margin-right:4px;font-size:10px;';
                    timeSpan.textContent = time;
                    line.appendChild(timeSpan);
                    if (options.html) {
                        const htmlWrap = document.createElement('div');
                        htmlWrap.style.color = color;
                        htmlWrap.innerHTML = text;
                        line.appendChild(htmlWrap);
                    } else {
                        const textSpan = document.createElement('span');
                        textSpan.style.color = color;
                        textSpan.textContent = text;
                        line.appendChild(textSpan);
                    }
                    logContent.appendChild(line);
                    card.querySelector('.card-body').scrollTop = card.querySelector('.card-body').scrollHeight;
                },
                setStatus: (status, type = 'info') => {
                    const badge = card.querySelector('.status-badge');
                    if (!badge) return;
                    const styles = {
                        info: 'background:rgba(42,91,255,.12);color:var(--am26-primary,#2a5bff);border:1px solid rgba(42,91,255,.28);',
                        success: 'background:rgba(14,168,111,.12);color:var(--am26-success,#0ea86f);border:1px solid rgba(14,168,111,.28);',
                        warning: 'background:rgba(232,163,37,.12);color:var(--am26-warning,#e8a325);border:1px solid rgba(232,163,37,.28);',
                        error: 'background:rgba(234,79,79,.12);color:var(--am26-danger,#ea4f4f);border:1px solid rgba(234,79,79,.28);'
                    };
                    badge.style.cssText = `padding:2px 8px;border-radius:10px;font-size:10px;${styles[type] || styles.info}`;
                    badge.textContent = status;

                    // åŒæ—¶æ›´æ–°å¡ç‰‡è¾¹æ¡†é¢œè‰²
                    const borderColors = {
                        info: 'rgba(42,91,255,.32)',
                        success: 'rgba(14,168,111,.35)',
                        warning: 'rgba(232,163,37,.35)',
                        error: 'rgba(234,79,79,.35)'
                    };
                    const borderColor = borderColors[type] || borderColors.info;
                    card.style.borderColor = borderColor;
                    const headerEl = card.querySelector('.card-header');
                    if (headerEl) {
                        headerEl.style.setProperty('border', '0', 'important');
                        headerEl.style.setProperty('border-bottom', '0', 'important');
                    }
                },
                collapse: () => {
                    card.querySelector('.card-body')?.classList.add('collapsed');
                    card.querySelector('.arrow')?.classList.add('rotated');
                }
            };
        },

        // æ¸²æŸ“è¡¨æ ¼åˆ°æŒ‡å®šå¡ç‰‡ï¼ˆé€šç”¨ï¼‰
        renderTableToCard: (cardLogger, data, columns, options = {}) => {
            if (!data.length) return;

            const { headerBg = 'rgba(255,255,255,.14)', headerColor = 'var(--am26-text,#1b2438)', highlight } = options;
            const { table, th, td } = UI.styles;

            let html = `<table style="${table}margin-top:4px;">
                <thead><tr>${columns.map(c =>
                `<th style="${th}background:${headerBg};color:${headerColor};${c.width ? `width:${c.width};` : ''}">${c.title}</th>`
            ).join('')}</tr></thead><tbody>`;

            data.forEach((row, idx) => {
                const isHighlight = !!highlight?.(row);
                const rowStyle = isHighlight ? 'background:rgba(42,91,255,.08);' : '';
                const nameStyle = isHighlight ? 'color:var(--am26-primary,#2a5bff);font-weight:600;' : '';

                html += `<tr style="${rowStyle}">${columns.map((c, i) => {
                    const val = typeof c.render === 'function' ? c.render(row, idx) : row[c.key];
                    const safeVal = Utils.escapeHtml(val ?? '-');
                    return `<td style="${td}${i === 1 ? nameStyle : ''}">${safeVal}</td>`;
                }).join('')}</tr>`;
            });

            html += '</tbody></table>';
            cardLogger.log(html, '#555', { html: true });
        },

        // æ¸²æŸ“æ‰€æœ‰åŸå§‹æ–¹æ¡ˆè¡¨æ ¼ï¼ˆåˆ°å¡ç‰‡ï¼‰
        renderAllActionsToCard: (cardLogger, allActionLists) => {
            const data = [];
            allActionLists.forEach(list => {
                list.forEach(item => {
                    const actionText = item.actionText || '';
                    if (!actionText || actionText === 'æœªçŸ¥' || actionText === 'æœªçŸ¥æ–¹æ¡ˆ') return;
                    data.push(item);
                });
            });

            if (!data.length) return;

            UI.renderTableToCard(cardLogger, data, [
                { title: '#', width: '24px', render: (_, i) => i + 1 },
                { title: 'æ–¹æ¡ˆåç§°', render: row => row.actionText },
                { title: 'è¯¦æƒ…', render: row => Utils.extractDetail(row) }
            ], {
                highlight: row => row.actionText?.includes('ç®—æ³•æŠ¤èˆª')
            });
        },

        // æ¸²æŸ“æŠ¤èˆªæ–¹æ¡ˆè¡¨æ ¼ï¼ˆåˆ°å¡ç‰‡ï¼‰
        renderEscortActionsToCard: (cardLogger, actionList) => {
            const data = actionList.filter(a => Utils.isValidAction(Utils.getActionName(a)));
            if (!data.length) return;

            UI.renderTableToCard(cardLogger, data, [
                { title: '#', width: '24px', render: (_, i) => i + 1 },
                { title: 'æ–¹æ¡ˆåç§°', render: row => Utils.getActionName(row) },
                {
                    title: 'è¯¦æƒ…', render: row => {
                        if (!row.adjustInfo) return '-';
                        try {
                            const info = typeof row.adjustInfo === 'string' ? JSON.parse(row.adjustInfo) : row.adjustInfo;
                            if (info.adjustValue) return `è°ƒæ•´å€¼: ${info.adjustValue}`;
                            return info.adjustType || '-';
                        } catch { return '-'; }
                    }
                }
            ], { headerBg: 'rgba(42,91,255,.12)', headerColor: 'var(--am26-primary,#2a5bff)' });
        },

        // æ¸²æŸ“æ‰§è¡Œç»“æœï¼ˆå…¨å±æ¨¡æ€å¼¹çª—ï¼‰
        renderResults: (successList, failList) => {
            const data = [
                ...successList.map(item => ({ ...item, success: true })),
                ...failList.map(item => ({ ...item, success: false }))
            ];
            if (!data.length) return;

            // ç§»é™¤æ—§ç»“æœå¼¹çª—
            const prevOverlay = document.getElementById(`${CONFIG.UI_ID}-result-overlay`);
            if (prevOverlay) prevOverlay.remove();

            // åˆ›å»ºæ¨¡æ€é®ç½©å±‚
            const overlay = document.createElement('div');
            overlay.id = `${CONFIG.UI_ID}-result-overlay`;
            overlay.style.cssText = `
                position:fixed;top:0;left:0;right:0;bottom:0;
                background:rgba(15,23,42,0.42);backdrop-filter:blur(6px);
                z-index:1000002;display:flex;align-items:center;justify-content:center;
                animation:fadeIn 0.3s ease;
            `;

            // åˆ›å»ºç»“æœå¡ç‰‡
            const successCount = successList.length;
            const failCount = failList.length;
            const totalCount = successCount + failCount;
            const isAllSuccess = failCount === 0;

            const rowsHtml = data.map((row, i) => {
                const safeName = Utils.escapeHtml(row.name ?? '-');
                return `
                                    <tr style="${row.success ? '' : 'background:rgba(234,79,79,.08);'}">
                                        <td style="padding:8px 12px;border-bottom:1px solid var(--am26-border,rgba(255,255,255,.35));color:var(--am26-text-soft,#505a74);">${i + 1}</td>
                                        <td style="padding:8px 12px;border-bottom:1px solid var(--am26-border,rgba(255,255,255,.35));${row.success ? 'color:var(--am26-text,#1b2438);' : 'color:var(--am26-danger,#ea4f4f);'}">${safeName}</td>
                                        <td style="padding:8px 12px;border-bottom:1px solid var(--am26-border,rgba(255,255,255,.35));text-align:center;">
                                            ${row.success
                        ? '<span style="color:var(--am26-success,#0ea86f);font-weight:600;">âœ“ æˆåŠŸ</span>'
                        : '<span style="color:var(--am26-danger,#ea4f4f);font-weight:600;">âœ— å¤±è´¥</span>'}
                                        </td>
                                    </tr>
                `;
            }).join('');

            overlay.innerHTML = `
                <style>
                    @keyframes fadeIn { from { opacity:0; } to { opacity:1; } }
                    @keyframes slideUp { from { transform:translateY(20px);opacity:0; } to { transform:translateY(0);opacity:1; } }
                </style>
                <div style="
                    background:var(--am26-panel-strong,rgba(255,255,255,.45));
                    border:1px solid var(--am26-border,rgba(255,255,255,.4));
                    border-radius:18px;padding:24px 32px;min-width:400px;max-width:600px;
                    box-shadow:0 20px 60px rgba(17,24,39,0.28);animation:slideUp 0.4s ease;
                    color:var(--am26-text,#1b2438);font-family:var(--am26-font,-apple-system,system-ui,sans-serif);
                    backdrop-filter:blur(16px);
                ">
                    <div style="text-align:center;margin-bottom:20px;">
                        <div style="font-size:48px;margin-bottom:12px;">${isAllSuccess ? 'ğŸ‰' : 'âš ï¸'}</div>
                        <div style="font-size:20px;font-weight:600;color:var(--am26-text,#1b2438);">æ‰§è¡Œå®Œæˆ</div>
                        <div style="font-size:14px;color:var(--am26-text-soft,#505a74);margin-top:8px;">
                            å…± ${totalCount} ä¸ªè®¡åˆ’ï¼Œ
                            <span style="color:var(--am26-success,#0ea86f);font-weight:600;">${successCount} æˆåŠŸ</span>
                            ${failCount > 0 ? `ï¼Œ<span style="color:var(--am26-danger,#ea4f4f);font-weight:600;">${failCount} å¤±è´¥</span>` : ''}
                        </div>
                    </div>
                    <div style="max-height:300px;overflow-y:auto;border:1px solid var(--am26-border,rgba(255,255,255,.4));border-radius:12px;">
                        <table style="width:100%;border-collapse:collapse;font-size:13px;">
                            <thead>
                                <tr style="background:rgba(255,255,255,.16);">
                                    <th style="padding:10px 12px;text-align:left;border-bottom:1px solid var(--am26-border,rgba(255,255,255,.35));width:40px;">#</th>
                                    <th style="padding:10px 12px;text-align:left;border-bottom:1px solid var(--am26-border,rgba(255,255,255,.35));">è®¡åˆ’åç§°</th>
                                    <th style="padding:10px 12px;text-align:center;border-bottom:1px solid var(--am26-border,rgba(255,255,255,.35));width:80px;">çŠ¶æ€</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${rowsHtml}
                            </tbody>
                        </table>
                    </div>
                    <div style="text-align:center;margin-top:20px;">
                        <button id="${CONFIG.UI_ID}-result-close" style="
                            padding:10px 32px;background:linear-gradient(135deg,var(--am26-primary,#2a5bff),var(--am26-primary-strong,#1d3fcf));color:#fff;
                            border:none;border-radius:10px;cursor:pointer;font-size:14px;font-weight:500;
                            transition:transform 0.2s,box-shadow 0.2s;
                        ">å…³é—­</button>
                    </div>
                </div>
            `;

            document.body.appendChild(overlay);

            // ç»‘å®šå…³é—­äº‹ä»¶
            const closeBtn = document.getElementById(`${CONFIG.UI_ID}-result-close`);
            if (closeBtn) {
                closeBtn.addEventListener('mouseenter', () => {
                    closeBtn.style.transform = 'scale(1.05)';
                    closeBtn.style.boxShadow = '0 4px 12px rgba(42,91,255,0.35)';
                });
                closeBtn.addEventListener('mouseleave', () => {
                    closeBtn.style.transform = 'scale(1)';
                    closeBtn.style.boxShadow = 'none';
                });
            }
            if (closeBtn) closeBtn.onclick = () => {
                overlay.style.opacity = '0';
                overlay.style.transition = 'opacity 0.3s ease';
                setTimeout(() => overlay.remove(), 300);
            };

            // ç‚¹å‡»é®ç½©å±‚ä¹Ÿå¯å…³é—­
            overlay.onclick = (e) => {
                if (e.target === overlay) {
                    overlay.style.opacity = '0';
                    overlay.style.transition = 'opacity 0.3s ease';
                    setTimeout(() => overlay.remove(), 300);
                }
            };
        },

        // åˆ›å»ºä¸»ç•Œé¢
        create: () => {
            if (document.getElementById(CONFIG.UI_ID)) return;

            // ä¸»é¢æ¿ï¼ˆé»˜è®¤éšè—ï¼Œç”¨æˆ·ç‚¹å‡»æœ€å°åŒ–æŒ‰é’®åæ˜¾ç¤ºï¼‰
            const panel = document.createElement('div');
            panel.id = CONFIG.UI_ID;
            panel.style.cssText = `
                position:fixed;top:20px;right:20px;width:250px;min-width:250px;max-width:600px;
                padding:15px;background:var(--am26-panel-strong,rgba(255,255,255,.45));
                color:var(--am26-text,#1b2438);border-radius:18px;z-index:1000001;
                font-size:13px;box-shadow:var(--am26-shadow,0 8px 32px rgba(31,38,135,.15));border:1px solid var(--am26-border,rgba(255,255,255,.4));
                font-family:var(--am26-font,-apple-system,system-ui,sans-serif);
                opacity:0;transform:scale(0.8);transform-origin:top right;pointer-events:none;
                transition:opacity 0.3s ease, transform 0.3s ease, width 0.8s cubic-bezier(0.4,0,0.2,1);
                overflow:hidden;
            `;


            panel.innerHTML = `
                <div style="font-weight:bold;margin-bottom:12px;border-bottom:0;padding-bottom:8px;display:flex;justify-content:space-between;align-items:center;">
                    <span style="color:var(--am26-primary,#2a5bff);">ğŸ›¡ï¸ ç®—æ³•æŠ¤èˆª v${CONFIG.VERSION}</span>
                    <div style="display:flex;align-items:center;gap:2px;">
                        <span style="font-size:10px;color:var(--am26-text-soft,#505a74);margin-right:6px;opacity:0.6;">APIç‰ˆ</span>
                        <span id="${CONFIG.UI_ID}-center" class="am-icon-btn" title="å±…ä¸­">
                            <svg viewBox="0 0 1024 1024" style="width:0.8em;height:0.8em;vertical-align:middle;fill:currentColor;overflow:hidden;"><path d="M838 314H197c-19.9 0-36-16.1-36-36s16.1-36 36-36h641c19.9 0 36 16.1 36 36s-16.1 36-36 36zM745 468H290c-19.9 0-36-16.1-36-36s16.1-36 36-36h455c19.9 0 36 16.1 36 36s-16.1 36-36 36zM838 621H197c-19.9 0-36-16.1-36-36s16.1-36 36-36h641c19.9 0 36 16.1 36 36s-16.1 36-36 36zM745 775H290c-19.9 0-36-16.1-36-36s16.1-36 36-36h455c19.9 0 36 16.1 36 36s-16.1 36-36 36z"></path></svg>
                        </span>
                        <span id="${CONFIG.UI_ID}-maximize" class="am-icon-btn" title="æœ€å¤§åŒ–">
                            <svg viewBox="0 0 1024 1024" style="width:0.8em;height:1.0em;vertical-align:middle;fill:currentColor;overflow:hidden;"><path d="M444.3 539.9L202 782.2 199.8 563c0-16.5-13.5-30-30-30s-30 13.5-30 30l2.2 285.1c0 8.8 3.8 16.7 9.8 22.2 5.5 6 13.4 9.8 22.2 9.8h295.6c16.5 0 30-13.5 30-30s-13.5-30-30-30H248.9l237.8-237.8c11.7-11.7 11.7-30.8 0-42.4-11.6-11.6-30.7-11.6-42.4 0zM578.1 488l242.3-242.3 2.2 219.2c0 16.5 13.5 30 30 30s30-13.5 30-30l-2.2-285.1c0-8.8-3.8-16.7-9.8-22.2-5.5-6-13.4-9.8-22.2-9.8H552.8c-16.5 0-30 13.5-30 30s13.5 30 30 30h220.7L535.7 445.6c-11.7 11.7-11.7 30.8 0 42.4 11.7 11.7 30.8 11.7 42.4 0z"></path></svg>
                        </span>
                        <span id="${CONFIG.UI_ID}-close" class="am-icon-btn danger" title="å…³é—­">
                            <svg viewBox="0 0 1024 1024" style="width:1.2em;height:1.2em;vertical-align:middle;fill:currentColor;overflow:hidden;"><path d="M551.424 512l195.072-195.072c9.728-9.728 9.728-25.6 0-36.864l-1.536-1.536c-9.728-9.728-25.6-9.728-35.328 0L514.56 475.136 319.488 280.064c-9.728-9.728-25.6-9.728-35.328 0l-1.536 1.536c-9.728 9.728-9.728 25.6 0 36.864L477.696 512 282.624 707.072c-9.728 9.728-9.728 25.6 0 36.864l1.536 1.536c9.728 9.728 25.6 9.728 35.328 0L514.56 548.864l195.072 195.072c9.728 9.728 25.6 9.728 35.328 0l1.536-1.536c9.728-9.728 9.728-25.6 0-36.864L551.424 512z"></path></svg>
                        </span>
                    </div>
                </div>
                <div id="${CONFIG.UI_ID}-log-wrapper" style="background:rgba(255,255,255,.22);padding:0;border-radius:12px;font-size:11px;height:0;max-height:500px;overflow:hidden;margin-bottom:0;border:1px solid var(--am26-border,rgba(255,255,255,.35));font-family:Monaco,Consolas,monospace;opacity:0;transform:scaleY(0.8);transform-origin:top;transition:all 0.6s ease-out;">
                    <div id="${CONFIG.UI_ID}-log" style="color:var(--am26-text-soft,#505a74);display:flex;flex-direction:column;gap:3px;line-height:1.5;padding:10px;"></div>
                </div>
                <button id="${CONFIG.UI_ID}-run" style="width:100%;padding:8px;background:linear-gradient(135deg,var(--am26-primary,#2a5bff),var(--am26-primary-strong,#1d3fcf));color:#fff;border:none;border-radius:10px;cursor:pointer;font-weight:500;margin-bottom:8px;">ç«‹å³æ‰«æå¹¶ä¼˜åŒ–</button>
                <div style="margin-bottom:8px;display:flex;gap:5px;align-items:center;">
                    <label style="color:var(--am26-text-soft,#505a74);font-size:10px;white-space:nowrap;">è¯Šæ–­è¯æœ¯:</label>
                    <input id="${CONFIG.UI_ID}-prompt" type="text" style="flex:1;padding:4px;border:1px solid var(--am26-border,rgba(255,255,255,.45));border-radius:10px;font-size:10px;background:rgba(255,255,255,.72);color:var(--am26-text,#1b2438);" placeholder="ä¾‹: å¸®æˆ‘è¿›è¡Œæ·±åº¦è¯Šæ–­" />
                </div>
                <div style="margin-bottom:8px;display:flex;gap:5px;align-items:center;">
                    <label style="color:var(--am26-text-soft,#505a74);font-size:10px;white-space:nowrap;">åŒæ—¶æ‰§è¡Œ:</label>
                    <input id="${CONFIG.UI_ID}-concurrency" type="number" min="1" max="10" style="width:50px;padding:4px;border:1px solid var(--am26-border,rgba(255,255,255,.45));border-radius:10px;font-size:10px;text-align:center;background:rgba(255,255,255,.72);color:var(--am26-text,#1b2438);" />
                    <span style="color:var(--am26-text-soft,#505a74);font-size:10px;">ä¸ªè®¡åˆ’ (1-10)</span>
                </div>
                <div style="margin-top:10px;font-size:10px;color:var(--am26-text-soft,#505a74);display:flex;justify-content:space-between;">
                    <span id="${CONFIG.UI_ID}-user" style="max-width:120px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;"></span>
                    <span id="${CONFIG.UI_ID}-token" style="cursor:help;" title="TokençŠ¶æ€">â— Token</span>
                </div>
            `;

            document.body.appendChild(panel);

            const promptInput = document.getElementById(`${CONFIG.UI_ID}-prompt`);
            if (promptInput) promptInput.value = userConfig.customPrompt || CONFIG.DEFAULT.customPrompt;
            const concurrencyInput = document.getElementById(`${CONFIG.UI_ID}-concurrency`);
            if (concurrencyInput) concurrencyInput.value = userConfig.concurrency || 3;

            // äº‹ä»¶ç»‘å®š
            ['center', 'maximize', 'close'].forEach(key => {
                const el = document.getElementById(`${CONFIG.UI_ID}-${key}`);
                if (!el) return;
                el.addEventListener('mouseenter', () => { el.style.color = 'var(--am26-primary,#2a5bff)'; });
                el.addEventListener('mouseleave', () => { el.style.color = 'var(--am26-text-soft,#505a74)'; });
            });

            document.getElementById(`${CONFIG.UI_ID}-close`).onclick = () => {
                panel.style.opacity = '0';
                panel.style.transform = 'scale(0.8)';
                panel.style.pointerEvents = 'none';
            };

            // å±…ä¸­æŒ‰é’®äº‹ä»¶ï¼ˆåˆ‡æ¢æ¨¡å¼ï¼‰
            document.getElementById(`${CONFIG.UI_ID}-center`).onclick = () => {
                const isCentered = panel.dataset.centered === 'true';

                if (isCentered) {
                    // æ¢å¤åŸä½ç½®ï¼ˆå³ä¸Šè§’ï¼‰
                    panel.style.left = 'auto';
                    panel.style.right = '20px';
                    panel.style.top = '20px';
                    panel.dataset.centered = 'false';
                } else {
                    // å±…ä¸­æ˜¾ç¤º
                    const panelWidth = panel.offsetWidth;
                    const panelHeight = panel.offsetHeight;
                    const screenWidth = window.innerWidth;
                    const screenHeight = window.innerHeight;
                    panel.style.left = `${(screenWidth - panelWidth) / 2}px`;
                    panel.style.top = `${(screenHeight - panelHeight) / 2}px`;
                    panel.style.right = 'auto';
                    panel.dataset.centered = 'true';
                }
            };

            // æœ€å¤§åŒ–æŒ‰é’®äº‹ä»¶
            document.getElementById(`${CONFIG.UI_ID}-maximize`).onclick = () => {
                const wrapper = document.getElementById(`${CONFIG.UI_ID}-log-wrapper`);
                const isMaximized = panel.dataset.maximized === 'true';

                if (isMaximized) {
                    // æ¢å¤é»˜è®¤å°ºå¯¸
                    panel.style.top = '20px';
                    panel.style.height = 'auto';
                    if (wrapper) {
                        wrapper.style.height = '200px';
                        wrapper.style.maxHeight = '500px';
                    }
                    panel.dataset.maximized = 'false';
                } else {
                    // æœ€å¤§åŒ–ï¼šé«˜åº¦å æ»¡å±å¹•ï¼Œå®½åº¦ä¿æŒä¸å˜
                    const screenHeight = window.innerHeight;
                    panel.style.top = '20px';
                    panel.style.height = `${screenHeight - 40}px`;  // ä¸Šä¸‹å„ç•™ 20px è¾¹è·
                    if (wrapper) {
                        wrapper.dataset.expanded = 'true';
                        // è®¡ç®—æ—¥å¿—åŒºåŸŸå¯ç”¨é«˜åº¦ï¼šé¢å¤–é¢„ç•™ 100px ç»™ä¸‹æ–¹é…ç½®åŒºï¼Œé¿å…é®æŒ¡
                        const availableHeight = screenHeight - 40 - 300;
                        wrapper.style.height = `${Math.max(200, availableHeight)}px`;
                        wrapper.style.maxHeight = 'none';
                        wrapper.style.opacity = '1';
                        wrapper.style.marginBottom = '12px';
                        wrapper.style.transform = 'scaleY(1)';
                        setTimeout(() => wrapper.style.overflow = 'auto', 300);
                    }
                    panel.dataset.maximized = 'true';
                }
            };

            document.getElementById(`${CONFIG.UI_ID}-run`).onclick = () => {
                // å±•å¼€æ—¥å¿—åŒºåŸŸï¼ˆä½¿ç”¨æœ€å¤§åŒ–æ•ˆæœï¼‰
                const wrapper = document.getElementById(`${CONFIG.UI_ID}-log-wrapper`);
                if (!wrapper.dataset.expanded || panel.dataset.maximized !== 'true') {
                    const screenHeight = window.innerHeight;
                    panel.style.top = '20px';
                    panel.style.height = `${screenHeight - 40}px`;
                    panel.style.width = '600px';
                    wrapper.dataset.expanded = 'true';
                    const availableHeight = screenHeight - 40 - 300;
                    wrapper.style.height = `${Math.max(200, availableHeight)}px`;
                    wrapper.style.maxHeight = 'none';
                    wrapper.style.opacity = '1';
                    wrapper.style.marginBottom = '12px';
                    wrapper.style.transform = 'scaleY(1)';
                    setTimeout(() => wrapper.style.overflow = 'auto', 300);
                    panel.dataset.maximized = 'true';
                }

                // ä¿å­˜é…ç½®
                const prompt = document.getElementById(`${CONFIG.UI_ID}-prompt`).value.trim();
                const concurrency = parseInt(document.getElementById(`${CONFIG.UI_ID}-concurrency`).value) || 3;
                userConfig.customPrompt = prompt || CONFIG.DEFAULT.customPrompt;
                userConfig.concurrency = Math.min(10, Math.max(1, concurrency));
                GM_setValue('config', userConfig);

                Core.run();
            };

            // ==================== æ‹–æ‹½è°ƒæ•´å°ºå¯¸ ====================
            let resizeState = { active: null, startX: 0, startY: 0, startW: 0, startH: 0 };

            // å·¦ä¾§æ‹–æ‹½æ¡ï¼ˆè°ƒæ•´å®½åº¦ï¼‰
            const resizerLeft = document.createElement('div');
            resizerLeft.style.cssText = 'position:absolute;left:0;top:0;bottom:0;width:6px;cursor:ew-resize;z-index:10;';
            resizerLeft.onmouseenter = () => resizerLeft.style.background = 'rgba(42,91,255,0.28)';
            resizerLeft.onmouseleave = () => resizerLeft.style.background = 'transparent';
            panel.appendChild(resizerLeft);

            // åº•éƒ¨æ‹–æ‹½æ¡ï¼ˆè°ƒæ•´é«˜åº¦ï¼‰
            const resizerBottom = document.createElement('div');
            resizerBottom.style.cssText = 'position:absolute;left:0;right:0;bottom:0;height:6px;cursor:ns-resize;z-index:10;';
            resizerBottom.onmouseenter = () => resizerBottom.style.background = 'rgba(42,91,255,0.28)';
            resizerBottom.onmouseleave = () => resizerBottom.style.background = 'transparent';
            panel.appendChild(resizerBottom);

            // å·¦ä¸‹è§’ï¼ˆåŒæ—¶è°ƒæ•´å®½é«˜ï¼‰
            const resizerCorner = document.createElement('div');
            resizerCorner.style.cssText = 'position:absolute;left:0;bottom:0;width:12px;height:12px;cursor:nesw-resize;z-index:11;';
            resizerCorner.onmouseenter = () => resizerCorner.style.background = 'rgba(42,91,255,0.42)';
            resizerCorner.onmouseleave = () => resizerCorner.style.background = 'transparent';
            panel.appendChild(resizerCorner);

            const startResize = (type, e) => {
                resizeState = {
                    active: type,
                    startX: e.clientX,
                    startY: e.clientY,
                    startW: panel.offsetWidth,
                    startH: document.getElementById(`${CONFIG.UI_ID}-log-wrapper`)?.offsetHeight || 200
                };
                e.preventDefault();
                document.body.style.userSelect = 'none';
            };

            const onResizeMove = e => {
                const wrapper = document.getElementById(`${CONFIG.UI_ID}-log-wrapper`);
                if (resizeState.active === 'width' || resizeState.active === 'both') {
                    panel.style.width = Math.min(800, Math.max(200, resizeState.startW + resizeState.startX - e.clientX)) + 'px';
                }
                if ((resizeState.active === 'height' || resizeState.active === 'both') && wrapper) {
                    wrapper.style.height = Math.min(500, Math.max(100, resizeState.startH + e.clientY - resizeState.startY)) + 'px';
                }
            };

            const onResizeEnd = () => {
                resizeState.active = null;
                document.body.style.userSelect = '';
                document.removeEventListener('mousemove', onResizeMove);
                document.removeEventListener('mouseup', onResizeEnd);
            };

            const bindResize = (type, e) => {
                startResize(type, e);
                document.addEventListener('mousemove', onResizeMove);
                document.addEventListener('mouseup', onResizeEnd);
            };

            resizerLeft.onmousedown = e => bindResize('width', e);
            resizerBottom.onmousedown = e => bindResize('height', e);
            resizerCorner.onmousedown = e => bindResize('both', e);

            // Token çŠ¶æ€æ£€æµ‹
            setInterval(() => {
                const tokenDot = document.getElementById(`${CONFIG.UI_ID}-token`);
                if (tokenDot) {
                    tokenDot.style.color = (State.tokens.dynamicToken && State.tokens.loginPointId) ? '#52c41a' : '#ff4d4f';
                }
            }, 1000);
        }
    };

    // ==================== æ ¸å¿ƒä¸šåŠ¡é€»è¾‘ ====================
    const Core = {
        // å¤„ç†å•ä¸ªè®¡åˆ’ï¼ˆä½¿ç”¨ç‹¬ç«‹å¡ç‰‡æ—¥å¿—ï¼‰
        processCampaign: async (campaignId, campaignName, index, total) => {
            // åˆ›å»ºè¯¥è®¡åˆ’çš„ç‹¬ç«‹å¡ç‰‡
            // å¦‚æœæ²¡æœ‰ IDï¼Œä½¿ç”¨é€šç”¨ ID "GLOBAL"
            const realId = campaignId || '0';
            const realName = campaignId ? campaignName : 'é€šç”¨é—®ç­”';

            const card = UI.createCampaignCard(realId, realName, index, total);
            if (!card) {
                Logger.error(`æ— æ³•åˆ›å»ºå¡ç‰‡: ${realId}`);
                return { success: false, msg: 'åˆ›å»ºå¡ç‰‡å¤±è´¥' };
            }

            Logger.info(`[${index}/${total}] ${realName}(${realId}) å¼€å§‹å¤„ç†...`);
            card.log('å¼€å§‹å¤„ç†...', '#1890ff');
            card.setStatus('è¯Šæ–­ä¸­', 'info');

            try {
                const today = Utils.toLocalYMD();
                // æ„é€ è¯·æ±‚æ•°æ®
                const talkData = {
                    fromPage: '/manage/search-detail',
                    entrance: 'huhang-pop_escort@onebpSearch@horizontal',
                    business: 'escort@onebpSearch@horizontal',
                    contextParam: {
                        mx_bizCode: 'onebpSearch',
                        bizCode: 'onebpSearch',
                        startTime: today,
                        endTime: today,
                        campaignGroupId: Utils.getCampaignGroupId(),
                        newUi: true,
                        bizQueryReference: 'escort',
                        campaignId: parseInt(campaignId)
                    },
                    bizCode: 'universalBP',
                    requestType: 'NlAnalysis',
                    client: 'pc_uni_bp',
                    product: 'escort',
                    sessionId: Utils.uuid(),
                    campaignId: parseInt(campaignId),
                    prompt: {
                        promptType: 'text',
                        valided: true,
                        isEmpty: false,
                        params: { questionSource: 'input' },
                        wordList: [{
                            word: `é’ˆå¯¹è®¡åˆ’ï¼š${campaignId}ï¼Œ${userConfig.customPrompt}`,
                            wordType: 'text'
                        }]
                    },
                    promptType: 'text',
                    timeStr: Date.now(),
                    ...State.tokens
                };

                card.log('è¯·æ±‚è¯Šæ–­æ¥å£...', 'orange');
                const talkRes = await API.request('https://ai.alimama.com/ai/chat/talk.json', talkData, {
                    signal: State.runAbortController?.signal
                });

                // æ”¶é›†æ‰€æœ‰ actionList
                const allActionLists = [];
                const seenKeys = new Set();

                const collect = (obj, depth = 0) => {
                    if (!obj || depth > 20) return;
                    if (Array.isArray(obj)) {
                        obj.forEach(item => collect(item, depth + 1));
                        return;
                    }
                    if (Array.isArray(obj.actionList) && obj.actionList.length) {
                        const key = obj.actionList.map(i => {
                            const infoStr = typeof i.actionInfo === 'string'
                                ? i.actionInfo
                                : JSON.stringify(i.actionInfo ?? '');
                            return `${i.actionText}::${(infoStr || '').substring(0, 100)}`;
                        }).join('|||');
                        if (!seenKeys.has(key)) {
                            seenKeys.add(key);
                            allActionLists.push(obj.actionList);
                        }
                    }
                    if (typeof obj === 'object') {
                        for (const k in obj) collect(obj[k], depth + 1);
                    }
                };

                if (talkRes.isStream) {
                    talkRes.chunks.forEach(c => collect(c));
                } else {
                    collect(talkRes);
                }

                // æ˜¾ç¤ºæ‰€æœ‰æ–¹æ¡ˆ
                if (allActionLists.length) {
                    Logger.debug('æ–¹æ¡ˆåˆ—è¡¨:', allActionLists.flat().map((a, i) => ({
                        åºå·: i + 1,
                        actionText: a.actionText || '-',
                        actionType: a.actionType || '-',
                        hasInfo: a.actionInfo ? 'âœ“' : '-'
                    })));

                    card.log(`æ”¶åˆ° ${allActionLists.length} ç»„æ–¹æ¡ˆ`, '#1890ff');
                    UI.renderAllActionsToCard(card, allActionLists);
                }

                // å¯»æ‰¾ç®—æ³•æŠ¤èˆª
                let actionList = null, targetInfo = null;
                for (const list of allActionLists) {
                    const escort = list.find(i => i.actionText?.includes('ç®—æ³•æŠ¤èˆª'));
                    if (escort?.actionInfo) {
                        try {
                            const info = JSON.parse(escort.actionInfo);
                            if (info.actionList) {
                                actionList = info.actionList;
                                targetInfo = info;
                                break;
                            }
                        } catch { }
                    }
                }

                if (!actionList?.length) {
                    card.log('âš ï¸ æœªå‘ç°"ç®—æ³•æŠ¤èˆª"æ–¹æ¡ˆ', 'orange');
                    card.setStatus('æ— æ–¹æ¡ˆ', 'warning');
                    card.collapse();
                    return { success: false, msg: 'æ— æŠ¤èˆªæ–¹æ¡ˆ' };
                }

                // æ˜¾ç¤ºæŠ¤èˆªæ–¹æ¡ˆ
                card.log(`è·å–åˆ° ${actionList.length} ä¸ªæŠ¤èˆªæ–¹æ¡ˆ`, '#1890ff');
                UI.renderEscortActionsToCard(card, actionList);

                // æäº¤æŠ¤èˆª
                card.log('æäº¤æŠ¤èˆªè¯·æ±‚...', 'orange');
                card.setStatus('æäº¤ä¸­', 'info');

                const openRes = await API.request('https://ai.alimama.com/ai/escort/open.json', {
                    actionList,
                    campaignId: campaignId.toString(),
                    continueDays: 3650,
                    target: targetInfo?.target || 'æ·±åº¦è¯Šæ–­æ‹¿é‡',
                    timeStr: Date.now(),
                    bizCode: userConfig.bizCode,
                    ...State.tokens
                }, {
                    signal: State.runAbortController?.signal
                });

                const success = openRes?.success || openRes?.ok || openRes?.info?.ok;
                const msg = openRes?.info?.message || (success ? 'æˆåŠŸ' : 'æœªçŸ¥é”™è¯¯');

                card.log(`${success ? 'âœ“' : 'âœ—'} ${msg}`, success ? 'green' : 'red');
                card.setStatus(success ? 'æˆåŠŸ' : 'å¤±è´¥', success ? 'success' : 'error');
                card.collapse();
                return { success, msg };

            } catch (e) {
                if (e?.name === 'AbortError') {
                    card.log('å·²å–æ¶ˆ', '#999');
                    card.setStatus('å·²å–æ¶ˆ', 'warning');
                    card.collapse();
                    return { success: false, msg: 'å·²å–æ¶ˆ' };
                }
                card.log(`å¼‚å¸¸: ${e.message}`, 'red');
                card.setStatus('å¼‚å¸¸', 'error');
                card.collapse();
                return { success: false, msg: e.message };
            }
        },

        // æ‰«æé¡µé¢è®¡åˆ’ï¼ˆå•æ¬¡ DOM éå†ï¼‰
        scanCampaigns: () => {
            const tasks = new Map();
            const campaignIdRegex = /campaignId=(\d{6,})/;

            document.querySelectorAll('a[href*="campaignId="], input[type="checkbox"][value]').forEach(el => {
                if (el.tagName === 'A') {
                    const m = el.href.match(campaignIdRegex);
                    if (m && !tasks.has(m[1])) {
                        tasks.set(m[1], el.innerText.trim() || 'æœªçŸ¥è®¡åˆ’');
                    }
                } else if (/^\d{6,}$/.test(el.value) && !el.closest('div[mx-view*="user-pop"]')) {
                    if (!tasks.has(el.value)) {
                        const row = el.closest('tr');
                        const name = row?.querySelector('a[title]')?.getAttribute('title') || 'æœªçŸ¥è®¡åˆ’';
                        tasks.set(el.value, name);
                    }
                }
            });

            return Array.from(tasks.entries());
        },

        // ä¸»è¿è¡Œå‡½æ•° - å¹¶å‘æ‰§è¡Œç‰ˆæœ¬
        run: async () => {
            State.currentRunId++;
            const runId = State.currentRunId;
            if (State.runAbortController) State.runAbortController.abort();
            State.runAbortController = new AbortController();

            // æ¸…ç©ºæ—¥å¿—
            const log = document.getElementById(`${CONFIG.UI_ID}-log`);
            if (log) log.textContent = '';

            UI.updateStatus('æ­£åœ¨è§£æé¡µé¢...', 'blue');

            TokenManager.refresh();

            if (!State.tokens.loginPointId || !State.tokens.dynamicToken) {
                UI.updateStatus('Token æœªå°±ç»ªï¼Œè¯·ç‚¹å‡»é¡µé¢ä»»æ„å¤„', 'red');
                return;
            }

            const campaigns = Core.scanCampaigns();
            if (!campaigns.length) {
                UI.updateStatus('æœªæ‰¾åˆ°è®¡åˆ’ID', '#ff4d4f');
                return;
            }

            const total = campaigns.length;
            const concurrency = userConfig.concurrency || 3;
            UI.updateStatus(`è¯†åˆ«åˆ° ${total} ä¸ªè®¡åˆ’ï¼Œå¼€å§‹å¹¶å‘å¤„ç† (å¹¶å‘æ•°: ${concurrency})...`, '#1890ff');

            // åˆ›å»ºä»»åŠ¡å‡½æ•°æ•°ç»„
            const taskFns = campaigns.map(([id, name], i) => async () => {
                if (State.currentRunId !== runId) return { success: false, id, name, msg: 'å·²å–æ¶ˆ' };
                const res = await Core.processCampaign(id, name, i + 1, total);
                return { ...res, id, name };
            });

            // å¹¶å‘æ‰§è¡Œï¼ˆä½¿ç”¨ç”¨æˆ·è®¾ç½®çš„å¹¶å‘æ•°ï¼‰
            const results = await Utils.concurrentLimit(taskFns, concurrency);

            // ç»Ÿè®¡ç»“æœ
            const successList = [], failList = [];
            results.forEach(r => {
                if (r.status === 'fulfilled') {
                    const { success, id, name, msg } = r.value;
                    (success ? successList : failList).push({ id, name, msg });
                } else {
                    failList.push({ id: '-', name: 'æœªçŸ¥', msg: r.reason?.message || 'æ‰§è¡Œå¼‚å¸¸' });
                }
            });

            // æ˜¾ç¤ºç»“æœ
            UI.updateStatus('--------------------------------', '#999');
            UI.updateStatus(`æ‰§è¡Œå®Œæˆã€‚æˆåŠŸ: ${successList.length}, å¤±è´¥: ${failList.length}`,
                successList.length ? 'green' : 'red');
        }
    };

    // ==================== åˆå§‹åŒ– ====================
    try {
        const hooks = createHookManager();
        hooks?.install?.();
    } catch { }
    TokenManager.hookXHR();

    // NOTE: å°† Token å¼•ç”¨æš´éœ²åˆ°å…¨å±€ï¼Œä¾›ä¸‡èƒ½æŸ¥æ•°å¼¹çª—ç­‰æ¨¡å—è·¨ä½œç”¨åŸŸè¯»å–
    const pageGlobal = (typeof unsafeWindow !== 'undefined' && unsafeWindow) ? unsafeWindow : window;
    const API_BRIDGE_REQ_EVENT = '__AM_WXT_PLAN_API_BRIDGE_REQ__';
    const API_BRIDGE_RES_EVENT = '__AM_WXT_PLAN_API_BRIDGE_RES__';
    const API_BRIDGE_MSG_CHANNEL = '__AM_WXT_PLAN_API_BRIDGE_MSG__';
    const API_BRIDGE_METHODS = [
        'openWizard',
        'getRuntimeDefaults',
        'searchItems',
        'createPlansBatch',
        'createPlansByScene',
        'createSitePlansBatch',
        'createKeywordPlansBatch',
        'createCrowdPlansBatch',
        'createShopDirectPlansBatch',
        'createContentPlansBatch',
        'createLeadPlansBatch',
        'appendKeywords',
        'suggestKeywords',
        'suggestCrowds',
        'runSceneSmokeTests',
        'runSceneGoalOptionTests',
        'runSceneOptionSubmitSimulations',
        'captureSceneCreateInterfaces',
        'captureAllSceneCreateInterfaces',
        'buildSceneParityCaseMatrix',
        'collectWizardSubmitSnapshot',
        'runWizardSceneParityTest',
        'checkWizardApiCoverage',
        'validate',
        'getSessionDraft',
        'clearSessionDraft'
    ];
    const installPageApiBridgeHost = () => {
        if (window.__AM_WXT_PLAN_API_BRIDGE_HOST__) return;
        window.__AM_WXT_PLAN_API_BRIDGE_HOST__ = true;
        const BRIDGE_RESULT_CACHE_TTL_MS = 90 * 1000;
        const inFlightCallIds = new Set();
        const resolvedPayloadCache = new Map();
        const cleanupBridgeCache = () => {
            const now = Date.now();
            resolvedPayloadCache.forEach((cached, callId) => {
                if (!cached || !Number.isFinite(cached.ts) || now - cached.ts > BRIDGE_RESULT_CACHE_TTL_MS) {
                    resolvedPayloadCache.delete(callId);
                }
            });
        };
        const extractBridgeDetail = (raw) => {
            if (!raw || typeof raw !== 'object') return null;
            const callId = String(raw.callId || '').trim();
            const method = String(raw.method || '').trim();
            const args = Array.isArray(raw.args) ? raw.args : [];
            if (!callId || !method) return null;
            return {
                callId,
                method,
                args
            };
        };
        const dispatchBridgeResponse = (payload) => {
            try {
                window.dispatchEvent(new CustomEvent(API_BRIDGE_RES_EVENT, { detail: payload }));
            } catch { }
            try {
                document.dispatchEvent(new CustomEvent(API_BRIDGE_RES_EVENT, { detail: payload }));
            } catch { }
            try {
                window.postMessage({
                    channel: API_BRIDGE_MSG_CHANNEL,
                    direction: 'res',
                    payload
                }, '*');
            } catch { }
        };
        const processBridgeRequest = async (detail) => {
            const callId = String(detail.callId || '').trim();
            const method = String(detail.method || '').trim();
            const args = Array.isArray(detail.args) ? detail.args : [];
            if (!callId || !method) return;
            cleanupBridgeCache();
            if (resolvedPayloadCache.has(callId)) {
                dispatchBridgeResponse(resolvedPayloadCache.get(callId).payload);
                return;
            }
            if (inFlightCallIds.has(callId)) return;
            inFlightCallIds.add(callId);
            const payload = {
                callId,
                method,
                ok: false,
                result: null,
                error: ''
            };
            try {
                const fn = KeywordPlanApi?.[method];
                if (typeof fn !== 'function') {
                    throw new Error(`method_not_found:${method}`);
                }
                payload.result = await fn(...args);
                payload.ok = true;
            } catch (err) {
                payload.error = err?.message || String(err);
            } finally {
                inFlightCallIds.delete(callId);
            }
            resolvedPayloadCache.set(callId, {
                ts: Date.now(),
                payload
            });
            dispatchBridgeResponse(payload);
        };
        const handleBridgeRequestEvent = (event) => {
            const detail = extractBridgeDetail(event?.detail);
            if (!detail) return;
            processBridgeRequest(detail);
        };
        const handleBridgeRequestMessage = (event) => {
            if (!event || event.source !== window) return;
            const data = event.data;
            if (!data || typeof data !== 'object') return;
            if (String(data.channel || '').trim() !== API_BRIDGE_MSG_CHANNEL) return;
            if (String(data.direction || '').trim() !== 'req') return;
            const detail = extractBridgeDetail(data.payload);
            if (!detail) return;
            processBridgeRequest(detail);
        };
        window.addEventListener(API_BRIDGE_REQ_EVENT, handleBridgeRequestEvent);
        document.addEventListener(API_BRIDGE_REQ_EVENT, handleBridgeRequestEvent);
        window.addEventListener('message', handleBridgeRequestMessage, false);
    };
    const injectPageApiBridgeClient = () => {
        if (document.getElementById('am-wxt-plan-api-bridge-client')) return;
        const script = document.createElement('script');
        script.id = 'am-wxt-plan-api-bridge-client';
        script.type = 'text/javascript';
        script.textContent = `
            ;(function() {
                try {
                    var REQ = ${JSON.stringify(API_BRIDGE_REQ_EVENT)};
                    var RES = ${JSON.stringify(API_BRIDGE_RES_EVENT)};
                    var CHANNEL = ${JSON.stringify(API_BRIDGE_MSG_CHANNEL)};
                    var METHODS = ${JSON.stringify(API_BRIDGE_METHODS)};
                    var BUILD = ${JSON.stringify(KeywordPlanApi.buildVersion || '')};
                    var METHOD_TIMEOUTS = {};
                    var resolveTimeout = function(method) {
                        var methodKey = String(method || '').trim();
                        if (!methodKey) return 180000;
                        var resolved = METHOD_TIMEOUTS[methodKey];
                        if (typeof resolved === 'number' && Number.isFinite(resolved) && resolved > 0) {
                            return Math.max(180000, resolved);
                        }
                        return 180000;
                    };
                    var callApi = function(method, args) {
                        return new Promise(function(resolve, reject) {
                            var callId = 'wxt_bridge_' + Date.now() + '_' + Math.random().toString(36).slice(2, 10);
                            var done = false;
                            var timeoutMs = resolveTimeout(method);
                            var timeoutId = setTimeout(function() {
                                if (done) return;
                                done = true;
                                window.removeEventListener(RES, onResponse, false);
                                document.removeEventListener(RES, onResponse, false);
                                window.removeEventListener('message', onMessage, false);
                                reject(new Error('bridge_timeout:' + method));
                            }, timeoutMs);
                            var onResponse = function(event) {
                                var detail = event && event.detail ? event.detail : {};
                                if (!detail || detail.callId !== callId) return;
                                if (done) return;
                                done = true;
                                clearTimeout(timeoutId);
                                window.removeEventListener(RES, onResponse, false);
                                document.removeEventListener(RES, onResponse, false);
                                window.removeEventListener('message', onMessage, false);
                                if (detail.ok) {
                                    resolve(detail.result);
                                } else {
                                    reject(new Error(detail.error || ('bridge_error:' + method)));
                                }
                            };
                            var onMessage = function(event) {
                                var data = event && event.data ? event.data : null;
                                if (!data || data.channel !== CHANNEL || data.direction !== 'res') return;
                                var detail = data && data.payload ? data.payload : {};
                                if (!detail || detail.callId !== callId) return;
                                if (done) return;
                                done = true;
                                clearTimeout(timeoutId);
                                window.removeEventListener(RES, onResponse, false);
                                document.removeEventListener(RES, onResponse, false);
                                window.removeEventListener('message', onMessage, false);
                                if (detail.ok) {
                                    resolve(detail.result);
                                } else {
                                    reject(new Error(detail.error || ('bridge_error:' + method)));
                                }
                            };
                            window.addEventListener(RES, onResponse, false);
                            document.addEventListener(RES, onResponse, false);
                            window.addEventListener('message', onMessage, false);
                            var requestDetail = {
                                callId: callId,
                                method: method,
                                args: Array.isArray(args) ? args : []
                            };
                            window.dispatchEvent(new CustomEvent(REQ, {
                                detail: requestDetail
                            }));
                            document.dispatchEvent(new CustomEvent(REQ, {
                                detail: requestDetail
                            }));
                            window.postMessage({
                                channel: CHANNEL,
                                direction: 'req',
                                payload: requestDetail
                            }, '*');
                        });
                    };
                    var bridgeApi = {
                        buildVersion: BUILD
                    };
                    METHODS.forEach(function(method) {
                        bridgeApi[method] = function() {
                            return callApi(method, Array.prototype.slice.call(arguments));
                        };
                    });
                    window.__AM_WXT_KEYWORD_API__ = bridgeApi;
                    window.__AM_WXT_PLAN_API__ = bridgeApi;
                    window.__AM_WXT_PLAN_BUILD__ = BUILD;
                } catch (err) {
                    console.warn('[AM] plan api bridge client inject failed', err);
                }
            })();
        `;
        (document.documentElement || document.head || document.body || document).appendChild(script);
        script.remove();
    };
    window.__AM_TOKENS__ = State.tokens;
    window.__AM_WXT_KEYWORD_API__ = KeywordPlanApi;
    window.__AM_WXT_PLAN_API__ = KeywordPlanApi;
    window.__AM_WXT_PLAN_BUILD__ = KeywordPlanApi.buildVersion || '';
    window.__AM_WXT_PLAN_PATCH__ = 'adzone-default-sync-v5';
    installPageApiBridgeHost();
    injectPageApiBridgeClient();
    if (pageGlobal && pageGlobal !== window) {
        pageGlobal.__AM_TOKENS__ = State.tokens;
        pageGlobal.__AM_WXT_PLAN_BUILD__ = KeywordPlanApi.buildVersion || '';
        pageGlobal.__AM_WXT_PLAN_PATCH__ = 'adzone-default-sync-v5';
    }

    // [INTEGRATED] Expose toggle function
    window.__ALIMAMA_OPTIMIZER_TOGGLE__ = () => {
        const panel = document.getElementById(CONFIG.UI_ID);
        if (!panel) {
            UI.create();
            setTimeout(() => {
                const p = document.getElementById(CONFIG.UI_ID);
                if (p) {
                    p.style.opacity = '1';
                    p.style.transform = 'scale(1)';
                    p.style.pointerEvents = 'auto';
                }
            }, 100);
        } else {
            if (panel.style.opacity === '0' || panel.style.opacity === '') {
                panel.style.opacity = '1';
                panel.style.transform = 'scale(1)';
                panel.style.pointerEvents = 'auto';
            } else {
                panel.style.boxShadow = '0 0 20px rgba(24,144,255,0.8)';
                setTimeout(() => panel.style.boxShadow = '0 4px 16px rgba(0,0,0,0.15)', 500);
            }
        }
    };

    // [INTEGRATED] Expose run campaign function for MagicReport
    window.__ALIMAMA_OPTIMIZER_RUN_CAMPAIGN__ = async (campaignId, customPrompt) => {
        // è¦†ç›–é…ç½®
        userConfig.customPrompt = customPrompt || userConfig.customPrompt;

        // ç¡®ä¿ Token å°±ç»ª
        TokenManager.refresh();
        if (!State.tokens.loginPointId || !State.tokens.dynamicToken) {
            return { success: false, msg: 'Token æœªå°±ç»ªï¼Œè¯·å…ˆåœ¨é¡µé¢ç‚¹å‡»ä»»æ„å¤„' };
        }

        // è°ƒç”¨å¤„ç†é€»è¾‘
        // æˆ‘ä»¬åˆ©ç”¨ ProcessCampaignï¼Œä½†æŠŠ UI éƒ¨åˆ†å‰¥ç¦»æˆ–å¤ç”¨ï¼Ÿ
        // processCampaign ä¾èµ– UI.createCampaignCardã€‚
        // ä¸ºäº† Magic Reportï¼Œæˆ‘ä»¬å¸Œæœ›å®ƒä»…ä»…è¿”å›ç»“æœï¼Œæˆ–è€…æˆ‘ä»¬å¯ä»¥è®© Logic è‡ªå·±å¤„ç† UIã€‚
        // è¿™é‡Œç®€å•åœ°è°ƒç”¨ processCampaignï¼Œå®ƒä¼šæŠŠæ—¥å¿—è¾“å‡ºåˆ° Escort é¢æ¿ã€‚
        // å¦‚æœæˆ‘ä»¬æƒ³è¦ Magic Report ç‹¬ç«‹æ˜¾ç¤ºï¼Œæˆ‘ä»¬éœ€è¦ä¿®æ”¹ Core.processCampaign 
        // ä½†ä¸ºäº†æœ€å°åŒ–ä¿®æ”¹ï¼Œæˆ‘ä»¬æš‚æ—¶è®©å®ƒåœ¨åå°è·‘ï¼Œå¹¶è¿”å›ç»“æœã€‚

        // ç¡®ä¿ ESCORT UI å­˜åœ¨ï¼ˆå› ä¸º ProcessCampaign ä¾èµ– UI åˆ›å»ºå¡ç‰‡ï¼‰
        if (!document.getElementById(CONFIG.UI_ID)) UI.create();

        // å¼ºåˆ¶å±•å¼€ Escort é¢æ¿ (å¯é€‰)
        // window.__ALIMAMA_OPTIMIZER_TOGGLE__();

        try {
            const res = await Core.processCampaign(campaignId, 'ä¸‡èƒ½æŸ¥æ•°ä»»åŠ¡', 1, 1);
            return res;
        } catch (e) {
            return { success: false, msg: e.message };
        }
    };
})();
